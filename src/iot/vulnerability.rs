use anyhow::Result;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct IoTVulnerability {
    pub vuln_type: String, // OWASP IoT Top 10
    pub severity: String,
    pub description: String,
    pub remediation: String,
}

/// OWASP IoT Top 10 (2018) vulnerability categories
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum OwaspIoTCategory {
    I1WeakGuessablePasswords,
    I2InsecureNetworkServices,
    I3InsecureEcosystemInterfaces,
    I4LackOfSecureUpdateMechanism,
    I5UseOfInsecureComponents,
    I6InsufficientPrivacyProtection,
    I7InsecureDataTransferStorage,
    I8LackOfDeviceManagement,
    I9InsecureDefaultSettings,
    I10LackOfPhysicalHardening,
}

impl OwaspIoTCategory {
    fn as_str(&self) -> &'static str {
        match self {
            Self::I1WeakGuessablePasswords => "I1: Weak, Guessable, or Hardcoded Passwords",
            Self::I2InsecureNetworkServices => "I2: Insecure Network Services",
            Self::I3InsecureEcosystemInterfaces => "I3: Insecure Ecosystem Interfaces",
            Self::I4LackOfSecureUpdateMechanism => "I4: Lack of Secure Update Mechanism",
            Self::I5UseOfInsecureComponents => "I5: Use of Insecure or Outdated Components",
            Self::I6InsufficientPrivacyProtection => "I6: Insufficient Privacy Protection",
            Self::I7InsecureDataTransferStorage => "I7: Insecure Data Transfer and Storage",
            Self::I8LackOfDeviceManagement => "I8: Lack of Device Management",
            Self::I9InsecureDefaultSettings => "I9: Insecure Default Settings",
            Self::I10LackOfPhysicalHardening => "I10: Lack of Physical Hardening",
        }
    }
}

/// Common IoT default credentials database
const DEFAULT_CREDENTIALS: &[(&str, &str, &str)] = &[
    // Format: (vendor/type, username, password)
    ("Generic", "admin", "admin"),
    ("Generic", "admin", "password"),
    ("Generic", "admin", "1234"),
    ("Generic", "admin", "12345"),
    ("Generic", "admin", "123456"),
    ("Generic", "root", "root"),
    ("Generic", "root", "toor"),
    ("Generic", "user", "user"),
    ("Generic", "guest", "guest"),
    ("D-Link", "admin", ""),
    ("D-Link", "admin", "admin"),
    ("Netgear", "admin", "password"),
    ("Netgear", "admin", "1234"),
    ("Linksys", "admin", "admin"),
    ("Linksys", "", "admin"),
    ("TP-Link", "admin", "admin"),
    ("ASUS", "admin", "admin"),
    ("Belkin", "admin", ""),
    ("Hikvision", "admin", "12345"),
    ("Dahua", "admin", "admin"),
    ("Ubiquiti", "ubnt", "ubnt"),
    ("Mikrotik", "admin", ""),
    ("Cisco", "cisco", "cisco"),
    ("Cisco", "admin", "admin"),
    ("ZTE", "admin", "admin"),
    ("ZTE", "ZXDSL", "ZXDSL"),
    ("Huawei", "admin", "admin"),
    ("Huawei", "telecomadmin", "admintelecom"),
    ("DVR", "admin", ""),
    ("DVR", "admin", "admin"),
    ("DVR", "admin", "4321"),
    ("IP Camera", "admin", "admin"),
    ("IP Camera", "admin", ""),
    ("IP Camera", "admin", "888888"),
    ("Axis Camera", "root", "pass"),
    ("Samsung", "admin", "4321"),
    ("Panasonic", "admin", "12345"),
    ("Avtech", "admin", "admin"),
    ("Foscam", "admin", ""),
    ("Grandstream", "admin", "admin"),
    ("Yealink", "admin", "admin"),
];

/// Insecure network services and ports
const INSECURE_SERVICES: &[(&str, u16, &str, &str)] = &[
    // (service, port, risk, recommendation)
    ("Telnet", 23, "Critical", "Disable telnet and use SSH instead"),
    ("FTP", 21, "High", "Disable FTP or use SFTP/FTPS"),
    ("TFTP", 69, "High", "Disable TFTP or restrict to trusted networks"),
    ("rlogin", 513, "Critical", "Disable rlogin and use SSH"),
    ("rsh", 514, "Critical", "Disable rsh and use SSH"),
    ("rexec", 512, "Critical", "Disable rexec and use SSH"),
    ("HTTP", 80, "Medium", "Use HTTPS instead of HTTP"),
    ("HTTP Alt", 8080, "Medium", "Use HTTPS instead of HTTP"),
    ("HTTP Alt", 8000, "Medium", "Use HTTPS instead of HTTP"),
    ("SNMP v1/v2", 161, "High", "Upgrade to SNMPv3 with authentication"),
    ("MQTT", 1883, "Medium", "Use MQTT over TLS (8883)"),
    ("CoAP", 5683, "Medium", "Use CoAP over DTLS (5684)"),
    ("UPnP", 1900, "High", "Disable UPnP on external interfaces"),
    ("mDNS", 5353, "Medium", "Restrict mDNS to local network"),
    ("LLMNR", 5355, "Medium", "Disable LLMNR if not needed"),
    ("VNC", 5900, "High", "Use VNC over SSH tunnel or disable"),
    ("RDP", 3389, "High", "Use VPN or restrict to trusted networks"),
    ("MySQL", 3306, "High", "Do not expose database ports externally"),
    ("PostgreSQL", 5432, "High", "Do not expose database ports externally"),
    ("MongoDB", 27017, "Critical", "Secure MongoDB with authentication"),
    ("Redis", 6379, "Critical", "Secure Redis with authentication and TLS"),
    ("Memcached", 11211, "High", "Do not expose memcached externally"),
    ("Elasticsearch", 9200, "High", "Secure Elasticsearch with authentication"),
    ("CouchDB", 5984, "High", "Secure CouchDB with authentication"),
    ("RTSP", 554, "Medium", "Use RTSPS (TLS) for camera streams"),
    ("SIP", 5060, "Medium", "Use SIPS (TLS) for VoIP"),
];

/// Scan device for OWASP IoT Top 10 vulnerabilities
pub async fn scan_owasp_iot_top10(device_id: &str) -> Result<Vec<IoTVulnerability>> {
    let mut vulnerabilities = Vec::new();

    // Simulate device scan - in production would do actual network probing
    let device_profile = get_device_profile(device_id).await;

    // I1: Check for weak/default passwords
    if let Some(vuln) = check_weak_passwords(&device_profile).await {
        vulnerabilities.push(vuln);
    }

    // I2: Check for insecure network services
    let service_vulns = check_insecure_services(&device_profile).await;
    vulnerabilities.extend(service_vulns);

    // I3: Check for insecure ecosystem interfaces
    if let Some(vuln) = check_insecure_interfaces(&device_profile).await {
        vulnerabilities.push(vuln);
    }

    // I4: Check for lack of secure update mechanism
    if let Some(vuln) = check_update_mechanism_internal(&device_profile).await {
        vulnerabilities.push(vuln);
    }

    // I5: Check for use of insecure/outdated components
    let component_vulns = check_insecure_components(&device_profile).await;
    vulnerabilities.extend(component_vulns);

    // I6: Check for insufficient privacy protection
    if let Some(vuln) = check_privacy_protection(&device_profile).await {
        vulnerabilities.push(vuln);
    }

    // I7: Check for insecure data transfer and storage
    let data_vulns = check_insecure_data_handling(&device_profile).await;
    vulnerabilities.extend(data_vulns);

    // I8: Check for lack of device management
    if let Some(vuln) = check_device_management(&device_profile).await {
        vulnerabilities.push(vuln);
    }

    // I9: Check for insecure default settings
    let default_vulns = check_insecure_defaults(&device_profile).await;
    vulnerabilities.extend(default_vulns);

    // I10: Check for lack of physical hardening
    if let Some(vuln) = check_physical_hardening(&device_profile).await {
        vulnerabilities.push(vuln);
    }

    Ok(vulnerabilities)
}

/// Device profile structure for vulnerability assessment
#[derive(Debug, Default)]
struct DeviceProfile {
    device_type: String,
    vendor: String,
    model: String,
    firmware_version: String,
    open_ports: Vec<u16>,
    services: HashMap<u16, String>,
    has_web_interface: bool,
    has_api: bool,
    supports_https: bool,
    supports_ssh: bool,
    has_telnet: bool,
    has_default_creds: bool,
    update_mechanism: Option<String>,
    encryption_in_transit: bool,
    encryption_at_rest: bool,
    management_interface: Option<String>,
    known_cves: Vec<String>,
}

/// Get device profile (simulated - would be from actual scanning)
async fn get_device_profile(_device_id: &str) -> DeviceProfile {
    // In production, this would:
    // 1. Query asset database for known device info
    // 2. Perform active scanning for open ports/services
    // 3. Fingerprint device type/vendor/firmware
    // 4. Check CVE databases for known vulnerabilities

    DeviceProfile::default()
}

/// Check for weak/default passwords (I1)
async fn check_weak_passwords(profile: &DeviceProfile) -> Option<IoTVulnerability> {
    if profile.has_default_creds {
        return Some(IoTVulnerability {
            vuln_type: OwaspIoTCategory::I1WeakGuessablePasswords.as_str().to_string(),
            severity: "Critical".to_string(),
            description: format!(
                "Device appears to use default or weak credentials. Vendor: {}",
                profile.vendor
            ),
            remediation: "Change default credentials immediately. Use strong, unique passwords \
                         with minimum 12 characters including uppercase, lowercase, numbers, \
                         and special characters. Enable account lockout after failed attempts.".to_string(),
        });
    }

    // Check if authentication is disabled
    if profile.has_web_interface && !profile.supports_https {
        return Some(IoTVulnerability {
            vuln_type: OwaspIoTCategory::I1WeakGuessablePasswords.as_str().to_string(),
            severity: "High".to_string(),
            description: "Web interface accessible over unencrypted HTTP, credentials may be exposed".to_string(),
            remediation: "Enable HTTPS for all web interfaces. Disable HTTP access or redirect to HTTPS.".to_string(),
        });
    }

    None
}

/// Check for insecure network services (I2)
async fn check_insecure_services(profile: &DeviceProfile) -> Vec<IoTVulnerability> {
    let mut vulnerabilities = Vec::new();

    for port in &profile.open_ports {
        for (service, service_port, severity, recommendation) in INSECURE_SERVICES {
            if port == service_port {
                vulnerabilities.push(IoTVulnerability {
                    vuln_type: OwaspIoTCategory::I2InsecureNetworkServices.as_str().to_string(),
                    severity: severity.to_string(),
                    description: format!(
                        "Insecure service '{}' detected on port {}",
                        service, port
                    ),
                    remediation: recommendation.to_string(),
                });
            }
        }
    }

    // Check for unnecessary services
    if profile.open_ports.len() > 10 {
        vulnerabilities.push(IoTVulnerability {
            vuln_type: OwaspIoTCategory::I2InsecureNetworkServices.as_str().to_string(),
            severity: "Medium".to_string(),
            description: format!(
                "Device has {} open ports, which increases attack surface",
                profile.open_ports.len()
            ),
            remediation: "Review and disable unnecessary network services. Apply principle of least privilege.".to_string(),
        });
    }

    vulnerabilities
}

/// Check for insecure ecosystem interfaces (I3)
async fn check_insecure_interfaces(profile: &DeviceProfile) -> Option<IoTVulnerability> {
    if profile.has_api && !profile.supports_https {
        return Some(IoTVulnerability {
            vuln_type: OwaspIoTCategory::I3InsecureEcosystemInterfaces.as_str().to_string(),
            severity: "High".to_string(),
            description: "Device API accessible without TLS encryption".to_string(),
            remediation: "Enable TLS for all API communications. Implement proper API authentication \
                         (OAuth 2.0, API keys with rate limiting). Validate all API inputs.".to_string(),
        });
    }

    // Check for cloud backend security
    if profile.has_api {
        return Some(IoTVulnerability {
            vuln_type: OwaspIoTCategory::I3InsecureEcosystemInterfaces.as_str().to_string(),
            severity: "Medium".to_string(),
            description: "Device connects to cloud services - verify cloud security controls".to_string(),
            remediation: "Ensure cloud backend uses strong authentication, TLS 1.2+, and proper \
                         access controls. Review API security, rate limiting, and input validation.".to_string(),
        });
    }

    None
}

/// Check for lack of secure update mechanism (I4) - internal version
async fn check_update_mechanism_internal(profile: &DeviceProfile) -> Option<IoTVulnerability> {
    match &profile.update_mechanism {
        None => Some(IoTVulnerability {
            vuln_type: OwaspIoTCategory::I4LackOfSecureUpdateMechanism.as_str().to_string(),
            severity: "High".to_string(),
            description: "No update mechanism detected on device".to_string(),
            remediation: "Implement secure firmware update capability with signed updates, \
                         TLS transport, and rollback protection. Enable automatic security updates.".to_string(),
        }),
        Some(mechanism) if mechanism.contains("http://") => Some(IoTVulnerability {
            vuln_type: OwaspIoTCategory::I4LackOfSecureUpdateMechanism.as_str().to_string(),
            severity: "Critical".to_string(),
            description: "Device uses unencrypted HTTP for firmware updates".to_string(),
            remediation: "Use HTTPS for all firmware downloads. Implement code signing \
                         and verify signatures before applying updates.".to_string(),
        }),
        Some(mechanism) if !mechanism.contains("signed") => Some(IoTVulnerability {
            vuln_type: OwaspIoTCategory::I4LackOfSecureUpdateMechanism.as_str().to_string(),
            severity: "High".to_string(),
            description: "Firmware updates may not be cryptographically signed".to_string(),
            remediation: "Implement code signing for all firmware updates. Verify signatures \
                         using hardware-backed key storage when possible.".to_string(),
        }),
        _ => None,
    }
}

/// Check for insecure/outdated components (I5)
async fn check_insecure_components(profile: &DeviceProfile) -> Vec<IoTVulnerability> {
    let mut vulnerabilities = Vec::new();

    // Check known CVEs
    for cve in &profile.known_cves {
        vulnerabilities.push(IoTVulnerability {
            vuln_type: OwaspIoTCategory::I5UseOfInsecureComponents.as_str().to_string(),
            severity: "High".to_string(),
            description: format!("Known vulnerability: {}", cve),
            remediation: "Update firmware to latest version. If no update available, \
                         implement compensating controls or replace device.".to_string(),
        });
    }

    // Check firmware age (simulated)
    if !profile.firmware_version.is_empty() {
        // In production, would check firmware age against vendor database
        vulnerabilities.push(IoTVulnerability {
            vuln_type: OwaspIoTCategory::I5UseOfInsecureComponents.as_str().to_string(),
            severity: "Medium".to_string(),
            description: format!("Firmware version {} - verify if latest", profile.firmware_version),
            remediation: "Check vendor website for latest firmware. Subscribe to vendor \
                         security advisories. Implement automated update checks.".to_string(),
        });
    }

    vulnerabilities
}

/// Check for insufficient privacy protection (I6)
async fn check_privacy_protection(profile: &DeviceProfile) -> Option<IoTVulnerability> {
    // Check if device collects/transmits personal data without encryption
    if !profile.encryption_in_transit {
        return Some(IoTVulnerability {
            vuln_type: OwaspIoTCategory::I6InsufficientPrivacyProtection.as_str().to_string(),
            severity: "High".to_string(),
            description: "Device may transmit data without encryption".to_string(),
            remediation: "Enable TLS for all data transmission. Review data collection practices. \
                         Implement data minimization principles. Provide user controls for data sharing.".to_string(),
        });
    }

    None
}

/// Check for insecure data transfer and storage (I7)
async fn check_insecure_data_handling(profile: &DeviceProfile) -> Vec<IoTVulnerability> {
    let mut vulnerabilities = Vec::new();

    if !profile.encryption_in_transit {
        vulnerabilities.push(IoTVulnerability {
            vuln_type: OwaspIoTCategory::I7InsecureDataTransferStorage.as_str().to_string(),
            severity: "High".to_string(),
            description: "Data transmitted without encryption".to_string(),
            remediation: "Enable TLS 1.2+ for all network communications. \
                         Disable legacy protocols (SSLv3, TLS 1.0/1.1).".to_string(),
        });
    }

    if !profile.encryption_at_rest {
        vulnerabilities.push(IoTVulnerability {
            vuln_type: OwaspIoTCategory::I7InsecureDataTransferStorage.as_str().to_string(),
            severity: "Medium".to_string(),
            description: "Sensitive data may be stored without encryption".to_string(),
            remediation: "Encrypt sensitive data at rest using AES-256 or equivalent. \
                         Use secure key storage. Implement secure deletion.".to_string(),
        });
    }

    vulnerabilities
}

/// Check for lack of device management (I8)
async fn check_device_management(profile: &DeviceProfile) -> Option<IoTVulnerability> {
    if profile.management_interface.is_none() {
        return Some(IoTVulnerability {
            vuln_type: OwaspIoTCategory::I8LackOfDeviceManagement.as_str().to_string(),
            severity: "Medium".to_string(),
            description: "Device lacks centralized management capabilities".to_string(),
            remediation: "Implement device management features: asset tracking, configuration \
                         management, security monitoring, and remote administration. \
                         Use network segmentation for unmanaged devices.".to_string(),
        });
    }

    None
}

/// Check for insecure default settings (I9)
async fn check_insecure_defaults(profile: &DeviceProfile) -> Vec<IoTVulnerability> {
    let mut vulnerabilities = Vec::new();

    // Check for telnet enabled by default
    if profile.has_telnet {
        vulnerabilities.push(IoTVulnerability {
            vuln_type: OwaspIoTCategory::I9InsecureDefaultSettings.as_str().to_string(),
            severity: "Critical".to_string(),
            description: "Telnet is enabled (insecure by default)".to_string(),
            remediation: "Disable telnet and use SSH for remote administration. \
                         If telnet is required, restrict to local network only.".to_string(),
        });
    }

    // Check for UPnP
    if profile.open_ports.contains(&1900) {
        vulnerabilities.push(IoTVulnerability {
            vuln_type: OwaspIoTCategory::I9InsecureDefaultSettings.as_str().to_string(),
            severity: "High".to_string(),
            description: "UPnP is enabled (commonly insecure by default)".to_string(),
            remediation: "Disable UPnP on router/firewall. If required, configure \
                         proper access controls and monitoring.".to_string(),
        });
    }

    // Check for default web interface
    if profile.has_web_interface && !profile.supports_https {
        vulnerabilities.push(IoTVulnerability {
            vuln_type: OwaspIoTCategory::I9InsecureDefaultSettings.as_str().to_string(),
            severity: "High".to_string(),
            description: "Web interface uses HTTP by default (should be HTTPS)".to_string(),
            remediation: "Configure HTTPS as default. Generate/install proper TLS certificate. \
                         Disable HTTP or redirect to HTTPS.".to_string(),
        });
    }

    vulnerabilities
}

/// Check for lack of physical hardening (I10)
async fn check_physical_hardening(profile: &DeviceProfile) -> Option<IoTVulnerability> {
    // This typically requires physical assessment
    // Here we flag devices that may be physically accessible

    let physical_risk_types = ["camera", "sensor", "gateway", "router", "access_point"];

    if physical_risk_types.iter().any(|t| profile.device_type.to_lowercase().contains(t)) {
        return Some(IoTVulnerability {
            vuln_type: OwaspIoTCategory::I10LackOfPhysicalHardening.as_str().to_string(),
            severity: "Medium".to_string(),
            description: format!(
                "Device type '{}' may be physically accessible - verify physical security",
                profile.device_type
            ),
            remediation: "Disable physical debug ports (JTAG, UART). Remove unnecessary \
                         external storage ports. Use tamper-evident enclosures. \
                         Implement tamper detection where possible.".to_string(),
        });
    }

    None
}

/// Check for default credentials on a device
pub async fn check_default_credentials(device_id: &str) -> Result<Option<IoTVulnerability>> {
    // Get device info for targeted credential check
    let device_profile = get_device_profile(device_id).await;
    let vendor = device_profile.vendor.to_lowercase();

    // Build list of credentials to check based on vendor
    let credentials_to_check: Vec<(&str, &str)> = DEFAULT_CREDENTIALS.iter()
        .filter(|(v, _, _)| v.to_lowercase() == vendor || *v == "Generic")
        .map(|(_, user, pass)| (*user, *pass))
        .collect();

    if credentials_to_check.is_empty() {
        // Check generic credentials only
        for (_, user, pass) in DEFAULT_CREDENTIALS.iter().filter(|(v, _, _)| *v == "Generic") {
            if check_credential_valid(device_id, user, pass).await {
                return Ok(Some(IoTVulnerability {
                    vuln_type: OwaspIoTCategory::I1WeakGuessablePasswords.as_str().to_string(),
                    severity: "Critical".to_string(),
                    description: format!(
                        "Default credentials accepted: {}:{}",
                        user,
                        "*".repeat(pass.len().max(3))
                    ),
                    remediation: "Change default credentials immediately. Implement password \
                                 complexity requirements and account lockout policies.".to_string(),
                }));
            }
        }
    } else {
        for (user, pass) in credentials_to_check {
            if check_credential_valid(device_id, user, pass).await {
                return Ok(Some(IoTVulnerability {
                    vuln_type: OwaspIoTCategory::I1WeakGuessablePasswords.as_str().to_string(),
                    severity: "Critical".to_string(),
                    description: format!(
                        "Vendor default credentials accepted ({} device): {}:{}",
                        vendor,
                        user,
                        "*".repeat(pass.len().max(3))
                    ),
                    remediation: format!(
                        "Change {} default credentials immediately. Consult vendor \
                         documentation for security hardening guide.",
                        vendor
                    ),
                }));
            }
        }
    }

    Ok(None)
}

/// Check if credential is valid (simulated)
async fn check_credential_valid(_device_id: &str, _user: &str, _pass: &str) -> bool {
    // In production, this would:
    // 1. Attempt login via appropriate protocol (HTTP, Telnet, SSH, etc.)
    // 2. Check authentication response
    // 3. Log attempt for audit trail
    false
}

/// Analyze firmware binary for vulnerabilities
pub async fn analyze_firmware(firmware_path: &str) -> Result<Vec<IoTVulnerability>> {
    let mut vulnerabilities = Vec::new();

    // Read firmware file
    let firmware_data = match tokio::fs::read(firmware_path).await {
        Ok(data) => data,
        Err(e) => {
            return Err(anyhow::anyhow!("Failed to read firmware: {}", e));
        }
    };

    // Check for hardcoded credentials
    let cred_findings = find_hardcoded_credentials(&firmware_data);
    for finding in cred_findings {
        vulnerabilities.push(IoTVulnerability {
            vuln_type: OwaspIoTCategory::I1WeakGuessablePasswords.as_str().to_string(),
            severity: "Critical".to_string(),
            description: format!("Hardcoded credential pattern found: {}", finding),
            remediation: "Remove hardcoded credentials from firmware. Use secure \
                         key storage and runtime credential management.".to_string(),
        });
    }

    // Check for known vulnerable libraries
    let lib_findings = find_vulnerable_libraries(&firmware_data);
    for finding in lib_findings {
        vulnerabilities.push(IoTVulnerability {
            vuln_type: OwaspIoTCategory::I5UseOfInsecureComponents.as_str().to_string(),
            severity: "High".to_string(),
            description: format!("Potentially vulnerable library: {}", finding),
            remediation: "Update to latest patched version of the library. \
                         If update not available, implement compensating controls.".to_string(),
        });
    }

    // Check for insecure functions
    let func_findings = find_insecure_functions(&firmware_data);
    for finding in func_findings {
        vulnerabilities.push(IoTVulnerability {
            vuln_type: OwaspIoTCategory::I5UseOfInsecureComponents.as_str().to_string(),
            severity: "Medium".to_string(),
            description: format!("Potentially insecure function usage: {}", finding),
            remediation: "Review code for proper input validation and buffer handling. \
                         Use safer alternatives (e.g., strncpy instead of strcpy).".to_string(),
        });
    }

    // Check for encryption keys
    let key_findings = find_embedded_keys(&firmware_data);
    for finding in key_findings {
        vulnerabilities.push(IoTVulnerability {
            vuln_type: OwaspIoTCategory::I7InsecureDataTransferStorage.as_str().to_string(),
            severity: "High".to_string(),
            description: format!("Embedded cryptographic key found: {}", finding),
            remediation: "Remove embedded keys from firmware. Use hardware security \
                         module (HSM) or secure element for key storage.".to_string(),
        });
    }

    // Check for debug information
    if firmware_data.windows(6).any(|w| w == b".debug") ||
       firmware_data.windows(8).any(|w| w == b"DWARF") {
        vulnerabilities.push(IoTVulnerability {
            vuln_type: OwaspIoTCategory::I10LackOfPhysicalHardening.as_str().to_string(),
            severity: "Low".to_string(),
            description: "Firmware contains debug symbols".to_string(),
            remediation: "Strip debug symbols from production firmware to prevent \
                         reverse engineering and reduce firmware size.".to_string(),
        });
    }

    Ok(vulnerabilities)
}

/// Find hardcoded credentials in firmware
fn find_hardcoded_credentials(data: &[u8]) -> Vec<String> {
    let mut findings = Vec::new();
    let text = String::from_utf8_lossy(data);

    // Common credential patterns
    let patterns = [
        (r#"password\s*[=:]\s*["']([^"']+)["']"#, "password assignment"),
        (r#"passwd\s*[=:]\s*["']([^"']+)["']"#, "passwd assignment"),
        (r#"secret\s*[=:]\s*["']([^"']+)["']"#, "secret assignment"),
        (r#"api_key\s*[=:]\s*["']([^"']+)["']"#, "API key"),
        (r#"auth_token\s*[=:]\s*["']([^"']+)["']"#, "auth token"),
    ];

    for (pattern, desc) in patterns {
        if let Ok(re) = regex::Regex::new(pattern) {
            if re.is_match(&text) {
                findings.push(desc.to_string());
            }
        }
    }

    // Check for known default passwords in binary
    for (_, _, pass) in DEFAULT_CREDENTIALS {
        if !pass.is_empty() && pass.len() >= 4 {
            if data.windows(pass.len()).any(|w| w == pass.as_bytes()) {
                findings.push(format!("default password '{}' embedded", pass));
            }
        }
    }

    findings
}

/// Find vulnerable libraries in firmware
fn find_vulnerable_libraries(data: &[u8]) -> Vec<String> {
    let mut findings = Vec::new();

    // Known vulnerable library signatures
    let vulnerable_libs: &[(&[u8], &str)] = &[
        (b"OpenSSL 0.", "OpenSSL 0.x (multiple CVEs)"),
        (b"OpenSSL 1.0.1", "OpenSSL 1.0.1 (Heartbleed vulnerable)"),
        (b"OpenSSL 1.0.2a", "OpenSSL 1.0.2a-g (various CVEs)"),
        (b"libcurl/7.1", "libcurl 7.1x (multiple CVEs)"),
        (b"libcurl/7.2", "libcurl 7.2x (multiple CVEs)"),
        (b"dropbear_0.", "Dropbear SSH 0.x (outdated)"),
        (b"dropbear_2012", "Dropbear SSH 2012 (outdated)"),
        (b"busybox v1.1", "BusyBox 1.1x (outdated)"),
        (b"uClibc-0.9.2", "uClibc 0.9.2x (multiple CVEs)"),
        (b"glibc 2.1", "glibc 2.1x (outdated)"),
    ];

    for (signature, description) in vulnerable_libs {
        if data.windows(signature.len()).any(|w| w == *signature) {
            findings.push(description.to_string());
        }
    }

    findings
}

/// Find insecure function usage in firmware
fn find_insecure_functions(data: &[u8]) -> Vec<String> {
    let mut findings = Vec::new();

    // Insecure C functions
    let insecure_funcs: &[(&[u8], &str)] = &[
        (b"strcpy", "strcpy (buffer overflow risk)"),
        (b"strcat", "strcat (buffer overflow risk)"),
        (b"sprintf", "sprintf (buffer overflow risk)"),
        (b"gets", "gets (buffer overflow risk)"),
        (b"scanf", "scanf (format string vulnerability)"),
        (b"system", "system (command injection risk)"),
        (b"popen", "popen (command injection risk)"),
        (b"execl", "exec family (command injection risk)"),
    ];

    for (signature, description) in insecure_funcs {
        if data.windows(signature.len()).any(|w| w == *signature) {
            // Only flag if appears multiple times (likely actual usage, not just string)
            let count = data.windows(signature.len())
                .filter(|w| *w == *signature)
                .count();
            if count > 2 {
                findings.push(description.to_string());
            }
        }
    }

    findings
}

/// Find embedded cryptographic keys in firmware
fn find_embedded_keys(data: &[u8]) -> Vec<String> {
    let mut findings = Vec::new();

    // RSA private key markers
    if data.windows(27).any(|w| w == b"-----BEGIN RSA PRIVATE KEY") {
        findings.push("RSA private key".to_string());
    }

    // EC private key markers
    if data.windows(26).any(|w| w == b"-----BEGIN EC PRIVATE KEY") {
        findings.push("EC private key".to_string());
    }

    // DSA private key markers
    if data.windows(27).any(|w| w == b"-----BEGIN DSA PRIVATE KEY") {
        findings.push("DSA private key".to_string());
    }

    // Generic private key
    if data.windows(22).any(|w| w == b"-----BEGIN PRIVATE KEY") {
        findings.push("Private key".to_string());
    }

    // Check for high entropy regions (potential AES keys)
    // This is a simplified heuristic
    let window_size = 32;
    for chunk in data.chunks(window_size) {
        if chunk.len() == window_size {
            let entropy = calculate_entropy(chunk);
            if entropy > 7.5 {
                // Very high entropy, might be a key
                // Would need more analysis to confirm
            }
        }
    }

    findings
}

/// Calculate Shannon entropy of bytes
fn calculate_entropy(data: &[u8]) -> f64 {
    if data.is_empty() {
        return 0.0;
    }

    let mut counts = [0u32; 256];
    for byte in data {
        counts[*byte as usize] += 1;
    }

    let len = data.len() as f64;
    counts.iter()
        .filter(|&&count| count > 0)
        .map(|&count| {
            let p = count as f64 / len;
            -p * p.log2()
        })
        .sum()
}

/// Check for insecure network services on device
pub async fn check_insecure_network_services(device_id: &str) -> Result<Vec<IoTVulnerability>> {
    let mut vulnerabilities = Vec::new();
    let profile = get_device_profile(device_id).await;

    // Check each open port against insecure services list
    for port in &profile.open_ports {
        for (service, service_port, severity, recommendation) in INSECURE_SERVICES {
            if port == service_port {
                let service_name = profile.services.get(port)
                    .cloned()
                    .unwrap_or_else(|| service.to_string());

                vulnerabilities.push(IoTVulnerability {
                    vuln_type: OwaspIoTCategory::I2InsecureNetworkServices.as_str().to_string(),
                    severity: severity.to_string(),
                    description: format!(
                        "Insecure service '{}' running on port {} - {}",
                        service_name, port, service
                    ),
                    remediation: recommendation.to_string(),
                });
            }
        }
    }

    // Additional checks for specific service configurations
    if profile.has_telnet {
        // Check if telnet is exposed to WAN
        vulnerabilities.push(IoTVulnerability {
            vuln_type: OwaspIoTCategory::I2InsecureNetworkServices.as_str().to_string(),
            severity: "Critical".to_string(),
            description: "Telnet service is enabled - all traffic including credentials sent in plaintext".to_string(),
            remediation: "Disable telnet immediately. Use SSH for remote administration. \
                         If telnet is absolutely required, restrict access via firewall rules.".to_string(),
        });
    }

    Ok(vulnerabilities)
}

/// Check for secure update mechanism
pub async fn check_update_mechanism(device_id: &str) -> Result<Option<IoTVulnerability>> {
    let profile = get_device_profile(device_id).await;
    Ok(check_update_mechanism_internal(&profile).await)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_owasp_category_strings() {
        assert!(OwaspIoTCategory::I1WeakGuessablePasswords.as_str().contains("Weak"));
        assert!(OwaspIoTCategory::I2InsecureNetworkServices.as_str().contains("Network"));
    }

    #[test]
    fn test_entropy_calculation() {
        // Low entropy (all same byte)
        assert!(calculate_entropy(&[0u8; 32]) < 0.1);

        // High entropy (random-like)
        let high_entropy: Vec<u8> = (0..32).collect();
        assert!(calculate_entropy(&high_entropy) > 4.0);
    }

    #[tokio::test]
    async fn test_scan_owasp_top10() {
        let vulns = scan_owasp_iot_top10("test_device").await.unwrap();
        // Should return empty for default profile
        assert!(vulns.is_empty() || vulns.iter().all(|v| !v.description.is_empty()));
    }

    #[tokio::test]
    async fn test_check_default_credentials() {
        let result = check_default_credentials("test_device").await.unwrap();
        // Should return None for simulated device (no actual connection)
        assert!(result.is_none());
    }

    #[test]
    fn test_find_hardcoded_credentials() {
        let firmware = b"config password = 'admin123' test";
        let findings = find_hardcoded_credentials(firmware);
        assert!(!findings.is_empty());
    }

    #[test]
    fn test_find_vulnerable_libraries() {
        let firmware = b"OpenSSL 1.0.1a - vulnerable version";
        let findings = find_vulnerable_libraries(firmware);
        assert!(!findings.is_empty());
        assert!(findings[0].contains("Heartbleed"));
    }
}
