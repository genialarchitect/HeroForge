//! ExploitDB integration for exploit correlation
//!
//! This module provides integration with ExploitDB to find known exploits
//! for discovered services and CVEs. It uses the exploits.shodan.io API
//! and local CVE mapping.

use anyhow::{anyhow, Result};
use log::{debug, info, warn};
use reqwest::Client;
use serde::Deserialize;
use std::collections::HashMap;
use std::time::Duration;

use super::types::ExploitInfo;

const EXPLOITS_API_BASE: &str = "https://exploits.shodan.io/api";
const EXPLOIT_DB_URL: &str = "https://www.exploit-db.com";
const REQUEST_TIMEOUT_SECS: u64 = 15;

/// ExploitDB client
pub struct ExploitDbClient {
    client: Client,
    shodan_api_key: Option<String>,
}

/// Response from Shodan exploits API search
#[derive(Debug, Deserialize)]
struct ExploitSearchResponse {
    matches: Vec<ExploitMatch>,
    total: i64,
}

/// Individual exploit match from search
#[derive(Debug, Deserialize)]
struct ExploitMatch {
    #[serde(rename = "_id")]
    id: String,
    description: String,
    #[serde(rename = "type")]
    exploit_type: Option<String>,
    platform: Option<String>,
    author: Option<String>,
    date: Option<String>,
    cve: Option<Vec<String>>,
    port: Option<u16>,
    source: Option<String>,
}

/// CVE-to-exploit mapping entry
#[derive(Debug, Clone)]
struct CveExploitMapping {
    cve_id: String,
    exploit_ids: Vec<String>,
}

impl ExploitDbClient {
    /// Create a new ExploitDB client
    pub fn new(shodan_api_key: Option<String>) -> Self {
        let client = Client::builder()
            .timeout(Duration::from_secs(REQUEST_TIMEOUT_SECS))
            .user_agent("HeroForge/0.1.0 (Security Scanner)")
            .build()
            .expect("Failed to build HTTP client");

        Self {
            client,
            shodan_api_key,
        }
    }

    /// Create client from environment
    pub fn from_env() -> Self {
        let shodan_api_key = std::env::var("SHODAN_API_KEY").ok();
        Self::new(shodan_api_key)
    }

    /// Search for exploits by query string
    pub async fn search(&self, query: &str) -> Result<Vec<ExploitInfo>> {
        let api_key = self.shodan_api_key.as_ref()
            .ok_or_else(|| anyhow!("Shodan API key required for exploit search"))?;

        let url = format!(
            "{}/search?query={}&key={}",
            EXPLOITS_API_BASE,
            urlencoding::encode(query),
            api_key
        );

        info!("Searching ExploitDB: {}", query);
        debug!("URL: {}", url.replace(api_key, "***"));

        let response = self.client.get(&url).send().await?;

        if !response.status().is_success() {
            let status = response.status();
            let body = response.text().await.unwrap_or_default();
            warn!("ExploitDB API error: {} - {}", status, body);
            return Err(anyhow!("ExploitDB API error: {} - {}", status, body));
        }

        let search_response: ExploitSearchResponse = response.json().await?;
        info!("ExploitDB search returned {} results", search_response.total);

        let exploits = search_response
            .matches
            .into_iter()
            .map(convert_exploit_match)
            .collect();

        Ok(exploits)
    }

    /// Search for exploits by CVE ID
    pub async fn search_by_cve(&self, cve_id: &str) -> Result<Vec<ExploitInfo>> {
        // First try Shodan exploits API
        if self.shodan_api_key.is_some() {
            let query = format!("cve:{}", cve_id);
            if let Ok(exploits) = self.search(&query).await {
                if !exploits.is_empty() {
                    return Ok(exploits);
                }
            }
        }

        // Fall back to offline CVE mapping
        Ok(get_offline_exploits_for_cve(cve_id))
    }

    /// Search for exploits by product/service name
    pub async fn search_by_product(&self, product: &str, version: Option<&str>) -> Result<Vec<ExploitInfo>> {
        let query = if let Some(ver) = version {
            format!("{} {}", product, ver)
        } else {
            product.to_string()
        };

        // Try API search first
        if self.shodan_api_key.is_some() {
            if let Ok(exploits) = self.search(&query).await {
                if !exploits.is_empty() {
                    return Ok(exploits);
                }
            }
        }

        // Fall back to offline database
        Ok(get_offline_exploits_for_product(product, version))
    }

    /// Get exploits for multiple CVEs
    pub async fn get_exploits_for_cves(&self, cve_ids: &[String]) -> Result<HashMap<String, Vec<ExploitInfo>>> {
        let mut results: HashMap<String, Vec<ExploitInfo>> = HashMap::new();

        for cve_id in cve_ids {
            match self.search_by_cve(cve_id).await {
                Ok(exploits) if !exploits.is_empty() => {
                    results.insert(cve_id.clone(), exploits);
                }
                Ok(_) => {
                    debug!("No exploits found for {}", cve_id);
                }
                Err(e) => {
                    warn!("Error searching exploits for {}: {}", cve_id, e);
                }
            }
        }

        Ok(results)
    }
}

/// Convert API response to our ExploitInfo type
fn convert_exploit_match(m: ExploitMatch) -> ExploitInfo {
    let url = format!("{}/exploits/{}", EXPLOIT_DB_URL, m.id);

    ExploitInfo {
        id: m.id.clone(),
        title: m.description.clone(),
        description: Some(m.description),
        exploit_type: m.exploit_type.unwrap_or_else(|| "unknown".to_string()),
        platform: m.platform,
        author: m.author,
        date_published: m.date,
        cve_ids: m.cve.unwrap_or_default(),
        verified: false, // API doesn't provide this
        url,
        source_url: m.source,
    }
}

/// Offline database of known CVE to exploit mappings
/// This provides fallback when API is unavailable
fn get_offline_exploits_for_cve(cve_id: &str) -> Vec<ExploitInfo> {
    // Common CVEs with known exploits
    let mappings: HashMap<&str, Vec<ExploitInfo>> = HashMap::from([
        // Log4Shell
        ("CVE-2021-44228", vec![
            ExploitInfo {
                id: "50592".to_string(),
                title: "Apache Log4j 2 - Remote Code Execution (RCE)".to_string(),
                description: Some("Log4Shell - Remote code execution via JNDI lookup".to_string()),
                exploit_type: "remote".to_string(),
                platform: Some("Multiple".to_string()),
                author: Some("Various".to_string()),
                date_published: Some("2021-12-10".to_string()),
                cve_ids: vec!["CVE-2021-44228".to_string()],
                verified: true,
                url: "https://www.exploit-db.com/exploits/50592".to_string(),
                source_url: None,
            },
        ]),
        // Apache Path Traversal
        ("CVE-2021-41773", vec![
            ExploitInfo {
                id: "50383".to_string(),
                title: "Apache HTTP Server 2.4.49 - Path Traversal and RCE".to_string(),
                description: Some("Path traversal and remote code execution".to_string()),
                exploit_type: "remote".to_string(),
                platform: Some("Multiple".to_string()),
                author: Some("Lucas Souza".to_string()),
                date_published: Some("2021-10-05".to_string()),
                cve_ids: vec!["CVE-2021-41773".to_string()],
                verified: true,
                url: "https://www.exploit-db.com/exploits/50383".to_string(),
                source_url: None,
            },
        ]),
        // ProxyShell
        ("CVE-2021-34473", vec![
            ExploitInfo {
                id: "50347".to_string(),
                title: "Microsoft Exchange ProxyShell RCE".to_string(),
                description: Some("Remote code execution via ProxyShell vulnerability chain".to_string()),
                exploit_type: "remote".to_string(),
                platform: Some("Windows".to_string()),
                author: Some("Various".to_string()),
                date_published: Some("2021-08-21".to_string()),
                cve_ids: vec!["CVE-2021-34473".to_string(), "CVE-2021-34523".to_string(), "CVE-2021-31207".to_string()],
                verified: true,
                url: "https://www.exploit-db.com/exploits/50347".to_string(),
                source_url: None,
            },
        ]),
        // Eternal Blue
        ("CVE-2017-0144", vec![
            ExploitInfo {
                id: "42315".to_string(),
                title: "Microsoft Windows - SMB Remote Code Execution (MS17-010)".to_string(),
                description: Some("EternalBlue SMB Remote Code Execution".to_string()),
                exploit_type: "remote".to_string(),
                platform: Some("Windows".to_string()),
                author: Some("Shadow Brokers".to_string()),
                date_published: Some("2017-04-14".to_string()),
                cve_ids: vec!["CVE-2017-0144".to_string()],
                verified: true,
                url: "https://www.exploit-db.com/exploits/42315".to_string(),
                source_url: None,
            },
        ]),
        // BlueKeep
        ("CVE-2019-0708", vec![
            ExploitInfo {
                id: "47416".to_string(),
                title: "Microsoft Windows - RDP BlueKeep Remote Code Execution".to_string(),
                description: Some("BlueKeep RDP vulnerability allowing RCE".to_string()),
                exploit_type: "remote".to_string(),
                platform: Some("Windows".to_string()),
                author: Some("Various".to_string()),
                date_published: Some("2019-09-06".to_string()),
                cve_ids: vec!["CVE-2019-0708".to_string()],
                verified: true,
                url: "https://www.exploit-db.com/exploits/47416".to_string(),
                source_url: None,
            },
        ]),
        // Spring4Shell
        ("CVE-2022-22965", vec![
            ExploitInfo {
                id: "50808".to_string(),
                title: "Spring Framework - RCE via Data Binding".to_string(),
                description: Some("Spring4Shell remote code execution".to_string()),
                exploit_type: "remote".to_string(),
                platform: Some("Multiple".to_string()),
                author: Some("Various".to_string()),
                date_published: Some("2022-03-30".to_string()),
                cve_ids: vec!["CVE-2022-22965".to_string()],
                verified: true,
                url: "https://www.exploit-db.com/exploits/50808".to_string(),
                source_url: None,
            },
        ]),
        // Shellshock
        ("CVE-2014-6271", vec![
            ExploitInfo {
                id: "34765".to_string(),
                title: "GNU Bash - Shellshock Environment Variable Command Injection".to_string(),
                description: Some("Shellshock bash environment variable injection".to_string()),
                exploit_type: "remote".to_string(),
                platform: Some("Linux".to_string()),
                author: Some("Various".to_string()),
                date_published: Some("2014-09-24".to_string()),
                cve_ids: vec!["CVE-2014-6271".to_string()],
                verified: true,
                url: "https://www.exploit-db.com/exploits/34765".to_string(),
                source_url: None,
            },
        ]),
    ]);

    mappings.get(cve_id).cloned().unwrap_or_default()
}

/// Offline product to exploit mapping
fn get_offline_exploits_for_product(product: &str, version: Option<&str>) -> Vec<ExploitInfo> {
    let product_lower = product.to_lowercase();
    let mut exploits = Vec::new();

    // Apache HTTP Server
    if product_lower.contains("apache") || product_lower.contains("httpd") {
        if let Some(ver) = version {
            if ver.starts_with("2.4.49") || ver.starts_with("2.4.50") {
                exploits.extend(get_offline_exploits_for_cve("CVE-2021-41773"));
            }
        }
    }

    // Microsoft Exchange
    if product_lower.contains("exchange") {
        exploits.extend(get_offline_exploits_for_cve("CVE-2021-34473"));
    }

    // SMB / Windows
    if product_lower.contains("smb") || product_lower.contains("microsoft-ds") {
        exploits.extend(get_offline_exploits_for_cve("CVE-2017-0144"));
    }

    // RDP
    if product_lower.contains("rdp") || product_lower.contains("remote desktop") {
        exploits.extend(get_offline_exploits_for_cve("CVE-2019-0708"));
    }

    // Log4j
    if product_lower.contains("log4j") || product_lower.contains("java") {
        exploits.extend(get_offline_exploits_for_cve("CVE-2021-44228"));
    }

    // Spring
    if product_lower.contains("spring") {
        exploits.extend(get_offline_exploits_for_cve("CVE-2022-22965"));
    }

    exploits
}

/// Check if a CVE has known exploits (fast offline check)
pub fn has_known_exploit(cve_id: &str) -> bool {
    let known_exploited_cves = [
        "CVE-2021-44228", "CVE-2021-41773", "CVE-2021-34473",
        "CVE-2017-0144", "CVE-2019-0708", "CVE-2022-22965",
        "CVE-2014-6271", "CVE-2021-26855", "CVE-2020-1472",
        "CVE-2021-27065", "CVE-2023-23397", "CVE-2023-0669",
        "CVE-2022-41040", "CVE-2022-41082", "CVE-2023-27350",
        "CVE-2023-44487", "CVE-2023-4966", "CVE-2024-1709",
    ];

    known_exploited_cves.contains(&cve_id)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_offline_exploit_lookup() {
        let exploits = get_offline_exploits_for_cve("CVE-2021-44228");
        assert!(!exploits.is_empty());
        assert!(exploits[0].title.contains("Log4j"));
    }

    #[test]
    fn test_has_known_exploit() {
        assert!(has_known_exploit("CVE-2021-44228"));
        assert!(has_known_exploit("CVE-2017-0144"));
        assert!(!has_known_exploit("CVE-2000-0000"));
    }

    #[test]
    fn test_product_exploit_lookup() {
        let exploits = get_offline_exploits_for_product("Apache", Some("2.4.49"));
        assert!(!exploits.is_empty());
    }
}
