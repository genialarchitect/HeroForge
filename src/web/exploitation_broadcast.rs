// Exploitation Broadcast Module
// Real-time progress updates for exploitation campaigns via WebSocket

use crate::scanner::exploitation::types::ExploitationProgress;
use once_cell::sync::Lazy;
use std::collections::HashMap;
use std::sync::Arc;
use std::time::{Duration, Instant};
use tokio::sync::{broadcast, RwLock};
use tokio::time;

pub type ExploitProgressSender = broadcast::Sender<ExploitationProgress>;
pub type ExploitProgressReceiver = broadcast::Receiver<ExploitationProgress>;

// Configuration constants
const CHANNEL_CLEANUP_DELAY_SECS: u64 = 300; // 5 minutes

/// Metadata for a campaign channel
#[derive(Clone)]
struct CampaignChannelInfo {
    sender: ExploitProgressSender,
    created_at: Instant,
    last_message_at: Instant,
    message_count: u32,
    is_completed: bool,
}

// Global map of campaign_id -> channel info
static CAMPAIGN_CHANNELS: Lazy<Arc<RwLock<HashMap<String, CampaignChannelInfo>>>> =
    Lazy::new(|| Arc::new(RwLock::new(HashMap::new())));

/// Create a new broadcast channel for a campaign
pub async fn create_campaign_channel(campaign_id: String) -> ExploitProgressSender {
    let (tx, _) = broadcast::channel(100);
    let now = Instant::now();

    let info = CampaignChannelInfo {
        sender: tx.clone(),
        created_at: now,
        last_message_at: now,
        message_count: 0,
        is_completed: false,
    };

    let mut channels = CAMPAIGN_CHANNELS.write().await;
    channels.insert(campaign_id.clone(), info);

    log::info!("Created exploitation broadcast channel for campaign: {}", campaign_id);

    tx
}

/// Subscribe to progress updates for a campaign
pub async fn subscribe_to_campaign(campaign_id: &str) -> Option<ExploitProgressReceiver> {
    let channels = CAMPAIGN_CHANNELS.read().await;
    channels.get(campaign_id).map(|info| info.sender.subscribe())
}

/// Send a progress message to all subscribers of a campaign
pub async fn send_progress(campaign_id: &str, message: ExploitationProgress) {
    let channels = CAMPAIGN_CHANNELS.read().await;

    if let Some(info) = channels.get(campaign_id) {
        let _ = info.sender.send(message.clone());

        // Update channel info
        drop(channels);
        let mut channels_mut = CAMPAIGN_CHANNELS.write().await;
        if let Some(info_mut) = channels_mut.get_mut(campaign_id) {
            info_mut.last_message_at = Instant::now();
            info_mut.message_count += 1;

            // Mark as completed if this is a completion message
            if matches!(
                message,
                ExploitationProgress::CampaignCompleted { .. }
                    | ExploitationProgress::Error { .. }
            ) {
                info_mut.is_completed = true;

                // Schedule cleanup
                let campaign_id_clone = campaign_id.to_string();
                tokio::spawn(async move {
                    time::sleep(Duration::from_secs(CHANNEL_CLEANUP_DELAY_SECS)).await;
                    cleanup_campaign_channel(&campaign_id_clone).await;
                });
            }
        }
    } else {
        log::warn!("No broadcast channel found for campaign: {}", campaign_id);
    }
}

/// Remove a campaign channel (cleanup after campaign completes)
#[allow(dead_code)]
pub async fn remove_campaign_channel(campaign_id: &str) {
    cleanup_campaign_channel(campaign_id).await;
}

/// Clean up all resources for a campaign channel
async fn cleanup_campaign_channel(campaign_id: &str) {
    log::info!("Cleaning up campaign channel: {}", campaign_id);
    let mut channels = CAMPAIGN_CHANNELS.write().await;
    channels.remove(campaign_id);
}

/// Check if a campaign channel exists
#[allow(dead_code)]
pub async fn channel_exists(campaign_id: &str) -> bool {
    let channels = CAMPAIGN_CHANNELS.read().await;
    channels.contains_key(campaign_id)
}

/// Get statistics for all active campaigns
#[allow(dead_code)]
pub async fn get_all_campaigns_stats() -> Vec<CampaignStats> {
    let channels = CAMPAIGN_CHANNELS.read().await;

    channels
        .iter()
        .map(|(campaign_id, info)| CampaignStats {
            campaign_id: campaign_id.clone(),
            message_count: info.message_count,
            elapsed_time: info.created_at.elapsed().as_secs_f64(),
            is_completed: info.is_completed,
        })
        .collect()
}

/// Statistics for a single campaign
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct CampaignStats {
    pub campaign_id: String,
    pub message_count: u32,
    pub elapsed_time: f64,
    pub is_completed: bool,
}
