// Exploitation WebSocket Handler
// Real-time updates for exploitation campaigns

#![allow(dead_code)]

use actix::{Actor, AsyncContext, StreamHandler, ActorContext};
use actix_web::{web, Error, HttpRequest, HttpResponse};
use actix_web_actors::ws;
use crate::web::exploitation_broadcast;
use crate::web::auth::jwt;
use sqlx::SqlitePool;
use std::time::{Duration, Instant};

/// Query parameters for WebSocket authentication
#[derive(Debug, serde::Deserialize)]
pub struct WsAuthQuery {
    pub token: String,
}

// Connection management constants
const HEARTBEAT_INTERVAL: Duration = Duration::from_secs(5);
const CLIENT_TIMEOUT: Duration = Duration::from_secs(30);

pub struct ExploitationWebSocket {
    pub campaign_id: String,
    pub user_id: String,
    last_heartbeat: Instant,
    message_count: u64,
    bytes_sent: u64,
}

impl ExploitationWebSocket {
    pub fn new(campaign_id: String, user_id: String) -> Self {
        Self {
            campaign_id,
            user_id,
            last_heartbeat: Instant::now(),
            message_count: 0,
            bytes_sent: 0,
        }
    }

    fn start_heartbeat(&self, ctx: &mut ws::WebsocketContext<Self>) {
        ctx.run_interval(HEARTBEAT_INTERVAL, |act, ctx| {
            if Instant::now().duration_since(act.last_heartbeat) > CLIENT_TIMEOUT {
                log::warn!(
                    "WebSocket client timeout for campaign: {}, closing connection",
                    act.campaign_id
                );
                ctx.stop();
                return;
            }
            ctx.ping(b"");

            log::debug!(
                "Exploitation WebSocket metrics for campaign {}: {} messages, {} bytes sent",
                act.campaign_id,
                act.message_count,
                act.bytes_sent
            );
        });
    }
}

impl Actor for ExploitationWebSocket {
    type Context = ws::WebsocketContext<Self>;

    fn started(&mut self, ctx: &mut Self::Context) {
        log::info!("Exploitation WebSocket connection established for campaign: {}", self.campaign_id);

        self.start_heartbeat(ctx);

        let campaign_id = self.campaign_id.clone();
        let addr = ctx.address();

        tokio::spawn(async move {
            if let Some(mut rx) = exploitation_broadcast::subscribe_to_campaign(&campaign_id).await {
                log::info!("Subscribed to campaign progress for: {}", campaign_id);

                loop {
                    match rx.recv().await {
                        Ok(msg) => {
                            if let Ok(json) = serde_json::to_string(&msg) {
                                let size = json.len();
                                addr.do_send(BroadcastMessage {
                                    content: json,
                                    size,
                                });
                            }
                        }
                        Err(tokio::sync::broadcast::error::RecvError::Closed) => {
                            log::info!("Broadcast channel closed for campaign: {}", campaign_id);
                            break;
                        }
                        Err(tokio::sync::broadcast::error::RecvError::Lagged(skipped)) => {
                            log::warn!(
                                "WebSocket lagged behind broadcast for campaign: {}, skipped {} messages",
                                campaign_id,
                                skipped
                            );
                            let lag_msg = serde_json::json!({
                                "type": "lag",
                                "skippedMessages": skipped,
                                "campaignId": campaign_id
                            });
                            if let Ok(json) = serde_json::to_string(&lag_msg) {
                                addr.do_send(BroadcastMessage {
                                    content: json.clone(),
                                    size: json.len(),
                                });
                            }
                        }
                    }
                }

                log::info!("Sending close notification for campaign: {}", campaign_id);
                addr.do_send(CloseConnection);
            } else {
                log::warn!("No broadcast channel found for campaign: {}", campaign_id);
                let error_msg = serde_json::json!({
                    "type": "error",
                    "message": "Campaign channel not found. The campaign may not have started yet.",
                    "campaignId": campaign_id
                });
                if let Ok(json) = serde_json::to_string(&error_msg) {
                    addr.do_send(BroadcastMessage {
                        content: json.clone(),
                        size: json.len(),
                    });
                }
            }
        });
    }

    fn stopped(&mut self, _ctx: &mut Self::Context) {
        log::info!(
            "Exploitation WebSocket connection closed for campaign: {} (sent {} messages, {} bytes total)",
            self.campaign_id,
            self.message_count,
            self.bytes_sent
        );
    }
}

#[derive(actix::Message)]
#[rtype(result = "()")]
struct BroadcastMessage {
    content: String,
    size: usize,
}

impl actix::Handler<BroadcastMessage> for ExploitationWebSocket {
    type Result = ();

    fn handle(&mut self, msg: BroadcastMessage, ctx: &mut Self::Context) {
        ctx.text(msg.content);
        self.message_count += 1;
        self.bytes_sent += msg.size as u64;
    }
}

#[derive(actix::Message)]
#[rtype(result = "()")]
struct CloseConnection;

impl actix::Handler<CloseConnection> for ExploitationWebSocket {
    type Result = ();

    fn handle(&mut self, _msg: CloseConnection, ctx: &mut Self::Context) {
        ctx.close(Some(ws::CloseReason {
            code: ws::CloseCode::Normal,
            description: Some("Campaign completed".to_string()),
        }));
        ctx.stop();
    }
}

impl StreamHandler<Result<ws::Message, ws::ProtocolError>> for ExploitationWebSocket {
    fn handle(&mut self, msg: Result<ws::Message, ws::ProtocolError>, ctx: &mut Self::Context) {
        match msg {
            Ok(ws::Message::Ping(msg)) => {
                self.last_heartbeat = Instant::now();
                ctx.pong(&msg);
            }
            Ok(ws::Message::Pong(_)) => {
                self.last_heartbeat = Instant::now();
            }
            Ok(ws::Message::Text(text)) => {
                log::debug!("Received client message for campaign {}: {}", self.campaign_id, text);
                self.last_heartbeat = Instant::now();
            }
            Ok(ws::Message::Binary(_)) => {
                self.last_heartbeat = Instant::now();
            }
            Ok(ws::Message::Close(reason)) => {
                log::info!("Client closed WebSocket for campaign: {}", self.campaign_id);
                ctx.close(reason);
                ctx.stop();
            }
            Ok(ws::Message::Continuation(_)) => {
                log::warn!("Continuation frame received, not supported");
            }
            Ok(ws::Message::Nop) => {}
            Err(err) => {
                log::error!(
                    "WebSocket protocol error for campaign {}: {:?}",
                    self.campaign_id,
                    err
                );
                ctx.stop();
            }
        }
    }
}

pub async fn ws_handler(
    req: HttpRequest,
    stream: web::Payload,
    campaign_id: web::Path<String>,
    query: web::Query<WsAuthQuery>,
    pool: web::Data<SqlitePool>,
) -> Result<HttpResponse, Error> {
    let campaign_id_str = campaign_id.into_inner();

    log::info!("Exploitation WebSocket connection request for campaign: {}", campaign_id_str);

    // Validate JWT token
    let claims = match jwt::verify_jwt(&query.token) {
        Ok(claims) => claims,
        Err(e) => {
            log::warn!("Exploitation WebSocket authentication failed for campaign {}: {}", campaign_id_str, e);
            return Ok(HttpResponse::Unauthorized().json(serde_json::json!({
                "error": "Invalid or expired authentication token"
            })));
        }
    };

    // Verify campaign ownership
    let campaign: Option<(String,)> = sqlx::query_as(
        "SELECT user_id FROM exploitation_campaigns WHERE id = ?",
    )
    .bind(&campaign_id_str)
    .fetch_optional(pool.get_ref())
    .await
    .map_err(|e| {
        log::error!("Database error: {}", e);
        actix_web::error::ErrorInternalServerError("Database error")
    })?;

    match campaign {
        Some((user_id,)) => {
            let is_admin = claims.roles.contains(&"admin".to_string());
            if user_id != claims.sub && !is_admin {
                log::warn!(
                    "Exploitation WebSocket: User {} attempted to access campaign {} owned by {}",
                    claims.sub,
                    campaign_id_str,
                    user_id
                );
                return Ok(HttpResponse::Forbidden().json(serde_json::json!({
                    "error": "Access denied - you do not own this campaign"
                })));
            }
        }
        None => {
            return Ok(HttpResponse::NotFound().json(serde_json::json!({
                "error": "Campaign not found"
            })));
        }
    }

    log::info!(
        "Exploitation WebSocket authenticated: user {} connecting to campaign {}",
        claims.username,
        campaign_id_str
    );

    let resp = ws::start(
        ExploitationWebSocket::new(campaign_id_str, claims.sub),
        &req,
        stream,
    )?;
    Ok(resp)
}
