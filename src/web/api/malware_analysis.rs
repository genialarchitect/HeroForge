//! Malware Analysis API Endpoints
//!
//! REST API for malware sample upload, static analysis, YARA rules, and classification.

use actix_multipart::Multipart;
use actix_web::{web, HttpResponse};
use chrono::Utc;
use futures::StreamExt;
use serde::{Deserialize, Serialize};
use sqlx::{Row, SqlitePool};

use crate::web::auth::Claims;
use crate::web::error::ApiError;
use crate::malware_analysis::{
    SampleStore, StaticAnalyzer, YaraEngine, PackerDetector,
    ApiPatternAnalyzer, ResourceExtractor, CertificateAnalyzer,
    MalwareClassifier, IocExtractor,
    StaticAnalysisResult,
    sandbox::{SandboxManager, SandboxType, SubmissionOptions},
};
use crate::binary_analysis::hashing::compute_md5;

/// Configure malware analysis API routes
pub fn configure(cfg: &mut web::ServiceConfig) {
    cfg.service(
        web::scope("/malware-analysis")
            // Dashboard & Stats
            .route("/stats", web::get().to(get_stats))
            .route("/dashboard", web::get().to(get_dashboard))
            // Samples
            .route("/samples", web::get().to(list_samples))
            .route("/samples", web::post().to(upload_sample))
            .route("/samples/{id}", web::get().to(get_sample))
            .route("/samples/{id}", web::delete().to(delete_sample))
            .route("/samples/{id}/analyze", web::post().to(analyze_sample))
            .route("/samples/{id}/reanalyze", web::post().to(reanalyze_sample))
            .route("/samples/{id}/download", web::get().to(download_sample))
            .route("/samples/{id}/strings", web::get().to(get_sample_strings))
            .route("/samples/{id}/imports", web::get().to(get_sample_imports))
            .route("/samples/{id}/iocs", web::get().to(get_sample_iocs))
            .route("/samples/{id}/yara-matches", web::get().to(get_yara_matches))
            .route("/samples/{id}/classification", web::get().to(get_classification))
            .route("/samples/{id}/tags", web::put().to(update_sample_tags))
            .route("/samples/search", web::post().to(search_samples))
            .route("/samples/lookup", web::post().to(lookup_sample))
            // YARA Rules
            .route("/yara/rules", web::get().to(list_yara_rules))
            .route("/yara/rules", web::post().to(create_yara_rule))
            .route("/yara/rules/{id}", web::get().to(get_yara_rule))
            .route("/yara/rules/{id}", web::put().to(update_yara_rule))
            .route("/yara/rules/{id}", web::delete().to(delete_yara_rule))
            .route("/yara/rules/{id}/toggle", web::post().to(toggle_yara_rule))
            .route("/yara/scan", web::post().to(scan_with_yara))
            // IOCs
            .route("/iocs", web::get().to(list_iocs))
            .route("/iocs/search", web::post().to(search_iocs))
            .route("/iocs/export", web::get().to(export_iocs))
            // Analysis Queue
            .route("/queue", web::get().to(list_queue))
            .route("/queue/{id}/cancel", web::post().to(cancel_queue_item))
            // Dynamic Analysis
            .route("/dynamic/stats", web::get().to(get_dynamic_stats))
            .route("/dynamic/sessions", web::get().to(list_dynamic_sessions))
            .route("/dynamic/sessions", web::post().to(create_dynamic_session))
            .route("/dynamic/sessions/{id}", web::get().to(get_dynamic_session))
            .route("/dynamic/sessions/{id}", web::delete().to(delete_dynamic_session))
            .route("/dynamic/sessions/{id}/start", web::post().to(start_dynamic_session))
            .route("/dynamic/sessions/{id}/stop", web::post().to(stop_dynamic_session))
            .route("/dynamic/sessions/{id}/result", web::get().to(get_dynamic_result))
            .route("/dynamic/sessions/{id}/processes", web::get().to(get_dynamic_processes))
            .route("/dynamic/sessions/{id}/api-calls", web::get().to(get_dynamic_api_calls))
            .route("/dynamic/sessions/{id}/network", web::get().to(get_dynamic_network))
            .route("/dynamic/sessions/{id}/dns", web::get().to(get_dynamic_dns))
            .route("/dynamic/sessions/{id}/http", web::get().to(get_dynamic_http))
            .route("/dynamic/sessions/{id}/files", web::get().to(get_dynamic_files))
            .route("/dynamic/sessions/{id}/registry", web::get().to(get_dynamic_registry))
            .route("/dynamic/sessions/{id}/timeline", web::get().to(get_dynamic_timeline))
            .route("/dynamic/sessions/{id}/dropped", web::get().to(get_dynamic_dropped_files))
            .route("/dynamic/sessions/{id}/memory", web::get().to(get_dynamic_memory_dumps))
            .route("/dynamic/sessions/{id}/screenshots", web::get().to(get_dynamic_screenshots))
            .route("/dynamic/sessions/{id}/anti-analysis", web::get().to(get_dynamic_anti_analysis))
            .route("/dynamic/sessions/{id}/iocs", web::get().to(get_dynamic_iocs))
            .route("/dynamic/sessions/{id}/persistence", web::get().to(get_dynamic_persistence))
            .route("/dynamic/sessions/{id}/mutexes", web::get().to(get_dynamic_mutexes))
            .route("/dynamic/sessions/{id}/c2", web::get().to(get_dynamic_c2_patterns))
            .route("/dynamic/sessions/{id}/ransomware", web::get().to(get_dynamic_ransomware))
            .route("/dynamic/sessions/{id}/report", web::get().to(get_dynamic_report))
            .route("/dynamic/hook-patterns", web::get().to(list_hook_patterns))
            .route("/dynamic/hook-patterns", web::post().to(create_hook_pattern))
            .route("/dynamic/hook-patterns/{id}", web::put().to(update_hook_pattern))
            .route("/dynamic/hook-patterns/{id}", web::delete().to(delete_hook_pattern)),
    );
}

// === Dashboard & Stats ===

#[derive(Debug, Serialize)]
struct MalwareStats {
    total_samples: i64,
    samples_analyzed: i64,
    samples_malicious: i64,
    samples_clean: i64,
    samples_pending: i64,
    total_iocs: i64,
    total_yara_rules: i64,
    yara_matches_total: i64,
    classifications: Vec<ClassificationCount>,
    file_types: Vec<FileTypeCount>,
    recent_samples: Vec<SampleSummary>,
}

#[derive(Debug, Serialize)]
struct ClassificationCount {
    classification: String,
    count: i64,
}

#[derive(Debug, Serialize)]
struct FileTypeCount {
    file_type: String,
    count: i64,
}

async fn get_stats(
    pool: web::Data<SqlitePool>,
    claims: web::ReqData<Claims>,
) -> Result<HttpResponse, ApiError> {
    let total_samples: i64 = sqlx::query_scalar(
        "SELECT COUNT(*) FROM malware_samples WHERE user_id = ?"
    )
    .bind(&claims.sub)
    .fetch_one(pool.get_ref())
    .await
    .unwrap_or(0);

    let samples_analyzed: i64 = sqlx::query_scalar(
        "SELECT COUNT(*) FROM malware_samples WHERE user_id = ? AND last_analyzed IS NOT NULL"
    )
    .bind(&claims.sub)
    .fetch_one(pool.get_ref())
    .await
    .unwrap_or(0);

    let samples_malicious: i64 = sqlx::query_scalar(
        "SELECT COUNT(*) FROM malware_samples WHERE user_id = ? AND is_malicious = 1"
    )
    .bind(&claims.sub)
    .fetch_one(pool.get_ref())
    .await
    .unwrap_or(0);

    let samples_clean: i64 = sqlx::query_scalar(
        "SELECT COUNT(*) FROM malware_samples WHERE user_id = ? AND is_malicious = 0"
    )
    .bind(&claims.sub)
    .fetch_one(pool.get_ref())
    .await
    .unwrap_or(0);

    let samples_pending: i64 = sqlx::query_scalar(
        "SELECT COUNT(*) FROM malware_analysis_queue WHERE user_id = ? AND status = 'pending'"
    )
    .bind(&claims.sub)
    .fetch_one(pool.get_ref())
    .await
    .unwrap_or(0);

    let total_iocs: i64 = sqlx::query_scalar(
        r#"SELECT COUNT(*) FROM malware_iocs i
           JOIN malware_samples s ON i.sample_id = s.id
           WHERE s.user_id = ?"#
    )
    .bind(&claims.sub)
    .fetch_one(pool.get_ref())
    .await
    .unwrap_or(0);

    let total_yara_rules: i64 = sqlx::query_scalar(
        "SELECT COUNT(*) FROM yara_rules WHERE user_id = ? OR is_builtin = 1"
    )
    .bind(&claims.sub)
    .fetch_one(pool.get_ref())
    .await
    .unwrap_or(0);

    let yara_matches_total: i64 = sqlx::query_scalar(
        r#"SELECT COUNT(*) FROM yara_rule_matches m
           JOIN malware_samples s ON m.sample_id = s.id
           WHERE s.user_id = ?"#
    )
    .bind(&claims.sub)
    .fetch_one(pool.get_ref())
    .await
    .unwrap_or(0);

    // Get classification breakdown
    let classifications: Vec<ClassificationCount> = sqlx::query(
        r#"SELECT classification, COUNT(*) as count FROM malware_samples
           WHERE user_id = ? AND classification IS NOT NULL
           GROUP BY classification ORDER BY count DESC LIMIT 10"#
    )
    .bind(&claims.sub)
    .fetch_all(pool.get_ref())
    .await
    .unwrap_or_default()
    .into_iter()
    .map(|row| ClassificationCount {
        classification: row.get("classification"),
        count: row.get("count"),
    })
    .collect();

    // Get file type breakdown
    let file_types: Vec<FileTypeCount> = sqlx::query(
        r#"SELECT file_type, COUNT(*) as count FROM malware_samples
           WHERE user_id = ?
           GROUP BY file_type ORDER BY count DESC LIMIT 10"#
    )
    .bind(&claims.sub)
    .fetch_all(pool.get_ref())
    .await
    .unwrap_or_default()
    .into_iter()
    .map(|row| FileTypeCount {
        file_type: row.get("file_type"),
        count: row.get("count"),
    })
    .collect();

    // Get recent samples
    let recent_samples: Vec<SampleSummary> = sqlx::query(
        r#"SELECT id, original_filename, file_type, file_size, md5, sha256,
                  threat_score, classification, family, created_at
           FROM malware_samples WHERE user_id = ?
           ORDER BY created_at DESC LIMIT 10"#
    )
    .bind(&claims.sub)
    .fetch_all(pool.get_ref())
    .await
    .unwrap_or_default()
    .into_iter()
    .map(|row| SampleSummary {
        id: row.get("id"),
        original_filename: row.get("original_filename"),
        file_type: row.get("file_type"),
        file_size: row.get("file_size"),
        md5: row.get("md5"),
        sha256: row.get("sha256"),
        threat_score: row.get("threat_score"),
        classification: row.get("classification"),
        family: row.get("family"),
        created_at: row.get("created_at"),
    })
    .collect();

    Ok(HttpResponse::Ok().json(MalwareStats {
        total_samples,
        samples_analyzed,
        samples_malicious,
        samples_clean,
        samples_pending,
        total_iocs,
        total_yara_rules,
        yara_matches_total,
        classifications,
        file_types,
        recent_samples,
    }))
}

async fn get_dashboard(
    pool: web::Data<SqlitePool>,
    claims: web::ReqData<Claims>,
) -> Result<HttpResponse, ApiError> {
    // Alias to get_stats for now
    get_stats(pool, claims).await
}

// === Samples ===

#[derive(Debug, Deserialize)]
struct ListSamplesQuery {
    file_type: Option<String>,
    classification: Option<String>,
    is_malicious: Option<bool>,
    search: Option<String>,
    limit: Option<i64>,
    offset: Option<i64>,
}

#[derive(Debug, Deserialize)]
struct UploadSampleQuery {
    customer_id: Option<String>,
    engagement_id: Option<String>,
}

#[derive(Debug, Serialize)]
struct SampleSummary {
    id: String,
    original_filename: String,
    file_type: String,
    file_size: i64,
    md5: String,
    sha256: String,
    threat_score: Option<i32>,
    classification: Option<String>,
    family: Option<String>,
    created_at: String,
}

async fn list_samples(
    pool: web::Data<SqlitePool>,
    claims: web::ReqData<Claims>,
    query: web::Query<ListSamplesQuery>,
) -> Result<HttpResponse, ApiError> {
    let limit = query.limit.unwrap_or(50);
    let offset = query.offset.unwrap_or(0);

    let mut sql = String::from(
        r#"SELECT id, original_filename, file_type, file_size, md5, sha256,
                  threat_score, classification, family, created_at
           FROM malware_samples WHERE user_id = ?"#
    );

    if let Some(ft) = &query.file_type {
        sql.push_str(&format!(" AND file_type = '{}'", ft.replace('\'', "''")));
    }
    if let Some(cls) = &query.classification {
        sql.push_str(&format!(" AND classification = '{}'", cls.replace('\'', "''")));
    }
    if let Some(is_mal) = query.is_malicious {
        sql.push_str(&format!(" AND is_malicious = {}", if is_mal { 1 } else { 0 }));
    }
    if let Some(search) = &query.search {
        let s = search.replace('\'', "''");
        sql.push_str(&format!(
            " AND (original_filename LIKE '%{}%' OR md5 LIKE '%{}%' OR sha256 LIKE '%{}%')",
            s, s, s
        ));
    }

    sql.push_str(" ORDER BY created_at DESC LIMIT ? OFFSET ?");

    let samples: Vec<SampleSummary> = sqlx::query(&sql)
        .bind(&claims.sub)
        .bind(limit)
        .bind(offset)
        .fetch_all(pool.get_ref())
        .await
        .map_err(|e| ApiError::internal(format!("Database error: {}", e)))?
        .into_iter()
        .map(|row| SampleSummary {
            id: row.get("id"),
            original_filename: row.get("original_filename"),
            file_type: row.get("file_type"),
            file_size: row.get("file_size"),
            md5: row.get("md5"),
            sha256: row.get("sha256"),
            threat_score: row.get("threat_score"),
            classification: row.get("classification"),
            family: row.get("family"),
            created_at: row.get("created_at"),
        })
        .collect();

    Ok(HttpResponse::Ok().json(samples))
}

async fn upload_sample(
    pool: web::Data<SqlitePool>,
    claims: web::ReqData<Claims>,
    query: web::Query<UploadSampleQuery>,
    mut payload: Multipart,
) -> Result<HttpResponse, ApiError> {
    let mut file_data: Vec<u8> = Vec::new();
    let mut original_filename = String::from("unknown");
    let mut source = String::from("upload");
    let mut tags: Vec<String> = Vec::new();
    let mut notes = String::new();

    // Process multipart form
    while let Some(item) = payload.next().await {
        let mut field = item.map_err(|e| ApiError::bad_request(format!("Multipart error: {}", e)))?;
        let content_disposition = field.content_disposition();
        let field_name = content_disposition
            .and_then(|cd| cd.get_name().map(|s| s.to_string()))
            .unwrap_or_default();

        match field_name.as_str() {
            "file" => {
                if let Some(filename) = content_disposition.and_then(|cd| cd.get_filename().map(|s| s.to_string())) {
                    original_filename = filename;
                }
                while let Some(chunk) = field.next().await {
                    let data = chunk.map_err(|e| ApiError::bad_request(format!("Read error: {}", e)))?;
                    file_data.extend_from_slice(&data);
                }
            }
            "source" => {
                let mut value = String::new();
                while let Some(chunk) = field.next().await {
                    let data = chunk.map_err(|e| ApiError::bad_request(format!("Read error: {}", e)))?;
                    value.push_str(&String::from_utf8_lossy(&data));
                }
                source = value;
            }
            "tags" => {
                let mut value = String::new();
                while let Some(chunk) = field.next().await {
                    let data = chunk.map_err(|e| ApiError::bad_request(format!("Read error: {}", e)))?;
                    value.push_str(&String::from_utf8_lossy(&data));
                }
                tags = value.split(',').map(|s| s.trim().to_string()).filter(|s| !s.is_empty()).collect();
            }
            "notes" => {
                while let Some(chunk) = field.next().await {
                    let data = chunk.map_err(|e| ApiError::bad_request(format!("Read error: {}", e)))?;
                    notes.push_str(&String::from_utf8_lossy(&data));
                }
            }
            _ => {}
        }
    }

    if file_data.is_empty() {
        return Err(ApiError::bad_request("No file uploaded"));
    }

    // Compute hashes
    let md5 = compute_md5(&file_data);
    let sha1 = crate::binary_analysis::hashing::compute_sha1(&file_data);
    let sha256 = crate::binary_analysis::hashing::compute_sha256(&file_data);

    // Check for duplicate
    let existing: Option<String> = sqlx::query_scalar(
        "SELECT id FROM malware_samples WHERE sha256 = ? AND user_id = ?"
    )
    .bind(&sha256)
    .bind(&claims.sub)
    .fetch_optional(pool.get_ref())
    .await
    .map_err(|e| ApiError::internal(format!("Database error: {}", e)))?;

    if let Some(existing_id) = existing {
        return Ok(HttpResponse::Conflict().json(serde_json::json!({
            "error": "Sample already exists",
            "existing_id": existing_id,
            "sha256": sha256
        })));
    }

    // Detect file type
    let file_type = detect_file_type(&file_data);
    let entropy = SampleStore::compute_entropy(&file_data);
    let file_size = file_data.len() as i64;

    // Store sample (encrypted)
    let id = uuid::Uuid::new_v4().to_string();
    let storage_dir = std::env::var("MALWARE_STORAGE_DIR")
        .unwrap_or_else(|_| "/tmp/malware_samples".to_string());
    std::fs::create_dir_all(&storage_dir)
        .map_err(|e| ApiError::internal(format!("Failed to create storage dir: {}", e)))?;

    let storage_path = format!("{}/{}.enc", storage_dir, id);

    // Encrypt and store
    let sample_store = SampleStore::from_env()
        .map_err(|e| ApiError::internal(format!("Failed to initialize sample store: {}", e)))?;
    sample_store.store_sample(&id, &file_data)
        .map_err(|e| ApiError::internal(format!("Failed to store sample: {}", e)))?;

    let now = Utc::now().to_rfc3339();
    let tags_json = serde_json::to_string(&tags).unwrap_or_else(|_| "[]".to_string());

    // Insert into database
    sqlx::query(
        r#"INSERT INTO malware_samples
           (id, user_id, original_filename, file_size, md5, sha1, sha256, file_type,
            entropy, storage_path, source, tags, notes, created_at, customer_id, engagement_id)
           VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)"#
    )
    .bind(&id)
    .bind(&claims.sub)
    .bind(&original_filename)
    .bind(file_size)
    .bind(&md5)
    .bind(&sha1)
    .bind(&sha256)
    .bind(&file_type)
    .bind(entropy)
    .bind(&storage_path)
    .bind(&source)
    .bind(&tags_json)
    .bind(&notes)
    .bind(&now)
    .bind(&query.customer_id)
    .bind(&query.engagement_id)
    .execute(pool.get_ref())
    .await
    .map_err(|e| ApiError::internal(format!("Database error: {}", e)))?;

    // Queue for analysis
    let queue_id = uuid::Uuid::new_v4().to_string();
    sqlx::query(
        r#"INSERT INTO malware_analysis_queue
           (id, sample_id, user_id, analysis_types, priority, status, created_at)
           VALUES (?, ?, ?, ?, ?, 'pending', ?)"#
    )
    .bind(&queue_id)
    .bind(&id)
    .bind(&claims.sub)
    .bind("static,yara,ioc,classification")
    .bind(5)
    .bind(&now)
    .execute(pool.get_ref())
    .await
    .map_err(|e| ApiError::internal(format!("Database error: {}", e)))?;

    Ok(HttpResponse::Created().json(serde_json::json!({
        "id": id,
        "sha256": sha256,
        "md5": md5,
        "file_type": file_type,
        "file_size": file_size,
        "entropy": entropy,
        "message": "Sample uploaded and queued for analysis"
    })))
}

fn detect_file_type(data: &[u8]) -> String {
    if data.len() < 4 {
        return "unknown".to_string();
    }

    match &data[..4] {
        [0x4D, 0x5A, ..] => "pe".to_string(),
        [0x7F, 0x45, 0x4C, 0x46] => "elf".to_string(),
        [0xCF, 0xFA, 0xED, 0xFE] | [0xFE, 0xED, 0xFA, 0xCF] => "macho".to_string(),
        [0x50, 0x4B, 0x03, 0x04] => {
            // Could be ZIP, APK, JAR, DOCX, etc.
            if data.len() > 30 {
                let content = String::from_utf8_lossy(&data[..100.min(data.len())]);
                if content.contains("AndroidManifest") {
                    return "apk".to_string();
                }
            }
            "zip".to_string()
        }
        [0x25, 0x50, 0x44, 0x46] => "pdf".to_string(),
        [0xD0, 0xCF, 0x11, 0xE0] => "ole".to_string(), // MS Office
        _ => {
            // Check for scripts
            let text = String::from_utf8_lossy(&data[..100.min(data.len())]);
            if text.starts_with("#!/") || text.starts_with("#!") {
                return "script".to_string();
            }
            if text.contains("<?php") {
                return "php".to_string();
            }
            if text.contains("<script") || text.contains("function(") {
                return "javascript".to_string();
            }
            "unknown".to_string()
        }
    }
}

#[derive(Debug, Serialize)]
struct SampleDetail {
    id: String,
    original_filename: String,
    file_size: i64,
    md5: String,
    sha1: String,
    sha256: String,
    ssdeep: Option<String>,
    file_type: String,
    mime_type: Option<String>,
    entropy: f64,
    source: String,
    source_url: Option<String>,
    tags: Vec<String>,
    notes: Option<String>,
    is_malicious: Option<bool>,
    threat_score: Option<i32>,
    classification: Option<String>,
    family: Option<String>,
    first_seen: String,
    last_analyzed: Option<String>,
    analysis_count: i32,
    created_at: String,
    static_analysis: Option<serde_json::Value>,
    yara_matches: Vec<YaraMatchSummary>,
    iocs: Vec<IocSummary>,
}

#[derive(Debug, Serialize)]
struct YaraMatchSummary {
    rule_name: String,
    tags: Vec<String>,
    matched_at: String,
}

#[derive(Debug, Serialize)]
struct IocSummary {
    ioc_type: String,
    value: String,
    confidence: f64,
}

async fn get_sample(
    pool: web::Data<SqlitePool>,
    claims: web::ReqData<Claims>,
    path: web::Path<String>,
) -> Result<HttpResponse, ApiError> {
    let sample_id = path.into_inner();

    let row = sqlx::query(
        r#"SELECT * FROM malware_samples WHERE id = ? AND user_id = ?"#
    )
    .bind(&sample_id)
    .bind(&claims.sub)
    .fetch_optional(pool.get_ref())
    .await
    .map_err(|e| ApiError::internal(format!("Database error: {}", e)))?;

    let row = row.ok_or_else(|| ApiError::not_found("Sample not found"))?;

    let tags_str: String = row.get("tags");
    let tags: Vec<String> = serde_json::from_str(&tags_str).unwrap_or_default();

    // Get static analysis
    let static_analysis: Option<serde_json::Value> = sqlx::query_scalar(
        r#"SELECT pe_info FROM malware_static_analysis WHERE sample_id = ? ORDER BY created_at DESC LIMIT 1"#
    )
    .bind(&sample_id)
    .fetch_optional(pool.get_ref())
    .await
    .ok()
    .flatten()
    .and_then(|s: String| serde_json::from_str(&s).ok());

    // Get YARA matches
    let yara_matches: Vec<YaraMatchSummary> = sqlx::query(
        r#"SELECT rule_name, tags, matched_at FROM yara_rule_matches WHERE sample_id = ?"#
    )
    .bind(&sample_id)
    .fetch_all(pool.get_ref())
    .await
    .unwrap_or_default()
    .into_iter()
    .map(|r| {
        let tags_str: String = r.get("tags");
        YaraMatchSummary {
            rule_name: r.get("rule_name"),
            tags: serde_json::from_str(&tags_str).unwrap_or_default(),
            matched_at: r.get("matched_at"),
        }
    })
    .collect();

    // Get IOCs
    let iocs: Vec<IocSummary> = sqlx::query(
        r#"SELECT ioc_type, value, confidence FROM malware_iocs WHERE sample_id = ? LIMIT 100"#
    )
    .bind(&sample_id)
    .fetch_all(pool.get_ref())
    .await
    .unwrap_or_default()
    .into_iter()
    .map(|r| IocSummary {
        ioc_type: r.get("ioc_type"),
        value: r.get("value"),
        confidence: r.get("confidence"),
    })
    .collect();

    let is_malicious: Option<i32> = row.get("is_malicious");

    Ok(HttpResponse::Ok().json(SampleDetail {
        id: row.get("id"),
        original_filename: row.get("original_filename"),
        file_size: row.get("file_size"),
        md5: row.get("md5"),
        sha1: row.get("sha1"),
        sha256: row.get("sha256"),
        ssdeep: row.get("ssdeep"),
        file_type: row.get("file_type"),
        mime_type: row.get("mime_type"),
        entropy: row.get("entropy"),
        source: row.get("source"),
        source_url: row.get("source_url"),
        tags,
        notes: row.get("notes"),
        is_malicious: is_malicious.map(|v| v == 1),
        threat_score: row.get("threat_score"),
        classification: row.get("classification"),
        family: row.get("family"),
        first_seen: row.get("first_seen"),
        last_analyzed: row.get("last_analyzed"),
        analysis_count: row.get("analysis_count"),
        created_at: row.get("created_at"),
        static_analysis,
        yara_matches,
        iocs,
    }))
}

async fn delete_sample(
    pool: web::Data<SqlitePool>,
    claims: web::ReqData<Claims>,
    path: web::Path<String>,
) -> Result<HttpResponse, ApiError> {
    let sample_id = path.into_inner();

    // Get storage path
    let storage_path: Option<String> = sqlx::query_scalar(
        "SELECT storage_path FROM malware_samples WHERE id = ? AND user_id = ?"
    )
    .bind(&sample_id)
    .bind(&claims.sub)
    .fetch_optional(pool.get_ref())
    .await
    .map_err(|e| ApiError::internal(format!("Database error: {}", e)))?;

    let storage_path = storage_path.ok_or_else(|| ApiError::not_found("Sample not found"))?;

    // Delete file
    let _ = std::fs::remove_file(&storage_path);

    // Delete from database (cascades to related tables)
    sqlx::query("DELETE FROM malware_samples WHERE id = ? AND user_id = ?")
        .bind(&sample_id)
        .bind(&claims.sub)
        .execute(pool.get_ref())
        .await
        .map_err(|e| ApiError::internal(format!("Database error: {}", e)))?;

    Ok(HttpResponse::Ok().json(serde_json::json!({
        "message": "Sample deleted successfully"
    })))
}

async fn analyze_sample(
    pool: web::Data<SqlitePool>,
    claims: web::ReqData<Claims>,
    path: web::Path<String>,
) -> Result<HttpResponse, ApiError> {
    let sample_id = path.into_inner();

    // Verify sample exists and belongs to user
    let sample: Option<(String, String)> = sqlx::query_as(
        "SELECT id, storage_path FROM malware_samples WHERE id = ? AND user_id = ?"
    )
    .bind(&sample_id)
    .bind(&claims.sub)
    .fetch_optional(pool.get_ref())
    .await
    .map_err(|e| ApiError::internal(format!("Database error: {}", e)))?;

    let (id, storage_path) = sample.ok_or_else(|| ApiError::not_found("Sample not found"))?;

    // Read and decrypt sample
    let sample_store = SampleStore::from_env()
        .map_err(|e| ApiError::internal(format!("Failed to initialize sample store: {}", e)))?;

    let data = sample_store.retrieve_sample(&id)
        .map_err(|e| ApiError::internal(format!("Failed to retrieve sample: {}", e)))?;

    // Run static analysis
    let analyzer = StaticAnalyzer::new(sample_store);
    let analysis = analyzer.analyze(&data)
        .map_err(|e| ApiError::internal(format!("Static analysis failed: {}", e)))?;

    // Run YARA
    let yara_engine = YaraEngine::new();
    let yara_matches = yara_engine.scan(&data);

    // Detect packers
    let packer_detector = PackerDetector::new();
    let packer_info = if let Some(ref pe_info) = analysis.pe_info {
        packer_detector.detect_pe(&data, &pe_info.sections, pe_info.entry_point)
    } else if let Some(ref elf_info) = analysis.elf_info {
        packer_detector.detect_elf(&data, &elf_info.sections)
    } else {
        None
    };

    // Analyze API patterns
    let api_analyzer = ApiPatternAnalyzer::new();
    let suspicious_patterns = api_analyzer.analyze(&analysis.imports);

    // Extract resources
    let resource_extractor = ResourceExtractor::new();
    let resources = resource_extractor.extract_pe_resources(&data).unwrap_or_default();
    let _overlay = resource_extractor.extract_overlay(&data);

    // Analyze certificates
    let cert_analyzer = CertificateAnalyzer::new();
    let certificates = cert_analyzer.analyze(&data).unwrap_or_default();

    // Extract IOCs
    let ioc_extractor = IocExtractor::new();
    let iocs = ioc_extractor.extract_from_binary(&data, &sample_id);

    // Build complete analysis result for classification
    let complete_analysis = StaticAnalysisResult {
        id: uuid::Uuid::new_v4().to_string(),
        sample_id: sample_id.clone(),
        pe_info: analysis.pe_info.clone(),
        elf_info: analysis.elf_info.clone(),
        imports: analysis.imports.clone(),
        exports: analysis.exports.clone(),
        strings_interesting: analysis.strings_interesting.clone(),
        yara_matches: yara_matches.clone(),
        packer_detected: packer_info.clone(),
        compiler_detected: analysis.compiler_detected.clone(),
        certificates: certificates.clone(),
        resources: resources.clone(),
        suspicious_patterns: suspicious_patterns.clone(),
        created_at: Utc::now(),
    };

    // Classify
    let classifier = MalwareClassifier::new();
    let classification = classifier.classify(&complete_analysis);

    let now = Utc::now().to_rfc3339();
    let analysis_id = uuid::Uuid::new_v4().to_string();

    // Store analysis results
    let pe_info_json = serde_json::to_string(&analysis.pe_info).ok();
    let elf_info_json = serde_json::to_string(&analysis.elf_info).ok();
    let imports_json = serde_json::to_string(&analysis.imports).ok();
    let exports_json = serde_json::to_string(&analysis.exports).ok();
    let strings_json = serde_json::to_string(&analysis.strings_interesting).ok();
    let yara_json = serde_json::to_string(&yara_matches).ok();
    let packer_json = serde_json::to_string(&packer_info).ok();
    let certs_json = serde_json::to_string(&certificates).ok();
    let resources_json = serde_json::to_string(&resources).ok();
    let patterns_json = serde_json::to_string(&suspicious_patterns).ok();
    let iocs_json = serde_json::to_string(&iocs).ok();
    let classification_json = serde_json::to_string(&classification).ok();

    sqlx::query(
        r#"INSERT INTO malware_static_analysis
           (id, sample_id, analysis_type, file_type, pe_info, elf_info, imports, exports,
            strings_count, strings_interesting, yara_matches, packer_detected,
            certificates, resources, suspicious_patterns, iocs, classification_result,
            threat_score, created_at)
           VALUES (?, ?, 'static', ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)"#
    )
    .bind(&analysis_id)
    .bind(&sample_id)
    .bind(if analysis.pe_info.is_some() { "pe" } else if analysis.elf_info.is_some() { "elf" } else { "unknown" })
    .bind(&pe_info_json)
    .bind(&elf_info_json)
    .bind(&imports_json)
    .bind(&exports_json)
    .bind(analysis.strings_interesting.len() as i32)
    .bind(&strings_json)
    .bind(&yara_json)
    .bind(&packer_json)
    .bind(&certs_json)
    .bind(&resources_json)
    .bind(&patterns_json)
    .bind(&iocs_json)
    .bind(&classification_json)
    .bind(classification.threat_score as i32)
    .bind(&now)
    .execute(pool.get_ref())
    .await
    .map_err(|e| ApiError::internal(format!("Database error: {}", e)))?;

    // Store YARA matches
    for ym in &yara_matches {
        let match_id = uuid::Uuid::new_v4().to_string();
        let tags_json = serde_json::to_string(&ym.tags).unwrap_or_else(|_| "[]".to_string());
        let strings_json = serde_json::to_string(&ym.matched_strings).unwrap_or_else(|_| "[]".to_string());

        let _ = sqlx::query(
            r#"INSERT OR IGNORE INTO yara_rule_matches
               (id, sample_id, rule_id, rule_name, rule_namespace, tags, matched_strings, matched_at)
               VALUES (?, ?, ?, ?, ?, ?, ?, ?)"#
        )
        .bind(&match_id)
        .bind(&sample_id)
        .bind(&ym.rule_name) // Using rule_name as rule_id for built-in rules
        .bind(&ym.rule_name)
        .bind(&ym.rule_namespace)
        .bind(&tags_json)
        .bind(&strings_json)
        .bind(&now)
        .execute(pool.get_ref())
        .await;
    }

    // Store IOCs
    for ioc in &iocs {
        let ioc_id = uuid::Uuid::new_v4().to_string();
        let _ = sqlx::query(
            r#"INSERT OR IGNORE INTO malware_iocs
               (id, sample_id, ioc_type, value, confidence, created_at)
               VALUES (?, ?, ?, ?, ?, ?)"#
        )
        .bind(&ioc_id)
        .bind(&sample_id)
        .bind(format!("{:?}", ioc.ioc_type))
        .bind(&ioc.ioc_value)
        .bind(ioc.confidence)
        .bind(&now)
        .execute(pool.get_ref())
        .await;
    }

    // Update sample with results
    let is_malicious = classification.threat_score > 50;
    sqlx::query(
        r#"UPDATE malware_samples
           SET last_analyzed = ?, analysis_count = analysis_count + 1,
               threat_score = ?, classification = ?, family = ?, is_malicious = ?
           WHERE id = ?"#
    )
    .bind(&now)
    .bind(classification.threat_score as i32)
    .bind(format!("{:?}", classification.classification))
    .bind(&classification.family)
    .bind(if is_malicious { 1 } else { 0 })
    .bind(&sample_id)
    .execute(pool.get_ref())
    .await
    .map_err(|e| ApiError::internal(format!("Database error: {}", e)))?;

    Ok(HttpResponse::Ok().json(serde_json::json!({
        "analysis_id": analysis_id,
        "threat_score": classification.threat_score,
        "classification": format!("{:?}", classification.classification),
        "family": classification.family,
        "yara_matches": yara_matches.len(),
        "iocs_extracted": iocs.len(),
        "suspicious_patterns": suspicious_patterns.len(),
        "packer_detected": packer_info.is_some(),
        "message": "Analysis completed successfully"
    })))
}

async fn reanalyze_sample(
    pool: web::Data<SqlitePool>,
    claims: web::ReqData<Claims>,
    path: web::Path<String>,
) -> Result<HttpResponse, ApiError> {
    // Just call analyze_sample again
    analyze_sample(pool, claims, path).await
}

async fn download_sample(
    pool: web::Data<SqlitePool>,
    claims: web::ReqData<Claims>,
    path: web::Path<String>,
) -> Result<HttpResponse, ApiError> {
    let sample_id = path.into_inner();

    // Verify ownership
    let sample: Option<(String, String)> = sqlx::query_as(
        "SELECT id, original_filename FROM malware_samples WHERE id = ? AND user_id = ?"
    )
    .bind(&sample_id)
    .bind(&claims.sub)
    .fetch_optional(pool.get_ref())
    .await
    .map_err(|e| ApiError::internal(format!("Database error: {}", e)))?;

    let (id, filename) = sample.ok_or_else(|| ApiError::not_found("Sample not found"))?;

    // Retrieve sample
    let sample_store = SampleStore::from_env()
        .map_err(|e| ApiError::internal(format!("Failed to initialize sample store: {}", e)))?;

    let data = sample_store.retrieve_sample(&id)
        .map_err(|e| ApiError::internal(format!("Failed to retrieve sample: {}", e)))?;

    Ok(HttpResponse::Ok()
        .content_type("application/octet-stream")
        .insert_header(("Content-Disposition", format!("attachment; filename=\"{}.malware\"", filename)))
        .body(data))
}

async fn get_sample_strings(
    pool: web::Data<SqlitePool>,
    claims: web::ReqData<Claims>,
    path: web::Path<String>,
) -> Result<HttpResponse, ApiError> {
    let sample_id = path.into_inner();

    let strings_json: Option<String> = sqlx::query_scalar(
        r#"SELECT strings_interesting FROM malware_static_analysis a
           JOIN malware_samples s ON a.sample_id = s.id
           WHERE s.id = ? AND s.user_id = ?
           ORDER BY a.created_at DESC LIMIT 1"#
    )
    .bind(&sample_id)
    .bind(&claims.sub)
    .fetch_optional(pool.get_ref())
    .await
    .map_err(|e| ApiError::internal(format!("Database error: {}", e)))?;

    let strings: Vec<serde_json::Value> = strings_json
        .and_then(|s| serde_json::from_str(&s).ok())
        .unwrap_or_default();

    Ok(HttpResponse::Ok().json(strings))
}

async fn get_sample_imports(
    pool: web::Data<SqlitePool>,
    claims: web::ReqData<Claims>,
    path: web::Path<String>,
) -> Result<HttpResponse, ApiError> {
    let sample_id = path.into_inner();

    let imports_json: Option<String> = sqlx::query_scalar(
        r#"SELECT imports FROM malware_static_analysis a
           JOIN malware_samples s ON a.sample_id = s.id
           WHERE s.id = ? AND s.user_id = ?
           ORDER BY a.created_at DESC LIMIT 1"#
    )
    .bind(&sample_id)
    .bind(&claims.sub)
    .fetch_optional(pool.get_ref())
    .await
    .map_err(|e| ApiError::internal(format!("Database error: {}", e)))?;

    let imports: Vec<serde_json::Value> = imports_json
        .and_then(|s| serde_json::from_str(&s).ok())
        .unwrap_or_default();

    Ok(HttpResponse::Ok().json(imports))
}

async fn get_sample_iocs(
    pool: web::Data<SqlitePool>,
    claims: web::ReqData<Claims>,
    path: web::Path<String>,
) -> Result<HttpResponse, ApiError> {
    let sample_id = path.into_inner();

    let iocs: Vec<IocSummary> = sqlx::query(
        r#"SELECT i.ioc_type, i.value, i.confidence FROM malware_iocs i
           JOIN malware_samples s ON i.sample_id = s.id
           WHERE s.id = ? AND s.user_id = ?"#
    )
    .bind(&sample_id)
    .bind(&claims.sub)
    .fetch_all(pool.get_ref())
    .await
    .unwrap_or_default()
    .into_iter()
    .map(|r| IocSummary {
        ioc_type: r.get("ioc_type"),
        value: r.get("value"),
        confidence: r.get("confidence"),
    })
    .collect();

    Ok(HttpResponse::Ok().json(iocs))
}

async fn get_yara_matches(
    pool: web::Data<SqlitePool>,
    claims: web::ReqData<Claims>,
    path: web::Path<String>,
) -> Result<HttpResponse, ApiError> {
    let sample_id = path.into_inner();

    let matches = sqlx::query(
        r#"SELECT m.* FROM yara_rule_matches m
           JOIN malware_samples s ON m.sample_id = s.id
           WHERE s.id = ? AND s.user_id = ?"#
    )
    .bind(&sample_id)
    .bind(&claims.sub)
    .fetch_all(pool.get_ref())
    .await
    .map_err(|e| ApiError::internal(format!("Database error: {}", e)))?;

    let results: Vec<serde_json::Value> = matches.into_iter()
        .map(|r| {
            let tags_str: String = r.get("tags");
            let strings_str: String = r.get("matched_strings");
            serde_json::json!({
                "id": r.get::<String, _>("id"),
                "rule_name": r.get::<String, _>("rule_name"),
                "rule_namespace": r.get::<Option<String>, _>("rule_namespace"),
                "tags": serde_json::from_str::<Vec<String>>(&tags_str).unwrap_or_default(),
                "matched_strings": serde_json::from_str::<Vec<serde_json::Value>>(&strings_str).unwrap_or_default(),
                "matched_at": r.get::<String, _>("matched_at")
            })
        })
        .collect();

    Ok(HttpResponse::Ok().json(results))
}

async fn get_classification(
    pool: web::Data<SqlitePool>,
    claims: web::ReqData<Claims>,
    path: web::Path<String>,
) -> Result<HttpResponse, ApiError> {
    let sample_id = path.into_inner();

    let classification = sqlx::query(
        r#"SELECT c.* FROM malware_classifications c
           JOIN malware_samples s ON c.sample_id = s.id
           WHERE s.id = ? AND s.user_id = ?
           ORDER BY c.created_at DESC LIMIT 1"#
    )
    .bind(&sample_id)
    .bind(&claims.sub)
    .fetch_optional(pool.get_ref())
    .await
    .map_err(|e| ApiError::internal(format!("Database error: {}", e)))?;

    if let Some(row) = classification {
        let reasoning_str: String = row.get("reasoning");
        Ok(HttpResponse::Ok().json(serde_json::json!({
            "classification": row.get::<String, _>("classification"),
            "family": row.get::<Option<String>, _>("family"),
            "confidence": row.get::<f64, _>("confidence"),
            "threat_score": row.get::<i32, _>("threat_score"),
            "reasoning": serde_json::from_str::<Vec<String>>(&reasoning_str).unwrap_or_default(),
            "classified_by": row.get::<String, _>("classified_by"),
            "created_at": row.get::<String, _>("created_at")
        })))
    } else {
        // Return sample's classification if no detailed record
        let sample = sqlx::query(
            "SELECT classification, family, threat_score FROM malware_samples WHERE id = ? AND user_id = ?"
        )
        .bind(&sample_id)
        .bind(&claims.sub)
        .fetch_optional(pool.get_ref())
        .await
        .map_err(|e| ApiError::internal(format!("Database error: {}", e)))?;

        if let Some(row) = sample {
            Ok(HttpResponse::Ok().json(serde_json::json!({
                "classification": row.get::<Option<String>, _>("classification"),
                "family": row.get::<Option<String>, _>("family"),
                "threat_score": row.get::<Option<i32>, _>("threat_score"),
            })))
        } else {
            Err(ApiError::not_found("Sample not found"))
        }
    }
}

#[derive(Debug, Deserialize)]
struct UpdateTagsRequest {
    tags: Vec<String>,
}

async fn update_sample_tags(
    pool: web::Data<SqlitePool>,
    claims: web::ReqData<Claims>,
    path: web::Path<String>,
    body: web::Json<UpdateTagsRequest>,
) -> Result<HttpResponse, ApiError> {
    let sample_id = path.into_inner();
    let tags_json = serde_json::to_string(&body.tags)
        .map_err(|e| ApiError::bad_request(format!("Invalid tags: {}", e)))?;

    let result = sqlx::query(
        "UPDATE malware_samples SET tags = ? WHERE id = ? AND user_id = ?"
    )
    .bind(&tags_json)
    .bind(&sample_id)
    .bind(&claims.sub)
    .execute(pool.get_ref())
    .await
    .map_err(|e| ApiError::internal(format!("Database error: {}", e)))?;

    if result.rows_affected() == 0 {
        return Err(ApiError::not_found("Sample not found"));
    }

    Ok(HttpResponse::Ok().json(serde_json::json!({
        "message": "Tags updated successfully"
    })))
}

#[derive(Debug, Deserialize)]
struct SearchSamplesRequest {
    query: Option<String>,
    hash: Option<String>,
    file_type: Option<String>,
    classification: Option<String>,
    min_threat_score: Option<i32>,
    max_threat_score: Option<i32>,
    limit: Option<i64>,
}

async fn search_samples(
    pool: web::Data<SqlitePool>,
    claims: web::ReqData<Claims>,
    body: web::Json<SearchSamplesRequest>,
) -> Result<HttpResponse, ApiError> {
    let limit = body.limit.unwrap_or(50);

    let mut sql = String::from(
        "SELECT id, original_filename, file_type, file_size, md5, sha256, threat_score, classification, family, created_at FROM malware_samples WHERE user_id = ?"
    );

    if let Some(q) = &body.query {
        let q = q.replace('\'', "''");
        sql.push_str(&format!(
            " AND (original_filename LIKE '%{}%' OR notes LIKE '%{}%')",
            q, q
        ));
    }

    if let Some(h) = &body.hash {
        let h = h.replace('\'', "''");
        sql.push_str(&format!(
            " AND (md5 = '{}' OR sha1 = '{}' OR sha256 = '{}')",
            h, h, h
        ));
    }

    if let Some(ft) = &body.file_type {
        sql.push_str(&format!(" AND file_type = '{}'", ft.replace('\'', "''")));
    }

    if let Some(cls) = &body.classification {
        sql.push_str(&format!(" AND classification = '{}'", cls.replace('\'', "''")));
    }

    if let Some(min) = body.min_threat_score {
        sql.push_str(&format!(" AND threat_score >= {}", min));
    }

    if let Some(max) = body.max_threat_score {
        sql.push_str(&format!(" AND threat_score <= {}", max));
    }

    sql.push_str(" ORDER BY created_at DESC LIMIT ?");

    let samples: Vec<SampleSummary> = sqlx::query(&sql)
        .bind(&claims.sub)
        .bind(limit)
        .fetch_all(pool.get_ref())
        .await
        .map_err(|e| ApiError::internal(format!("Database error: {}", e)))?
        .into_iter()
        .map(|row| SampleSummary {
            id: row.get("id"),
            original_filename: row.get("original_filename"),
            file_type: row.get("file_type"),
            file_size: row.get("file_size"),
            md5: row.get("md5"),
            sha256: row.get("sha256"),
            threat_score: row.get("threat_score"),
            classification: row.get("classification"),
            family: row.get("family"),
            created_at: row.get("created_at"),
        })
        .collect();

    Ok(HttpResponse::Ok().json(samples))
}

#[derive(Debug, Deserialize)]
struct LookupSampleRequest {
    hash: String,
}

async fn lookup_sample(
    pool: web::Data<SqlitePool>,
    claims: web::ReqData<Claims>,
    body: web::Json<LookupSampleRequest>,
) -> Result<HttpResponse, ApiError> {
    let hash = body.hash.to_lowercase();

    let sample: Option<SampleSummary> = sqlx::query(
        r#"SELECT id, original_filename, file_type, file_size, md5, sha256, threat_score, classification, family, created_at
           FROM malware_samples
           WHERE user_id = ? AND (md5 = ? OR sha1 = ? OR sha256 = ?)
           LIMIT 1"#
    )
    .bind(&claims.sub)
    .bind(&hash)
    .bind(&hash)
    .bind(&hash)
    .fetch_optional(pool.get_ref())
    .await
    .map_err(|e| ApiError::internal(format!("Database error: {}", e)))?
    .map(|row| SampleSummary {
        id: row.get("id"),
        original_filename: row.get("original_filename"),
        file_type: row.get("file_type"),
        file_size: row.get("file_size"),
        md5: row.get("md5"),
        sha256: row.get("sha256"),
        threat_score: row.get("threat_score"),
        classification: row.get("classification"),
        family: row.get("family"),
        created_at: row.get("created_at"),
    });

    if let Some(s) = sample {
        Ok(HttpResponse::Ok().json(serde_json::json!({
            "found": true,
            "sample": s
        })))
    } else {
        Ok(HttpResponse::Ok().json(serde_json::json!({
            "found": false
        })))
    }
}

// === YARA Rules ===

#[derive(Debug, Deserialize)]
struct ListYaraRulesQuery {
    category: Option<String>,
    include_builtin: Option<bool>,
}

async fn list_yara_rules(
    pool: web::Data<SqlitePool>,
    claims: web::ReqData<Claims>,
    query: web::Query<ListYaraRulesQuery>,
) -> Result<HttpResponse, ApiError> {
    let include_builtin = query.include_builtin.unwrap_or(true);

    let mut sql = String::from(
        r#"SELECT id, name, description, category, tags, severity, is_enabled, is_builtin, match_count, created_at
           FROM yara_rules WHERE (user_id = ?"#
    );

    if include_builtin {
        sql.push_str(" OR is_builtin = 1)");
    } else {
        sql.push(')');
    }

    if let Some(cat) = &query.category {
        sql.push_str(&format!(" AND category = '{}'", cat.replace('\'', "''")));
    }

    sql.push_str(" ORDER BY is_builtin DESC, name ASC");

    let rules = sqlx::query(&sql)
        .bind(&claims.sub)
        .fetch_all(pool.get_ref())
        .await
        .map_err(|e| ApiError::internal(format!("Database error: {}", e)))?;

    let results: Vec<serde_json::Value> = rules.into_iter()
        .map(|r| {
            let tags_str: String = r.get("tags");
            serde_json::json!({
                "id": r.get::<String, _>("id"),
                "name": r.get::<String, _>("name"),
                "description": r.get::<Option<String>, _>("description"),
                "category": r.get::<String, _>("category"),
                "tags": serde_json::from_str::<Vec<String>>(&tags_str).unwrap_or_default(),
                "severity": r.get::<String, _>("severity"),
                "is_enabled": r.get::<i32, _>("is_enabled") == 1,
                "is_builtin": r.get::<i32, _>("is_builtin") == 1,
                "match_count": r.get::<i32, _>("match_count"),
                "created_at": r.get::<String, _>("created_at")
            })
        })
        .collect();

    Ok(HttpResponse::Ok().json(results))
}

#[derive(Debug, Deserialize)]
struct CreateYaraRuleRequest {
    name: String,
    description: Option<String>,
    category: String,
    rule_content: String,
    tags: Vec<String>,
    severity: Option<String>,
}

async fn create_yara_rule(
    pool: web::Data<SqlitePool>,
    claims: web::ReqData<Claims>,
    body: web::Json<CreateYaraRuleRequest>,
) -> Result<HttpResponse, ApiError> {
    let id = uuid::Uuid::new_v4().to_string();
    let now = Utc::now().to_rfc3339();
    let tags_json = serde_json::to_string(&body.tags).unwrap_or_else(|_| "[]".to_string());
    let severity = body.severity.clone().unwrap_or_else(|| "medium".to_string());

    sqlx::query(
        r#"INSERT INTO yara_rules
           (id, user_id, name, description, category, rule_content, tags, severity, is_builtin, created_at, updated_at)
           VALUES (?, ?, ?, ?, ?, ?, ?, ?, 0, ?, ?)"#
    )
    .bind(&id)
    .bind(&claims.sub)
    .bind(&body.name)
    .bind(&body.description)
    .bind(&body.category)
    .bind(&body.rule_content)
    .bind(&tags_json)
    .bind(&severity)
    .bind(&now)
    .bind(&now)
    .execute(pool.get_ref())
    .await
    .map_err(|e| {
        if e.to_string().contains("UNIQUE") {
            ApiError::bad_request("Rule with this name already exists")
        } else {
            ApiError::internal(format!("Database error: {}", e))
        }
    })?;

    Ok(HttpResponse::Created().json(serde_json::json!({
        "id": id,
        "message": "YARA rule created successfully"
    })))
}

async fn get_yara_rule(
    pool: web::Data<SqlitePool>,
    claims: web::ReqData<Claims>,
    path: web::Path<String>,
) -> Result<HttpResponse, ApiError> {
    let rule_id = path.into_inner();

    let rule = sqlx::query(
        "SELECT * FROM yara_rules WHERE id = ? AND (user_id = ? OR is_builtin = 1)"
    )
    .bind(&rule_id)
    .bind(&claims.sub)
    .fetch_optional(pool.get_ref())
    .await
    .map_err(|e| ApiError::internal(format!("Database error: {}", e)))?;

    let row = rule.ok_or_else(|| ApiError::not_found("Rule not found"))?;
    let tags_str: String = row.get("tags");

    Ok(HttpResponse::Ok().json(serde_json::json!({
        "id": row.get::<String, _>("id"),
        "name": row.get::<String, _>("name"),
        "description": row.get::<Option<String>, _>("description"),
        "category": row.get::<String, _>("category"),
        "rule_content": row.get::<String, _>("rule_content"),
        "tags": serde_json::from_str::<Vec<String>>(&tags_str).unwrap_or_default(),
        "severity": row.get::<String, _>("severity"),
        "is_enabled": row.get::<i32, _>("is_enabled") == 1,
        "is_builtin": row.get::<i32, _>("is_builtin") == 1,
        "match_count": row.get::<i32, _>("match_count"),
        "created_at": row.get::<String, _>("created_at"),
        "updated_at": row.get::<String, _>("updated_at")
    })))
}

async fn update_yara_rule(
    pool: web::Data<SqlitePool>,
    claims: web::ReqData<Claims>,
    path: web::Path<String>,
    body: web::Json<CreateYaraRuleRequest>,
) -> Result<HttpResponse, ApiError> {
    let rule_id = path.into_inner();
    let now = Utc::now().to_rfc3339();
    let tags_json = serde_json::to_string(&body.tags).unwrap_or_else(|_| "[]".to_string());
    let severity = body.severity.clone().unwrap_or_else(|| "medium".to_string());

    let result = sqlx::query(
        r#"UPDATE yara_rules
           SET name = ?, description = ?, category = ?, rule_content = ?, tags = ?, severity = ?, updated_at = ?
           WHERE id = ? AND user_id = ? AND is_builtin = 0"#
    )
    .bind(&body.name)
    .bind(&body.description)
    .bind(&body.category)
    .bind(&body.rule_content)
    .bind(&tags_json)
    .bind(&severity)
    .bind(&now)
    .bind(&rule_id)
    .bind(&claims.sub)
    .execute(pool.get_ref())
    .await
    .map_err(|e| ApiError::internal(format!("Database error: {}", e)))?;

    if result.rows_affected() == 0 {
        return Err(ApiError::not_found("Rule not found or cannot modify built-in rule"));
    }

    Ok(HttpResponse::Ok().json(serde_json::json!({
        "message": "Rule updated successfully"
    })))
}

async fn delete_yara_rule(
    pool: web::Data<SqlitePool>,
    claims: web::ReqData<Claims>,
    path: web::Path<String>,
) -> Result<HttpResponse, ApiError> {
    let rule_id = path.into_inner();

    let result = sqlx::query(
        "DELETE FROM yara_rules WHERE id = ? AND user_id = ? AND is_builtin = 0"
    )
    .bind(&rule_id)
    .bind(&claims.sub)
    .execute(pool.get_ref())
    .await
    .map_err(|e| ApiError::internal(format!("Database error: {}", e)))?;

    if result.rows_affected() == 0 {
        return Err(ApiError::not_found("Rule not found or cannot delete built-in rule"));
    }

    Ok(HttpResponse::Ok().json(serde_json::json!({
        "message": "Rule deleted successfully"
    })))
}

async fn toggle_yara_rule(
    pool: web::Data<SqlitePool>,
    claims: web::ReqData<Claims>,
    path: web::Path<String>,
) -> Result<HttpResponse, ApiError> {
    let rule_id = path.into_inner();
    let now = Utc::now().to_rfc3339();

    let result = sqlx::query(
        r#"UPDATE yara_rules
           SET is_enabled = CASE WHEN is_enabled = 1 THEN 0 ELSE 1 END, updated_at = ?
           WHERE id = ? AND (user_id = ? OR is_builtin = 1)"#
    )
    .bind(&now)
    .bind(&rule_id)
    .bind(&claims.sub)
    .execute(pool.get_ref())
    .await
    .map_err(|e| ApiError::internal(format!("Database error: {}", e)))?;

    if result.rows_affected() == 0 {
        return Err(ApiError::not_found("Rule not found"));
    }

    Ok(HttpResponse::Ok().json(serde_json::json!({
        "message": "Rule toggled successfully"
    })))
}

#[derive(Debug, Deserialize)]
struct ScanWithYaraRequest {
    sample_id: String,
}

async fn scan_with_yara(
    pool: web::Data<SqlitePool>,
    claims: web::ReqData<Claims>,
    body: web::Json<ScanWithYaraRequest>,
) -> Result<HttpResponse, ApiError> {
    // Just trigger analysis on the sample
    let path = web::Path::from(body.sample_id.clone());
    analyze_sample(pool, claims, path).await
}

// === IOCs ===

#[derive(Debug, Deserialize)]
struct ListIocsQuery {
    ioc_type: Option<String>,
    limit: Option<i64>,
    offset: Option<i64>,
}

async fn list_iocs(
    pool: web::Data<SqlitePool>,
    claims: web::ReqData<Claims>,
    query: web::Query<ListIocsQuery>,
) -> Result<HttpResponse, ApiError> {
    let limit = query.limit.unwrap_or(100);
    let offset = query.offset.unwrap_or(0);

    let mut sql = String::from(
        r#"SELECT i.*, s.original_filename, s.sha256 as sample_sha256
           FROM malware_iocs i
           JOIN malware_samples s ON i.sample_id = s.id
           WHERE s.user_id = ?"#
    );

    if let Some(it) = &query.ioc_type {
        sql.push_str(&format!(" AND i.ioc_type = '{}'", it.replace('\'', "''")));
    }

    sql.push_str(" ORDER BY i.created_at DESC LIMIT ? OFFSET ?");

    let iocs = sqlx::query(&sql)
        .bind(&claims.sub)
        .bind(limit)
        .bind(offset)
        .fetch_all(pool.get_ref())
        .await
        .map_err(|e| ApiError::internal(format!("Database error: {}", e)))?;

    let results: Vec<serde_json::Value> = iocs.into_iter()
        .map(|r| serde_json::json!({
            "id": r.get::<String, _>("id"),
            "sample_id": r.get::<String, _>("sample_id"),
            "sample_filename": r.get::<String, _>("original_filename"),
            "sample_sha256": r.get::<String, _>("sample_sha256"),
            "ioc_type": r.get::<String, _>("ioc_type"),
            "value": r.get::<String, _>("value"),
            "context": r.get::<Option<String>, _>("context"),
            "confidence": r.get::<f64, _>("confidence"),
            "threat_intel_hit": r.get::<i32, _>("threat_intel_hit") == 1,
            "created_at": r.get::<String, _>("created_at")
        }))
        .collect();

    Ok(HttpResponse::Ok().json(results))
}

#[derive(Debug, Deserialize)]
struct SearchIocsRequest {
    value: String,
    ioc_type: Option<String>,
}

async fn search_iocs(
    pool: web::Data<SqlitePool>,
    claims: web::ReqData<Claims>,
    body: web::Json<SearchIocsRequest>,
) -> Result<HttpResponse, ApiError> {
    let value = body.value.replace('\'', "''");

    let mut sql = String::from(
        r#"SELECT i.*, s.original_filename, s.sha256 as sample_sha256
           FROM malware_iocs i
           JOIN malware_samples s ON i.sample_id = s.id
           WHERE s.user_id = ? AND i.value LIKE ?"#
    );

    if let Some(it) = &body.ioc_type {
        sql.push_str(&format!(" AND i.ioc_type = '{}'", it.replace('\'', "''")));
    }

    sql.push_str(" ORDER BY i.confidence DESC LIMIT 100");

    let iocs = sqlx::query(&sql)
        .bind(&claims.sub)
        .bind(format!("%{}%", value))
        .fetch_all(pool.get_ref())
        .await
        .map_err(|e| ApiError::internal(format!("Database error: {}", e)))?;

    let results: Vec<serde_json::Value> = iocs.into_iter()
        .map(|r| serde_json::json!({
            "id": r.get::<String, _>("id"),
            "sample_id": r.get::<String, _>("sample_id"),
            "sample_filename": r.get::<String, _>("original_filename"),
            "sample_sha256": r.get::<String, _>("sample_sha256"),
            "ioc_type": r.get::<String, _>("ioc_type"),
            "value": r.get::<String, _>("value"),
            "confidence": r.get::<f64, _>("confidence"),
        }))
        .collect();

    Ok(HttpResponse::Ok().json(results))
}

#[derive(Debug, Deserialize)]
struct ExportIocsQuery {
    format: Option<String>,
    ioc_type: Option<String>,
}

async fn export_iocs(
    pool: web::Data<SqlitePool>,
    claims: web::ReqData<Claims>,
    query: web::Query<ExportIocsQuery>,
) -> Result<HttpResponse, ApiError> {
    let format = query.format.clone().unwrap_or_else(|| "csv".to_string());

    let mut sql = String::from(
        r#"SELECT i.ioc_type, i.value, i.confidence, s.sha256 as sample_sha256
           FROM malware_iocs i
           JOIN malware_samples s ON i.sample_id = s.id
           WHERE s.user_id = ?"#
    );

    if let Some(it) = &query.ioc_type {
        sql.push_str(&format!(" AND i.ioc_type = '{}'", it.replace('\'', "''")));
    }

    sql.push_str(" ORDER BY i.ioc_type, i.value");

    let iocs = sqlx::query(&sql)
        .bind(&claims.sub)
        .fetch_all(pool.get_ref())
        .await
        .map_err(|e| ApiError::internal(format!("Database error: {}", e)))?;

    match format.as_str() {
        "csv" => {
            let mut csv = String::from("ioc_type,value,confidence,sample_sha256\n");
            for r in iocs {
                csv.push_str(&format!(
                    "{},{},{},{}\n",
                    r.get::<String, _>("ioc_type"),
                    r.get::<String, _>("value"),
                    r.get::<f64, _>("confidence"),
                    r.get::<String, _>("sample_sha256")
                ));
            }
            Ok(HttpResponse::Ok()
                .content_type("text/csv")
                .insert_header(("Content-Disposition", "attachment; filename=\"iocs.csv\""))
                .body(csv))
        }
        _ => {
            let results: Vec<serde_json::Value> = iocs.into_iter()
                .map(|r| serde_json::json!({
                    "ioc_type": r.get::<String, _>("ioc_type"),
                    "value": r.get::<String, _>("value"),
                    "confidence": r.get::<f64, _>("confidence"),
                    "sample_sha256": r.get::<String, _>("sample_sha256")
                }))
                .collect();
            Ok(HttpResponse::Ok().json(results))
        }
    }
}

// === Analysis Queue ===

async fn list_queue(
    pool: web::Data<SqlitePool>,
    claims: web::ReqData<Claims>,
) -> Result<HttpResponse, ApiError> {
    let items = sqlx::query(
        r#"SELECT q.*, s.original_filename, s.sha256
           FROM malware_analysis_queue q
           JOIN malware_samples s ON q.sample_id = s.id
           WHERE q.user_id = ?
           ORDER BY q.priority DESC, q.created_at ASC
           LIMIT 100"#
    )
    .bind(&claims.sub)
    .fetch_all(pool.get_ref())
    .await
    .map_err(|e| ApiError::internal(format!("Database error: {}", e)))?;

    let results: Vec<serde_json::Value> = items.into_iter()
        .map(|r| serde_json::json!({
            "id": r.get::<String, _>("id"),
            "sample_id": r.get::<String, _>("sample_id"),
            "sample_filename": r.get::<String, _>("original_filename"),
            "sample_sha256": r.get::<String, _>("sha256"),
            "analysis_types": r.get::<String, _>("analysis_types"),
            "priority": r.get::<i32, _>("priority"),
            "status": r.get::<String, _>("status"),
            "attempts": r.get::<i32, _>("attempts"),
            "error_message": r.get::<Option<String>, _>("error_message"),
            "created_at": r.get::<String, _>("created_at")
        }))
        .collect();

    Ok(HttpResponse::Ok().json(results))
}

async fn cancel_queue_item(
    pool: web::Data<SqlitePool>,
    claims: web::ReqData<Claims>,
    path: web::Path<String>,
) -> Result<HttpResponse, ApiError> {
    let queue_id = path.into_inner();

    let result = sqlx::query(
        "UPDATE malware_analysis_queue SET status = 'cancelled' WHERE id = ? AND user_id = ? AND status = 'pending'"
    )
    .bind(&queue_id)
    .bind(&claims.sub)
    .execute(pool.get_ref())
    .await
    .map_err(|e| ApiError::internal(format!("Database error: {}", e)))?;

    if result.rows_affected() == 0 {
        return Err(ApiError::not_found("Queue item not found or already processed"));
    }

    Ok(HttpResponse::Ok().json(serde_json::json!({
        "message": "Queue item cancelled"
    })))
}

// === Dynamic Analysis ===

#[derive(Debug, Serialize)]
struct DynamicStats {
    total_sessions: i64,
    sessions_pending: i64,
    sessions_running: i64,
    sessions_completed: i64,
    sessions_failed: i64,
    total_malicious: i64,
    total_suspicious: i64,
    total_clean: i64,
    total_processes: i64,
    total_api_calls: i64,
    total_network_connections: i64,
    total_iocs_extracted: i64,
    recent_sessions: Vec<serde_json::Value>,
}

async fn get_dynamic_stats(
    pool: web::Data<SqlitePool>,
    claims: web::ReqData<Claims>,
) -> Result<HttpResponse, ApiError> {
    let total_sessions: i64 = sqlx::query_scalar(
        "SELECT COUNT(*) FROM dynamic_analysis_sessions WHERE user_id = ?"
    )
    .bind(&claims.sub)
    .fetch_one(pool.get_ref())
    .await
    .unwrap_or(0);

    let sessions_pending: i64 = sqlx::query_scalar(
        "SELECT COUNT(*) FROM dynamic_analysis_sessions WHERE user_id = ? AND status = 'pending'"
    )
    .bind(&claims.sub)
    .fetch_one(pool.get_ref())
    .await
    .unwrap_or(0);

    let sessions_running: i64 = sqlx::query_scalar(
        "SELECT COUNT(*) FROM dynamic_analysis_sessions WHERE user_id = ? AND status = 'running'"
    )
    .bind(&claims.sub)
    .fetch_one(pool.get_ref())
    .await
    .unwrap_or(0);

    let sessions_completed: i64 = sqlx::query_scalar(
        "SELECT COUNT(*) FROM dynamic_analysis_sessions WHERE user_id = ? AND status = 'completed'"
    )
    .bind(&claims.sub)
    .fetch_one(pool.get_ref())
    .await
    .unwrap_or(0);

    let sessions_failed: i64 = sqlx::query_scalar(
        "SELECT COUNT(*) FROM dynamic_analysis_sessions WHERE user_id = ? AND status = 'failed'"
    )
    .bind(&claims.sub)
    .fetch_one(pool.get_ref())
    .await
    .unwrap_or(0);

    let total_malicious: i64 = sqlx::query_scalar(
        r#"SELECT COUNT(*) FROM dynamic_analysis_results r
           JOIN dynamic_analysis_sessions s ON r.session_id = s.id
           WHERE s.user_id = ? AND r.verdict = 'malicious'"#
    )
    .bind(&claims.sub)
    .fetch_one(pool.get_ref())
    .await
    .unwrap_or(0);

    let total_suspicious: i64 = sqlx::query_scalar(
        r#"SELECT COUNT(*) FROM dynamic_analysis_results r
           JOIN dynamic_analysis_sessions s ON r.session_id = s.id
           WHERE s.user_id = ? AND r.verdict = 'suspicious'"#
    )
    .bind(&claims.sub)
    .fetch_one(pool.get_ref())
    .await
    .unwrap_or(0);

    let total_clean: i64 = sqlx::query_scalar(
        r#"SELECT COUNT(*) FROM dynamic_analysis_results r
           JOIN dynamic_analysis_sessions s ON r.session_id = s.id
           WHERE s.user_id = ? AND r.verdict = 'clean'"#
    )
    .bind(&claims.sub)
    .fetch_one(pool.get_ref())
    .await
    .unwrap_or(0);

    let total_processes: i64 = sqlx::query_scalar(
        r#"SELECT COUNT(*) FROM dynamic_processes p
           JOIN dynamic_analysis_sessions s ON p.session_id = s.id
           WHERE s.user_id = ?"#
    )
    .bind(&claims.sub)
    .fetch_one(pool.get_ref())
    .await
    .unwrap_or(0);

    let total_api_calls: i64 = sqlx::query_scalar(
        r#"SELECT COUNT(*) FROM dynamic_api_calls a
           JOIN dynamic_analysis_sessions s ON a.session_id = s.id
           WHERE s.user_id = ?"#
    )
    .bind(&claims.sub)
    .fetch_one(pool.get_ref())
    .await
    .unwrap_or(0);

    let total_network_connections: i64 = sqlx::query_scalar(
        r#"SELECT COUNT(*) FROM dynamic_network_activity n
           JOIN dynamic_analysis_sessions s ON n.session_id = s.id
           WHERE s.user_id = ?"#
    )
    .bind(&claims.sub)
    .fetch_one(pool.get_ref())
    .await
    .unwrap_or(0);

    let total_iocs_extracted: i64 = sqlx::query_scalar(
        r#"SELECT COUNT(*) FROM dynamic_iocs i
           JOIN dynamic_analysis_sessions s ON i.session_id = s.id
           WHERE s.user_id = ?"#
    )
    .bind(&claims.sub)
    .fetch_one(pool.get_ref())
    .await
    .unwrap_or(0);

    let recent_rows = sqlx::query(
        r#"SELECT s.id, s.sample_id, s.environment, s.os_type, s.status, s.created_at,
                  m.sha256, m.original_filename,
                  r.verdict, r.threat_score
           FROM dynamic_analysis_sessions s
           LEFT JOIN malware_samples m ON s.sample_id = m.id
           LEFT JOIN dynamic_analysis_results r ON s.id = r.session_id
           WHERE s.user_id = ?
           ORDER BY s.created_at DESC
           LIMIT 10"#
    )
    .bind(&claims.sub)
    .fetch_all(pool.get_ref())
    .await
    .unwrap_or_default();

    let recent_sessions: Vec<serde_json::Value> = recent_rows.into_iter()
        .map(|r| serde_json::json!({
            "id": r.get::<String, _>("id"),
            "sample_id": r.get::<String, _>("sample_id"),
            "sha256": r.get::<Option<String>, _>("sha256"),
            "filename": r.get::<Option<String>, _>("original_filename"),
            "environment": r.get::<String, _>("environment"),
            "os_type": r.get::<String, _>("os_type"),
            "status": r.get::<String, _>("status"),
            "verdict": r.get::<Option<String>, _>("verdict"),
            "threat_score": r.get::<Option<i32>, _>("threat_score"),
            "created_at": r.get::<String, _>("created_at")
        }))
        .collect();

    Ok(HttpResponse::Ok().json(DynamicStats {
        total_sessions,
        sessions_pending,
        sessions_running,
        sessions_completed,
        sessions_failed,
        total_malicious,
        total_suspicious,
        total_clean,
        total_processes,
        total_api_calls,
        total_network_connections,
        total_iocs_extracted,
        recent_sessions,
    }))
}

#[derive(Debug, Deserialize)]
struct ListDynamicSessionsQuery {
    status: Option<String>,
    sample_id: Option<String>,
    limit: Option<i32>,
    offset: Option<i32>,
}

async fn list_dynamic_sessions(
    pool: web::Data<SqlitePool>,
    claims: web::ReqData<Claims>,
    query: web::Query<ListDynamicSessionsQuery>,
) -> Result<HttpResponse, ApiError> {
    let limit = query.limit.unwrap_or(50).min(100);
    let offset = query.offset.unwrap_or(0);

    let mut sql = String::from(
        r#"SELECT s.*, m.sha256, m.original_filename,
                  r.verdict, r.threat_score, r.confidence
           FROM dynamic_analysis_sessions s
           LEFT JOIN malware_samples m ON s.sample_id = m.id
           LEFT JOIN dynamic_analysis_results r ON s.id = r.session_id
           WHERE s.user_id = ?"#
    );

    if query.status.is_some() {
        sql.push_str(" AND s.status = ?");
    }
    if query.sample_id.is_some() {
        sql.push_str(" AND s.sample_id = ?");
    }

    sql.push_str(" ORDER BY s.created_at DESC LIMIT ? OFFSET ?");

    let mut q = sqlx::query(&sql).bind(&claims.sub);

    if let Some(ref status) = query.status {
        q = q.bind(status);
    }
    if let Some(ref sample_id) = query.sample_id {
        q = q.bind(sample_id);
    }

    let rows = q
        .bind(limit)
        .bind(offset)
        .fetch_all(pool.get_ref())
        .await
        .map_err(|e| ApiError::internal(format!("Database error: {}", e)))?;

    let sessions: Vec<serde_json::Value> = rows.into_iter()
        .map(|r| serde_json::json!({
            "id": r.get::<String, _>("id"),
            "sample_id": r.get::<String, _>("sample_id"),
            "sha256": r.get::<Option<String>, _>("sha256"),
            "filename": r.get::<Option<String>, _>("original_filename"),
            "environment": r.get::<String, _>("environment"),
            "os_type": r.get::<String, _>("os_type"),
            "os_version": r.get::<Option<String>, _>("os_version"),
            "architecture": r.get::<String, _>("architecture"),
            "analysis_timeout_secs": r.get::<i32, _>("analysis_timeout_secs"),
            "network_enabled": r.get::<bool, _>("network_enabled"),
            "human_interaction": r.get::<bool, _>("human_interaction"),
            "status": r.get::<String, _>("status"),
            "started_at": r.get::<Option<String>, _>("started_at"),
            "completed_at": r.get::<Option<String>, _>("completed_at"),
            "execution_time_secs": r.get::<Option<i32>, _>("execution_time_secs"),
            "error_message": r.get::<Option<String>, _>("error_message"),
            "verdict": r.get::<Option<String>, _>("verdict"),
            "threat_score": r.get::<Option<i32>, _>("threat_score"),
            "confidence": r.get::<Option<f64>, _>("confidence"),
            "created_at": r.get::<String, _>("created_at")
        }))
        .collect();

    Ok(HttpResponse::Ok().json(sessions))
}

#[derive(Debug, Deserialize)]
struct CreateDynamicSessionRequest {
    sample_id: String,
    environment: Option<String>,
    os_type: Option<String>,
    os_version: Option<String>,
    architecture: Option<String>,
    analysis_timeout_secs: Option<i32>,
    network_enabled: Option<bool>,
    human_interaction: Option<bool>,
}

async fn create_dynamic_session(
    pool: web::Data<SqlitePool>,
    claims: web::ReqData<Claims>,
    body: web::Json<CreateDynamicSessionRequest>,
) -> Result<HttpResponse, ApiError> {
    // Verify sample exists and belongs to user
    let sample_exists: bool = sqlx::query_scalar(
        "SELECT COUNT(*) > 0 FROM malware_samples WHERE id = ? AND user_id = ?"
    )
    .bind(&body.sample_id)
    .bind(&claims.sub)
    .fetch_one(pool.get_ref())
    .await
    .unwrap_or(false);

    if !sample_exists {
        return Err(ApiError::not_found("Sample not found"));
    }

    let session_id = uuid::Uuid::new_v4().to_string();
    let environment = body.environment.clone().unwrap_or_else(|| "sandbox".to_string());
    let os_type = body.os_type.clone().unwrap_or_else(|| "windows".to_string());
    let architecture = body.architecture.clone().unwrap_or_else(|| "x64".to_string());
    let timeout = body.analysis_timeout_secs.unwrap_or(300);
    let network = body.network_enabled.unwrap_or(false);
    let human = body.human_interaction.unwrap_or(false);

    sqlx::query(
        r#"INSERT INTO dynamic_analysis_sessions
           (id, sample_id, user_id, environment, os_type, os_version, architecture,
            analysis_timeout_secs, network_enabled, human_interaction, status)
           VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, 'pending')"#
    )
    .bind(&session_id)
    .bind(&body.sample_id)
    .bind(&claims.sub)
    .bind(&environment)
    .bind(&os_type)
    .bind(&body.os_version)
    .bind(&architecture)
    .bind(timeout)
    .bind(network)
    .bind(human)
    .execute(pool.get_ref())
    .await
    .map_err(|e| ApiError::internal(format!("Failed to create session: {}", e)))?;

    Ok(HttpResponse::Created().json(serde_json::json!({
        "id": session_id,
        "sample_id": body.sample_id,
        "environment": environment,
        "os_type": os_type,
        "status": "pending",
        "message": "Dynamic analysis session created"
    })))
}

async fn get_dynamic_session(
    pool: web::Data<SqlitePool>,
    claims: web::ReqData<Claims>,
    path: web::Path<String>,
) -> Result<HttpResponse, ApiError> {
    let session_id = path.into_inner();

    let row = sqlx::query(
        r#"SELECT s.*, m.sha256, m.original_filename, m.file_type,
                  r.id as result_id, r.verdict, r.verdict_classification, r.threat_score,
                  r.confidence, r.threat_categories, r.summary,
                  r.process_count, r.api_call_count, r.network_connection_count,
                  r.file_operation_count, r.registry_operation_count,
                  r.dropped_file_count, r.anti_analysis_technique_count, r.ioc_count,
                  r.persistence_detected, r.code_injection_detected,
                  r.c2_communication_detected, r.ransomware_behavior_detected,
                  r.data_exfiltration_detected, r.mitre_techniques
           FROM dynamic_analysis_sessions s
           LEFT JOIN malware_samples m ON s.sample_id = m.id
           LEFT JOIN dynamic_analysis_results r ON s.id = r.session_id
           WHERE s.id = ? AND s.user_id = ?"#
    )
    .bind(&session_id)
    .bind(&claims.sub)
    .fetch_optional(pool.get_ref())
    .await
    .map_err(|e| ApiError::internal(format!("Database error: {}", e)))?;

    match row {
        Some(r) => Ok(HttpResponse::Ok().json(serde_json::json!({
            "id": r.get::<String, _>("id"),
            "sample_id": r.get::<String, _>("sample_id"),
            "sha256": r.get::<Option<String>, _>("sha256"),
            "filename": r.get::<Option<String>, _>("original_filename"),
            "file_type": r.get::<Option<String>, _>("file_type"),
            "environment": r.get::<String, _>("environment"),
            "os_type": r.get::<String, _>("os_type"),
            "os_version": r.get::<Option<String>, _>("os_version"),
            "architecture": r.get::<String, _>("architecture"),
            "analysis_timeout_secs": r.get::<i32, _>("analysis_timeout_secs"),
            "network_enabled": r.get::<bool, _>("network_enabled"),
            "human_interaction": r.get::<bool, _>("human_interaction"),
            "status": r.get::<String, _>("status"),
            "started_at": r.get::<Option<String>, _>("started_at"),
            "completed_at": r.get::<Option<String>, _>("completed_at"),
            "execution_time_secs": r.get::<Option<i32>, _>("execution_time_secs"),
            "error_message": r.get::<Option<String>, _>("error_message"),
            "created_at": r.get::<String, _>("created_at"),
            "result": {
                "verdict": r.get::<Option<String>, _>("verdict"),
                "verdict_classification": r.get::<Option<String>, _>("verdict_classification"),
                "threat_score": r.get::<Option<i32>, _>("threat_score"),
                "confidence": r.get::<Option<f64>, _>("confidence"),
                "threat_categories": r.get::<Option<String>, _>("threat_categories"),
                "summary": r.get::<Option<String>, _>("summary"),
                "process_count": r.get::<Option<i32>, _>("process_count"),
                "api_call_count": r.get::<Option<i32>, _>("api_call_count"),
                "network_connection_count": r.get::<Option<i32>, _>("network_connection_count"),
                "file_operation_count": r.get::<Option<i32>, _>("file_operation_count"),
                "registry_operation_count": r.get::<Option<i32>, _>("registry_operation_count"),
                "dropped_file_count": r.get::<Option<i32>, _>("dropped_file_count"),
                "anti_analysis_technique_count": r.get::<Option<i32>, _>("anti_analysis_technique_count"),
                "ioc_count": r.get::<Option<i32>, _>("ioc_count"),
                "persistence_detected": r.get::<Option<bool>, _>("persistence_detected"),
                "code_injection_detected": r.get::<Option<bool>, _>("code_injection_detected"),
                "c2_communication_detected": r.get::<Option<bool>, _>("c2_communication_detected"),
                "ransomware_behavior_detected": r.get::<Option<bool>, _>("ransomware_behavior_detected"),
                "data_exfiltration_detected": r.get::<Option<bool>, _>("data_exfiltration_detected"),
                "mitre_techniques": r.get::<Option<String>, _>("mitre_techniques")
            }
        }))),
        None => Err(ApiError::not_found("Session not found")),
    }
}

async fn delete_dynamic_session(
    pool: web::Data<SqlitePool>,
    claims: web::ReqData<Claims>,
    path: web::Path<String>,
) -> Result<HttpResponse, ApiError> {
    let session_id = path.into_inner();

    let result = sqlx::query(
        "DELETE FROM dynamic_analysis_sessions WHERE id = ? AND user_id = ?"
    )
    .bind(&session_id)
    .bind(&claims.sub)
    .execute(pool.get_ref())
    .await
    .map_err(|e| ApiError::internal(format!("Database error: {}", e)))?;

    if result.rows_affected() == 0 {
        return Err(ApiError::not_found("Session not found"));
    }

    Ok(HttpResponse::Ok().json(serde_json::json!({
        "message": "Session deleted"
    })))
}

async fn start_dynamic_session(
    pool: web::Data<SqlitePool>,
    claims: web::ReqData<Claims>,
    path: web::Path<String>,
) -> Result<HttpResponse, ApiError> {
    let session_id = path.into_inner();

    // Check session exists and is pending
    let status: Option<String> = sqlx::query_scalar(
        "SELECT status FROM dynamic_analysis_sessions WHERE id = ? AND user_id = ?"
    )
    .bind(&session_id)
    .bind(&claims.sub)
    .fetch_optional(pool.get_ref())
    .await
    .map_err(|e| ApiError::internal(format!("Database error: {}", e)))?;

    match status {
        None => return Err(ApiError::not_found("Session not found")),
        Some(s) if s != "pending" => {
            return Err(ApiError::bad_request(format!("Session is already {}", s)));
        }
        _ => {}
    }

    // Get session details for sandbox dispatch
    let session_row = sqlx::query(
        r#"SELECT s.sample_id, s.sandbox_type, s.environment, s.timeout_seconds, s.network_enabled, s.internet_simulation, s.fake_desktop,
           m.file_name, m.file_hash, m.file_path
           FROM dynamic_analysis_sessions s
           JOIN malware_samples m ON s.sample_id = m.id
           WHERE s.id = ? AND s.user_id = ?"#
    )
    .bind(&session_id)
    .bind(&claims.sub)
    .fetch_optional(pool.get_ref())
    .await
    .map_err(|e| ApiError::internal(format!("Database error: {}", e)))?;

    let session_row = match session_row {
        Some(r) => r,
        None => return Err(ApiError::not_found("Session not found")),
    };

    let sandbox_type: String = session_row.get("sandbox_type");
    let file_hash: String = session_row.get("file_hash");
    let file_path: Option<String> = session_row.get("file_path");
    let timeout: i32 = session_row.get("timeout_seconds");
    let network_enabled: bool = session_row.get("network_enabled");

    // Update status to running
    sqlx::query(
        "UPDATE dynamic_analysis_sessions SET status = 'running', started_at = datetime('now') WHERE id = ?"
    )
    .bind(&session_id)
    .execute(pool.get_ref())
    .await
    .map_err(|e| ApiError::internal(format!("Database error: {}", e)))?;

    // Dispatch to appropriate sandbox based on type
    let pool_clone = pool.get_ref().clone();
    let session_id_clone = session_id.clone();
    let sandbox_type_for_response = sandbox_type.clone();

    tokio::spawn(async move {
        let result = dispatch_to_sandbox(
            &sandbox_type,
            &file_hash,
            file_path.as_deref(),
            timeout as u32,
            network_enabled,
        ).await;

        match result {
            Ok(sandbox_result) => {
                // Update session with results
                let _ = sqlx::query(
                    r#"UPDATE dynamic_analysis_sessions
                       SET status = 'completed',
                           completed_at = datetime('now'),
                           sandbox_report = ?,
                           threat_score = ?,
                           verdict = ?,
                           network_connections = ?,
                           processes_created = ?,
                           files_modified = ?,
                           registry_changes = ?,
                           anti_analysis_technique_count = ?
                       WHERE id = ?"#
                )
                .bind(serde_json::to_string(&sandbox_result.report).ok())
                .bind(sandbox_result.threat_score)
                .bind(&sandbox_result.verdict)
                .bind(sandbox_result.network_connections as i32)
                .bind(sandbox_result.processes_created as i32)
                .bind(sandbox_result.files_modified as i32)
                .bind(sandbox_result.registry_changes as i32)
                .bind(sandbox_result.anti_analysis_count as i32)
                .bind(&session_id_clone)
                .execute(&pool_clone)
                .await;

                log::info!("Sandbox analysis completed for session {}: verdict={}",
                    session_id_clone, sandbox_result.verdict);
            }
            Err(e) => {
                // Mark session as failed
                let _ = sqlx::query(
                    "UPDATE dynamic_analysis_sessions SET status = 'failed', completed_at = datetime('now'), error_message = ? WHERE id = ?"
                )
                .bind(e.to_string())
                .bind(&session_id_clone)
                .execute(&pool_clone)
                .await;

                log::error!("Sandbox analysis failed for session {}: {}", session_id_clone, e);
            }
        }
    });

    Ok(HttpResponse::Ok().json(serde_json::json!({
        "id": session_id,
        "status": "running",
        "message": "Dynamic analysis started - dispatched to sandbox",
        "sandbox_type": sandbox_type_for_response
    })))
}

async fn stop_dynamic_session(
    pool: web::Data<SqlitePool>,
    claims: web::ReqData<Claims>,
    path: web::Path<String>,
) -> Result<HttpResponse, ApiError> {
    let session_id = path.into_inner();

    let result = sqlx::query(
        r#"UPDATE dynamic_analysis_sessions
           SET status = 'stopped', completed_at = datetime('now')
           WHERE id = ? AND user_id = ? AND status = 'running'"#
    )
    .bind(&session_id)
    .bind(&claims.sub)
    .execute(pool.get_ref())
    .await
    .map_err(|e| ApiError::internal(format!("Database error: {}", e)))?;

    if result.rows_affected() == 0 {
        return Err(ApiError::bad_request("Session not found or not running"));
    }

    Ok(HttpResponse::Ok().json(serde_json::json!({
        "id": session_id,
        "status": "stopped",
        "message": "Dynamic analysis stopped"
    })))
}

async fn get_dynamic_result(
    pool: web::Data<SqlitePool>,
    claims: web::ReqData<Claims>,
    path: web::Path<String>,
) -> Result<HttpResponse, ApiError> {
    let session_id = path.into_inner();

    let row = sqlx::query(
        r#"SELECT r.* FROM dynamic_analysis_results r
           JOIN dynamic_analysis_sessions s ON r.session_id = s.id
           WHERE s.id = ? AND s.user_id = ?"#
    )
    .bind(&session_id)
    .bind(&claims.sub)
    .fetch_optional(pool.get_ref())
    .await
    .map_err(|e| ApiError::internal(format!("Database error: {}", e)))?;

    match row {
        Some(r) => Ok(HttpResponse::Ok().json(serde_json::json!({
            "id": r.get::<String, _>("id"),
            "session_id": r.get::<String, _>("session_id"),
            "verdict": r.get::<String, _>("verdict"),
            "verdict_classification": r.get::<String, _>("verdict_classification"),
            "threat_score": r.get::<i32, _>("threat_score"),
            "confidence": r.get::<f64, _>("confidence"),
            "threat_categories": r.get::<Option<String>, _>("threat_categories"),
            "summary": r.get::<Option<String>, _>("summary"),
            "process_count": r.get::<i32, _>("process_count"),
            "api_call_count": r.get::<i32, _>("api_call_count"),
            "network_connection_count": r.get::<i32, _>("network_connection_count"),
            "file_operation_count": r.get::<i32, _>("file_operation_count"),
            "registry_operation_count": r.get::<i32, _>("registry_operation_count"),
            "dropped_file_count": r.get::<i32, _>("dropped_file_count"),
            "anti_analysis_technique_count": r.get::<i32, _>("anti_analysis_technique_count"),
            "ioc_count": r.get::<i32, _>("ioc_count"),
            "persistence_detected": r.get::<bool, _>("persistence_detected"),
            "code_injection_detected": r.get::<bool, _>("code_injection_detected"),
            "c2_communication_detected": r.get::<bool, _>("c2_communication_detected"),
            "ransomware_behavior_detected": r.get::<bool, _>("ransomware_behavior_detected"),
            "data_exfiltration_detected": r.get::<bool, _>("data_exfiltration_detected"),
            "mitre_techniques": r.get::<Option<String>, _>("mitre_techniques"),
            "created_at": r.get::<String, _>("created_at")
        }))),
        None => Err(ApiError::not_found("Result not found")),
    }
}

async fn get_dynamic_processes(
    pool: web::Data<SqlitePool>,
    claims: web::ReqData<Claims>,
    path: web::Path<String>,
) -> Result<HttpResponse, ApiError> {
    let session_id = path.into_inner();

    // Verify session belongs to user
    verify_session_ownership(&pool, &session_id, &claims.sub).await?;

    let rows = sqlx::query(
        "SELECT * FROM dynamic_processes WHERE session_id = ? ORDER BY started_at"
    )
    .bind(&session_id)
    .fetch_all(pool.get_ref())
    .await
    .map_err(|e| ApiError::internal(format!("Database error: {}", e)))?;

    let processes: Vec<serde_json::Value> = rows.into_iter()
        .map(|r| serde_json::json!({
            "id": r.get::<String, _>("id"),
            "pid": r.get::<i32, _>("pid"),
            "parent_pid": r.get::<i32, _>("parent_pid"),
            "name": r.get::<String, _>("name"),
            "path": r.get::<Option<String>, _>("path"),
            "command_line": r.get::<Option<String>, _>("command_line"),
            "username": r.get::<Option<String>, _>("username"),
            "integrity_level": r.get::<Option<String>, _>("integrity_level"),
            "is_injected": r.get::<bool, _>("is_injected"),
            "is_hollowed": r.get::<bool, _>("is_hollowed"),
            "is_suspicious": r.get::<bool, _>("is_suspicious"),
            "suspicion_reasons": r.get::<Option<String>, _>("suspicion_reasons"),
            "injected_modules": r.get::<Option<String>, _>("injected_modules"),
            "started_at": r.get::<String, _>("started_at"),
            "terminated_at": r.get::<Option<String>, _>("terminated_at"),
            "exit_code": r.get::<Option<i32>, _>("exit_code"),
            "cpu_usage": r.get::<Option<f64>, _>("cpu_usage"),
            "memory_usage": r.get::<Option<i64>, _>("memory_usage"),
            "children_count": r.get::<i32, _>("children_count")
        }))
        .collect();

    Ok(HttpResponse::Ok().json(processes))
}

#[derive(Debug, Deserialize)]
struct ApiCallsQuery {
    category: Option<String>,
    severity: Option<String>,
    process_id: Option<String>,
    limit: Option<i32>,
    offset: Option<i32>,
}

async fn get_dynamic_api_calls(
    pool: web::Data<SqlitePool>,
    claims: web::ReqData<Claims>,
    path: web::Path<String>,
    query: web::Query<ApiCallsQuery>,
) -> Result<HttpResponse, ApiError> {
    let session_id = path.into_inner();
    verify_session_ownership(&pool, &session_id, &claims.sub).await?;

    let limit = query.limit.unwrap_or(100).min(1000);
    let offset = query.offset.unwrap_or(0);

    let mut sql = String::from("SELECT * FROM dynamic_api_calls WHERE session_id = ?");

    if query.category.is_some() {
        sql.push_str(" AND api_category = ?");
    }
    if query.severity.is_some() {
        sql.push_str(" AND severity = ?");
    }
    if query.process_id.is_some() {
        sql.push_str(" AND process_id = ?");
    }

    sql.push_str(" ORDER BY timestamp LIMIT ? OFFSET ?");

    let mut q = sqlx::query(&sql).bind(&session_id);

    if let Some(ref cat) = query.category {
        q = q.bind(cat);
    }
    if let Some(ref sev) = query.severity {
        q = q.bind(sev);
    }
    if let Some(ref pid) = query.process_id {
        q = q.bind(pid);
    }

    let rows = q.bind(limit).bind(offset)
        .fetch_all(pool.get_ref())
        .await
        .map_err(|e| ApiError::internal(format!("Database error: {}", e)))?;

    let calls: Vec<serde_json::Value> = rows.into_iter()
        .map(|r| serde_json::json!({
            "id": r.get::<String, _>("id"),
            "process_id": r.get::<String, _>("process_id"),
            "pid": r.get::<i32, _>("pid"),
            "process_name": r.get::<String, _>("process_name"),
            "module": r.get::<String, _>("module"),
            "function": r.get::<String, _>("function"),
            "arguments": r.get::<Option<String>, _>("arguments"),
            "return_value": r.get::<Option<String>, _>("return_value"),
            "timestamp": r.get::<String, _>("timestamp"),
            "api_category": r.get::<String, _>("api_category"),
            "severity": r.get::<String, _>("severity"),
            "is_hooked": r.get::<bool, _>("is_hooked"),
            "mitre_techniques": r.get::<Option<String>, _>("mitre_techniques"),
            "call_stack": r.get::<Option<String>, _>("call_stack")
        }))
        .collect();

    Ok(HttpResponse::Ok().json(calls))
}

async fn get_dynamic_network(
    pool: web::Data<SqlitePool>,
    claims: web::ReqData<Claims>,
    path: web::Path<String>,
) -> Result<HttpResponse, ApiError> {
    let session_id = path.into_inner();
    verify_session_ownership(&pool, &session_id, &claims.sub).await?;

    let rows = sqlx::query(
        "SELECT * FROM dynamic_network_activity WHERE session_id = ? ORDER BY timestamp"
    )
    .bind(&session_id)
    .fetch_all(pool.get_ref())
    .await
    .map_err(|e| ApiError::internal(format!("Database error: {}", e)))?;

    let connections: Vec<serde_json::Value> = rows.into_iter()
        .map(|r| serde_json::json!({
            "id": r.get::<String, _>("id"),
            "process_id": r.get::<Option<String>, _>("process_id"),
            "pid": r.get::<i32, _>("pid"),
            "process_name": r.get::<String, _>("process_name"),
            "protocol": r.get::<String, _>("protocol"),
            "local_address": r.get::<Option<String>, _>("local_address"),
            "local_port": r.get::<Option<i32>, _>("local_port"),
            "remote_address": r.get::<String, _>("remote_address"),
            "remote_port": r.get::<i32, _>("remote_port"),
            "direction": r.get::<String, _>("direction"),
            "bytes_sent": r.get::<i64, _>("bytes_sent"),
            "bytes_received": r.get::<i64, _>("bytes_received"),
            "packet_count": r.get::<i32, _>("packet_count"),
            "timestamp": r.get::<String, _>("timestamp"),
            "is_suspicious": r.get::<bool, _>("is_suspicious"),
            "suspicion_reason": r.get::<Option<String>, _>("suspicion_reason"),
            "geo_location": r.get::<Option<String>, _>("geo_location"),
            "asn": r.get::<Option<String>, _>("asn"),
            "tls_info": r.get::<Option<String>, _>("tls_info")
        }))
        .collect();

    Ok(HttpResponse::Ok().json(connections))
}

async fn get_dynamic_dns(
    pool: web::Data<SqlitePool>,
    claims: web::ReqData<Claims>,
    path: web::Path<String>,
) -> Result<HttpResponse, ApiError> {
    let session_id = path.into_inner();
    verify_session_ownership(&pool, &session_id, &claims.sub).await?;

    let rows = sqlx::query(
        "SELECT * FROM dynamic_dns_queries WHERE session_id = ? ORDER BY timestamp"
    )
    .bind(&session_id)
    .fetch_all(pool.get_ref())
    .await
    .map_err(|e| ApiError::internal(format!("Database error: {}", e)))?;

    let queries: Vec<serde_json::Value> = rows.into_iter()
        .map(|r| serde_json::json!({
            "id": r.get::<String, _>("id"),
            "query_name": r.get::<String, _>("query_name"),
            "query_type": r.get::<String, _>("query_type"),
            "response_ips": r.get::<Option<String>, _>("response_ips"),
            "response_cnames": r.get::<Option<String>, _>("response_cnames"),
            "is_dga": r.get::<bool, _>("is_dga"),
            "dga_score": r.get::<Option<f64>, _>("dga_score"),
            "timestamp": r.get::<String, _>("timestamp")
        }))
        .collect();

    Ok(HttpResponse::Ok().json(queries))
}

async fn get_dynamic_http(
    pool: web::Data<SqlitePool>,
    claims: web::ReqData<Claims>,
    path: web::Path<String>,
) -> Result<HttpResponse, ApiError> {
    let session_id = path.into_inner();
    verify_session_ownership(&pool, &session_id, &claims.sub).await?;

    let rows = sqlx::query(
        "SELECT * FROM dynamic_http_requests WHERE session_id = ? ORDER BY timestamp"
    )
    .bind(&session_id)
    .fetch_all(pool.get_ref())
    .await
    .map_err(|e| ApiError::internal(format!("Database error: {}", e)))?;

    let requests: Vec<serde_json::Value> = rows.into_iter()
        .map(|r| serde_json::json!({
            "id": r.get::<String, _>("id"),
            "method": r.get::<String, _>("method"),
            "url": r.get::<String, _>("url"),
            "host": r.get::<String, _>("host"),
            "path": r.get::<String, _>("path"),
            "user_agent": r.get::<Option<String>, _>("user_agent"),
            "headers": r.get::<Option<String>, _>("headers"),
            "body": r.get::<Option<String>, _>("body"),
            "response_status": r.get::<Option<i32>, _>("response_status"),
            "response_headers": r.get::<Option<String>, _>("response_headers"),
            "response_body_preview": r.get::<Option<String>, _>("response_body_preview"),
            "content_type": r.get::<Option<String>, _>("content_type"),
            "is_suspicious": r.get::<bool, _>("is_suspicious"),
            "timestamp": r.get::<String, _>("timestamp")
        }))
        .collect();

    Ok(HttpResponse::Ok().json(requests))
}

async fn get_dynamic_files(
    pool: web::Data<SqlitePool>,
    claims: web::ReqData<Claims>,
    path: web::Path<String>,
) -> Result<HttpResponse, ApiError> {
    let session_id = path.into_inner();
    verify_session_ownership(&pool, &session_id, &claims.sub).await?;

    let rows = sqlx::query(
        "SELECT * FROM dynamic_file_operations WHERE session_id = ? ORDER BY timestamp"
    )
    .bind(&session_id)
    .fetch_all(pool.get_ref())
    .await
    .map_err(|e| ApiError::internal(format!("Database error: {}", e)))?;

    let files: Vec<serde_json::Value> = rows.into_iter()
        .map(|r| serde_json::json!({
            "id": r.get::<String, _>("id"),
            "process_id": r.get::<Option<String>, _>("process_id"),
            "pid": r.get::<i32, _>("pid"),
            "process_name": r.get::<String, _>("process_name"),
            "operation_type": r.get::<String, _>("operation_type"),
            "path": r.get::<String, _>("path"),
            "new_path": r.get::<Option<String>, _>("new_path"),
            "file_size": r.get::<Option<i64>, _>("file_size"),
            "file_hash": r.get::<Option<String>, _>("file_hash"),
            "timestamp": r.get::<String, _>("timestamp"),
            "is_suspicious": r.get::<bool, _>("is_suspicious"),
            "suspicion_reason": r.get::<Option<String>, _>("suspicion_reason"),
            "is_ransomware_indicator": r.get::<bool, _>("is_ransomware_indicator")
        }))
        .collect();

    Ok(HttpResponse::Ok().json(files))
}

async fn get_dynamic_registry(
    pool: web::Data<SqlitePool>,
    claims: web::ReqData<Claims>,
    path: web::Path<String>,
) -> Result<HttpResponse, ApiError> {
    let session_id = path.into_inner();
    verify_session_ownership(&pool, &session_id, &claims.sub).await?;

    let rows = sqlx::query(
        "SELECT * FROM dynamic_registry_operations WHERE session_id = ? ORDER BY timestamp"
    )
    .bind(&session_id)
    .fetch_all(pool.get_ref())
    .await
    .map_err(|e| ApiError::internal(format!("Database error: {}", e)))?;

    let ops: Vec<serde_json::Value> = rows.into_iter()
        .map(|r| serde_json::json!({
            "id": r.get::<String, _>("id"),
            "process_id": r.get::<Option<String>, _>("process_id"),
            "pid": r.get::<i32, _>("pid"),
            "process_name": r.get::<String, _>("process_name"),
            "operation_type": r.get::<String, _>("operation_type"),
            "key_path": r.get::<String, _>("key_path"),
            "value_name": r.get::<Option<String>, _>("value_name"),
            "value_type": r.get::<Option<String>, _>("value_type"),
            "value_data": r.get::<Option<String>, _>("value_data"),
            "old_value_data": r.get::<Option<String>, _>("old_value_data"),
            "timestamp": r.get::<String, _>("timestamp"),
            "is_suspicious": r.get::<bool, _>("is_suspicious"),
            "suspicion_reason": r.get::<Option<String>, _>("suspicion_reason"),
            "is_persistence": r.get::<bool, _>("is_persistence"),
            "persistence_type": r.get::<Option<String>, _>("persistence_type")
        }))
        .collect();

    Ok(HttpResponse::Ok().json(ops))
}

async fn get_dynamic_timeline(
    pool: web::Data<SqlitePool>,
    claims: web::ReqData<Claims>,
    path: web::Path<String>,
) -> Result<HttpResponse, ApiError> {
    let session_id = path.into_inner();
    verify_session_ownership(&pool, &session_id, &claims.sub).await?;

    let rows = sqlx::query(
        "SELECT * FROM dynamic_behavior_events WHERE session_id = ? ORDER BY timestamp LIMIT 1000"
    )
    .bind(&session_id)
    .fetch_all(pool.get_ref())
    .await
    .map_err(|e| ApiError::internal(format!("Database error: {}", e)))?;

    let events: Vec<serde_json::Value> = rows.into_iter()
        .map(|r| serde_json::json!({
            "id": r.get::<String, _>("id"),
            "event_type": r.get::<String, _>("event_type"),
            "pid": r.get::<i32, _>("pid"),
            "process_name": r.get::<String, _>("process_name"),
            "description": r.get::<String, _>("description"),
            "severity": r.get::<String, _>("severity"),
            "timestamp": r.get::<String, _>("timestamp"),
            "details": r.get::<Option<String>, _>("details"),
            "mitre_techniques": r.get::<Option<String>, _>("mitre_techniques"),
            "related_events": r.get::<Option<String>, _>("related_events")
        }))
        .collect();

    Ok(HttpResponse::Ok().json(events))
}

async fn get_dynamic_dropped_files(
    pool: web::Data<SqlitePool>,
    claims: web::ReqData<Claims>,
    path: web::Path<String>,
) -> Result<HttpResponse, ApiError> {
    let session_id = path.into_inner();
    verify_session_ownership(&pool, &session_id, &claims.sub).await?;

    let rows = sqlx::query(
        "SELECT * FROM dynamic_dropped_files WHERE session_id = ? ORDER BY dropped_at"
    )
    .bind(&session_id)
    .fetch_all(pool.get_ref())
    .await
    .map_err(|e| ApiError::internal(format!("Database error: {}", e)))?;

    let files: Vec<serde_json::Value> = rows.into_iter()
        .map(|r| serde_json::json!({
            "id": r.get::<String, _>("id"),
            "process_id": r.get::<Option<String>, _>("process_id"),
            "pid": r.get::<i32, _>("pid"),
            "process_name": r.get::<String, _>("process_name"),
            "path": r.get::<String, _>("path"),
            "original_name": r.get::<Option<String>, _>("original_name"),
            "size": r.get::<i64, _>("size"),
            "md5": r.get::<Option<String>, _>("md5"),
            "sha1": r.get::<Option<String>, _>("sha1"),
            "sha256": r.get::<String, _>("sha256"),
            "file_type": r.get::<Option<String>, _>("file_type"),
            "mime_type": r.get::<Option<String>, _>("mime_type"),
            "is_executable": r.get::<bool, _>("is_executable"),
            "is_suspicious": r.get::<bool, _>("is_suspicious"),
            "yara_matches": r.get::<Option<String>, _>("yara_matches"),
            "dropped_at": r.get::<String, _>("dropped_at")
        }))
        .collect();

    Ok(HttpResponse::Ok().json(files))
}

async fn get_dynamic_memory_dumps(
    pool: web::Data<SqlitePool>,
    claims: web::ReqData<Claims>,
    path: web::Path<String>,
) -> Result<HttpResponse, ApiError> {
    let session_id = path.into_inner();
    verify_session_ownership(&pool, &session_id, &claims.sub).await?;

    let rows = sqlx::query(
        "SELECT * FROM dynamic_memory_dumps WHERE session_id = ? ORDER BY captured_at"
    )
    .bind(&session_id)
    .fetch_all(pool.get_ref())
    .await
    .map_err(|e| ApiError::internal(format!("Database error: {}", e)))?;

    let dumps: Vec<serde_json::Value> = rows.into_iter()
        .map(|r| serde_json::json!({
            "id": r.get::<String, _>("id"),
            "process_id": r.get::<Option<String>, _>("process_id"),
            "pid": r.get::<i32, _>("pid"),
            "process_name": r.get::<String, _>("process_name"),
            "dump_type": r.get::<String, _>("dump_type"),
            "base_address": r.get::<Option<String>, _>("base_address"),
            "region_size": r.get::<i64, _>("region_size"),
            "protection": r.get::<Option<String>, _>("protection"),
            "file_path": r.get::<String, _>("file_path"),
            "sha256": r.get::<String, _>("sha256"),
            "strings_extracted": r.get::<i32, _>("strings_extracted"),
            "yara_matches": r.get::<Option<String>, _>("yara_matches"),
            "captured_at": r.get::<String, _>("captured_at")
        }))
        .collect();

    Ok(HttpResponse::Ok().json(dumps))
}

async fn get_dynamic_screenshots(
    pool: web::Data<SqlitePool>,
    claims: web::ReqData<Claims>,
    path: web::Path<String>,
) -> Result<HttpResponse, ApiError> {
    let session_id = path.into_inner();
    verify_session_ownership(&pool, &session_id, &claims.sub).await?;

    let rows = sqlx::query(
        "SELECT * FROM dynamic_screenshots WHERE session_id = ? ORDER BY captured_at"
    )
    .bind(&session_id)
    .fetch_all(pool.get_ref())
    .await
    .map_err(|e| ApiError::internal(format!("Database error: {}", e)))?;

    let screenshots: Vec<serde_json::Value> = rows.into_iter()
        .map(|r| serde_json::json!({
            "id": r.get::<String, _>("id"),
            "file_path": r.get::<String, _>("file_path"),
            "width": r.get::<i32, _>("width"),
            "height": r.get::<i32, _>("height"),
            "format": r.get::<String, _>("format"),
            "file_size": r.get::<i64, _>("file_size"),
            "sha256": r.get::<String, _>("sha256"),
            "ocr_text": r.get::<Option<String>, _>("ocr_text"),
            "captured_at": r.get::<String, _>("captured_at")
        }))
        .collect();

    Ok(HttpResponse::Ok().json(screenshots))
}

async fn get_dynamic_anti_analysis(
    pool: web::Data<SqlitePool>,
    claims: web::ReqData<Claims>,
    path: web::Path<String>,
) -> Result<HttpResponse, ApiError> {
    let session_id = path.into_inner();
    verify_session_ownership(&pool, &session_id, &claims.sub).await?;

    let rows = sqlx::query(
        "SELECT * FROM dynamic_anti_analysis WHERE session_id = ? ORDER BY detected_at"
    )
    .bind(&session_id)
    .fetch_all(pool.get_ref())
    .await
    .map_err(|e| ApiError::internal(format!("Database error: {}", e)))?;

    let techniques: Vec<serde_json::Value> = rows.into_iter()
        .map(|r| serde_json::json!({
            "id": r.get::<String, _>("id"),
            "technique_type": r.get::<String, _>("technique_type"),
            "technique_name": r.get::<String, _>("technique_name"),
            "description": r.get::<String, _>("description"),
            "severity": r.get::<String, _>("severity"),
            "confidence": r.get::<f64, _>("confidence"),
            "evidence": r.get::<Option<String>, _>("evidence"),
            "mitre_technique": r.get::<Option<String>, _>("mitre_technique"),
            "detected_at": r.get::<String, _>("detected_at")
        }))
        .collect();

    Ok(HttpResponse::Ok().json(techniques))
}

async fn get_dynamic_iocs(
    pool: web::Data<SqlitePool>,
    claims: web::ReqData<Claims>,
    path: web::Path<String>,
) -> Result<HttpResponse, ApiError> {
    let session_id = path.into_inner();
    verify_session_ownership(&pool, &session_id, &claims.sub).await?;

    let rows = sqlx::query(
        "SELECT * FROM dynamic_iocs WHERE session_id = ? ORDER BY first_seen"
    )
    .bind(&session_id)
    .fetch_all(pool.get_ref())
    .await
    .map_err(|e| ApiError::internal(format!("Database error: {}", e)))?;

    let iocs: Vec<serde_json::Value> = rows.into_iter()
        .map(|r| serde_json::json!({
            "id": r.get::<String, _>("id"),
            "ioc_type": r.get::<String, _>("ioc_type"),
            "value": r.get::<String, _>("value"),
            "context": r.get::<Option<String>, _>("context"),
            "source": r.get::<String, _>("source"),
            "confidence": r.get::<f64, _>("confidence"),
            "is_malicious": r.get::<bool, _>("is_malicious"),
            "tags": r.get::<Option<String>, _>("tags"),
            "first_seen": r.get::<String, _>("first_seen")
        }))
        .collect();

    Ok(HttpResponse::Ok().json(iocs))
}

async fn get_dynamic_persistence(
    pool: web::Data<SqlitePool>,
    claims: web::ReqData<Claims>,
    path: web::Path<String>,
) -> Result<HttpResponse, ApiError> {
    let session_id = path.into_inner();
    verify_session_ownership(&pool, &session_id, &claims.sub).await?;

    let rows = sqlx::query(
        "SELECT * FROM dynamic_persistence WHERE session_id = ? ORDER BY detected_at"
    )
    .bind(&session_id)
    .fetch_all(pool.get_ref())
    .await
    .map_err(|e| ApiError::internal(format!("Database error: {}", e)))?;

    let persistence: Vec<serde_json::Value> = rows.into_iter()
        .map(|r| serde_json::json!({
            "id": r.get::<String, _>("id"),
            "process_id": r.get::<Option<String>, _>("process_id"),
            "persistence_type": r.get::<String, _>("persistence_type"),
            "location": r.get::<String, _>("location"),
            "value": r.get::<Option<String>, _>("value"),
            "description": r.get::<String, _>("description"),
            "mitre_technique": r.get::<Option<String>, _>("mitre_technique"),
            "severity": r.get::<String, _>("severity"),
            "detected_at": r.get::<String, _>("detected_at")
        }))
        .collect();

    Ok(HttpResponse::Ok().json(persistence))
}

async fn get_dynamic_mutexes(
    pool: web::Data<SqlitePool>,
    claims: web::ReqData<Claims>,
    path: web::Path<String>,
) -> Result<HttpResponse, ApiError> {
    let session_id = path.into_inner();
    verify_session_ownership(&pool, &session_id, &claims.sub).await?;

    let rows = sqlx::query(
        "SELECT * FROM dynamic_mutexes WHERE session_id = ? ORDER BY timestamp"
    )
    .bind(&session_id)
    .fetch_all(pool.get_ref())
    .await
    .map_err(|e| ApiError::internal(format!("Database error: {}", e)))?;

    let mutexes: Vec<serde_json::Value> = rows.into_iter()
        .map(|r| serde_json::json!({
            "id": r.get::<String, _>("id"),
            "process_id": r.get::<Option<String>, _>("process_id"),
            "pid": r.get::<i32, _>("pid"),
            "process_name": r.get::<String, _>("process_name"),
            "operation": r.get::<String, _>("operation"),
            "name": r.get::<String, _>("name"),
            "is_known_malware": r.get::<bool, _>("is_known_malware"),
            "malware_family": r.get::<Option<String>, _>("malware_family"),
            "timestamp": r.get::<String, _>("timestamp")
        }))
        .collect();

    Ok(HttpResponse::Ok().json(mutexes))
}

async fn get_dynamic_c2_patterns(
    pool: web::Data<SqlitePool>,
    claims: web::ReqData<Claims>,
    path: web::Path<String>,
) -> Result<HttpResponse, ApiError> {
    let session_id = path.into_inner();
    verify_session_ownership(&pool, &session_id, &claims.sub).await?;

    let rows = sqlx::query(
        "SELECT * FROM dynamic_c2_patterns WHERE session_id = ? ORDER BY detected_at"
    )
    .bind(&session_id)
    .fetch_all(pool.get_ref())
    .await
    .map_err(|e| ApiError::internal(format!("Database error: {}", e)))?;

    let patterns: Vec<serde_json::Value> = rows.into_iter()
        .map(|r| serde_json::json!({
            "id": r.get::<String, _>("id"),
            "pattern_type": r.get::<String, _>("pattern_type"),
            "confidence": r.get::<f64, _>("confidence"),
            "beacon_interval_avg": r.get::<Option<f64>, _>("beacon_interval_avg"),
            "beacon_interval_stddev": r.get::<Option<f64>, _>("beacon_interval_stddev"),
            "beacon_count": r.get::<Option<i32>, _>("beacon_count"),
            "remote_addresses": r.get::<String, _>("remote_addresses"),
            "ports": r.get::<String, _>("ports"),
            "protocol": r.get::<String, _>("protocol"),
            "user_agent": r.get::<Option<String>, _>("user_agent"),
            "evidence": r.get::<Option<String>, _>("evidence"),
            "detected_at": r.get::<String, _>("detected_at")
        }))
        .collect();

    Ok(HttpResponse::Ok().json(patterns))
}

async fn get_dynamic_ransomware(
    pool: web::Data<SqlitePool>,
    claims: web::ReqData<Claims>,
    path: web::Path<String>,
) -> Result<HttpResponse, ApiError> {
    let session_id = path.into_inner();
    verify_session_ownership(&pool, &session_id, &claims.sub).await?;

    let rows = sqlx::query(
        "SELECT * FROM dynamic_ransomware_indicators WHERE session_id = ? ORDER BY detected_at"
    )
    .bind(&session_id)
    .fetch_all(pool.get_ref())
    .await
    .map_err(|e| ApiError::internal(format!("Database error: {}", e)))?;

    let indicators: Vec<serde_json::Value> = rows.into_iter()
        .map(|r| serde_json::json!({
            "id": r.get::<String, _>("id"),
            "indicator_type": r.get::<String, _>("indicator_type"),
            "description": r.get::<String, _>("description"),
            "affected_paths": r.get::<Option<String>, _>("affected_paths"),
            "file_count": r.get::<Option<i32>, _>("file_count"),
            "encrypted_extensions": r.get::<Option<String>, _>("encrypted_extensions"),
            "ransom_note_content": r.get::<Option<String>, _>("ransom_note_content"),
            "bitcoin_addresses": r.get::<Option<String>, _>("bitcoin_addresses"),
            "contact_info": r.get::<Option<String>, _>("contact_info"),
            "confidence": r.get::<f64, _>("confidence"),
            "detected_at": r.get::<String, _>("detected_at")
        }))
        .collect();

    Ok(HttpResponse::Ok().json(indicators))
}

async fn get_dynamic_report(
    pool: web::Data<SqlitePool>,
    claims: web::ReqData<Claims>,
    path: web::Path<String>,
) -> Result<HttpResponse, ApiError> {
    let session_id = path.into_inner();
    verify_session_ownership(&pool, &session_id, &claims.sub).await?;

    // Get session info
    let session = sqlx::query(
        r#"SELECT s.*, m.sha256, m.original_filename, m.file_type, m.file_size,
                  r.verdict, r.verdict_classification, r.threat_score, r.confidence,
                  r.threat_categories, r.summary, r.mitre_techniques,
                  r.persistence_detected, r.code_injection_detected,
                  r.c2_communication_detected, r.ransomware_behavior_detected
           FROM dynamic_analysis_sessions s
           LEFT JOIN malware_samples m ON s.sample_id = m.id
           LEFT JOIN dynamic_analysis_results r ON s.id = r.session_id
           WHERE s.id = ?"#
    )
    .bind(&session_id)
    .fetch_optional(pool.get_ref())
    .await
    .map_err(|e| ApiError::internal(format!("Database error: {}", e)))?
    .ok_or_else(|| ApiError::not_found("Session not found"))?;

    // Get counts
    let process_count: i64 = sqlx::query_scalar(
        "SELECT COUNT(*) FROM dynamic_processes WHERE session_id = ?"
    ).bind(&session_id).fetch_one(pool.get_ref()).await.unwrap_or(0);

    let api_call_count: i64 = sqlx::query_scalar(
        "SELECT COUNT(*) FROM dynamic_api_calls WHERE session_id = ?"
    ).bind(&session_id).fetch_one(pool.get_ref()).await.unwrap_or(0);

    let network_count: i64 = sqlx::query_scalar(
        "SELECT COUNT(*) FROM dynamic_network_activity WHERE session_id = ?"
    ).bind(&session_id).fetch_one(pool.get_ref()).await.unwrap_or(0);

    let file_count: i64 = sqlx::query_scalar(
        "SELECT COUNT(*) FROM dynamic_file_operations WHERE session_id = ?"
    ).bind(&session_id).fetch_one(pool.get_ref()).await.unwrap_or(0);

    let registry_count: i64 = sqlx::query_scalar(
        "SELECT COUNT(*) FROM dynamic_registry_operations WHERE session_id = ?"
    ).bind(&session_id).fetch_one(pool.get_ref()).await.unwrap_or(0);

    let dropped_count: i64 = sqlx::query_scalar(
        "SELECT COUNT(*) FROM dynamic_dropped_files WHERE session_id = ?"
    ).bind(&session_id).fetch_one(pool.get_ref()).await.unwrap_or(0);

    let anti_analysis_count: i64 = sqlx::query_scalar(
        "SELECT COUNT(*) FROM dynamic_anti_analysis WHERE session_id = ?"
    ).bind(&session_id).fetch_one(pool.get_ref()).await.unwrap_or(0);

    let ioc_count: i64 = sqlx::query_scalar(
        "SELECT COUNT(*) FROM dynamic_iocs WHERE session_id = ?"
    ).bind(&session_id).fetch_one(pool.get_ref()).await.unwrap_or(0);

    Ok(HttpResponse::Ok().json(serde_json::json!({
        "session": {
            "id": session.get::<String, _>("id"),
            "sample_id": session.get::<String, _>("sample_id"),
            "sha256": session.get::<Option<String>, _>("sha256"),
            "filename": session.get::<Option<String>, _>("original_filename"),
            "file_type": session.get::<Option<String>, _>("file_type"),
            "file_size": session.get::<Option<i64>, _>("file_size"),
            "environment": session.get::<String, _>("environment"),
            "os_type": session.get::<String, _>("os_type"),
            "os_version": session.get::<Option<String>, _>("os_version"),
            "architecture": session.get::<String, _>("architecture"),
            "status": session.get::<String, _>("status"),
            "started_at": session.get::<Option<String>, _>("started_at"),
            "completed_at": session.get::<Option<String>, _>("completed_at"),
            "execution_time_secs": session.get::<Option<i32>, _>("execution_time_secs"),
            "created_at": session.get::<String, _>("created_at")
        },
        "verdict": {
            "verdict": session.get::<Option<String>, _>("verdict"),
            "classification": session.get::<Option<String>, _>("verdict_classification"),
            "threat_score": session.get::<Option<i32>, _>("threat_score"),
            "confidence": session.get::<Option<f64>, _>("confidence"),
            "threat_categories": session.get::<Option<String>, _>("threat_categories"),
            "summary": session.get::<Option<String>, _>("summary"),
            "mitre_techniques": session.get::<Option<String>, _>("mitre_techniques")
        },
        "detection_summary": {
            "persistence_detected": session.get::<Option<bool>, _>("persistence_detected"),
            "code_injection_detected": session.get::<Option<bool>, _>("code_injection_detected"),
            "c2_communication_detected": session.get::<Option<bool>, _>("c2_communication_detected"),
            "ransomware_behavior_detected": session.get::<Option<bool>, _>("ransomware_behavior_detected")
        },
        "counts": {
            "processes": process_count,
            "api_calls": api_call_count,
            "network_connections": network_count,
            "file_operations": file_count,
            "registry_operations": registry_count,
            "dropped_files": dropped_count,
            "anti_analysis_techniques": anti_analysis_count,
            "iocs": ioc_count
        }
    })))
}

// === API Hook Patterns ===

async fn list_hook_patterns(
    pool: web::Data<SqlitePool>,
    claims: web::ReqData<Claims>,
) -> Result<HttpResponse, ApiError> {
    let rows = sqlx::query(
        r#"SELECT * FROM dynamic_api_hook_patterns
           WHERE enabled = 1 AND (custom = 0 OR created_by = ?)
           ORDER BY module, function"#
    )
    .bind(&claims.sub)
    .fetch_all(pool.get_ref())
    .await
    .map_err(|e| ApiError::internal(format!("Database error: {}", e)))?;

    let patterns: Vec<serde_json::Value> = rows.into_iter()
        .map(|r| serde_json::json!({
            "id": r.get::<String, _>("id"),
            "name": r.get::<String, _>("name"),
            "module": r.get::<String, _>("module"),
            "function": r.get::<String, _>("function"),
            "pattern_type": r.get::<String, _>("pattern_type"),
            "category": r.get::<String, _>("category"),
            "severity": r.get::<String, _>("severity"),
            "description": r.get::<String, _>("description"),
            "mitre_techniques": r.get::<Option<String>, _>("mitre_techniques"),
            "os_type": r.get::<String, _>("os_type"),
            "enabled": r.get::<bool, _>("enabled"),
            "custom": r.get::<bool, _>("custom"),
            "created_at": r.get::<String, _>("created_at")
        }))
        .collect();

    Ok(HttpResponse::Ok().json(patterns))
}

#[derive(Debug, Deserialize)]
struct CreateHookPatternRequest {
    name: String,
    module: String,
    function: String,
    pattern_type: String,
    category: String,
    severity: Option<String>,
    description: String,
    mitre_techniques: Option<String>,
    os_type: Option<String>,
}

async fn create_hook_pattern(
    pool: web::Data<SqlitePool>,
    claims: web::ReqData<Claims>,
    body: web::Json<CreateHookPatternRequest>,
) -> Result<HttpResponse, ApiError> {
    let pattern_id = uuid::Uuid::new_v4().to_string();
    let severity = body.severity.clone().unwrap_or_else(|| "medium".to_string());
    let os_type = body.os_type.clone().unwrap_or_else(|| "windows".to_string());

    sqlx::query(
        r#"INSERT INTO dynamic_api_hook_patterns
           (id, name, module, function, pattern_type, category, severity, description,
            mitre_techniques, os_type, enabled, custom, created_by)
           VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, 1, 1, ?)"#
    )
    .bind(&pattern_id)
    .bind(&body.name)
    .bind(&body.module)
    .bind(&body.function)
    .bind(&body.pattern_type)
    .bind(&body.category)
    .bind(&severity)
    .bind(&body.description)
    .bind(&body.mitre_techniques)
    .bind(&os_type)
    .bind(&claims.sub)
    .execute(pool.get_ref())
    .await
    .map_err(|e| ApiError::internal(format!("Failed to create pattern: {}", e)))?;

    Ok(HttpResponse::Created().json(serde_json::json!({
        "id": pattern_id,
        "message": "Hook pattern created"
    })))
}

async fn update_hook_pattern(
    pool: web::Data<SqlitePool>,
    claims: web::ReqData<Claims>,
    path: web::Path<String>,
    body: web::Json<CreateHookPatternRequest>,
) -> Result<HttpResponse, ApiError> {
    let pattern_id = path.into_inner();

    let result = sqlx::query(
        r#"UPDATE dynamic_api_hook_patterns
           SET name = ?, module = ?, function = ?, pattern_type = ?, category = ?,
               severity = ?, description = ?, mitre_techniques = ?, os_type = ?
           WHERE id = ? AND created_by = ? AND custom = 1"#
    )
    .bind(&body.name)
    .bind(&body.module)
    .bind(&body.function)
    .bind(&body.pattern_type)
    .bind(&body.category)
    .bind(&body.severity.clone().unwrap_or_else(|| "medium".to_string()))
    .bind(&body.description)
    .bind(&body.mitre_techniques)
    .bind(&body.os_type.clone().unwrap_or_else(|| "windows".to_string()))
    .bind(&pattern_id)
    .bind(&claims.sub)
    .execute(pool.get_ref())
    .await
    .map_err(|e| ApiError::internal(format!("Database error: {}", e)))?;

    if result.rows_affected() == 0 {
        return Err(ApiError::not_found("Pattern not found or not owned by user"));
    }

    Ok(HttpResponse::Ok().json(serde_json::json!({
        "message": "Pattern updated"
    })))
}

async fn delete_hook_pattern(
    pool: web::Data<SqlitePool>,
    claims: web::ReqData<Claims>,
    path: web::Path<String>,
) -> Result<HttpResponse, ApiError> {
    let pattern_id = path.into_inner();

    let result = sqlx::query(
        "DELETE FROM dynamic_api_hook_patterns WHERE id = ? AND created_by = ? AND custom = 1"
    )
    .bind(&pattern_id)
    .bind(&claims.sub)
    .execute(pool.get_ref())
    .await
    .map_err(|e| ApiError::internal(format!("Database error: {}", e)))?;

    if result.rows_affected() == 0 {
        return Err(ApiError::not_found("Pattern not found or not owned by user"));
    }

    Ok(HttpResponse::Ok().json(serde_json::json!({
        "message": "Pattern deleted"
    })))
}

// === Helper Functions ===

async fn verify_session_ownership(
    pool: &SqlitePool,
    session_id: &str,
    user_id: &str,
) -> Result<(), ApiError> {
    let exists: bool = sqlx::query_scalar(
        "SELECT COUNT(*) > 0 FROM dynamic_analysis_sessions WHERE id = ? AND user_id = ?"
    )
    .bind(session_id)
    .bind(user_id)
    .fetch_one(pool)
    .await
    .unwrap_or(false);

    if !exists {
        return Err(ApiError::not_found("Session not found"));
    }

    Ok(())
}

/// Result from sandbox analysis dispatch
#[derive(Debug)]
struct SandboxAnalysisResult {
    pub report: serde_json::Value,
    pub threat_score: i32,
    pub verdict: String,
    pub network_connections: usize,
    pub processes_created: usize,
    pub files_modified: usize,
    pub registry_changes: usize,
    pub anti_analysis_count: usize,
}

/// Dispatch sample to the appropriate sandbox for dynamic analysis
async fn dispatch_to_sandbox(
    sandbox_type: &str,
    file_hash: &str,
    file_path: Option<&str>,
    timeout: u32,
    network_enabled: bool,
) -> anyhow::Result<SandboxAnalysisResult> {
    use std::time::Duration;

    // Parse sandbox type
    let sandbox_type_enum: SandboxType = sandbox_type.parse()
        .map_err(|e: String| anyhow::anyhow!(e))?;

    // Read sample file
    let file_data = if let Some(path) = file_path {
        tokio::fs::read(path).await
            .map_err(|e| anyhow::anyhow!("Failed to read sample file: {}", e))?
    } else {
        // Try to find file in uploads directory by hash
        let upload_path = format!("./uploads/malware/{}.bin", file_hash);
        tokio::fs::read(&upload_path).await
            .map_err(|e| anyhow::anyhow!("Failed to read sample file from uploads: {}", e))?
    };

    // Create sandbox manager with configuration from environment
    let mut manager = SandboxManager::new();

    // Configure based on sandbox type and available environment variables
    match sandbox_type_enum {
        SandboxType::Cuckoo => {
            let url = std::env::var("CUCKOO_URL")
                .unwrap_or_else(|_| "http://localhost:8090".to_string());
            let api_key = std::env::var("CUCKOO_API_KEY").ok();
            manager = manager.with_cuckoo(&url, api_key.as_deref());
        }
        SandboxType::AnyRun => {
            let api_key = std::env::var("ANYRUN_API_KEY")
                .map_err(|_| anyhow::anyhow!("ANYRUN_API_KEY not configured"))?;
            manager = manager.with_anyrun(&api_key);
        }
        SandboxType::HybridAnalysis => {
            let api_key = std::env::var("HYBRID_ANALYSIS_API_KEY")
                .map_err(|_| anyhow::anyhow!("HYBRID_ANALYSIS_API_KEY not configured"))?;
            manager = manager.with_hybrid(&api_key);
        }
    }

    // Prepare submission options
    let options = SubmissionOptions {
        timeout: Some(timeout),
        enable_network: network_enabled,
        internet_access: network_enabled,
        ..Default::default()
    };

    // Submit sample
    let filename = format!("{}.bin", file_hash);
    let submission = manager.submit(sandbox_type_enum.clone(), &file_data, &filename, &options).await
        .map_err(|e| anyhow::anyhow!("Failed to submit to sandbox: {}", e))?;

    log::info!("Submitted to {} sandbox with task_id: {}", sandbox_type, submission.task_id);

    // Poll for results with timeout
    let poll_interval = Duration::from_secs(30);
    let max_wait = Duration::from_secs(timeout as u64 + 300); // Extra 5 minutes buffer
    let start_time = std::time::Instant::now();

    loop {
        // Check if we've exceeded the maximum wait time
        if start_time.elapsed() > max_wait {
            return Err(anyhow::anyhow!("Sandbox analysis timed out waiting for results"));
        }

        // Check status
        let status = manager.get_status(sandbox_type_enum.clone(), &submission.task_id).await
            .map_err(|e| anyhow::anyhow!("Failed to get sandbox status: {}", e))?;

        match status {
            crate::malware_analysis::sandbox::SandboxStatus::Completed => {
                // Get full results
                let result = manager.get_results(sandbox_type_enum.clone(), &submission.task_id).await
                    .map_err(|e| anyhow::anyhow!("Failed to get sandbox results: {}", e))?;

                let raw_report = manager.get_raw_report(sandbox_type_enum.clone(), &submission.task_id).await
                    .unwrap_or_else(|_| serde_json::json!({}));

                // Convert to our result format
                let verdict = match result.verdict {
                    crate::malware_analysis::sandbox::SandboxVerdict::Malicious => "malicious",
                    crate::malware_analysis::sandbox::SandboxVerdict::Suspicious => "suspicious",
                    crate::malware_analysis::sandbox::SandboxVerdict::Clean => "clean",
                    crate::malware_analysis::sandbox::SandboxVerdict::Unknown => "unknown",
                };

                return Ok(SandboxAnalysisResult {
                    report: raw_report,
                    threat_score: result.score as i32,
                    verdict: verdict.to_string(),
                    network_connections: result.network_activity.tcp_connections.len(),
                    processes_created: result.processes.len(),
                    files_modified: result.file_activity.files_created.len() + result.file_activity.files_modified.len(),
                    registry_changes: result.registry_activity.keys_created.len() + result.registry_activity.keys_modified.len(),
                    anti_analysis_count: result.signatures.iter()
                        .filter(|s| s.category == "anti-analysis" || s.category == "evasion")
                        .count(),
                });
            }
            crate::malware_analysis::sandbox::SandboxStatus::Failed => {
                return Err(anyhow::anyhow!("Sandbox analysis failed"));
            }
            crate::malware_analysis::sandbox::SandboxStatus::Timeout => {
                return Err(anyhow::anyhow!("Sandbox analysis timed out"));
            }
            crate::malware_analysis::sandbox::SandboxStatus::Cancelled => {
                return Err(anyhow::anyhow!("Sandbox analysis was cancelled"));
            }
            _ => {
                // Still running or pending, wait and poll again
                tokio::time::sleep(poll_interval).await;
            }
        }
    }
}
