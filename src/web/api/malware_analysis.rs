//! Malware Analysis API Endpoints
//!
//! REST API for malware sample upload, static analysis, YARA rules, and classification.

use actix_multipart::Multipart;
use actix_web::{web, HttpResponse, Scope};
use chrono::Utc;
use futures::StreamExt;
use serde::{Deserialize, Serialize};
use sqlx::{Row, SqlitePool};
use std::io::Write;

use crate::web::auth::Claims;
use crate::web::error::ApiError;
use crate::malware_analysis::{
    SampleStore, StaticAnalyzer, YaraEngine, PackerDetector,
    ApiPatternAnalyzer, ResourceExtractor, CertificateAnalyzer,
    MalwareClassifier, IocExtractor, FileType, SampleSource,
    StaticAnalysisResult,
};
use crate::binary_analysis::hashing::compute_md5;

/// Configure malware analysis API routes
pub fn configure(cfg: &mut web::ServiceConfig) {
    cfg.service(
        web::scope("/malware-analysis")
            // Dashboard & Stats
            .route("/stats", web::get().to(get_stats))
            .route("/dashboard", web::get().to(get_dashboard))
            // Samples
            .route("/samples", web::get().to(list_samples))
            .route("/samples", web::post().to(upload_sample))
            .route("/samples/{id}", web::get().to(get_sample))
            .route("/samples/{id}", web::delete().to(delete_sample))
            .route("/samples/{id}/analyze", web::post().to(analyze_sample))
            .route("/samples/{id}/reanalyze", web::post().to(reanalyze_sample))
            .route("/samples/{id}/download", web::get().to(download_sample))
            .route("/samples/{id}/strings", web::get().to(get_sample_strings))
            .route("/samples/{id}/imports", web::get().to(get_sample_imports))
            .route("/samples/{id}/iocs", web::get().to(get_sample_iocs))
            .route("/samples/{id}/yara-matches", web::get().to(get_yara_matches))
            .route("/samples/{id}/classification", web::get().to(get_classification))
            .route("/samples/{id}/tags", web::put().to(update_sample_tags))
            .route("/samples/search", web::post().to(search_samples))
            .route("/samples/lookup", web::post().to(lookup_sample))
            // YARA Rules
            .route("/yara/rules", web::get().to(list_yara_rules))
            .route("/yara/rules", web::post().to(create_yara_rule))
            .route("/yara/rules/{id}", web::get().to(get_yara_rule))
            .route("/yara/rules/{id}", web::put().to(update_yara_rule))
            .route("/yara/rules/{id}", web::delete().to(delete_yara_rule))
            .route("/yara/rules/{id}/toggle", web::post().to(toggle_yara_rule))
            .route("/yara/scan", web::post().to(scan_with_yara))
            // IOCs
            .route("/iocs", web::get().to(list_iocs))
            .route("/iocs/search", web::post().to(search_iocs))
            .route("/iocs/export", web::get().to(export_iocs))
            // Analysis Queue
            .route("/queue", web::get().to(list_queue))
            .route("/queue/{id}/cancel", web::post().to(cancel_queue_item)),
    );
}

// === Dashboard & Stats ===

#[derive(Debug, Serialize)]
struct MalwareStats {
    total_samples: i64,
    samples_analyzed: i64,
    samples_malicious: i64,
    samples_clean: i64,
    samples_pending: i64,
    total_iocs: i64,
    total_yara_rules: i64,
    yara_matches_total: i64,
    classifications: Vec<ClassificationCount>,
    file_types: Vec<FileTypeCount>,
    recent_samples: Vec<SampleSummary>,
}

#[derive(Debug, Serialize)]
struct ClassificationCount {
    classification: String,
    count: i64,
}

#[derive(Debug, Serialize)]
struct FileTypeCount {
    file_type: String,
    count: i64,
}

async fn get_stats(
    pool: web::Data<SqlitePool>,
    claims: web::ReqData<Claims>,
) -> Result<HttpResponse, ApiError> {
    let total_samples: i64 = sqlx::query_scalar(
        "SELECT COUNT(*) FROM malware_samples WHERE user_id = ?"
    )
    .bind(&claims.sub)
    .fetch_one(pool.get_ref())
    .await
    .unwrap_or(0);

    let samples_analyzed: i64 = sqlx::query_scalar(
        "SELECT COUNT(*) FROM malware_samples WHERE user_id = ? AND last_analyzed IS NOT NULL"
    )
    .bind(&claims.sub)
    .fetch_one(pool.get_ref())
    .await
    .unwrap_or(0);

    let samples_malicious: i64 = sqlx::query_scalar(
        "SELECT COUNT(*) FROM malware_samples WHERE user_id = ? AND is_malicious = 1"
    )
    .bind(&claims.sub)
    .fetch_one(pool.get_ref())
    .await
    .unwrap_or(0);

    let samples_clean: i64 = sqlx::query_scalar(
        "SELECT COUNT(*) FROM malware_samples WHERE user_id = ? AND is_malicious = 0"
    )
    .bind(&claims.sub)
    .fetch_one(pool.get_ref())
    .await
    .unwrap_or(0);

    let samples_pending: i64 = sqlx::query_scalar(
        "SELECT COUNT(*) FROM malware_analysis_queue WHERE user_id = ? AND status = 'pending'"
    )
    .bind(&claims.sub)
    .fetch_one(pool.get_ref())
    .await
    .unwrap_or(0);

    let total_iocs: i64 = sqlx::query_scalar(
        r#"SELECT COUNT(*) FROM malware_iocs i
           JOIN malware_samples s ON i.sample_id = s.id
           WHERE s.user_id = ?"#
    )
    .bind(&claims.sub)
    .fetch_one(pool.get_ref())
    .await
    .unwrap_or(0);

    let total_yara_rules: i64 = sqlx::query_scalar(
        "SELECT COUNT(*) FROM yara_rules WHERE user_id = ? OR is_builtin = 1"
    )
    .bind(&claims.sub)
    .fetch_one(pool.get_ref())
    .await
    .unwrap_or(0);

    let yara_matches_total: i64 = sqlx::query_scalar(
        r#"SELECT COUNT(*) FROM yara_rule_matches m
           JOIN malware_samples s ON m.sample_id = s.id
           WHERE s.user_id = ?"#
    )
    .bind(&claims.sub)
    .fetch_one(pool.get_ref())
    .await
    .unwrap_or(0);

    // Get classification breakdown
    let classifications: Vec<ClassificationCount> = sqlx::query(
        r#"SELECT classification, COUNT(*) as count FROM malware_samples
           WHERE user_id = ? AND classification IS NOT NULL
           GROUP BY classification ORDER BY count DESC LIMIT 10"#
    )
    .bind(&claims.sub)
    .fetch_all(pool.get_ref())
    .await
    .unwrap_or_default()
    .into_iter()
    .map(|row| ClassificationCount {
        classification: row.get("classification"),
        count: row.get("count"),
    })
    .collect();

    // Get file type breakdown
    let file_types: Vec<FileTypeCount> = sqlx::query(
        r#"SELECT file_type, COUNT(*) as count FROM malware_samples
           WHERE user_id = ?
           GROUP BY file_type ORDER BY count DESC LIMIT 10"#
    )
    .bind(&claims.sub)
    .fetch_all(pool.get_ref())
    .await
    .unwrap_or_default()
    .into_iter()
    .map(|row| FileTypeCount {
        file_type: row.get("file_type"),
        count: row.get("count"),
    })
    .collect();

    // Get recent samples
    let recent_samples: Vec<SampleSummary> = sqlx::query(
        r#"SELECT id, original_filename, file_type, file_size, md5, sha256,
                  threat_score, classification, family, created_at
           FROM malware_samples WHERE user_id = ?
           ORDER BY created_at DESC LIMIT 10"#
    )
    .bind(&claims.sub)
    .fetch_all(pool.get_ref())
    .await
    .unwrap_or_default()
    .into_iter()
    .map(|row| SampleSummary {
        id: row.get("id"),
        original_filename: row.get("original_filename"),
        file_type: row.get("file_type"),
        file_size: row.get("file_size"),
        md5: row.get("md5"),
        sha256: row.get("sha256"),
        threat_score: row.get("threat_score"),
        classification: row.get("classification"),
        family: row.get("family"),
        created_at: row.get("created_at"),
    })
    .collect();

    Ok(HttpResponse::Ok().json(MalwareStats {
        total_samples,
        samples_analyzed,
        samples_malicious,
        samples_clean,
        samples_pending,
        total_iocs,
        total_yara_rules,
        yara_matches_total,
        classifications,
        file_types,
        recent_samples,
    }))
}

async fn get_dashboard(
    pool: web::Data<SqlitePool>,
    claims: web::ReqData<Claims>,
) -> Result<HttpResponse, ApiError> {
    // Alias to get_stats for now
    get_stats(pool, claims).await
}

// === Samples ===

#[derive(Debug, Deserialize)]
struct ListSamplesQuery {
    file_type: Option<String>,
    classification: Option<String>,
    is_malicious: Option<bool>,
    search: Option<String>,
    limit: Option<i64>,
    offset: Option<i64>,
}

#[derive(Debug, Serialize)]
struct SampleSummary {
    id: String,
    original_filename: String,
    file_type: String,
    file_size: i64,
    md5: String,
    sha256: String,
    threat_score: Option<i32>,
    classification: Option<String>,
    family: Option<String>,
    created_at: String,
}

async fn list_samples(
    pool: web::Data<SqlitePool>,
    claims: web::ReqData<Claims>,
    query: web::Query<ListSamplesQuery>,
) -> Result<HttpResponse, ApiError> {
    let limit = query.limit.unwrap_or(50);
    let offset = query.offset.unwrap_or(0);

    let mut sql = String::from(
        r#"SELECT id, original_filename, file_type, file_size, md5, sha256,
                  threat_score, classification, family, created_at
           FROM malware_samples WHERE user_id = ?"#
    );

    if let Some(ft) = &query.file_type {
        sql.push_str(&format!(" AND file_type = '{}'", ft.replace('\'', "''")));
    }
    if let Some(cls) = &query.classification {
        sql.push_str(&format!(" AND classification = '{}'", cls.replace('\'', "''")));
    }
    if let Some(is_mal) = query.is_malicious {
        sql.push_str(&format!(" AND is_malicious = {}", if is_mal { 1 } else { 0 }));
    }
    if let Some(search) = &query.search {
        let s = search.replace('\'', "''");
        sql.push_str(&format!(
            " AND (original_filename LIKE '%{}%' OR md5 LIKE '%{}%' OR sha256 LIKE '%{}%')",
            s, s, s
        ));
    }

    sql.push_str(" ORDER BY created_at DESC LIMIT ? OFFSET ?");

    let samples: Vec<SampleSummary> = sqlx::query(&sql)
        .bind(&claims.sub)
        .bind(limit)
        .bind(offset)
        .fetch_all(pool.get_ref())
        .await
        .map_err(|e| ApiError::internal(format!("Database error: {}", e)))?
        .into_iter()
        .map(|row| SampleSummary {
            id: row.get("id"),
            original_filename: row.get("original_filename"),
            file_type: row.get("file_type"),
            file_size: row.get("file_size"),
            md5: row.get("md5"),
            sha256: row.get("sha256"),
            threat_score: row.get("threat_score"),
            classification: row.get("classification"),
            family: row.get("family"),
            created_at: row.get("created_at"),
        })
        .collect();

    Ok(HttpResponse::Ok().json(samples))
}

async fn upload_sample(
    pool: web::Data<SqlitePool>,
    claims: web::ReqData<Claims>,
    mut payload: Multipart,
) -> Result<HttpResponse, ApiError> {
    let mut file_data: Vec<u8> = Vec::new();
    let mut original_filename = String::from("unknown");
    let mut source = String::from("upload");
    let mut tags: Vec<String> = Vec::new();
    let mut notes = String::new();

    // Process multipart form
    while let Some(item) = payload.next().await {
        let mut field = item.map_err(|e| ApiError::bad_request(format!("Multipart error: {}", e)))?;
        let content_disposition = field.content_disposition();
        let field_name = content_disposition
            .and_then(|cd| cd.get_name().map(|s| s.to_string()))
            .unwrap_or_default();

        match field_name.as_str() {
            "file" => {
                if let Some(filename) = content_disposition.and_then(|cd| cd.get_filename().map(|s| s.to_string())) {
                    original_filename = filename;
                }
                while let Some(chunk) = field.next().await {
                    let data = chunk.map_err(|e| ApiError::bad_request(format!("Read error: {}", e)))?;
                    file_data.extend_from_slice(&data);
                }
            }
            "source" => {
                let mut value = String::new();
                while let Some(chunk) = field.next().await {
                    let data = chunk.map_err(|e| ApiError::bad_request(format!("Read error: {}", e)))?;
                    value.push_str(&String::from_utf8_lossy(&data));
                }
                source = value;
            }
            "tags" => {
                let mut value = String::new();
                while let Some(chunk) = field.next().await {
                    let data = chunk.map_err(|e| ApiError::bad_request(format!("Read error: {}", e)))?;
                    value.push_str(&String::from_utf8_lossy(&data));
                }
                tags = value.split(',').map(|s| s.trim().to_string()).filter(|s| !s.is_empty()).collect();
            }
            "notes" => {
                while let Some(chunk) = field.next().await {
                    let data = chunk.map_err(|e| ApiError::bad_request(format!("Read error: {}", e)))?;
                    notes.push_str(&String::from_utf8_lossy(&data));
                }
            }
            _ => {}
        }
    }

    if file_data.is_empty() {
        return Err(ApiError::bad_request("No file uploaded"));
    }

    // Compute hashes
    let md5 = compute_md5(&file_data);
    let sha1 = crate::binary_analysis::hashing::compute_sha1(&file_data);
    let sha256 = crate::binary_analysis::hashing::compute_sha256(&file_data);

    // Check for duplicate
    let existing: Option<String> = sqlx::query_scalar(
        "SELECT id FROM malware_samples WHERE sha256 = ? AND user_id = ?"
    )
    .bind(&sha256)
    .bind(&claims.sub)
    .fetch_optional(pool.get_ref())
    .await
    .map_err(|e| ApiError::internal(format!("Database error: {}", e)))?;

    if let Some(existing_id) = existing {
        return Ok(HttpResponse::Conflict().json(serde_json::json!({
            "error": "Sample already exists",
            "existing_id": existing_id,
            "sha256": sha256
        })));
    }

    // Detect file type
    let file_type = detect_file_type(&file_data);
    let entropy = SampleStore::compute_entropy(&file_data);
    let file_size = file_data.len() as i64;

    // Store sample (encrypted)
    let id = uuid::Uuid::new_v4().to_string();
    let storage_dir = std::env::var("MALWARE_STORAGE_DIR")
        .unwrap_or_else(|_| "/tmp/malware_samples".to_string());
    std::fs::create_dir_all(&storage_dir)
        .map_err(|e| ApiError::internal(format!("Failed to create storage dir: {}", e)))?;

    let storage_path = format!("{}/{}.enc", storage_dir, id);

    // Encrypt and store
    let sample_store = SampleStore::from_env()
        .map_err(|e| ApiError::internal(format!("Failed to initialize sample store: {}", e)))?;
    sample_store.store_sample(&id, &file_data)
        .map_err(|e| ApiError::internal(format!("Failed to store sample: {}", e)))?;

    let now = Utc::now().to_rfc3339();
    let tags_json = serde_json::to_string(&tags).unwrap_or_else(|_| "[]".to_string());

    // Insert into database
    sqlx::query(
        r#"INSERT INTO malware_samples
           (id, user_id, original_filename, file_size, md5, sha1, sha256, file_type,
            entropy, storage_path, source, tags, notes, created_at)
           VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)"#
    )
    .bind(&id)
    .bind(&claims.sub)
    .bind(&original_filename)
    .bind(file_size)
    .bind(&md5)
    .bind(&sha1)
    .bind(&sha256)
    .bind(&file_type)
    .bind(entropy)
    .bind(&storage_path)
    .bind(&source)
    .bind(&tags_json)
    .bind(&notes)
    .bind(&now)
    .execute(pool.get_ref())
    .await
    .map_err(|e| ApiError::internal(format!("Database error: {}", e)))?;

    // Queue for analysis
    let queue_id = uuid::Uuid::new_v4().to_string();
    sqlx::query(
        r#"INSERT INTO malware_analysis_queue
           (id, sample_id, user_id, analysis_types, priority, status, created_at)
           VALUES (?, ?, ?, ?, ?, 'pending', ?)"#
    )
    .bind(&queue_id)
    .bind(&id)
    .bind(&claims.sub)
    .bind("static,yara,ioc,classification")
    .bind(5)
    .bind(&now)
    .execute(pool.get_ref())
    .await
    .map_err(|e| ApiError::internal(format!("Database error: {}", e)))?;

    Ok(HttpResponse::Created().json(serde_json::json!({
        "id": id,
        "sha256": sha256,
        "md5": md5,
        "file_type": file_type,
        "file_size": file_size,
        "entropy": entropy,
        "message": "Sample uploaded and queued for analysis"
    })))
}

fn detect_file_type(data: &[u8]) -> String {
    if data.len() < 4 {
        return "unknown".to_string();
    }

    match &data[..4] {
        [0x4D, 0x5A, ..] => "pe".to_string(),
        [0x7F, 0x45, 0x4C, 0x46] => "elf".to_string(),
        [0xCF, 0xFA, 0xED, 0xFE] | [0xFE, 0xED, 0xFA, 0xCF] => "macho".to_string(),
        [0x50, 0x4B, 0x03, 0x04] => {
            // Could be ZIP, APK, JAR, DOCX, etc.
            if data.len() > 30 {
                let content = String::from_utf8_lossy(&data[..100.min(data.len())]);
                if content.contains("AndroidManifest") {
                    return "apk".to_string();
                }
            }
            "zip".to_string()
        }
        [0x25, 0x50, 0x44, 0x46] => "pdf".to_string(),
        [0xD0, 0xCF, 0x11, 0xE0] => "ole".to_string(), // MS Office
        _ => {
            // Check for scripts
            let text = String::from_utf8_lossy(&data[..100.min(data.len())]);
            if text.starts_with("#!/") || text.starts_with("#!") {
                return "script".to_string();
            }
            if text.contains("<?php") {
                return "php".to_string();
            }
            if text.contains("<script") || text.contains("function(") {
                return "javascript".to_string();
            }
            "unknown".to_string()
        }
    }
}

#[derive(Debug, Serialize)]
struct SampleDetail {
    id: String,
    original_filename: String,
    file_size: i64,
    md5: String,
    sha1: String,
    sha256: String,
    ssdeep: Option<String>,
    file_type: String,
    mime_type: Option<String>,
    entropy: f64,
    source: String,
    source_url: Option<String>,
    tags: Vec<String>,
    notes: Option<String>,
    is_malicious: Option<bool>,
    threat_score: Option<i32>,
    classification: Option<String>,
    family: Option<String>,
    first_seen: String,
    last_analyzed: Option<String>,
    analysis_count: i32,
    created_at: String,
    static_analysis: Option<serde_json::Value>,
    yara_matches: Vec<YaraMatchSummary>,
    iocs: Vec<IocSummary>,
}

#[derive(Debug, Serialize)]
struct YaraMatchSummary {
    rule_name: String,
    tags: Vec<String>,
    matched_at: String,
}

#[derive(Debug, Serialize)]
struct IocSummary {
    ioc_type: String,
    value: String,
    confidence: f64,
}

async fn get_sample(
    pool: web::Data<SqlitePool>,
    claims: web::ReqData<Claims>,
    path: web::Path<String>,
) -> Result<HttpResponse, ApiError> {
    let sample_id = path.into_inner();

    let row = sqlx::query(
        r#"SELECT * FROM malware_samples WHERE id = ? AND user_id = ?"#
    )
    .bind(&sample_id)
    .bind(&claims.sub)
    .fetch_optional(pool.get_ref())
    .await
    .map_err(|e| ApiError::internal(format!("Database error: {}", e)))?;

    let row = row.ok_or_else(|| ApiError::not_found("Sample not found"))?;

    let tags_str: String = row.get("tags");
    let tags: Vec<String> = serde_json::from_str(&tags_str).unwrap_or_default();

    // Get static analysis
    let static_analysis: Option<serde_json::Value> = sqlx::query_scalar(
        r#"SELECT pe_info FROM malware_static_analysis WHERE sample_id = ? ORDER BY created_at DESC LIMIT 1"#
    )
    .bind(&sample_id)
    .fetch_optional(pool.get_ref())
    .await
    .ok()
    .flatten()
    .and_then(|s: String| serde_json::from_str(&s).ok());

    // Get YARA matches
    let yara_matches: Vec<YaraMatchSummary> = sqlx::query(
        r#"SELECT rule_name, tags, matched_at FROM yara_rule_matches WHERE sample_id = ?"#
    )
    .bind(&sample_id)
    .fetch_all(pool.get_ref())
    .await
    .unwrap_or_default()
    .into_iter()
    .map(|r| {
        let tags_str: String = r.get("tags");
        YaraMatchSummary {
            rule_name: r.get("rule_name"),
            tags: serde_json::from_str(&tags_str).unwrap_or_default(),
            matched_at: r.get("matched_at"),
        }
    })
    .collect();

    // Get IOCs
    let iocs: Vec<IocSummary> = sqlx::query(
        r#"SELECT ioc_type, value, confidence FROM malware_iocs WHERE sample_id = ? LIMIT 100"#
    )
    .bind(&sample_id)
    .fetch_all(pool.get_ref())
    .await
    .unwrap_or_default()
    .into_iter()
    .map(|r| IocSummary {
        ioc_type: r.get("ioc_type"),
        value: r.get("value"),
        confidence: r.get("confidence"),
    })
    .collect();

    let is_malicious: Option<i32> = row.get("is_malicious");

    Ok(HttpResponse::Ok().json(SampleDetail {
        id: row.get("id"),
        original_filename: row.get("original_filename"),
        file_size: row.get("file_size"),
        md5: row.get("md5"),
        sha1: row.get("sha1"),
        sha256: row.get("sha256"),
        ssdeep: row.get("ssdeep"),
        file_type: row.get("file_type"),
        mime_type: row.get("mime_type"),
        entropy: row.get("entropy"),
        source: row.get("source"),
        source_url: row.get("source_url"),
        tags,
        notes: row.get("notes"),
        is_malicious: is_malicious.map(|v| v == 1),
        threat_score: row.get("threat_score"),
        classification: row.get("classification"),
        family: row.get("family"),
        first_seen: row.get("first_seen"),
        last_analyzed: row.get("last_analyzed"),
        analysis_count: row.get("analysis_count"),
        created_at: row.get("created_at"),
        static_analysis,
        yara_matches,
        iocs,
    }))
}

async fn delete_sample(
    pool: web::Data<SqlitePool>,
    claims: web::ReqData<Claims>,
    path: web::Path<String>,
) -> Result<HttpResponse, ApiError> {
    let sample_id = path.into_inner();

    // Get storage path
    let storage_path: Option<String> = sqlx::query_scalar(
        "SELECT storage_path FROM malware_samples WHERE id = ? AND user_id = ?"
    )
    .bind(&sample_id)
    .bind(&claims.sub)
    .fetch_optional(pool.get_ref())
    .await
    .map_err(|e| ApiError::internal(format!("Database error: {}", e)))?;

    let storage_path = storage_path.ok_or_else(|| ApiError::not_found("Sample not found"))?;

    // Delete file
    let _ = std::fs::remove_file(&storage_path);

    // Delete from database (cascades to related tables)
    sqlx::query("DELETE FROM malware_samples WHERE id = ? AND user_id = ?")
        .bind(&sample_id)
        .bind(&claims.sub)
        .execute(pool.get_ref())
        .await
        .map_err(|e| ApiError::internal(format!("Database error: {}", e)))?;

    Ok(HttpResponse::Ok().json(serde_json::json!({
        "message": "Sample deleted successfully"
    })))
}

async fn analyze_sample(
    pool: web::Data<SqlitePool>,
    claims: web::ReqData<Claims>,
    path: web::Path<String>,
) -> Result<HttpResponse, ApiError> {
    let sample_id = path.into_inner();

    // Verify sample exists and belongs to user
    let sample: Option<(String, String)> = sqlx::query_as(
        "SELECT id, storage_path FROM malware_samples WHERE id = ? AND user_id = ?"
    )
    .bind(&sample_id)
    .bind(&claims.sub)
    .fetch_optional(pool.get_ref())
    .await
    .map_err(|e| ApiError::internal(format!("Database error: {}", e)))?;

    let (id, storage_path) = sample.ok_or_else(|| ApiError::not_found("Sample not found"))?;

    // Read and decrypt sample
    let sample_store = SampleStore::from_env()
        .map_err(|e| ApiError::internal(format!("Failed to initialize sample store: {}", e)))?;

    let data = sample_store.retrieve_sample(&id)
        .map_err(|e| ApiError::internal(format!("Failed to retrieve sample: {}", e)))?;

    // Run static analysis
    let analyzer = StaticAnalyzer::new(sample_store);
    let analysis = analyzer.analyze(&data)
        .map_err(|e| ApiError::internal(format!("Static analysis failed: {}", e)))?;

    // Run YARA
    let yara_engine = YaraEngine::new();
    let yara_matches = yara_engine.scan(&data);

    // Detect packers
    let packer_detector = PackerDetector::new();
    let packer_info = if let Some(ref pe_info) = analysis.pe_info {
        packer_detector.detect_pe(&data, &pe_info.sections, pe_info.entry_point)
    } else if let Some(ref elf_info) = analysis.elf_info {
        packer_detector.detect_elf(&data, &elf_info.sections)
    } else {
        None
    };

    // Analyze API patterns
    let api_analyzer = ApiPatternAnalyzer::new();
    let suspicious_patterns = api_analyzer.analyze(&analysis.imports);

    // Extract resources
    let resource_extractor = ResourceExtractor::new();
    let resources = resource_extractor.extract_pe_resources(&data).unwrap_or_default();
    let _overlay = resource_extractor.extract_overlay(&data);

    // Analyze certificates
    let cert_analyzer = CertificateAnalyzer::new();
    let certificates = cert_analyzer.analyze(&data).unwrap_or_default();

    // Extract IOCs
    let ioc_extractor = IocExtractor::new();
    let iocs = ioc_extractor.extract_from_binary(&data, &sample_id);

    // Build complete analysis result for classification
    let complete_analysis = StaticAnalysisResult {
        id: uuid::Uuid::new_v4().to_string(),
        sample_id: sample_id.clone(),
        pe_info: analysis.pe_info.clone(),
        elf_info: analysis.elf_info.clone(),
        imports: analysis.imports.clone(),
        exports: analysis.exports.clone(),
        strings_interesting: analysis.strings_interesting.clone(),
        yara_matches: yara_matches.clone(),
        packer_detected: packer_info.clone(),
        compiler_detected: analysis.compiler_detected.clone(),
        certificates: certificates.clone(),
        resources: resources.clone(),
        suspicious_patterns: suspicious_patterns.clone(),
        created_at: Utc::now(),
    };

    // Classify
    let classifier = MalwareClassifier::new();
    let classification = classifier.classify(&complete_analysis);

    let now = Utc::now().to_rfc3339();
    let analysis_id = uuid::Uuid::new_v4().to_string();

    // Store analysis results
    let pe_info_json = serde_json::to_string(&analysis.pe_info).ok();
    let elf_info_json = serde_json::to_string(&analysis.elf_info).ok();
    let imports_json = serde_json::to_string(&analysis.imports).ok();
    let exports_json = serde_json::to_string(&analysis.exports).ok();
    let strings_json = serde_json::to_string(&analysis.strings_interesting).ok();
    let yara_json = serde_json::to_string(&yara_matches).ok();
    let packer_json = serde_json::to_string(&packer_info).ok();
    let certs_json = serde_json::to_string(&certificates).ok();
    let resources_json = serde_json::to_string(&resources).ok();
    let patterns_json = serde_json::to_string(&suspicious_patterns).ok();
    let iocs_json = serde_json::to_string(&iocs).ok();
    let classification_json = serde_json::to_string(&classification).ok();

    sqlx::query(
        r#"INSERT INTO malware_static_analysis
           (id, sample_id, analysis_type, file_type, pe_info, elf_info, imports, exports,
            strings_count, strings_interesting, yara_matches, packer_detected,
            certificates, resources, suspicious_patterns, iocs, classification_result,
            threat_score, created_at)
           VALUES (?, ?, 'static', ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)"#
    )
    .bind(&analysis_id)
    .bind(&sample_id)
    .bind(if analysis.pe_info.is_some() { "pe" } else if analysis.elf_info.is_some() { "elf" } else { "unknown" })
    .bind(&pe_info_json)
    .bind(&elf_info_json)
    .bind(&imports_json)
    .bind(&exports_json)
    .bind(analysis.strings_interesting.len() as i32)
    .bind(&strings_json)
    .bind(&yara_json)
    .bind(&packer_json)
    .bind(&certs_json)
    .bind(&resources_json)
    .bind(&patterns_json)
    .bind(&iocs_json)
    .bind(&classification_json)
    .bind(classification.threat_score as i32)
    .bind(&now)
    .execute(pool.get_ref())
    .await
    .map_err(|e| ApiError::internal(format!("Database error: {}", e)))?;

    // Store YARA matches
    for ym in &yara_matches {
        let match_id = uuid::Uuid::new_v4().to_string();
        let tags_json = serde_json::to_string(&ym.tags).unwrap_or_else(|_| "[]".to_string());
        let strings_json = serde_json::to_string(&ym.matched_strings).unwrap_or_else(|_| "[]".to_string());

        let _ = sqlx::query(
            r#"INSERT OR IGNORE INTO yara_rule_matches
               (id, sample_id, rule_id, rule_name, rule_namespace, tags, matched_strings, matched_at)
               VALUES (?, ?, ?, ?, ?, ?, ?, ?)"#
        )
        .bind(&match_id)
        .bind(&sample_id)
        .bind(&ym.rule_name) // Using rule_name as rule_id for built-in rules
        .bind(&ym.rule_name)
        .bind(&ym.rule_namespace)
        .bind(&tags_json)
        .bind(&strings_json)
        .bind(&now)
        .execute(pool.get_ref())
        .await;
    }

    // Store IOCs
    for ioc in &iocs {
        let ioc_id = uuid::Uuid::new_v4().to_string();
        let _ = sqlx::query(
            r#"INSERT OR IGNORE INTO malware_iocs
               (id, sample_id, ioc_type, value, confidence, created_at)
               VALUES (?, ?, ?, ?, ?, ?)"#
        )
        .bind(&ioc_id)
        .bind(&sample_id)
        .bind(format!("{:?}", ioc.ioc_type))
        .bind(&ioc.ioc_value)
        .bind(ioc.confidence)
        .bind(&now)
        .execute(pool.get_ref())
        .await;
    }

    // Update sample with results
    let is_malicious = classification.threat_score > 50;
    sqlx::query(
        r#"UPDATE malware_samples
           SET last_analyzed = ?, analysis_count = analysis_count + 1,
               threat_score = ?, classification = ?, family = ?, is_malicious = ?
           WHERE id = ?"#
    )
    .bind(&now)
    .bind(classification.threat_score as i32)
    .bind(format!("{:?}", classification.classification))
    .bind(&classification.family)
    .bind(if is_malicious { 1 } else { 0 })
    .bind(&sample_id)
    .execute(pool.get_ref())
    .await
    .map_err(|e| ApiError::internal(format!("Database error: {}", e)))?;

    Ok(HttpResponse::Ok().json(serde_json::json!({
        "analysis_id": analysis_id,
        "threat_score": classification.threat_score,
        "classification": format!("{:?}", classification.classification),
        "family": classification.family,
        "yara_matches": yara_matches.len(),
        "iocs_extracted": iocs.len(),
        "suspicious_patterns": suspicious_patterns.len(),
        "packer_detected": packer_info.is_some(),
        "message": "Analysis completed successfully"
    })))
}

async fn reanalyze_sample(
    pool: web::Data<SqlitePool>,
    claims: web::ReqData<Claims>,
    path: web::Path<String>,
) -> Result<HttpResponse, ApiError> {
    // Just call analyze_sample again
    analyze_sample(pool, claims, path).await
}

async fn download_sample(
    pool: web::Data<SqlitePool>,
    claims: web::ReqData<Claims>,
    path: web::Path<String>,
) -> Result<HttpResponse, ApiError> {
    let sample_id = path.into_inner();

    // Verify ownership
    let sample: Option<(String, String)> = sqlx::query_as(
        "SELECT id, original_filename FROM malware_samples WHERE id = ? AND user_id = ?"
    )
    .bind(&sample_id)
    .bind(&claims.sub)
    .fetch_optional(pool.get_ref())
    .await
    .map_err(|e| ApiError::internal(format!("Database error: {}", e)))?;

    let (id, filename) = sample.ok_or_else(|| ApiError::not_found("Sample not found"))?;

    // Retrieve sample
    let sample_store = SampleStore::from_env()
        .map_err(|e| ApiError::internal(format!("Failed to initialize sample store: {}", e)))?;

    let data = sample_store.retrieve_sample(&id)
        .map_err(|e| ApiError::internal(format!("Failed to retrieve sample: {}", e)))?;

    Ok(HttpResponse::Ok()
        .content_type("application/octet-stream")
        .insert_header(("Content-Disposition", format!("attachment; filename=\"{}.malware\"", filename)))
        .body(data))
}

async fn get_sample_strings(
    pool: web::Data<SqlitePool>,
    claims: web::ReqData<Claims>,
    path: web::Path<String>,
) -> Result<HttpResponse, ApiError> {
    let sample_id = path.into_inner();

    let strings_json: Option<String> = sqlx::query_scalar(
        r#"SELECT strings_interesting FROM malware_static_analysis a
           JOIN malware_samples s ON a.sample_id = s.id
           WHERE s.id = ? AND s.user_id = ?
           ORDER BY a.created_at DESC LIMIT 1"#
    )
    .bind(&sample_id)
    .bind(&claims.sub)
    .fetch_optional(pool.get_ref())
    .await
    .map_err(|e| ApiError::internal(format!("Database error: {}", e)))?;

    let strings: Vec<serde_json::Value> = strings_json
        .and_then(|s| serde_json::from_str(&s).ok())
        .unwrap_or_default();

    Ok(HttpResponse::Ok().json(strings))
}

async fn get_sample_imports(
    pool: web::Data<SqlitePool>,
    claims: web::ReqData<Claims>,
    path: web::Path<String>,
) -> Result<HttpResponse, ApiError> {
    let sample_id = path.into_inner();

    let imports_json: Option<String> = sqlx::query_scalar(
        r#"SELECT imports FROM malware_static_analysis a
           JOIN malware_samples s ON a.sample_id = s.id
           WHERE s.id = ? AND s.user_id = ?
           ORDER BY a.created_at DESC LIMIT 1"#
    )
    .bind(&sample_id)
    .bind(&claims.sub)
    .fetch_optional(pool.get_ref())
    .await
    .map_err(|e| ApiError::internal(format!("Database error: {}", e)))?;

    let imports: Vec<serde_json::Value> = imports_json
        .and_then(|s| serde_json::from_str(&s).ok())
        .unwrap_or_default();

    Ok(HttpResponse::Ok().json(imports))
}

async fn get_sample_iocs(
    pool: web::Data<SqlitePool>,
    claims: web::ReqData<Claims>,
    path: web::Path<String>,
) -> Result<HttpResponse, ApiError> {
    let sample_id = path.into_inner();

    let iocs: Vec<IocSummary> = sqlx::query(
        r#"SELECT i.ioc_type, i.value, i.confidence FROM malware_iocs i
           JOIN malware_samples s ON i.sample_id = s.id
           WHERE s.id = ? AND s.user_id = ?"#
    )
    .bind(&sample_id)
    .bind(&claims.sub)
    .fetch_all(pool.get_ref())
    .await
    .unwrap_or_default()
    .into_iter()
    .map(|r| IocSummary {
        ioc_type: r.get("ioc_type"),
        value: r.get("value"),
        confidence: r.get("confidence"),
    })
    .collect();

    Ok(HttpResponse::Ok().json(iocs))
}

async fn get_yara_matches(
    pool: web::Data<SqlitePool>,
    claims: web::ReqData<Claims>,
    path: web::Path<String>,
) -> Result<HttpResponse, ApiError> {
    let sample_id = path.into_inner();

    let matches = sqlx::query(
        r#"SELECT m.* FROM yara_rule_matches m
           JOIN malware_samples s ON m.sample_id = s.id
           WHERE s.id = ? AND s.user_id = ?"#
    )
    .bind(&sample_id)
    .bind(&claims.sub)
    .fetch_all(pool.get_ref())
    .await
    .map_err(|e| ApiError::internal(format!("Database error: {}", e)))?;

    let results: Vec<serde_json::Value> = matches.into_iter()
        .map(|r| {
            let tags_str: String = r.get("tags");
            let strings_str: String = r.get("matched_strings");
            serde_json::json!({
                "id": r.get::<String, _>("id"),
                "rule_name": r.get::<String, _>("rule_name"),
                "rule_namespace": r.get::<Option<String>, _>("rule_namespace"),
                "tags": serde_json::from_str::<Vec<String>>(&tags_str).unwrap_or_default(),
                "matched_strings": serde_json::from_str::<Vec<serde_json::Value>>(&strings_str).unwrap_or_default(),
                "matched_at": r.get::<String, _>("matched_at")
            })
        })
        .collect();

    Ok(HttpResponse::Ok().json(results))
}

async fn get_classification(
    pool: web::Data<SqlitePool>,
    claims: web::ReqData<Claims>,
    path: web::Path<String>,
) -> Result<HttpResponse, ApiError> {
    let sample_id = path.into_inner();

    let classification = sqlx::query(
        r#"SELECT c.* FROM malware_classifications c
           JOIN malware_samples s ON c.sample_id = s.id
           WHERE s.id = ? AND s.user_id = ?
           ORDER BY c.created_at DESC LIMIT 1"#
    )
    .bind(&sample_id)
    .bind(&claims.sub)
    .fetch_optional(pool.get_ref())
    .await
    .map_err(|e| ApiError::internal(format!("Database error: {}", e)))?;

    if let Some(row) = classification {
        let reasoning_str: String = row.get("reasoning");
        Ok(HttpResponse::Ok().json(serde_json::json!({
            "classification": row.get::<String, _>("classification"),
            "family": row.get::<Option<String>, _>("family"),
            "confidence": row.get::<f64, _>("confidence"),
            "threat_score": row.get::<i32, _>("threat_score"),
            "reasoning": serde_json::from_str::<Vec<String>>(&reasoning_str).unwrap_or_default(),
            "classified_by": row.get::<String, _>("classified_by"),
            "created_at": row.get::<String, _>("created_at")
        })))
    } else {
        // Return sample's classification if no detailed record
        let sample = sqlx::query(
            "SELECT classification, family, threat_score FROM malware_samples WHERE id = ? AND user_id = ?"
        )
        .bind(&sample_id)
        .bind(&claims.sub)
        .fetch_optional(pool.get_ref())
        .await
        .map_err(|e| ApiError::internal(format!("Database error: {}", e)))?;

        if let Some(row) = sample {
            Ok(HttpResponse::Ok().json(serde_json::json!({
                "classification": row.get::<Option<String>, _>("classification"),
                "family": row.get::<Option<String>, _>("family"),
                "threat_score": row.get::<Option<i32>, _>("threat_score"),
            })))
        } else {
            Err(ApiError::not_found("Sample not found"))
        }
    }
}

#[derive(Debug, Deserialize)]
struct UpdateTagsRequest {
    tags: Vec<String>,
}

async fn update_sample_tags(
    pool: web::Data<SqlitePool>,
    claims: web::ReqData<Claims>,
    path: web::Path<String>,
    body: web::Json<UpdateTagsRequest>,
) -> Result<HttpResponse, ApiError> {
    let sample_id = path.into_inner();
    let tags_json = serde_json::to_string(&body.tags)
        .map_err(|e| ApiError::bad_request(format!("Invalid tags: {}", e)))?;

    let result = sqlx::query(
        "UPDATE malware_samples SET tags = ? WHERE id = ? AND user_id = ?"
    )
    .bind(&tags_json)
    .bind(&sample_id)
    .bind(&claims.sub)
    .execute(pool.get_ref())
    .await
    .map_err(|e| ApiError::internal(format!("Database error: {}", e)))?;

    if result.rows_affected() == 0 {
        return Err(ApiError::not_found("Sample not found"));
    }

    Ok(HttpResponse::Ok().json(serde_json::json!({
        "message": "Tags updated successfully"
    })))
}

#[derive(Debug, Deserialize)]
struct SearchSamplesRequest {
    query: Option<String>,
    hash: Option<String>,
    file_type: Option<String>,
    classification: Option<String>,
    min_threat_score: Option<i32>,
    max_threat_score: Option<i32>,
    limit: Option<i64>,
}

async fn search_samples(
    pool: web::Data<SqlitePool>,
    claims: web::ReqData<Claims>,
    body: web::Json<SearchSamplesRequest>,
) -> Result<HttpResponse, ApiError> {
    let limit = body.limit.unwrap_or(50);

    let mut sql = String::from(
        "SELECT id, original_filename, file_type, file_size, md5, sha256, threat_score, classification, family, created_at FROM malware_samples WHERE user_id = ?"
    );

    if let Some(q) = &body.query {
        let q = q.replace('\'', "''");
        sql.push_str(&format!(
            " AND (original_filename LIKE '%{}%' OR notes LIKE '%{}%')",
            q, q
        ));
    }

    if let Some(h) = &body.hash {
        let h = h.replace('\'', "''");
        sql.push_str(&format!(
            " AND (md5 = '{}' OR sha1 = '{}' OR sha256 = '{}')",
            h, h, h
        ));
    }

    if let Some(ft) = &body.file_type {
        sql.push_str(&format!(" AND file_type = '{}'", ft.replace('\'', "''")));
    }

    if let Some(cls) = &body.classification {
        sql.push_str(&format!(" AND classification = '{}'", cls.replace('\'', "''")));
    }

    if let Some(min) = body.min_threat_score {
        sql.push_str(&format!(" AND threat_score >= {}", min));
    }

    if let Some(max) = body.max_threat_score {
        sql.push_str(&format!(" AND threat_score <= {}", max));
    }

    sql.push_str(" ORDER BY created_at DESC LIMIT ?");

    let samples: Vec<SampleSummary> = sqlx::query(&sql)
        .bind(&claims.sub)
        .bind(limit)
        .fetch_all(pool.get_ref())
        .await
        .map_err(|e| ApiError::internal(format!("Database error: {}", e)))?
        .into_iter()
        .map(|row| SampleSummary {
            id: row.get("id"),
            original_filename: row.get("original_filename"),
            file_type: row.get("file_type"),
            file_size: row.get("file_size"),
            md5: row.get("md5"),
            sha256: row.get("sha256"),
            threat_score: row.get("threat_score"),
            classification: row.get("classification"),
            family: row.get("family"),
            created_at: row.get("created_at"),
        })
        .collect();

    Ok(HttpResponse::Ok().json(samples))
}

#[derive(Debug, Deserialize)]
struct LookupSampleRequest {
    hash: String,
}

async fn lookup_sample(
    pool: web::Data<SqlitePool>,
    claims: web::ReqData<Claims>,
    body: web::Json<LookupSampleRequest>,
) -> Result<HttpResponse, ApiError> {
    let hash = body.hash.to_lowercase();

    let sample: Option<SampleSummary> = sqlx::query(
        r#"SELECT id, original_filename, file_type, file_size, md5, sha256, threat_score, classification, family, created_at
           FROM malware_samples
           WHERE user_id = ? AND (md5 = ? OR sha1 = ? OR sha256 = ?)
           LIMIT 1"#
    )
    .bind(&claims.sub)
    .bind(&hash)
    .bind(&hash)
    .bind(&hash)
    .fetch_optional(pool.get_ref())
    .await
    .map_err(|e| ApiError::internal(format!("Database error: {}", e)))?
    .map(|row| SampleSummary {
        id: row.get("id"),
        original_filename: row.get("original_filename"),
        file_type: row.get("file_type"),
        file_size: row.get("file_size"),
        md5: row.get("md5"),
        sha256: row.get("sha256"),
        threat_score: row.get("threat_score"),
        classification: row.get("classification"),
        family: row.get("family"),
        created_at: row.get("created_at"),
    });

    if let Some(s) = sample {
        Ok(HttpResponse::Ok().json(serde_json::json!({
            "found": true,
            "sample": s
        })))
    } else {
        Ok(HttpResponse::Ok().json(serde_json::json!({
            "found": false
        })))
    }
}

// === YARA Rules ===

#[derive(Debug, Deserialize)]
struct ListYaraRulesQuery {
    category: Option<String>,
    include_builtin: Option<bool>,
}

async fn list_yara_rules(
    pool: web::Data<SqlitePool>,
    claims: web::ReqData<Claims>,
    query: web::Query<ListYaraRulesQuery>,
) -> Result<HttpResponse, ApiError> {
    let include_builtin = query.include_builtin.unwrap_or(true);

    let mut sql = String::from(
        r#"SELECT id, name, description, category, tags, severity, is_enabled, is_builtin, match_count, created_at
           FROM yara_rules WHERE (user_id = ?"#
    );

    if include_builtin {
        sql.push_str(" OR is_builtin = 1)");
    } else {
        sql.push(')');
    }

    if let Some(cat) = &query.category {
        sql.push_str(&format!(" AND category = '{}'", cat.replace('\'', "''")));
    }

    sql.push_str(" ORDER BY is_builtin DESC, name ASC");

    let rules = sqlx::query(&sql)
        .bind(&claims.sub)
        .fetch_all(pool.get_ref())
        .await
        .map_err(|e| ApiError::internal(format!("Database error: {}", e)))?;

    let results: Vec<serde_json::Value> = rules.into_iter()
        .map(|r| {
            let tags_str: String = r.get("tags");
            serde_json::json!({
                "id": r.get::<String, _>("id"),
                "name": r.get::<String, _>("name"),
                "description": r.get::<Option<String>, _>("description"),
                "category": r.get::<String, _>("category"),
                "tags": serde_json::from_str::<Vec<String>>(&tags_str).unwrap_or_default(),
                "severity": r.get::<String, _>("severity"),
                "is_enabled": r.get::<i32, _>("is_enabled") == 1,
                "is_builtin": r.get::<i32, _>("is_builtin") == 1,
                "match_count": r.get::<i32, _>("match_count"),
                "created_at": r.get::<String, _>("created_at")
            })
        })
        .collect();

    Ok(HttpResponse::Ok().json(results))
}

#[derive(Debug, Deserialize)]
struct CreateYaraRuleRequest {
    name: String,
    description: Option<String>,
    category: String,
    rule_content: String,
    tags: Vec<String>,
    severity: Option<String>,
}

async fn create_yara_rule(
    pool: web::Data<SqlitePool>,
    claims: web::ReqData<Claims>,
    body: web::Json<CreateYaraRuleRequest>,
) -> Result<HttpResponse, ApiError> {
    let id = uuid::Uuid::new_v4().to_string();
    let now = Utc::now().to_rfc3339();
    let tags_json = serde_json::to_string(&body.tags).unwrap_or_else(|_| "[]".to_string());
    let severity = body.severity.clone().unwrap_or_else(|| "medium".to_string());

    sqlx::query(
        r#"INSERT INTO yara_rules
           (id, user_id, name, description, category, rule_content, tags, severity, is_builtin, created_at, updated_at)
           VALUES (?, ?, ?, ?, ?, ?, ?, ?, 0, ?, ?)"#
    )
    .bind(&id)
    .bind(&claims.sub)
    .bind(&body.name)
    .bind(&body.description)
    .bind(&body.category)
    .bind(&body.rule_content)
    .bind(&tags_json)
    .bind(&severity)
    .bind(&now)
    .bind(&now)
    .execute(pool.get_ref())
    .await
    .map_err(|e| {
        if e.to_string().contains("UNIQUE") {
            ApiError::bad_request("Rule with this name already exists")
        } else {
            ApiError::internal(format!("Database error: {}", e))
        }
    })?;

    Ok(HttpResponse::Created().json(serde_json::json!({
        "id": id,
        "message": "YARA rule created successfully"
    })))
}

async fn get_yara_rule(
    pool: web::Data<SqlitePool>,
    claims: web::ReqData<Claims>,
    path: web::Path<String>,
) -> Result<HttpResponse, ApiError> {
    let rule_id = path.into_inner();

    let rule = sqlx::query(
        "SELECT * FROM yara_rules WHERE id = ? AND (user_id = ? OR is_builtin = 1)"
    )
    .bind(&rule_id)
    .bind(&claims.sub)
    .fetch_optional(pool.get_ref())
    .await
    .map_err(|e| ApiError::internal(format!("Database error: {}", e)))?;

    let row = rule.ok_or_else(|| ApiError::not_found("Rule not found"))?;
    let tags_str: String = row.get("tags");

    Ok(HttpResponse::Ok().json(serde_json::json!({
        "id": row.get::<String, _>("id"),
        "name": row.get::<String, _>("name"),
        "description": row.get::<Option<String>, _>("description"),
        "category": row.get::<String, _>("category"),
        "rule_content": row.get::<String, _>("rule_content"),
        "tags": serde_json::from_str::<Vec<String>>(&tags_str).unwrap_or_default(),
        "severity": row.get::<String, _>("severity"),
        "is_enabled": row.get::<i32, _>("is_enabled") == 1,
        "is_builtin": row.get::<i32, _>("is_builtin") == 1,
        "match_count": row.get::<i32, _>("match_count"),
        "created_at": row.get::<String, _>("created_at"),
        "updated_at": row.get::<String, _>("updated_at")
    })))
}

async fn update_yara_rule(
    pool: web::Data<SqlitePool>,
    claims: web::ReqData<Claims>,
    path: web::Path<String>,
    body: web::Json<CreateYaraRuleRequest>,
) -> Result<HttpResponse, ApiError> {
    let rule_id = path.into_inner();
    let now = Utc::now().to_rfc3339();
    let tags_json = serde_json::to_string(&body.tags).unwrap_or_else(|_| "[]".to_string());
    let severity = body.severity.clone().unwrap_or_else(|| "medium".to_string());

    let result = sqlx::query(
        r#"UPDATE yara_rules
           SET name = ?, description = ?, category = ?, rule_content = ?, tags = ?, severity = ?, updated_at = ?
           WHERE id = ? AND user_id = ? AND is_builtin = 0"#
    )
    .bind(&body.name)
    .bind(&body.description)
    .bind(&body.category)
    .bind(&body.rule_content)
    .bind(&tags_json)
    .bind(&severity)
    .bind(&now)
    .bind(&rule_id)
    .bind(&claims.sub)
    .execute(pool.get_ref())
    .await
    .map_err(|e| ApiError::internal(format!("Database error: {}", e)))?;

    if result.rows_affected() == 0 {
        return Err(ApiError::not_found("Rule not found or cannot modify built-in rule"));
    }

    Ok(HttpResponse::Ok().json(serde_json::json!({
        "message": "Rule updated successfully"
    })))
}

async fn delete_yara_rule(
    pool: web::Data<SqlitePool>,
    claims: web::ReqData<Claims>,
    path: web::Path<String>,
) -> Result<HttpResponse, ApiError> {
    let rule_id = path.into_inner();

    let result = sqlx::query(
        "DELETE FROM yara_rules WHERE id = ? AND user_id = ? AND is_builtin = 0"
    )
    .bind(&rule_id)
    .bind(&claims.sub)
    .execute(pool.get_ref())
    .await
    .map_err(|e| ApiError::internal(format!("Database error: {}", e)))?;

    if result.rows_affected() == 0 {
        return Err(ApiError::not_found("Rule not found or cannot delete built-in rule"));
    }

    Ok(HttpResponse::Ok().json(serde_json::json!({
        "message": "Rule deleted successfully"
    })))
}

async fn toggle_yara_rule(
    pool: web::Data<SqlitePool>,
    claims: web::ReqData<Claims>,
    path: web::Path<String>,
) -> Result<HttpResponse, ApiError> {
    let rule_id = path.into_inner();
    let now = Utc::now().to_rfc3339();

    let result = sqlx::query(
        r#"UPDATE yara_rules
           SET is_enabled = CASE WHEN is_enabled = 1 THEN 0 ELSE 1 END, updated_at = ?
           WHERE id = ? AND (user_id = ? OR is_builtin = 1)"#
    )
    .bind(&now)
    .bind(&rule_id)
    .bind(&claims.sub)
    .execute(pool.get_ref())
    .await
    .map_err(|e| ApiError::internal(format!("Database error: {}", e)))?;

    if result.rows_affected() == 0 {
        return Err(ApiError::not_found("Rule not found"));
    }

    Ok(HttpResponse::Ok().json(serde_json::json!({
        "message": "Rule toggled successfully"
    })))
}

#[derive(Debug, Deserialize)]
struct ScanWithYaraRequest {
    sample_id: String,
}

async fn scan_with_yara(
    pool: web::Data<SqlitePool>,
    claims: web::ReqData<Claims>,
    body: web::Json<ScanWithYaraRequest>,
) -> Result<HttpResponse, ApiError> {
    // Just trigger analysis on the sample
    let path = web::Path::from(body.sample_id.clone());
    analyze_sample(pool, claims, path).await
}

// === IOCs ===

#[derive(Debug, Deserialize)]
struct ListIocsQuery {
    ioc_type: Option<String>,
    limit: Option<i64>,
    offset: Option<i64>,
}

async fn list_iocs(
    pool: web::Data<SqlitePool>,
    claims: web::ReqData<Claims>,
    query: web::Query<ListIocsQuery>,
) -> Result<HttpResponse, ApiError> {
    let limit = query.limit.unwrap_or(100);
    let offset = query.offset.unwrap_or(0);

    let mut sql = String::from(
        r#"SELECT i.*, s.original_filename, s.sha256 as sample_sha256
           FROM malware_iocs i
           JOIN malware_samples s ON i.sample_id = s.id
           WHERE s.user_id = ?"#
    );

    if let Some(it) = &query.ioc_type {
        sql.push_str(&format!(" AND i.ioc_type = '{}'", it.replace('\'', "''")));
    }

    sql.push_str(" ORDER BY i.created_at DESC LIMIT ? OFFSET ?");

    let iocs = sqlx::query(&sql)
        .bind(&claims.sub)
        .bind(limit)
        .bind(offset)
        .fetch_all(pool.get_ref())
        .await
        .map_err(|e| ApiError::internal(format!("Database error: {}", e)))?;

    let results: Vec<serde_json::Value> = iocs.into_iter()
        .map(|r| serde_json::json!({
            "id": r.get::<String, _>("id"),
            "sample_id": r.get::<String, _>("sample_id"),
            "sample_filename": r.get::<String, _>("original_filename"),
            "sample_sha256": r.get::<String, _>("sample_sha256"),
            "ioc_type": r.get::<String, _>("ioc_type"),
            "value": r.get::<String, _>("value"),
            "context": r.get::<Option<String>, _>("context"),
            "confidence": r.get::<f64, _>("confidence"),
            "threat_intel_hit": r.get::<i32, _>("threat_intel_hit") == 1,
            "created_at": r.get::<String, _>("created_at")
        }))
        .collect();

    Ok(HttpResponse::Ok().json(results))
}

#[derive(Debug, Deserialize)]
struct SearchIocsRequest {
    value: String,
    ioc_type: Option<String>,
}

async fn search_iocs(
    pool: web::Data<SqlitePool>,
    claims: web::ReqData<Claims>,
    body: web::Json<SearchIocsRequest>,
) -> Result<HttpResponse, ApiError> {
    let value = body.value.replace('\'', "''");

    let mut sql = String::from(
        r#"SELECT i.*, s.original_filename, s.sha256 as sample_sha256
           FROM malware_iocs i
           JOIN malware_samples s ON i.sample_id = s.id
           WHERE s.user_id = ? AND i.value LIKE ?"#
    );

    if let Some(it) = &body.ioc_type {
        sql.push_str(&format!(" AND i.ioc_type = '{}'", it.replace('\'', "''")));
    }

    sql.push_str(" ORDER BY i.confidence DESC LIMIT 100");

    let iocs = sqlx::query(&sql)
        .bind(&claims.sub)
        .bind(format!("%{}%", value))
        .fetch_all(pool.get_ref())
        .await
        .map_err(|e| ApiError::internal(format!("Database error: {}", e)))?;

    let results: Vec<serde_json::Value> = iocs.into_iter()
        .map(|r| serde_json::json!({
            "id": r.get::<String, _>("id"),
            "sample_id": r.get::<String, _>("sample_id"),
            "sample_filename": r.get::<String, _>("original_filename"),
            "sample_sha256": r.get::<String, _>("sample_sha256"),
            "ioc_type": r.get::<String, _>("ioc_type"),
            "value": r.get::<String, _>("value"),
            "confidence": r.get::<f64, _>("confidence"),
        }))
        .collect();

    Ok(HttpResponse::Ok().json(results))
}

#[derive(Debug, Deserialize)]
struct ExportIocsQuery {
    format: Option<String>,
    ioc_type: Option<String>,
}

async fn export_iocs(
    pool: web::Data<SqlitePool>,
    claims: web::ReqData<Claims>,
    query: web::Query<ExportIocsQuery>,
) -> Result<HttpResponse, ApiError> {
    let format = query.format.clone().unwrap_or_else(|| "csv".to_string());

    let mut sql = String::from(
        r#"SELECT i.ioc_type, i.value, i.confidence, s.sha256 as sample_sha256
           FROM malware_iocs i
           JOIN malware_samples s ON i.sample_id = s.id
           WHERE s.user_id = ?"#
    );

    if let Some(it) = &query.ioc_type {
        sql.push_str(&format!(" AND i.ioc_type = '{}'", it.replace('\'', "''")));
    }

    sql.push_str(" ORDER BY i.ioc_type, i.value");

    let iocs = sqlx::query(&sql)
        .bind(&claims.sub)
        .fetch_all(pool.get_ref())
        .await
        .map_err(|e| ApiError::internal(format!("Database error: {}", e)))?;

    match format.as_str() {
        "csv" => {
            let mut csv = String::from("ioc_type,value,confidence,sample_sha256\n");
            for r in iocs {
                csv.push_str(&format!(
                    "{},{},{},{}\n",
                    r.get::<String, _>("ioc_type"),
                    r.get::<String, _>("value"),
                    r.get::<f64, _>("confidence"),
                    r.get::<String, _>("sample_sha256")
                ));
            }
            Ok(HttpResponse::Ok()
                .content_type("text/csv")
                .insert_header(("Content-Disposition", "attachment; filename=\"iocs.csv\""))
                .body(csv))
        }
        _ => {
            let results: Vec<serde_json::Value> = iocs.into_iter()
                .map(|r| serde_json::json!({
                    "ioc_type": r.get::<String, _>("ioc_type"),
                    "value": r.get::<String, _>("value"),
                    "confidence": r.get::<f64, _>("confidence"),
                    "sample_sha256": r.get::<String, _>("sample_sha256")
                }))
                .collect();
            Ok(HttpResponse::Ok().json(results))
        }
    }
}

// === Analysis Queue ===

async fn list_queue(
    pool: web::Data<SqlitePool>,
    claims: web::ReqData<Claims>,
) -> Result<HttpResponse, ApiError> {
    let items = sqlx::query(
        r#"SELECT q.*, s.original_filename, s.sha256
           FROM malware_analysis_queue q
           JOIN malware_samples s ON q.sample_id = s.id
           WHERE q.user_id = ?
           ORDER BY q.priority DESC, q.created_at ASC
           LIMIT 100"#
    )
    .bind(&claims.sub)
    .fetch_all(pool.get_ref())
    .await
    .map_err(|e| ApiError::internal(format!("Database error: {}", e)))?;

    let results: Vec<serde_json::Value> = items.into_iter()
        .map(|r| serde_json::json!({
            "id": r.get::<String, _>("id"),
            "sample_id": r.get::<String, _>("sample_id"),
            "sample_filename": r.get::<String, _>("original_filename"),
            "sample_sha256": r.get::<String, _>("sha256"),
            "analysis_types": r.get::<String, _>("analysis_types"),
            "priority": r.get::<i32, _>("priority"),
            "status": r.get::<String, _>("status"),
            "attempts": r.get::<i32, _>("attempts"),
            "error_message": r.get::<Option<String>, _>("error_message"),
            "created_at": r.get::<String, _>("created_at")
        }))
        .collect();

    Ok(HttpResponse::Ok().json(results))
}

async fn cancel_queue_item(
    pool: web::Data<SqlitePool>,
    claims: web::ReqData<Claims>,
    path: web::Path<String>,
) -> Result<HttpResponse, ApiError> {
    let queue_id = path.into_inner();

    let result = sqlx::query(
        "UPDATE malware_analysis_queue SET status = 'cancelled' WHERE id = ? AND user_id = ? AND status = 'pending'"
    )
    .bind(&queue_id)
    .bind(&claims.sub)
    .execute(pool.get_ref())
    .await
    .map_err(|e| ApiError::internal(format!("Database error: {}", e)))?;

    if result.rows_affected() == 0 {
        return Err(ApiError::not_found("Queue item not found or already processed"));
    }

    Ok(HttpResponse::Ok().json(serde_json::json!({
        "message": "Queue item cancelled"
    })))
}
