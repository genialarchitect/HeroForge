// Exploitation API Endpoints
// REST API for exploitation campaigns, shell generation, and post-exploitation

use actix_web::{web, HttpResponse, Result};
use chrono::Utc;
use serde::{Deserialize, Serialize};
use sqlx::SqlitePool;
use uuid::Uuid;

use crate::scanner::exploitation::{
    types::*, ExploitationEngine, SafetyController,
};
use crate::web::auth::Claims;
use crate::web::error::ApiError;
use crate::web::exploitation_broadcast;

// ============================================================================
// Request/Response Types
// ============================================================================

#[derive(Debug, Deserialize)]
pub struct CreateCampaignRequest {
    pub name: String,
    pub attack_type: AttackType,
    pub config: serde_json::Value,
    pub targets: Vec<String>,
}

#[derive(Debug, Deserialize)]
pub struct AuthorizeCampaignRequest {
    pub authorized: bool,
}

#[derive(Debug, Deserialize, Serialize)]
pub struct GenerateShellRequest {
    pub shell_type: ShellType,
    pub platform: Platform,
    pub format: ShellFormat,
    pub lhost: String,
    pub lport: u16,
    #[serde(default)]
    pub encoding: EncodingType,
    #[serde(default)]
    pub obfuscation_level: u8,
    #[serde(default)]
    pub staged: bool,
    pub xor_key: Option<String>,
    #[serde(default)]
    pub architecture: Architecture,
    #[serde(default)]
    pub msf_encoder: MsfEncoder,
    #[serde(default = "default_encoder_iterations")]
    pub encoder_iterations: u8,
    #[serde(default)]
    pub bad_chars: Option<String>,
    #[serde(default)]
    pub exit_func: Option<String>,
}

fn default_encoder_iterations() -> u8 { 1 }

#[derive(Debug, Serialize)]
pub struct CampaignResponse {
    pub id: String,
    pub name: String,
    pub attack_type: AttackType,
    pub status: CampaignStatus,
    pub targets: Vec<String>,
    pub results_count: i32,
    pub successful_count: i32,
    pub created_at: String,
    pub started_at: Option<String>,
    pub completed_at: Option<String>,
}

#[derive(Debug, Serialize)]
pub struct ShellTemplateInfo {
    pub format: ShellFormat,
    pub platform: Platform,
    pub name: String,
    pub description: String,
    pub requires_msfvenom: bool,
}

#[derive(Debug, Serialize)]
pub struct PostExploitModuleInfo {
    pub module: PostExploitModule,
    pub name: String,
    pub description: String,
    pub category: PostExploitCategory,
    pub platforms: Vec<Platform>,
}

#[derive(Debug, Serialize)]
pub struct ExploitationStatusResponse {
    pub msfvenom_available: bool,
    pub active_campaigns: i32,
    pub total_campaigns: i32,
    pub credentials_stored: i32,
    pub payloads_generated: i32,
}

// ============================================================================
// Handlers
// ============================================================================

/// Get exploitation status
pub async fn get_status(
    claims: web::ReqData<Claims>,
    pool: web::Data<SqlitePool>,
) -> Result<HttpResponse, ApiError> {
    let user_id = &claims.sub;

    // Count campaigns
    let active_campaigns: (i32,) = sqlx::query_as(
        "SELECT COUNT(*) FROM exploitation_campaigns WHERE user_id = ? AND status = 'running'",
    )
    .bind(user_id)
    .fetch_one(pool.get_ref())
    .await
    .unwrap_or((0,));

    let total_campaigns: (i32,) = sqlx::query_as(
        "SELECT COUNT(*) FROM exploitation_campaigns WHERE user_id = ?",
    )
    .bind(user_id)
    .fetch_one(pool.get_ref())
    .await
    .unwrap_or((0,));

    let credentials_stored: (i32,) = sqlx::query_as(
        "SELECT COUNT(*) FROM exploitation_results WHERE campaign_id IN (SELECT id FROM exploitation_campaigns WHERE user_id = ?) AND result_type = 'credential_found'",
    )
    .bind(user_id)
    .fetch_one(pool.get_ref())
    .await
    .unwrap_or((0,));

    let payloads_generated: (i32,) = sqlx::query_as(
        "SELECT COUNT(*) FROM generated_payloads WHERE user_id = ?",
    )
    .bind(user_id)
    .fetch_one(pool.get_ref())
    .await
    .unwrap_or((0,));

    Ok(HttpResponse::Ok().json(ExploitationStatusResponse {
        msfvenom_available: SafetyController::check_msfvenom_available(),
        active_campaigns: active_campaigns.0,
        total_campaigns: total_campaigns.0,
        credentials_stored: credentials_stored.0,
        payloads_generated: payloads_generated.0,
    }))
}

/// Create a new exploitation campaign
pub async fn create_campaign(
    claims: web::ReqData<Claims>,
    pool: web::Data<SqlitePool>,
    body: web::Json<CreateCampaignRequest>,
) -> Result<HttpResponse, ApiError> {
    let id = Uuid::new_v4().to_string();
    let now = Utc::now().to_rfc3339();
    let targets_json = serde_json::to_string(&body.targets).unwrap_or_default();
    let config_json = serde_json::to_string(&body.config).unwrap_or_default();
    let attack_type_json = serde_json::to_string(&body.attack_type).unwrap_or_default();

    sqlx::query(
        r#"
        INSERT INTO exploitation_campaigns (id, user_id, name, attack_type, status, config, targets, created_at)
        VALUES (?, ?, ?, ?, 'pending', ?, ?, ?)
        "#,
    )
    .bind(&id)
    .bind(&claims.sub)
    .bind(&body.name)
    .bind(&attack_type_json)
    .bind(&config_json)
    .bind(&targets_json)
    .bind(&now)
    .execute(pool.get_ref())
    .await?;

    // Log the action
    log_exploitation_action(
        pool.get_ref(),
        &claims.sub,
        Some(&id),
        "campaign_created",
        None,
        serde_json::json!({
            "name": body.name,
            "attack_type": body.attack_type,
            "targets_count": body.targets.len()
        }),
    )
    .await?;

    Ok(HttpResponse::Created().json(serde_json::json!({
        "id": id,
        "status": "pending",
        "message": "Campaign created. Authorize to start execution."
    })))
}

/// List user's campaigns
pub async fn list_campaigns(
    claims: web::ReqData<Claims>,
    pool: web::Data<SqlitePool>,
) -> Result<HttpResponse, ApiError> {
    let campaigns: Vec<(String, String, String, String, String, i32, i32, String, Option<String>, Option<String>)> = sqlx::query_as(
        r#"
        SELECT id, name, attack_type, status, targets, results_count, successful_count, created_at, started_at, completed_at
        FROM exploitation_campaigns
        WHERE user_id = ?
        ORDER BY created_at DESC
        "#,
    )
    .bind(&claims.sub)
    .fetch_all(pool.get_ref())
    .await?;

    let responses: Vec<CampaignResponse> = campaigns
        .into_iter()
        .map(|(id, name, attack_type, status, targets, results_count, successful_count, created_at, started_at, completed_at)| {
            CampaignResponse {
                id,
                name,
                attack_type: serde_json::from_str(&attack_type).unwrap_or(AttackType::PasswordSpray),
                status: match status.as_str() {
                    "running" => CampaignStatus::Running,
                    "completed" => CampaignStatus::Completed,
                    "failed" => CampaignStatus::Failed,
                    "cancelled" => CampaignStatus::Cancelled,
                    _ => CampaignStatus::Pending,
                },
                targets: serde_json::from_str(&targets).unwrap_or_default(),
                results_count,
                successful_count,
                created_at,
                started_at,
                completed_at,
            }
        })
        .collect();

    Ok(HttpResponse::Ok().json(responses))
}

/// Get campaign details
pub async fn get_campaign(
    claims: web::ReqData<Claims>,
    pool: web::Data<SqlitePool>,
    path: web::Path<String>,
) -> Result<HttpResponse, ApiError> {
    let campaign_id = path.into_inner();

    let campaign: Option<(String, String, String, String, String, String, i32, i32, String, Option<String>, Option<String>, Option<String>)> = sqlx::query_as(
        r#"
        SELECT id, name, attack_type, status, config, targets, results_count, successful_count, created_at, started_at, completed_at, error_message
        FROM exploitation_campaigns
        WHERE id = ? AND user_id = ?
        "#,
    )
    .bind(&campaign_id)
    .bind(&claims.sub)
    .fetch_optional(pool.get_ref())
    .await?;

    match campaign {
        Some((id, name, attack_type, status, config, targets, results_count, successful_count, created_at, started_at, completed_at, error_message)) => {
            Ok(HttpResponse::Ok().json(serde_json::json!({
                "id": id,
                "name": name,
                "attack_type": serde_json::from_str::<AttackType>(&attack_type).ok(),
                "status": status,
                "config": serde_json::from_str::<serde_json::Value>(&config).ok(),
                "targets": serde_json::from_str::<Vec<String>>(&targets).unwrap_or_default(),
                "results_count": results_count,
                "successful_count": successful_count,
                "created_at": created_at,
                "started_at": started_at,
                "completed_at": completed_at,
                "error_message": error_message
            })))
        }
        None => Err(ApiError::not_found("Campaign not found")),
    }
}

/// Authorize and start campaign
pub async fn start_campaign(
    claims: web::ReqData<Claims>,
    pool: web::Data<SqlitePool>,
    path: web::Path<String>,
    body: web::Json<AuthorizeCampaignRequest>,
) -> Result<HttpResponse, ApiError> {
    let campaign_id = path.into_inner();

    if !body.authorized {
        return Err(ApiError::bad_request(
            "You must explicitly authorize the campaign execution",
        ));
    }

    // Verify campaign exists and belongs to user
    let campaign: Option<(String, String, String, String, String)> = sqlx::query_as(
        "SELECT id, status, attack_type, config, targets FROM exploitation_campaigns WHERE id = ? AND user_id = ?",
    )
    .bind(&campaign_id)
    .bind(&claims.sub)
    .fetch_optional(pool.get_ref())
    .await?;

    let (id, status, attack_type_json, config_json, targets_json) = campaign
        .ok_or_else(|| ApiError::not_found("Campaign not found"))?;

    if status != "pending" {
        return Err(ApiError::bad_request(format!(
            "Campaign is already {}",
            status
        )));
    }

    // Parse attack type and config
    let attack_type: AttackType = serde_json::from_str(&attack_type_json)
        .map_err(|_| ApiError::internal("Invalid attack type in database"))?;
    let config: serde_json::Value = serde_json::from_str(&config_json)
        .unwrap_or(serde_json::json!({}));
    let targets: Vec<String> = serde_json::from_str(&targets_json)
        .unwrap_or_default();

    // Update status to running
    let now = Utc::now().to_rfc3339();
    sqlx::query("UPDATE exploitation_campaigns SET status = 'running', started_at = ? WHERE id = ?")
        .bind(&now)
        .bind(&id)
        .execute(pool.get_ref())
        .await?;

    // Log authorization
    log_exploitation_action(
        pool.get_ref(),
        &claims.sub,
        Some(&id),
        "campaign_authorized",
        None,
        serde_json::json!({"authorized": true}),
    )
    .await?;

    // Create broadcast channel for real-time updates
    let progress_tx = exploitation_broadcast::create_campaign_channel(id.clone()).await;

    // Clone values for background task
    let campaign_id_clone = id.clone();
    let pool_clone = pool.get_ref().clone();
    let user_id = claims.sub.clone();

    // Spawn background task to run the campaign
    tokio::spawn(async move {
        run_campaign_task(
            campaign_id_clone,
            attack_type,
            config,
            targets,
            pool_clone,
            user_id,
            progress_tx,
        )
        .await;
    });

    Ok(HttpResponse::Accepted().json(serde_json::json!({
        "id": id,
        "status": "running",
        "message": "Campaign authorized and started",
        "websocket_url": format!("/api/ws/exploitation/{}", id)
    })))
}

/// Background task to run exploitation campaign
async fn run_campaign_task(
    campaign_id: String,
    attack_type: AttackType,
    config: serde_json::Value,
    targets: Vec<String>,
    pool: SqlitePool,
    user_id: String,
    progress_tx: tokio::sync::broadcast::Sender<ExploitationProgress>,
) {
    use std::time::Instant;
    let start_time = Instant::now();

    log::info!("Starting campaign execution: {} ({:?})", campaign_id, attack_type);

    // Create engine with progress channel
    let mut engine = ExploitationEngine::with_default_safety();
    engine.set_progress_channel(progress_tx.clone());
    engine.authorize_campaign(&campaign_id).await;

    // Forward progress to broadcast channel
    let campaign_id_for_broadcast = campaign_id.clone();
    let progress_tx_clone = progress_tx.clone();
    let mut progress_rx = progress_tx.subscribe();
    tokio::spawn(async move {
        while let Ok(progress) = progress_rx.recv().await {
            exploitation_broadcast::send_progress(&campaign_id_for_broadcast, progress).await;
        }
    });

    let result: Result<(usize, usize), String> = match attack_type {
        AttackType::PasswordSpray => {
            run_password_spray_campaign(&engine, &campaign_id, config, targets, &pool).await
        }
        AttackType::Kerberoast => {
            run_kerberoast_campaign(&engine, &campaign_id, config, &pool).await
        }
        AttackType::AsrepRoast => {
            run_asrep_roast_campaign(&engine, &campaign_id, config, &pool).await
        }
        AttackType::SmbRelay => {
            run_smb_relay_campaign(&engine, &campaign_id, config, targets, &pool).await
        }
        AttackType::CredentialDump | AttackType::PrivilegeEscalation |
        AttackType::Persistence | AttackType::LateralMovement => {
            run_post_exploit_campaign(&engine, &campaign_id, attack_type, config, targets, &pool).await
        }
        _ => {
            Err(format!("Attack type {:?} not yet implemented for execution", attack_type))
        }
    };

    let duration_ms = start_time.elapsed().as_millis() as u64;

    // Update campaign status
    let (final_status, error_message, total_results, successful) = match result {
        Ok((total, success)) => ("completed", None, total as i32, success as i32),
        Err(e) => {
            log::error!("Campaign {} failed: {}", campaign_id, e);
            ("failed", Some(e), 0, 0)
        }
    };

    // Send completion message
    let _ = progress_tx.send(ExploitationProgress::CampaignCompleted {
        campaign_id: campaign_id.clone(),
        total_results: total_results as usize,
        successful: successful as usize,
        duration_ms,
    });

    // Update database
    let now = Utc::now().to_rfc3339();
    let _ = sqlx::query(
        "UPDATE exploitation_campaigns SET status = ?, completed_at = ?, results_count = ?, successful_count = ?, error_message = ? WHERE id = ?"
    )
    .bind(final_status)
    .bind(&now)
    .bind(total_results)
    .bind(successful)
    .bind(&error_message)
    .bind(&campaign_id)
    .execute(&pool)
    .await;

    // Log completion
    let _ = log_exploitation_action(
        &pool,
        &user_id,
        Some(&campaign_id),
        if final_status == "completed" { "campaign_completed" } else { "campaign_failed" },
        None,
        serde_json::json!({
            "status": final_status,
            "total_results": total_results,
            "successful": successful,
            "duration_ms": duration_ms,
            "error": error_message
        }),
    )
    .await;

    log::info!(
        "Campaign {} {}: {} results, {} successful, {}ms",
        campaign_id, final_status, total_results, successful, duration_ms
    );
}

/// Run password spray campaign
async fn run_password_spray_campaign(
    engine: &ExploitationEngine,
    campaign_id: &str,
    config: serde_json::Value,
    targets: Vec<String>,
    pool: &SqlitePool,
) -> Result<(usize, usize), String> {
    let spray_config = PasswordSprayConfig {
        targets,
        usernames: config.get("usernames")
            .and_then(|v| serde_json::from_value(v.clone()).ok())
            .unwrap_or_default(),
        passwords: config.get("passwords")
            .and_then(|v| serde_json::from_value(v.clone()).ok())
            .unwrap_or_default(),
        protocol: config.get("protocol")
            .and_then(|v| serde_json::from_value(v.clone()).ok())
            .unwrap_or(SprayProtocol::Smb),
        domain: config.get("domain").and_then(|v| v.as_str()).map(String::from),
        port: config.get("port").and_then(|v| v.as_u64()).map(|p| p as u16),
        use_ssl: config.get("use_ssl").and_then(|v| v.as_bool()).unwrap_or(false),
        delay_between_attempts_ms: config.get("delay_between_attempts_ms")
            .and_then(|v| v.as_u64())
            .unwrap_or(1000),
        delay_between_users_ms: config.get("delay_between_users_ms")
            .and_then(|v| v.as_u64())
            .unwrap_or(0),
        max_attempts_per_user: config.get("max_attempts_per_user")
            .and_then(|v| v.as_u64())
            .map(|v| v as u32)
            .unwrap_or(3),
        stop_on_success: config.get("stop_on_success")
            .and_then(|v| v.as_bool())
            .unwrap_or(false),
        threads: config.get("threads")
            .and_then(|v| v.as_u64())
            .map(|v| v as u32)
            .unwrap_or(5),
    };

    let results = engine.run_password_spray(campaign_id, spray_config)
        .await
        .map_err(|e| e.to_string())?;

    let successful = results.iter().filter(|r| r.success).count();

    // Store results
    for result in &results {
        let result_id = Uuid::new_v4().to_string();
        let now = Utc::now().to_rfc3339();
        let severity = if result.success { Some("critical") } else { None };

        let _ = sqlx::query(
            "INSERT INTO exploitation_results (id, campaign_id, target, result_type, data, severity, created_at) VALUES (?, ?, ?, ?, ?, ?, ?)"
        )
        .bind(&result_id)
        .bind(campaign_id)
        .bind(&result.target)
        .bind(if result.success { "credential_found" } else { "attempt_failed" })
        .bind(serde_json::to_string(&result).unwrap_or_default())
        .bind(severity)
        .bind(&now)
        .execute(pool)
        .await;
    }

    Ok((results.len(), successful))
}

/// Run Kerberoast campaign
async fn run_kerberoast_campaign(
    engine: &ExploitationEngine,
    campaign_id: &str,
    config: serde_json::Value,
    pool: &SqlitePool,
) -> Result<(usize, usize), String> {
    let kerb_config = KerberoastConfig {
        domain_controller: config.get("domain_controller")
            .and_then(|v| v.as_str())
            .unwrap_or("")
            .to_string(),
        domain: config.get("domain")
            .and_then(|v| v.as_str())
            .unwrap_or("")
            .to_string(),
        username: config.get("username")
            .and_then(|v| v.as_str())
            .unwrap_or("")
            .to_string(),
        password: config.get("password")
            .and_then(|v| v.as_str())
            .map(String::from),
        ntlm_hash: config.get("ntlm_hash")
            .and_then(|v| v.as_str())
            .map(String::from),
        target_spns: config.get("target_spns")
            .and_then(|v| serde_json::from_value(v.clone()).ok()),
        output_format: config.get("output_format")
            .and_then(|v| serde_json::from_value(v.clone()).ok())
            .unwrap_or(HashFormat::Hashcat),
        request_rc4: config.get("request_rc4")
            .and_then(|v| v.as_bool())
            .unwrap_or(true),
    };

    let results = engine.run_kerberoast(campaign_id, kerb_config)
        .await
        .map_err(|e| e.to_string())?;

    // Store results
    for result in &results {
        let result_id = Uuid::new_v4().to_string();
        let now = Utc::now().to_rfc3339();

        let _ = sqlx::query(
            "INSERT INTO exploitation_results (id, campaign_id, target, result_type, data, severity, created_at) VALUES (?, ?, ?, ?, ?, ?, ?)"
        )
        .bind(&result_id)
        .bind(campaign_id)
        .bind(&result.spn)
        .bind("hash_extracted")
        .bind(serde_json::to_string(&result).unwrap_or_default())
        .bind("high")
        .bind(&now)
        .execute(pool)
        .await;
    }

    Ok((results.len(), results.len()))
}

/// Run AS-REP Roast campaign
async fn run_asrep_roast_campaign(
    engine: &ExploitationEngine,
    campaign_id: &str,
    config: serde_json::Value,
    pool: &SqlitePool,
) -> Result<(usize, usize), String> {
    let asrep_config = AsrepRoastConfig {
        domain_controller: config.get("domain_controller")
            .and_then(|v| v.as_str())
            .unwrap_or("")
            .to_string(),
        domain: config.get("domain")
            .and_then(|v| v.as_str())
            .unwrap_or("")
            .to_string(),
        usernames: config.get("usernames")
            .and_then(|v| serde_json::from_value(v.clone()).ok())
            .unwrap_or_default(),
        enumerate_users: config.get("enumerate_users")
            .and_then(|v| v.as_bool())
            .unwrap_or(true),
        output_format: config.get("output_format")
            .and_then(|v| serde_json::from_value(v.clone()).ok())
            .unwrap_or(HashFormat::Hashcat),
    };

    let results = engine.run_asrep_roast(campaign_id, asrep_config)
        .await
        .map_err(|e| e.to_string())?;

    // Store results
    for result in &results {
        let result_id = Uuid::new_v4().to_string();
        let now = Utc::now().to_rfc3339();

        let _ = sqlx::query(
            "INSERT INTO exploitation_results (id, campaign_id, target, result_type, data, severity, created_at) VALUES (?, ?, ?, ?, ?, ?, ?)"
        )
        .bind(&result_id)
        .bind(campaign_id)
        .bind(&result.username)
        .bind("hash_extracted")
        .bind(serde_json::to_string(&result).unwrap_or_default())
        .bind("high")
        .bind(&now)
        .execute(pool)
        .await;
    }

    Ok((results.len(), results.len()))
}

/// Run SMB Relay campaign
async fn run_smb_relay_campaign(
    engine: &ExploitationEngine,
    campaign_id: &str,
    config: serde_json::Value,
    targets: Vec<String>,
    pool: &SqlitePool,
) -> Result<(usize, usize), String> {
    // SMB Relay uses post-exploit module infrastructure
    let module = config.get("module")
        .and_then(|v| v.as_str())
        .unwrap_or("ntlm_relay");

    let post_config = PostExploitConfig {
        module: match module {
            "ldap_relay" => PostExploitModule::PassTheHash, // Placeholder
            "http_relay" => PostExploitModule::PassTheHash, // Placeholder
            _ => PostExploitModule::PassTheHash,
        },
        target: targets.first().cloned().unwrap_or_default(),
        credentials: Some(Credentials {
            username: config.get("username").and_then(|v| v.as_str()).unwrap_or("").to_string(),
            password: config.get("password").and_then(|v| v.as_str()).map(String::from),
            ntlm_hash: config.get("ntlm_hash").and_then(|v| v.as_str()).map(String::from),
            domain: config.get("domain").and_then(|v| v.as_str()).map(String::from),
            ssh_key: config.get("ssh_key").and_then(|v| v.as_str()).map(String::from),
        }),
        options: std::collections::HashMap::new(),
    };

    let result = engine.run_post_exploit(campaign_id, post_config)
        .await
        .map_err(|e| e.to_string())?;

    let successful = if result.success { 1 } else { 0 };

    // Store result
    let result_id = Uuid::new_v4().to_string();
    let now = Utc::now().to_rfc3339();
    let _ = sqlx::query(
        "INSERT INTO exploitation_results (id, campaign_id, target, result_type, data, severity, created_at) VALUES (?, ?, ?, ?, ?, ?, ?)"
    )
    .bind(&result_id)
    .bind(campaign_id)
    .bind(&result.target)
    .bind(if result.success { "relay_success" } else { "relay_failed" })
    .bind(serde_json::to_string(&result).unwrap_or_default())
    .bind(if result.success { Some("critical") } else { None::<&str> })
    .bind(&now)
    .execute(pool)
    .await;

    Ok((1, successful))
}

/// Run post-exploitation campaign
async fn run_post_exploit_campaign(
    engine: &ExploitationEngine,
    campaign_id: &str,
    attack_type: AttackType,
    config: serde_json::Value,
    targets: Vec<String>,
    pool: &SqlitePool,
) -> Result<(usize, usize), String> {
    let module = match attack_type {
        AttackType::CredentialDump => {
            match config.get("module").and_then(|v| v.as_str()).unwrap_or("dump_sam") {
                "dump_lsass" => PostExploitModule::DumpLsass,
                "browser_creds" => PostExploitModule::ExtractBrowserCreds,
                "wifi_passwords" => PostExploitModule::ExtractWifiPasswords,
                "keepass" => PostExploitModule::DumpKeePass,
                _ => PostExploitModule::DumpSam,
            }
        }
        AttackType::PrivilegeEscalation => {
            match config.get("module").and_then(|v| v.as_str()).unwrap_or("always_install_elevated") {
                "unquoted_paths" => PostExploitModule::CheckUnquotedPaths,
                "weak_service_perms" => PostExploitModule::CheckWeakServicePerms,
                "se_impersonate" => PostExploitModule::CheckSeImpersonate,
                "sudoers" => PostExploitModule::CheckSudoers,
                "suid_binaries" => PostExploitModule::CheckSuid,
                _ => PostExploitModule::CheckAlwaysInstallElevated,
            }
        }
        AttackType::Persistence => {
            match config.get("module").and_then(|v| v.as_str()).unwrap_or("scheduled_task") {
                "registry_run" => PostExploitModule::AddRegistryRunKey,
                "service" => PostExploitModule::CreateService,
                "cron_job" => PostExploitModule::AddCronJob,
                "ssh_key" => PostExploitModule::AddSshKey,
                _ => PostExploitModule::CreateScheduledTask,
            }
        }
        AttackType::LateralMovement => {
            match config.get("module").and_then(|v| v.as_str()).unwrap_or("pass_the_hash") {
                "pass_the_ticket" => PostExploitModule::PassTheTicket,
                "psexec" => PostExploitModule::PsExec,
                "wmi_exec" => PostExploitModule::WmiExec,
                "ssh_pivot" => PostExploitModule::SshPivot,
                _ => PostExploitModule::PassTheHash,
            }
        }
        _ => return Err("Invalid attack type for post-exploitation".to_string()),
    };

    let mut total = 0;
    let mut successful = 0;

    for target in targets {
        let post_config = PostExploitConfig {
            module: module.clone(),
            target: target.clone(),
            credentials: Some(Credentials {
                username: config.get("username").and_then(|v| v.as_str()).unwrap_or("").to_string(),
                password: config.get("password").and_then(|v| v.as_str()).map(String::from),
                ntlm_hash: config.get("ntlm_hash").and_then(|v| v.as_str()).map(String::from),
                domain: config.get("domain").and_then(|v| v.as_str()).map(String::from),
                ssh_key: None,
            }),
            options: std::collections::HashMap::new(),
        };

        match engine.run_post_exploit(campaign_id, post_config).await {
            Ok(result) => {
                total += 1;
                if result.success {
                    successful += 1;
                }

                // Store result
                let result_id = Uuid::new_v4().to_string();
                let now = Utc::now().to_rfc3339();
                let _ = sqlx::query(
                    "INSERT INTO exploitation_results (id, campaign_id, target, result_type, data, severity, created_at) VALUES (?, ?, ?, ?, ?, ?, ?)"
                )
                .bind(&result_id)
                .bind(campaign_id)
                .bind(&target)
                .bind(if result.success { "module_success" } else { "module_failed" })
                .bind(serde_json::to_string(&result).unwrap_or_default())
                .bind(if result.success { Some("high") } else { None::<&str> })
                .bind(&now)
                .execute(pool)
                .await;
            }
            Err(e) => {
                log::error!("Post-exploit module failed on {}: {}", target, e);
                total += 1;
            }
        }
    }

    Ok((total, successful))
}

/// Stop a running campaign
pub async fn stop_campaign(
    claims: web::ReqData<Claims>,
    pool: web::Data<SqlitePool>,
    engine: web::Data<std::sync::Arc<ExploitationEngine>>,
    path: web::Path<String>,
) -> Result<HttpResponse, ApiError> {
    let campaign_id = path.into_inner();

    // First, try to cancel the running campaign via the engine
    let was_running = engine.cancel_campaign(&campaign_id).await;

    // Update database status regardless
    let result = sqlx::query(
        "UPDATE exploitation_campaigns SET status = 'cancelled', completed_at = ? WHERE id = ? AND user_id = ? AND status = 'running'",
    )
    .bind(Utc::now().to_rfc3339())
    .bind(&campaign_id)
    .bind(&claims.sub)
    .execute(pool.get_ref())
    .await?;

    if result.rows_affected() == 0 && !was_running {
        return Err(ApiError::not_found(
            "Campaign not found or not running",
        ));
    }

    log_exploitation_action(
        pool.get_ref(),
        &claims.sub,
        Some(&campaign_id),
        "campaign_cancelled",
        None,
        serde_json::json!({"was_running_in_memory": was_running}),
    )
    .await?;

    Ok(HttpResponse::Ok().json(serde_json::json!({
        "id": campaign_id,
        "status": "cancelled",
        "message": if was_running { "Campaign stopped" } else { "Campaign marked as cancelled" }
    })))
}

/// Delete a campaign
pub async fn delete_campaign(
    claims: web::ReqData<Claims>,
    pool: web::Data<SqlitePool>,
    path: web::Path<String>,
) -> Result<HttpResponse, ApiError> {
    let campaign_id = path.into_inner();

    let result = sqlx::query(
        "DELETE FROM exploitation_campaigns WHERE id = ? AND user_id = ?",
    )
    .bind(&campaign_id)
    .bind(&claims.sub)
    .execute(pool.get_ref())
    .await?;

    if result.rows_affected() == 0 {
        return Err(ApiError::not_found("Campaign not found"));
    }

    Ok(HttpResponse::Ok().json(serde_json::json!({
        "message": "Campaign deleted"
    })))
}

/// Get campaign results
pub async fn get_campaign_results(
    claims: web::ReqData<Claims>,
    pool: web::Data<SqlitePool>,
    path: web::Path<String>,
) -> Result<HttpResponse, ApiError> {
    let campaign_id = path.into_inner();

    // Verify ownership
    let campaign: Option<(String,)> = sqlx::query_as(
        "SELECT id FROM exploitation_campaigns WHERE id = ? AND user_id = ?",
    )
    .bind(&campaign_id)
    .bind(&claims.sub)
    .fetch_optional(pool.get_ref())
    .await?;

    if campaign.is_none() {
        return Err(ApiError::not_found("Campaign not found"));
    }

    let results: Vec<(String, String, String, String, Option<String>, String)> = sqlx::query_as(
        "SELECT id, target, result_type, data, severity, created_at FROM exploitation_results WHERE campaign_id = ? ORDER BY created_at DESC",
    )
    .bind(&campaign_id)
    .fetch_all(pool.get_ref())
    .await?;

    let response: Vec<serde_json::Value> = results
        .into_iter()
        .map(|(id, target, result_type, data, severity, created_at)| {
            serde_json::json!({
                "id": id,
                "target": target,
                "result_type": result_type,
                "data": serde_json::from_str::<serde_json::Value>(&data).ok(),
                "severity": severity,
                "created_at": created_at
            })
        })
        .collect();

    Ok(HttpResponse::Ok().json(response))
}

#[derive(Debug, Deserialize)]
pub struct ExportRequest {
    /// Export format: json, csv, hashcat, john, markdown, html
    pub format: String,
}

/// Export campaign results
pub async fn export_campaign_results(
    claims: web::ReqData<Claims>,
    pool: web::Data<SqlitePool>,
    path: web::Path<String>,
    body: web::Json<ExportRequest>,
) -> Result<HttpResponse, ApiError> {
    let campaign_id = path.into_inner();

    // Verify ownership and get campaign details
    let campaign: Option<(String, String, String, String, String, Option<String>)> = sqlx::query_as(
        "SELECT id, name, attack_type, status, created_at, completed_at FROM exploitation_campaigns WHERE id = ? AND user_id = ?",
    )
    .bind(&campaign_id)
    .bind(&claims.sub)
    .fetch_optional(pool.get_ref())
    .await?;

    let campaign = campaign.ok_or_else(|| ApiError::not_found("Campaign not found"))?;
    let (_, campaign_name, attack_type, status, created_at, completed_at) = campaign;

    let results: Vec<(String, String, String, String, Option<String>, String)> = sqlx::query_as(
        "SELECT id, target, result_type, data, severity, created_at FROM exploitation_results WHERE campaign_id = ? ORDER BY created_at DESC",
    )
    .bind(&campaign_id)
    .fetch_all(pool.get_ref())
    .await?;

    match body.format.as_str() {
        "csv" => {
            let mut csv_output = String::from("id,target,result_type,severity,created_at,data\n");
            for (id, target, result_type, data, severity, created_at) in results {
                let escaped_data = data.replace('"', "\"\"");
                csv_output.push_str(&format!(
                    "{},{},{},{},{},\"{}\"\n",
                    id,
                    target,
                    result_type,
                    severity.unwrap_or_default(),
                    created_at,
                    escaped_data
                ));
            }
            Ok(HttpResponse::Ok()
                .content_type("text/csv")
                .insert_header(("Content-Disposition", format!("attachment; filename=\"campaign_{}.csv\"", campaign_id)))
                .body(csv_output))
        }

        "hashcat" => {
            // Export hashes in hashcat-compatible format
            let mut hash_output = String::new();
            for (_, _, result_type, data, _, _) in results {
                if result_type.contains("hash") || result_type.contains("kerberoast") || result_type.contains("asrep") {
                    if let Ok(parsed) = serde_json::from_str::<serde_json::Value>(&data) {
                        if let Some(hash) = parsed.get("hash").and_then(|h| h.as_str()) {
                            hash_output.push_str(hash);
                            hash_output.push('\n');
                        }
                        if let Some(hash) = parsed.get("nt_hash").and_then(|h| h.as_str()) {
                            // NTLM hash format for hashcat mode 1000
                            hash_output.push_str(hash);
                            hash_output.push('\n');
                        }
                    }
                }
            }
            Ok(HttpResponse::Ok()
                .content_type("text/plain")
                .insert_header(("Content-Disposition", format!("attachment; filename=\"hashes_{}.txt\"", campaign_id)))
                .body(hash_output))
        }

        "john" => {
            // Export hashes in John the Ripper format
            let mut hash_output = String::new();
            for (_, target, result_type, data, _, _) in results {
                if result_type.contains("hash") || result_type.contains("kerberoast") || result_type.contains("asrep") {
                    if let Ok(parsed) = serde_json::from_str::<serde_json::Value>(&data) {
                        if let Some(user) = parsed.get("user").or(parsed.get("username")).and_then(|u| u.as_str()) {
                            if let Some(hash) = parsed.get("hash").and_then(|h| h.as_str()) {
                                // user:hash format
                                hash_output.push_str(&format!("{}:{}\n", user, hash));
                            }
                            if let Some(nt_hash) = parsed.get("nt_hash").and_then(|h| h.as_str()) {
                                // NTLM format: user:$NT$hash
                                hash_output.push_str(&format!("{}:$NT${}\n", user, nt_hash));
                            }
                        }
                    }
                }
            }
            Ok(HttpResponse::Ok()
                .content_type("text/plain")
                .insert_header(("Content-Disposition", format!("attachment; filename=\"john_hashes_{}.txt\"", campaign_id)))
                .body(hash_output))
        }

        "markdown" => {
            // Export as Markdown report
            let mut md = format!("# Exploitation Campaign Report\n\n");
            md.push_str(&format!("**Campaign:** {}\n\n", campaign_name));
            md.push_str(&format!("**Attack Type:** {}\n\n", attack_type));
            md.push_str(&format!("**Status:** {}\n\n", status));
            md.push_str(&format!("**Started:** {}\n\n", created_at));
            if let Some(ref completed) = completed_at {
                md.push_str(&format!("**Completed:** {}\n\n", completed));
            }
            md.push_str("---\n\n");
            md.push_str("## Results\n\n");

            // Group results by severity
            let critical: Vec<_> = results.iter().filter(|r| r.4.as_deref() == Some("critical")).collect();
            let high: Vec<_> = results.iter().filter(|r| r.4.as_deref() == Some("high")).collect();
            let medium: Vec<_> = results.iter().filter(|r| r.4.as_deref() == Some("medium")).collect();
            let other: Vec<_> = results.iter().filter(|r| !["critical", "high", "medium"].contains(&r.4.as_deref().unwrap_or(""))).collect();

            if !critical.is_empty() {
                md.push_str("### ðŸ”´ Critical Findings\n\n");
                for (_, target, result_type, data, _, created_at) in critical {
                    md.push_str(&format!("- **{}** on `{}` ({})\n", result_type, target, created_at));
                    if let Ok(parsed) = serde_json::from_str::<serde_json::Value>(&data) {
                        md.push_str(&format!("  ```json\n  {}\n  ```\n", serde_json::to_string_pretty(&parsed).unwrap_or_default()));
                    }
                }
                md.push_str("\n");
            }

            if !high.is_empty() {
                md.push_str("### ðŸŸ  High Severity Findings\n\n");
                for (_, target, result_type, _, _, _) in high {
                    md.push_str(&format!("- **{}** on `{}`\n", result_type, target));
                }
                md.push_str("\n");
            }

            if !medium.is_empty() {
                md.push_str("### ðŸŸ¡ Medium Severity Findings\n\n");
                for (_, target, result_type, _, _, _) in medium {
                    md.push_str(&format!("- **{}** on `{}`\n", result_type, target));
                }
                md.push_str("\n");
            }

            if !other.is_empty() {
                md.push_str("### â„¹ï¸ Other Findings\n\n");
                for (_, target, result_type, _, _, _) in other {
                    md.push_str(&format!("- **{}** on `{}`\n", result_type, target));
                }
                md.push_str("\n");
            }

            md.push_str("---\n\n");
            md.push_str(&format!("*Generated by HeroForge - Total Results: {}*\n", results.len()));

            Ok(HttpResponse::Ok()
                .content_type("text/markdown")
                .insert_header(("Content-Disposition", format!("attachment; filename=\"report_{}.md\"", campaign_id)))
                .body(md))
        }

        "html" => {
            // Export as HTML report
            let mut html = format!(r#"<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Campaign Report: {}</title>
    <style>
        body {{ font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; max-width: 1200px; margin: 0 auto; padding: 20px; background: #1a1a2e; color: #eee; }}
        h1 {{ color: #00d9ff; }}
        h2 {{ color: #00d9ff; border-bottom: 1px solid #333; padding-bottom: 10px; }}
        .meta {{ background: #16213e; padding: 15px; border-radius: 8px; margin-bottom: 20px; }}
        .meta p {{ margin: 5px 0; }}
        .result {{ background: #16213e; padding: 15px; border-radius: 8px; margin: 10px 0; border-left: 4px solid #666; }}
        .result.critical {{ border-left-color: #ff4444; }}
        .result.high {{ border-left-color: #ff8800; }}
        .result.medium {{ border-left-color: #ffcc00; }}
        .result h3 {{ margin: 0 0 10px 0; color: #00d9ff; }}
        .target {{ font-family: monospace; background: #0a0a1a; padding: 2px 6px; border-radius: 4px; }}
        pre {{ background: #0a0a1a; padding: 10px; border-radius: 4px; overflow-x: auto; }}
    </style>
</head>
<body>
    <h1>Exploitation Campaign Report</h1>
    <div class="meta">
        <p><strong>Campaign:</strong> {}</p>
        <p><strong>Attack Type:</strong> {}</p>
        <p><strong>Status:</strong> {}</p>
        <p><strong>Started:</strong> {}</p>
        <p><strong>Completed:</strong> {}</p>
        <p><strong>Total Results:</strong> {}</p>
    </div>
    <h2>Results</h2>
"#, campaign_name, campaign_name, attack_type, status, created_at, completed_at.as_deref().unwrap_or("In Progress"), results.len());

            for (_, target, result_type, data, severity, created_at) in &results {
                let severity_class = severity.as_deref().unwrap_or("info");
                html.push_str(&format!(
                    r#"    <div class="result {}">
        <h3>{}</h3>
        <p>Target: <span class="target">{}</span></p>
        <p>Time: {}</p>
        <pre>{}</pre>
    </div>
"#,
                    severity_class,
                    result_type,
                    target,
                    created_at,
                    serde_json::from_str::<serde_json::Value>(&data)
                        .map(|v| serde_json::to_string_pretty(&v).unwrap_or_default())
                        .unwrap_or_else(|_| data.clone())
                ));
            }

            html.push_str(r#"
    <hr>
    <p style="text-align: center; color: #666;">Generated by HeroForge</p>
</body>
</html>"#);

            Ok(HttpResponse::Ok()
                .content_type("text/html")
                .insert_header(("Content-Disposition", format!("attachment; filename=\"report_{}.html\"", campaign_id)))
                .body(html))
        }

        _ => {
            // Default to JSON
            let response: Vec<serde_json::Value> = results
                .into_iter()
                .map(|(id, target, result_type, data, severity, created_at)| {
                    serde_json::json!({
                        "id": id,
                        "target": target,
                        "result_type": result_type,
                        "data": serde_json::from_str::<serde_json::Value>(&data).ok(),
                        "severity": severity,
                        "created_at": created_at
                    })
                })
                .collect();

            Ok(HttpResponse::Ok()
                .content_type("application/json")
                .insert_header(("Content-Disposition", format!("attachment; filename=\"results_{}.json\"", campaign_id)))
                .json(response))
        }
    }
}

/// Generate shell payload
pub async fn generate_shell(
    claims: web::ReqData<Claims>,
    pool: web::Data<SqlitePool>,
    body: web::Json<GenerateShellRequest>,
) -> Result<HttpResponse, ApiError> {
    let config = ShellConfig {
        shell_type: body.shell_type.clone(),
        platform: body.platform.clone(),
        format: body.format.clone(),
        lhost: body.lhost.clone(),
        lport: body.lport,
        encoding: body.encoding.clone(),
        obfuscation_level: body.obfuscation_level,
        staged: body.staged,
        xor_key: body.xor_key.clone(),
        architecture: body.architecture.clone(),
        msf_encoder: body.msf_encoder.clone(),
        encoder_iterations: body.encoder_iterations,
        bad_chars: body.bad_chars.clone(),
        exit_func: body.exit_func.clone(),
    };

    // Create engine and generate shell
    let engine = ExploitationEngine::with_default_safety();
    let result = engine.generate_shell(config).await.map_err(|e| {
        ApiError::internal(format!("Failed to generate shell: {}", e))
    })?;

    // Save to database
    let config_json = serde_json::to_string(&body.0).unwrap_or_default();
    let shell_type_json = serde_json::to_string(&body.shell_type).unwrap_or_default();
    let platform_json = serde_json::to_string(&body.platform).unwrap_or_default();
    let format_json = serde_json::to_string(&body.format).unwrap_or_default();
    sqlx::query(
        r#"
        INSERT INTO generated_payloads (id, user_id, payload_type, platform, format, config, payload_hash, created_at)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?)
        "#,
    )
    .bind(&result.id)
    .bind(&claims.sub)
    .bind(&shell_type_json)
    .bind(&platform_json)
    .bind(&format_json)
    .bind(&config_json)
    .bind(&result.payload_hash)
    .bind(result.created_at.to_rfc3339())
    .execute(pool.get_ref())
    .await?;

    // Log the action
    log_exploitation_action(
        pool.get_ref(),
        &claims.sub,
        None,
        "shell_generated",
        None,
        serde_json::json!({
            "payload_id": result.id,
            "format": result.format,
            "platform": result.platform
        }),
    )
    .await?;

    Ok(HttpResponse::Ok().json(serde_json::json!({
        "id": result.id,
        "payload": result.payload,
        "payload_hash": result.payload_hash,
        "format": result.format,
        "platform": result.platform,
        "listener_command": result.listener_command,
        "one_liner": result.one_liner,
        "created_at": result.created_at
    })))
}

/// List shell templates
pub async fn list_shell_templates() -> Result<HttpResponse, ApiError> {
    let templates = vec![
        ShellTemplateInfo {
            format: ShellFormat::Bash,
            platform: Platform::Linux,
            name: "Bash Reverse Shell".to_string(),
            description: "Simple bash reverse shell using /dev/tcp".to_string(),
            requires_msfvenom: false,
        },
        ShellTemplateInfo {
            format: ShellFormat::PowerShell,
            platform: Platform::Windows,
            name: "PowerShell Reverse Shell".to_string(),
            description: "PowerShell TCP reverse shell with optional obfuscation".to_string(),
            requires_msfvenom: false,
        },
        ShellTemplateInfo {
            format: ShellFormat::Python,
            platform: Platform::Universal,
            name: "Python Reverse Shell".to_string(),
            description: "Cross-platform Python reverse shell".to_string(),
            requires_msfvenom: false,
        },
        ShellTemplateInfo {
            format: ShellFormat::Php,
            platform: Platform::Universal,
            name: "PHP Reverse Shell".to_string(),
            description: "PHP reverse shell for web exploitation".to_string(),
            requires_msfvenom: false,
        },
        ShellTemplateInfo {
            format: ShellFormat::Php,
            platform: Platform::Universal,
            name: "PHP Web Shell".to_string(),
            description: "Simple PHP web shell for command execution".to_string(),
            requires_msfvenom: false,
        },
        ShellTemplateInfo {
            format: ShellFormat::MeterpreterExe,
            platform: Platform::Windows,
            name: "Meterpreter EXE".to_string(),
            description: "Windows Meterpreter reverse TCP executable".to_string(),
            requires_msfvenom: true,
        },
        ShellTemplateInfo {
            format: ShellFormat::MeterpreterElf,
            platform: Platform::Linux,
            name: "Meterpreter ELF".to_string(),
            description: "Linux Meterpreter reverse TCP executable".to_string(),
            requires_msfvenom: true,
        },
        ShellTemplateInfo {
            format: ShellFormat::MeterpreterPowerShell,
            platform: Platform::Windows,
            name: "Meterpreter PowerShell".to_string(),
            description: "Windows Meterpreter PowerShell payload".to_string(),
            requires_msfvenom: true,
        },
    ];

    Ok(HttpResponse::Ok().json(templates))
}

/// List post-exploitation modules
pub async fn list_post_exploit_modules() -> Result<HttpResponse, ApiError> {
    let modules = vec![
        // Credential Harvesting
        PostExploitModuleInfo {
            module: PostExploitModule::DumpSam,
            name: "Dump SAM".to_string(),
            description: PostExploitModule::DumpSam.description().to_string(),
            category: PostExploitCategory::CredentialHarvesting,
            platforms: PostExploitModule::DumpSam.supported_platforms(),
        },
        PostExploitModuleInfo {
            module: PostExploitModule::DumpLsass,
            name: "Dump LSASS".to_string(),
            description: PostExploitModule::DumpLsass.description().to_string(),
            category: PostExploitCategory::CredentialHarvesting,
            platforms: PostExploitModule::DumpLsass.supported_platforms(),
        },
        PostExploitModuleInfo {
            module: PostExploitModule::ExtractBrowserCreds,
            name: "Extract Browser Credentials".to_string(),
            description: PostExploitModule::ExtractBrowserCreds.description().to_string(),
            category: PostExploitCategory::CredentialHarvesting,
            platforms: PostExploitModule::ExtractBrowserCreds.supported_platforms(),
        },
        // Privilege Escalation
        PostExploitModuleInfo {
            module: PostExploitModule::CheckAlwaysInstallElevated,
            name: "Check AlwaysInstallElevated".to_string(),
            description: PostExploitModule::CheckAlwaysInstallElevated.description().to_string(),
            category: PostExploitCategory::PrivilegeEscalation,
            platforms: PostExploitModule::CheckAlwaysInstallElevated.supported_platforms(),
        },
        PostExploitModuleInfo {
            module: PostExploitModule::CheckSuid,
            name: "Check SUID Binaries".to_string(),
            description: PostExploitModule::CheckSuid.description().to_string(),
            category: PostExploitCategory::PrivilegeEscalation,
            platforms: PostExploitModule::CheckSuid.supported_platforms(),
        },
        PostExploitModuleInfo {
            module: PostExploitModule::CheckSudoers,
            name: "Check Sudoers".to_string(),
            description: PostExploitModule::CheckSudoers.description().to_string(),
            category: PostExploitCategory::PrivilegeEscalation,
            platforms: PostExploitModule::CheckSudoers.supported_platforms(),
        },
        // Lateral Movement
        PostExploitModuleInfo {
            module: PostExploitModule::PassTheHash,
            name: "Pass-the-Hash".to_string(),
            description: PostExploitModule::PassTheHash.description().to_string(),
            category: PostExploitCategory::LateralMovement,
            platforms: PostExploitModule::PassTheHash.supported_platforms(),
        },
        PostExploitModuleInfo {
            module: PostExploitModule::PsExec,
            name: "PsExec".to_string(),
            description: PostExploitModule::PsExec.description().to_string(),
            category: PostExploitCategory::LateralMovement,
            platforms: PostExploitModule::PsExec.supported_platforms(),
        },
    ];

    Ok(HttpResponse::Ok().json(modules))
}

/// List user's generated payloads
pub async fn list_payloads(
    claims: web::ReqData<Claims>,
    pool: web::Data<SqlitePool>,
) -> Result<HttpResponse, ApiError> {
    let payloads: Vec<(String, String, String, String, String, String)> = sqlx::query_as(
        "SELECT id, payload_type, platform, format, payload_hash, created_at FROM generated_payloads WHERE user_id = ? ORDER BY created_at DESC LIMIT 50",
    )
    .bind(&claims.sub)
    .fetch_all(pool.get_ref())
    .await?;

    let response: Vec<serde_json::Value> = payloads
        .into_iter()
        .map(|(id, payload_type, platform, format, hash, created_at)| {
            serde_json::json!({
                "id": id,
                "payload_type": payload_type,
                "platform": platform,
                "format": format,
                "payload_hash": hash,
                "created_at": created_at
            })
        })
        .collect();

    Ok(HttpResponse::Ok().json(response))
}

// ============================================================================
// Helper Functions
// ============================================================================

async fn log_exploitation_action(
    pool: &SqlitePool,
    user_id: &str,
    campaign_id: Option<&str>,
    action: &str,
    target: Option<&str>,
    details: serde_json::Value,
) -> Result<(), ApiError> {
    let id = Uuid::new_v4().to_string();
    let now = Utc::now().to_rfc3339();

    sqlx::query(
        r#"
        INSERT INTO exploitation_audit_logs (id, user_id, campaign_id, action, target, details, created_at)
        VALUES (?, ?, ?, ?, ?, ?, ?)
        "#,
    )
    .bind(&id)
    .bind(user_id)
    .bind(campaign_id)
    .bind(action)
    .bind(target)
    .bind(details.to_string())
    .bind(&now)
    .execute(pool)
    .await?;

    Ok(())
}

// ============================================================================
// Route Configuration
// ============================================================================

pub fn configure(cfg: &mut web::ServiceConfig) {
    cfg.service(
        web::scope("/exploitation")
            .route("/status", web::get().to(get_status))
            .route("/campaigns", web::post().to(create_campaign))
            .route("/campaigns", web::get().to(list_campaigns))
            .route("/campaigns/{id}", web::get().to(get_campaign))
            .route("/campaigns/{id}/start", web::post().to(start_campaign))
            .route("/campaigns/{id}/stop", web::post().to(stop_campaign))
            .route("/campaigns/{id}", web::delete().to(delete_campaign))
            .route("/campaigns/{id}/results", web::get().to(get_campaign_results))
            .route("/campaigns/{id}/export", web::post().to(export_campaign_results))
            .route("/shells/generate", web::post().to(generate_shell))
            .route("/shells/templates", web::get().to(list_shell_templates))
            .route("/shells", web::get().to(list_payloads))
            .route("/modules", web::get().to(list_post_exploit_modules)),
    );
}
