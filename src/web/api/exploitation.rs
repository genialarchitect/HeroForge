// Exploitation API Endpoints
// REST API for exploitation campaigns, shell generation, and post-exploitation

use actix_web::{web, HttpResponse, Result};
use chrono::Utc;
use serde::{Deserialize, Serialize};
use sqlx::SqlitePool;
use uuid::Uuid;

use crate::scanner::exploitation::{
    types::*, ExploitationEngine, ExploitSafetyConfig, SafetyController,
};
use crate::web::auth::Claims;
use crate::web::error::ApiError;

// ============================================================================
// Request/Response Types
// ============================================================================

#[derive(Debug, Deserialize)]
pub struct CreateCampaignRequest {
    pub name: String,
    pub attack_type: AttackType,
    pub config: serde_json::Value,
    pub targets: Vec<String>,
}

#[derive(Debug, Deserialize)]
pub struct AuthorizeCampaignRequest {
    pub authorized: bool,
}

#[derive(Debug, Deserialize, Serialize)]
pub struct GenerateShellRequest {
    pub shell_type: ShellType,
    pub platform: Platform,
    pub format: ShellFormat,
    pub lhost: String,
    pub lport: u16,
    #[serde(default)]
    pub encoding: EncodingType,
    #[serde(default)]
    pub obfuscation_level: u8,
    #[serde(default)]
    pub staged: bool,
    pub xor_key: Option<String>,
}

#[derive(Debug, Serialize)]
pub struct CampaignResponse {
    pub id: String,
    pub name: String,
    pub attack_type: AttackType,
    pub status: CampaignStatus,
    pub targets: Vec<String>,
    pub results_count: i32,
    pub successful_count: i32,
    pub created_at: String,
    pub started_at: Option<String>,
    pub completed_at: Option<String>,
}

#[derive(Debug, Serialize)]
pub struct ShellTemplateInfo {
    pub format: ShellFormat,
    pub platform: Platform,
    pub name: String,
    pub description: String,
    pub requires_msfvenom: bool,
}

#[derive(Debug, Serialize)]
pub struct PostExploitModuleInfo {
    pub module: PostExploitModule,
    pub name: String,
    pub description: String,
    pub category: PostExploitCategory,
    pub platforms: Vec<Platform>,
}

#[derive(Debug, Serialize)]
pub struct ExploitationStatusResponse {
    pub msfvenom_available: bool,
    pub active_campaigns: i32,
    pub total_campaigns: i32,
    pub credentials_stored: i32,
    pub payloads_generated: i32,
}

// ============================================================================
// Handlers
// ============================================================================

/// Get exploitation status
pub async fn get_status(
    claims: web::ReqData<Claims>,
    pool: web::Data<SqlitePool>,
) -> Result<HttpResponse, ApiError> {
    let user_id = &claims.sub;

    // Count campaigns
    let active_campaigns: (i32,) = sqlx::query_as(
        "SELECT COUNT(*) FROM exploitation_campaigns WHERE user_id = ? AND status = 'running'",
    )
    .bind(user_id)
    .fetch_one(pool.get_ref())
    .await
    .unwrap_or((0,));

    let total_campaigns: (i32,) = sqlx::query_as(
        "SELECT COUNT(*) FROM exploitation_campaigns WHERE user_id = ?",
    )
    .bind(user_id)
    .fetch_one(pool.get_ref())
    .await
    .unwrap_or((0,));

    let credentials_stored: (i32,) = sqlx::query_as(
        "SELECT COUNT(*) FROM exploitation_results WHERE campaign_id IN (SELECT id FROM exploitation_campaigns WHERE user_id = ?) AND result_type = 'credential_found'",
    )
    .bind(user_id)
    .fetch_one(pool.get_ref())
    .await
    .unwrap_or((0,));

    let payloads_generated: (i32,) = sqlx::query_as(
        "SELECT COUNT(*) FROM generated_payloads WHERE user_id = ?",
    )
    .bind(user_id)
    .fetch_one(pool.get_ref())
    .await
    .unwrap_or((0,));

    Ok(HttpResponse::Ok().json(ExploitationStatusResponse {
        msfvenom_available: SafetyController::check_msfvenom_available(),
        active_campaigns: active_campaigns.0,
        total_campaigns: total_campaigns.0,
        credentials_stored: credentials_stored.0,
        payloads_generated: payloads_generated.0,
    }))
}

/// Create a new exploitation campaign
pub async fn create_campaign(
    claims: web::ReqData<Claims>,
    pool: web::Data<SqlitePool>,
    body: web::Json<CreateCampaignRequest>,
) -> Result<HttpResponse, ApiError> {
    let id = Uuid::new_v4().to_string();
    let now = Utc::now().to_rfc3339();
    let targets_json = serde_json::to_string(&body.targets).unwrap_or_default();
    let config_json = serde_json::to_string(&body.config).unwrap_or_default();
    let attack_type_json = serde_json::to_string(&body.attack_type).unwrap_or_default();

    sqlx::query(
        r#"
        INSERT INTO exploitation_campaigns (id, user_id, name, attack_type, status, config, targets, created_at)
        VALUES (?, ?, ?, ?, 'pending', ?, ?, ?)
        "#,
    )
    .bind(&id)
    .bind(&claims.sub)
    .bind(&body.name)
    .bind(&attack_type_json)
    .bind(&config_json)
    .bind(&targets_json)
    .bind(&now)
    .execute(pool.get_ref())
    .await?;

    // Log the action
    log_exploitation_action(
        pool.get_ref(),
        &claims.sub,
        Some(&id),
        "campaign_created",
        None,
        serde_json::json!({
            "name": body.name,
            "attack_type": body.attack_type,
            "targets_count": body.targets.len()
        }),
    )
    .await?;

    Ok(HttpResponse::Created().json(serde_json::json!({
        "id": id,
        "status": "pending",
        "message": "Campaign created. Authorize to start execution."
    })))
}

/// List user's campaigns
pub async fn list_campaigns(
    claims: web::ReqData<Claims>,
    pool: web::Data<SqlitePool>,
) -> Result<HttpResponse, ApiError> {
    let campaigns: Vec<(String, String, String, String, String, i32, i32, String, Option<String>, Option<String>)> = sqlx::query_as(
        r#"
        SELECT id, name, attack_type, status, targets, results_count, successful_count, created_at, started_at, completed_at
        FROM exploitation_campaigns
        WHERE user_id = ?
        ORDER BY created_at DESC
        "#,
    )
    .bind(&claims.sub)
    .fetch_all(pool.get_ref())
    .await?;

    let responses: Vec<CampaignResponse> = campaigns
        .into_iter()
        .map(|(id, name, attack_type, status, targets, results_count, successful_count, created_at, started_at, completed_at)| {
            CampaignResponse {
                id,
                name,
                attack_type: serde_json::from_str(&attack_type).unwrap_or(AttackType::PasswordSpray),
                status: match status.as_str() {
                    "running" => CampaignStatus::Running,
                    "completed" => CampaignStatus::Completed,
                    "failed" => CampaignStatus::Failed,
                    "cancelled" => CampaignStatus::Cancelled,
                    _ => CampaignStatus::Pending,
                },
                targets: serde_json::from_str(&targets).unwrap_or_default(),
                results_count,
                successful_count,
                created_at,
                started_at,
                completed_at,
            }
        })
        .collect();

    Ok(HttpResponse::Ok().json(responses))
}

/// Get campaign details
pub async fn get_campaign(
    claims: web::ReqData<Claims>,
    pool: web::Data<SqlitePool>,
    path: web::Path<String>,
) -> Result<HttpResponse, ApiError> {
    let campaign_id = path.into_inner();

    let campaign: Option<(String, String, String, String, String, String, i32, i32, String, Option<String>, Option<String>, Option<String>)> = sqlx::query_as(
        r#"
        SELECT id, name, attack_type, status, config, targets, results_count, successful_count, created_at, started_at, completed_at, error_message
        FROM exploitation_campaigns
        WHERE id = ? AND user_id = ?
        "#,
    )
    .bind(&campaign_id)
    .bind(&claims.sub)
    .fetch_optional(pool.get_ref())
    .await?;

    match campaign {
        Some((id, name, attack_type, status, config, targets, results_count, successful_count, created_at, started_at, completed_at, error_message)) => {
            Ok(HttpResponse::Ok().json(serde_json::json!({
                "id": id,
                "name": name,
                "attack_type": serde_json::from_str::<AttackType>(&attack_type).ok(),
                "status": status,
                "config": serde_json::from_str::<serde_json::Value>(&config).ok(),
                "targets": serde_json::from_str::<Vec<String>>(&targets).unwrap_or_default(),
                "results_count": results_count,
                "successful_count": successful_count,
                "created_at": created_at,
                "started_at": started_at,
                "completed_at": completed_at,
                "error_message": error_message
            })))
        }
        None => Err(ApiError::not_found("Campaign not found")),
    }
}

/// Authorize and start campaign
pub async fn start_campaign(
    claims: web::ReqData<Claims>,
    pool: web::Data<SqlitePool>,
    path: web::Path<String>,
    body: web::Json<AuthorizeCampaignRequest>,
) -> Result<HttpResponse, ApiError> {
    let campaign_id = path.into_inner();

    if !body.authorized {
        return Err(ApiError::bad_request(
            "You must explicitly authorize the campaign execution",
        ));
    }

    // Verify campaign exists and belongs to user
    let campaign: Option<(String, String, String, String)> = sqlx::query_as(
        "SELECT id, status, attack_type, config FROM exploitation_campaigns WHERE id = ? AND user_id = ?",
    )
    .bind(&campaign_id)
    .bind(&claims.sub)
    .fetch_optional(pool.get_ref())
    .await?;

    let (id, status, attack_type, config) = campaign
        .ok_or_else(|| ApiError::not_found("Campaign not found"))?;

    if status != "pending" {
        return Err(ApiError::bad_request(format!(
            "Campaign is already {}",
            status
        )));
    }

    // Update status to running
    let now = Utc::now().to_rfc3339();
    sqlx::query("UPDATE exploitation_campaigns SET status = 'running', started_at = ? WHERE id = ?")
        .bind(&now)
        .bind(&id)
        .execute(pool.get_ref())
        .await?;

    // Log authorization
    log_exploitation_action(
        pool.get_ref(),
        &claims.sub,
        Some(&id),
        "campaign_authorized",
        None,
        serde_json::json!({"authorized": true}),
    )
    .await?;

    // TODO: Spawn background task to run the campaign
    // For now, just return success
    Ok(HttpResponse::Accepted().json(serde_json::json!({
        "id": id,
        "status": "running",
        "message": "Campaign authorized and started"
    })))
}

/// Stop a running campaign
pub async fn stop_campaign(
    claims: web::ReqData<Claims>,
    pool: web::Data<SqlitePool>,
    path: web::Path<String>,
) -> Result<HttpResponse, ApiError> {
    let campaign_id = path.into_inner();

    let result = sqlx::query(
        "UPDATE exploitation_campaigns SET status = 'cancelled', completed_at = ? WHERE id = ? AND user_id = ? AND status = 'running'",
    )
    .bind(Utc::now().to_rfc3339())
    .bind(&campaign_id)
    .bind(&claims.sub)
    .execute(pool.get_ref())
    .await?;

    if result.rows_affected() == 0 {
        return Err(ApiError::not_found(
            "Campaign not found or not running",
        ));
    }

    log_exploitation_action(
        pool.get_ref(),
        &claims.sub,
        Some(&campaign_id),
        "campaign_cancelled",
        None,
        serde_json::json!({}),
    )
    .await?;

    Ok(HttpResponse::Ok().json(serde_json::json!({
        "id": campaign_id,
        "status": "cancelled",
        "message": "Campaign stopped"
    })))
}

/// Delete a campaign
pub async fn delete_campaign(
    claims: web::ReqData<Claims>,
    pool: web::Data<SqlitePool>,
    path: web::Path<String>,
) -> Result<HttpResponse, ApiError> {
    let campaign_id = path.into_inner();

    let result = sqlx::query(
        "DELETE FROM exploitation_campaigns WHERE id = ? AND user_id = ?",
    )
    .bind(&campaign_id)
    .bind(&claims.sub)
    .execute(pool.get_ref())
    .await?;

    if result.rows_affected() == 0 {
        return Err(ApiError::not_found("Campaign not found"));
    }

    Ok(HttpResponse::Ok().json(serde_json::json!({
        "message": "Campaign deleted"
    })))
}

/// Get campaign results
pub async fn get_campaign_results(
    claims: web::ReqData<Claims>,
    pool: web::Data<SqlitePool>,
    path: web::Path<String>,
) -> Result<HttpResponse, ApiError> {
    let campaign_id = path.into_inner();

    // Verify ownership
    let campaign: Option<(String,)> = sqlx::query_as(
        "SELECT id FROM exploitation_campaigns WHERE id = ? AND user_id = ?",
    )
    .bind(&campaign_id)
    .bind(&claims.sub)
    .fetch_optional(pool.get_ref())
    .await?;

    if campaign.is_none() {
        return Err(ApiError::not_found("Campaign not found"));
    }

    let results: Vec<(String, String, String, String, Option<String>, String)> = sqlx::query_as(
        "SELECT id, target, result_type, data, severity, created_at FROM exploitation_results WHERE campaign_id = ? ORDER BY created_at DESC",
    )
    .bind(&campaign_id)
    .fetch_all(pool.get_ref())
    .await?;

    let response: Vec<serde_json::Value> = results
        .into_iter()
        .map(|(id, target, result_type, data, severity, created_at)| {
            serde_json::json!({
                "id": id,
                "target": target,
                "result_type": result_type,
                "data": serde_json::from_str::<serde_json::Value>(&data).ok(),
                "severity": severity,
                "created_at": created_at
            })
        })
        .collect();

    Ok(HttpResponse::Ok().json(response))
}

#[derive(Debug, Deserialize)]
pub struct ExportRequest {
    pub format: String, // "json" or "csv"
}

/// Export campaign results
pub async fn export_campaign_results(
    claims: web::ReqData<Claims>,
    pool: web::Data<SqlitePool>,
    path: web::Path<String>,
    body: web::Json<ExportRequest>,
) -> Result<HttpResponse, ApiError> {
    let campaign_id = path.into_inner();

    // Verify ownership
    let campaign: Option<(String,)> = sqlx::query_as(
        "SELECT id FROM exploitation_campaigns WHERE id = ? AND user_id = ?",
    )
    .bind(&campaign_id)
    .bind(&claims.sub)
    .fetch_optional(pool.get_ref())
    .await?;

    if campaign.is_none() {
        return Err(ApiError::not_found("Campaign not found"));
    }

    let results: Vec<(String, String, String, String, Option<String>, String)> = sqlx::query_as(
        "SELECT id, target, result_type, data, severity, created_at FROM exploitation_results WHERE campaign_id = ? ORDER BY created_at DESC",
    )
    .bind(&campaign_id)
    .fetch_all(pool.get_ref())
    .await?;

    match body.format.as_str() {
        "csv" => {
            let mut csv_output = String::from("id,target,result_type,severity,created_at,data\n");
            for (id, target, result_type, data, severity, created_at) in results {
                let escaped_data = data.replace('"', "\"\"");
                csv_output.push_str(&format!(
                    "{},{},{},{},{},\"{}\"\n",
                    id,
                    target,
                    result_type,
                    severity.unwrap_or_default(),
                    created_at,
                    escaped_data
                ));
            }
            Ok(HttpResponse::Ok()
                .content_type("text/csv")
                .body(csv_output))
        }
        _ => {
            // Default to JSON
            let response: Vec<serde_json::Value> = results
                .into_iter()
                .map(|(id, target, result_type, data, severity, created_at)| {
                    serde_json::json!({
                        "id": id,
                        "target": target,
                        "result_type": result_type,
                        "data": serde_json::from_str::<serde_json::Value>(&data).ok(),
                        "severity": severity,
                        "created_at": created_at
                    })
                })
                .collect();

            Ok(HttpResponse::Ok()
                .content_type("application/json")
                .json(response))
        }
    }
}

/// Generate shell payload
pub async fn generate_shell(
    claims: web::ReqData<Claims>,
    pool: web::Data<SqlitePool>,
    body: web::Json<GenerateShellRequest>,
) -> Result<HttpResponse, ApiError> {
    let config = ShellConfig {
        shell_type: body.shell_type.clone(),
        platform: body.platform.clone(),
        format: body.format.clone(),
        lhost: body.lhost.clone(),
        lport: body.lport,
        encoding: body.encoding.clone(),
        obfuscation_level: body.obfuscation_level,
        staged: body.staged,
        xor_key: body.xor_key.clone(),
    };

    // Create engine and generate shell
    let engine = ExploitationEngine::with_default_safety();
    let result = engine.generate_shell(config).await.map_err(|e| {
        ApiError::internal(format!("Failed to generate shell: {}", e))
    })?;

    // Save to database
    let config_json = serde_json::to_string(&body.0).unwrap_or_default();
    let shell_type_json = serde_json::to_string(&body.shell_type).unwrap_or_default();
    let platform_json = serde_json::to_string(&body.platform).unwrap_or_default();
    let format_json = serde_json::to_string(&body.format).unwrap_or_default();
    sqlx::query(
        r#"
        INSERT INTO generated_payloads (id, user_id, payload_type, platform, format, config, payload_hash, created_at)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?)
        "#,
    )
    .bind(&result.id)
    .bind(&claims.sub)
    .bind(&shell_type_json)
    .bind(&platform_json)
    .bind(&format_json)
    .bind(&config_json)
    .bind(&result.payload_hash)
    .bind(result.created_at.to_rfc3339())
    .execute(pool.get_ref())
    .await?;

    // Log the action
    log_exploitation_action(
        pool.get_ref(),
        &claims.sub,
        None,
        "shell_generated",
        None,
        serde_json::json!({
            "payload_id": result.id,
            "format": result.format,
            "platform": result.platform
        }),
    )
    .await?;

    Ok(HttpResponse::Ok().json(serde_json::json!({
        "id": result.id,
        "payload": result.payload,
        "payload_hash": result.payload_hash,
        "format": result.format,
        "platform": result.platform,
        "listener_command": result.listener_command,
        "one_liner": result.one_liner,
        "created_at": result.created_at
    })))
}

/// List shell templates
pub async fn list_shell_templates() -> Result<HttpResponse, ApiError> {
    let templates = vec![
        ShellTemplateInfo {
            format: ShellFormat::Bash,
            platform: Platform::Linux,
            name: "Bash Reverse Shell".to_string(),
            description: "Simple bash reverse shell using /dev/tcp".to_string(),
            requires_msfvenom: false,
        },
        ShellTemplateInfo {
            format: ShellFormat::PowerShell,
            platform: Platform::Windows,
            name: "PowerShell Reverse Shell".to_string(),
            description: "PowerShell TCP reverse shell with optional obfuscation".to_string(),
            requires_msfvenom: false,
        },
        ShellTemplateInfo {
            format: ShellFormat::Python,
            platform: Platform::Universal,
            name: "Python Reverse Shell".to_string(),
            description: "Cross-platform Python reverse shell".to_string(),
            requires_msfvenom: false,
        },
        ShellTemplateInfo {
            format: ShellFormat::Php,
            platform: Platform::Universal,
            name: "PHP Reverse Shell".to_string(),
            description: "PHP reverse shell for web exploitation".to_string(),
            requires_msfvenom: false,
        },
        ShellTemplateInfo {
            format: ShellFormat::Php,
            platform: Platform::Universal,
            name: "PHP Web Shell".to_string(),
            description: "Simple PHP web shell for command execution".to_string(),
            requires_msfvenom: false,
        },
        ShellTemplateInfo {
            format: ShellFormat::MeterpreterExe,
            platform: Platform::Windows,
            name: "Meterpreter EXE".to_string(),
            description: "Windows Meterpreter reverse TCP executable".to_string(),
            requires_msfvenom: true,
        },
        ShellTemplateInfo {
            format: ShellFormat::MeterpreterElf,
            platform: Platform::Linux,
            name: "Meterpreter ELF".to_string(),
            description: "Linux Meterpreter reverse TCP executable".to_string(),
            requires_msfvenom: true,
        },
        ShellTemplateInfo {
            format: ShellFormat::MeterpreterPowerShell,
            platform: Platform::Windows,
            name: "Meterpreter PowerShell".to_string(),
            description: "Windows Meterpreter PowerShell payload".to_string(),
            requires_msfvenom: true,
        },
    ];

    Ok(HttpResponse::Ok().json(templates))
}

/// List post-exploitation modules
pub async fn list_post_exploit_modules() -> Result<HttpResponse, ApiError> {
    let modules = vec![
        // Credential Harvesting
        PostExploitModuleInfo {
            module: PostExploitModule::DumpSam,
            name: "Dump SAM".to_string(),
            description: PostExploitModule::DumpSam.description().to_string(),
            category: PostExploitCategory::CredentialHarvesting,
            platforms: PostExploitModule::DumpSam.supported_platforms(),
        },
        PostExploitModuleInfo {
            module: PostExploitModule::DumpLsass,
            name: "Dump LSASS".to_string(),
            description: PostExploitModule::DumpLsass.description().to_string(),
            category: PostExploitCategory::CredentialHarvesting,
            platforms: PostExploitModule::DumpLsass.supported_platforms(),
        },
        PostExploitModuleInfo {
            module: PostExploitModule::ExtractBrowserCreds,
            name: "Extract Browser Credentials".to_string(),
            description: PostExploitModule::ExtractBrowserCreds.description().to_string(),
            category: PostExploitCategory::CredentialHarvesting,
            platforms: PostExploitModule::ExtractBrowserCreds.supported_platforms(),
        },
        // Privilege Escalation
        PostExploitModuleInfo {
            module: PostExploitModule::CheckAlwaysInstallElevated,
            name: "Check AlwaysInstallElevated".to_string(),
            description: PostExploitModule::CheckAlwaysInstallElevated.description().to_string(),
            category: PostExploitCategory::PrivilegeEscalation,
            platforms: PostExploitModule::CheckAlwaysInstallElevated.supported_platforms(),
        },
        PostExploitModuleInfo {
            module: PostExploitModule::CheckSuid,
            name: "Check SUID Binaries".to_string(),
            description: PostExploitModule::CheckSuid.description().to_string(),
            category: PostExploitCategory::PrivilegeEscalation,
            platforms: PostExploitModule::CheckSuid.supported_platforms(),
        },
        PostExploitModuleInfo {
            module: PostExploitModule::CheckSudoers,
            name: "Check Sudoers".to_string(),
            description: PostExploitModule::CheckSudoers.description().to_string(),
            category: PostExploitCategory::PrivilegeEscalation,
            platforms: PostExploitModule::CheckSudoers.supported_platforms(),
        },
        // Lateral Movement
        PostExploitModuleInfo {
            module: PostExploitModule::PassTheHash,
            name: "Pass-the-Hash".to_string(),
            description: PostExploitModule::PassTheHash.description().to_string(),
            category: PostExploitCategory::LateralMovement,
            platforms: PostExploitModule::PassTheHash.supported_platforms(),
        },
        PostExploitModuleInfo {
            module: PostExploitModule::PsExec,
            name: "PsExec".to_string(),
            description: PostExploitModule::PsExec.description().to_string(),
            category: PostExploitCategory::LateralMovement,
            platforms: PostExploitModule::PsExec.supported_platforms(),
        },
    ];

    Ok(HttpResponse::Ok().json(modules))
}

/// List user's generated payloads
pub async fn list_payloads(
    claims: web::ReqData<Claims>,
    pool: web::Data<SqlitePool>,
) -> Result<HttpResponse, ApiError> {
    let payloads: Vec<(String, String, String, String, String, String)> = sqlx::query_as(
        "SELECT id, payload_type, platform, format, payload_hash, created_at FROM generated_payloads WHERE user_id = ? ORDER BY created_at DESC LIMIT 50",
    )
    .bind(&claims.sub)
    .fetch_all(pool.get_ref())
    .await?;

    let response: Vec<serde_json::Value> = payloads
        .into_iter()
        .map(|(id, payload_type, platform, format, hash, created_at)| {
            serde_json::json!({
                "id": id,
                "payload_type": payload_type,
                "platform": platform,
                "format": format,
                "payload_hash": hash,
                "created_at": created_at
            })
        })
        .collect();

    Ok(HttpResponse::Ok().json(response))
}

// ============================================================================
// Helper Functions
// ============================================================================

async fn log_exploitation_action(
    pool: &SqlitePool,
    user_id: &str,
    campaign_id: Option<&str>,
    action: &str,
    target: Option<&str>,
    details: serde_json::Value,
) -> Result<(), ApiError> {
    let id = Uuid::new_v4().to_string();
    let now = Utc::now().to_rfc3339();

    sqlx::query(
        r#"
        INSERT INTO exploitation_audit_logs (id, user_id, campaign_id, action, target, details, created_at)
        VALUES (?, ?, ?, ?, ?, ?, ?)
        "#,
    )
    .bind(&id)
    .bind(user_id)
    .bind(campaign_id)
    .bind(action)
    .bind(target)
    .bind(details.to_string())
    .bind(&now)
    .execute(pool)
    .await?;

    Ok(())
}

// ============================================================================
// Route Configuration
// ============================================================================

pub fn configure(cfg: &mut web::ServiceConfig) {
    cfg.service(
        web::scope("/exploitation")
            .route("/status", web::get().to(get_status))
            .route("/campaigns", web::post().to(create_campaign))
            .route("/campaigns", web::get().to(list_campaigns))
            .route("/campaigns/{id}", web::get().to(get_campaign))
            .route("/campaigns/{id}/start", web::post().to(start_campaign))
            .route("/campaigns/{id}/stop", web::post().to(stop_campaign))
            .route("/campaigns/{id}", web::delete().to(delete_campaign))
            .route("/campaigns/{id}/results", web::get().to(get_campaign_results))
            .route("/campaigns/{id}/export", web::post().to(export_campaign_results))
            .route("/shells/generate", web::post().to(generate_shell))
            .route("/shells/templates", web::get().to(list_shell_templates))
            .route("/shells", web::get().to(list_payloads))
            .route("/modules", web::get().to(list_post_exploit_modules)),
    );
}
