// Exploitation API Endpoints
// REST API for exploitation campaigns, shell generation, and post-exploitation

use actix_web::{web, HttpResponse, Result};
use chrono::Utc;
use serde::{Deserialize, Serialize};
use sqlx::SqlitePool;
use uuid::Uuid;

use crate::scanner::exploitation::{
    types::*, ExploitationEngine, SafetyController,
};
use crate::web::auth::Claims;
use crate::web::error::ApiError;
use crate::web::exploitation_broadcast;

// ============================================================================
// Request/Response Types
// ============================================================================

#[derive(Debug, Deserialize)]
pub struct CreateCampaignRequest {
    pub name: String,
    pub attack_type: AttackType,
    pub config: serde_json::Value,
    pub targets: Vec<String>,
    /// Required: Customer this campaign is associated with
    pub customer_id: String,
    /// Required: Asset IDs being targeted (must belong to customer)
    pub asset_ids: Vec<String>,
    /// Optional: Engagement this campaign is part of
    pub engagement_id: Option<String>,
}

#[derive(Debug, Deserialize)]
pub struct AuthorizeCampaignRequest {
    pub authorized: bool,
}

#[derive(Debug, Deserialize, Serialize)]
pub struct GenerateShellRequest {
    pub shell_type: ShellType,
    pub platform: Platform,
    pub format: ShellFormat,
    pub lhost: String,
    pub lport: u16,
    #[serde(default)]
    pub encoding: EncodingType,
    #[serde(default)]
    pub obfuscation_level: u8,
    #[serde(default)]
    pub staged: bool,
    pub xor_key: Option<String>,
    #[serde(default)]
    pub architecture: Architecture,
    #[serde(default)]
    pub msf_encoder: MsfEncoder,
    #[serde(default = "default_encoder_iterations")]
    pub encoder_iterations: u8,
    #[serde(default)]
    pub bad_chars: Option<String>,
    #[serde(default)]
    pub exit_func: Option<String>,
}

fn default_encoder_iterations() -> u8 { 1 }

#[derive(Debug, Serialize)]
pub struct CampaignResponse {
    pub id: String,
    pub name: String,
    pub attack_type: AttackType,
    pub status: CampaignStatus,
    pub targets: Vec<String>,
    pub results_count: i32,
    pub successful_count: i32,
    pub created_at: String,
    pub started_at: Option<String>,
    pub completed_at: Option<String>,
    /// Customer associated with this campaign
    pub customer_id: Option<String>,
    pub customer_name: Option<String>,
    /// Assets being targeted
    pub asset_ids: Vec<String>,
    /// Engagement this campaign is part of
    pub engagement_id: Option<String>,
}

#[derive(Debug, Serialize)]
pub struct ShellTemplateInfo {
    pub format: ShellFormat,
    pub platform: Platform,
    pub name: String,
    pub description: String,
    pub requires_msfvenom: bool,
}

#[derive(Debug, Serialize)]
pub struct PostExploitModuleInfo {
    pub module: PostExploitModule,
    pub name: String,
    pub description: String,
    pub category: PostExploitCategory,
    pub platforms: Vec<Platform>,
}

#[derive(Debug, Serialize)]
pub struct ExploitationStatusResponse {
    pub msfvenom_available: bool,
    pub active_campaigns: i32,
    pub total_campaigns: i32,
    pub credentials_stored: i32,
    pub payloads_generated: i32,
}

// ============================================================================
// Handlers
// ============================================================================

/// Get exploitation status
pub async fn get_status(
    claims: web::ReqData<Claims>,
    pool: web::Data<SqlitePool>,
) -> Result<HttpResponse, ApiError> {
    let user_id = &claims.sub;

    // Count campaigns
    let active_campaigns: (i32,) = sqlx::query_as(
        "SELECT COUNT(*) FROM exploitation_campaigns WHERE user_id = ? AND status = 'running'",
    )
    .bind(user_id)
    .fetch_one(pool.get_ref())
    .await
    .unwrap_or((0,));

    let total_campaigns: (i32,) = sqlx::query_as(
        "SELECT COUNT(*) FROM exploitation_campaigns WHERE user_id = ?",
    )
    .bind(user_id)
    .fetch_one(pool.get_ref())
    .await
    .unwrap_or((0,));

    let credentials_stored: (i32,) = sqlx::query_as(
        "SELECT COUNT(*) FROM exploitation_results WHERE campaign_id IN (SELECT id FROM exploitation_campaigns WHERE user_id = ?) AND result_type = 'credential_found'",
    )
    .bind(user_id)
    .fetch_one(pool.get_ref())
    .await
    .unwrap_or((0,));

    let payloads_generated: (i32,) = sqlx::query_as(
        "SELECT COUNT(*) FROM generated_payloads WHERE user_id = ?",
    )
    .bind(user_id)
    .fetch_one(pool.get_ref())
    .await
    .unwrap_or((0,));

    Ok(HttpResponse::Ok().json(ExploitationStatusResponse {
        msfvenom_available: SafetyController::check_msfvenom_available(),
        active_campaigns: active_campaigns.0,
        total_campaigns: total_campaigns.0,
        credentials_stored: credentials_stored.0,
        payloads_generated: payloads_generated.0,
    }))
}

/// Create a new exploitation campaign
pub async fn create_campaign(
    claims: web::ReqData<Claims>,
    pool: web::Data<SqlitePool>,
    body: web::Json<CreateCampaignRequest>,
) -> Result<HttpResponse, ApiError> {
    // SAFEGUARD 1: Validate customer exists and belongs to user
    let customer: Option<(String, String)> = sqlx::query_as(
        "SELECT id, name FROM customers WHERE id = ? AND user_id = ?"
    )
    .bind(&body.customer_id)
    .bind(&claims.sub)
    .fetch_optional(pool.get_ref())
    .await?;

    let (customer_id, customer_name) = customer
        .ok_or_else(|| ApiError::bad_request("Customer not found or access denied"))?;

    // SAFEGUARD 2: Validate all assets belong to the customer
    if body.asset_ids.is_empty() {
        return Err(ApiError::bad_request("At least one asset must be selected for exploitation"));
    }

    for asset_id in &body.asset_ids {
        let asset: Option<(String, String, Option<String>)> = sqlx::query_as(
            "SELECT id, ip_address, os_family FROM assets WHERE id = ? AND user_id = ?"
        )
        .bind(asset_id)
        .bind(&claims.sub)
        .fetch_optional(pool.get_ref())
        .await?;

        if asset.is_none() {
            return Err(ApiError::bad_request(format!(
                "Asset {} not found or access denied", asset_id
            )));
        }
    }

    // SAFEGUARD 3: If engagement_id provided, validate it belongs to the customer
    if let Some(ref engagement_id) = body.engagement_id {
        let engagement: Option<(String,)> = sqlx::query_as(
            "SELECT id FROM engagements WHERE id = ? AND customer_id = ?"
        )
        .bind(engagement_id)
        .bind(&customer_id)
        .fetch_optional(pool.get_ref())
        .await?;

        if engagement.is_none() {
            return Err(ApiError::bad_request(
                "Engagement not found or does not belong to the selected customer"
            ));
        }
    }

    // SAFEGUARD 4: Validate targets match asset IPs
    let _asset_ips: Vec<(String,)> = sqlx::query_as(
        &format!(
            "SELECT ip_address FROM assets WHERE id IN ({}) AND user_id = ?",
            body.asset_ids.iter().map(|_| "?").collect::<Vec<_>>().join(",")
        )
    )
    .bind(&claims.sub)
    .fetch_all(pool.get_ref())
    .await
    .unwrap_or_default();

    // Build a simpler query for asset IPs
    let mut valid_ips: Vec<String> = Vec::new();
    for asset_id in &body.asset_ids {
        let ip: Option<(String,)> = sqlx::query_as(
            "SELECT ip_address FROM assets WHERE id = ? AND user_id = ?"
        )
        .bind(asset_id)
        .bind(&claims.sub)
        .fetch_optional(pool.get_ref())
        .await?;

        if let Some((ip_addr,)) = ip {
            valid_ips.push(ip_addr);
        }
    }

    // Validate that provided targets are within the authorized asset IPs
    for target in &body.targets {
        // Allow hostnames that might resolve to the asset IPs, or exact IP matches
        let is_valid = valid_ips.iter().any(|ip| {
            target == ip || target.contains(ip) || ip.contains(target)
        });

        if !is_valid && !valid_ips.is_empty() {
            return Err(ApiError::bad_request(format!(
                "Target '{}' is not associated with any selected asset. Valid IPs: {:?}",
                target, valid_ips
            )));
        }
    }

    let id = Uuid::new_v4().to_string();
    let now = Utc::now().to_rfc3339();
    let targets_json = serde_json::to_string(&body.targets).unwrap_or_default();
    let asset_ids_json = serde_json::to_string(&body.asset_ids).unwrap_or_default();
    let config_json = serde_json::to_string(&body.config).unwrap_or_default();
    let attack_type_json = serde_json::to_string(&body.attack_type).unwrap_or_default();

    sqlx::query(
        r#"
        INSERT INTO exploitation_campaigns (id, user_id, name, attack_type, status, config, targets, customer_id, asset_ids, engagement_id, created_at)
        VALUES (?, ?, ?, ?, 'pending', ?, ?, ?, ?, ?, ?)
        "#,
    )
    .bind(&id)
    .bind(&claims.sub)
    .bind(&body.name)
    .bind(&attack_type_json)
    .bind(&config_json)
    .bind(&targets_json)
    .bind(&customer_id)
    .bind(&asset_ids_json)
    .bind(&body.engagement_id)
    .bind(&now)
    .execute(pool.get_ref())
    .await?;

    // Log the action with customer context
    log_exploitation_action(
        pool.get_ref(),
        &claims.sub,
        Some(&id),
        "campaign_created",
        None,
        serde_json::json!({
            "name": body.name,
            "attack_type": body.attack_type,
            "customer_id": customer_id,
            "customer_name": customer_name,
            "asset_ids": body.asset_ids,
            "targets_count": body.targets.len()
        }),
    )
    .await?;

    Ok(HttpResponse::Created().json(serde_json::json!({
        "id": id,
        "status": "pending",
        "customer_id": customer_id,
        "customer_name": customer_name,
        "asset_count": body.asset_ids.len(),
        "message": "Campaign created. Authorize to start execution."
    })))
}

/// List user's campaigns
pub async fn list_campaigns(
    claims: web::ReqData<Claims>,
    pool: web::Data<SqlitePool>,
) -> Result<HttpResponse, ApiError> {
    let campaigns: Vec<(String, String, String, String, String, i32, i32, String, Option<String>, Option<String>, Option<String>, Option<String>, Option<String>)> = sqlx::query_as(
        r#"
        SELECT ec.id, ec.name, ec.attack_type, ec.status, ec.targets, ec.results_count, ec.successful_count,
               ec.created_at, ec.started_at, ec.completed_at, ec.customer_id, ec.asset_ids, ec.engagement_id
        FROM exploitation_campaigns ec
        WHERE ec.user_id = ?
        ORDER BY ec.created_at DESC
        "#,
    )
    .bind(&claims.sub)
    .fetch_all(pool.get_ref())
    .await?;

    let mut responses: Vec<CampaignResponse> = Vec::new();

    for (id, name, attack_type, status, targets, results_count, successful_count, created_at, started_at, completed_at, customer_id, asset_ids, engagement_id) in campaigns {
        // Get customer name if customer_id exists
        let customer_name = if let Some(ref cid) = customer_id {
            let result: Option<(String,)> = sqlx::query_as(
                "SELECT name FROM customers WHERE id = ?"
            )
            .bind(cid)
            .fetch_optional(pool.get_ref())
            .await
            .ok()
            .flatten();
            result.map(|(name,)| name)
        } else {
            None
        };

        responses.push(CampaignResponse {
            id,
            name,
            attack_type: serde_json::from_str(&attack_type).unwrap_or(AttackType::PasswordSpray),
            status: match status.as_str() {
                "running" => CampaignStatus::Running,
                "completed" => CampaignStatus::Completed,
                "failed" => CampaignStatus::Failed,
                "cancelled" => CampaignStatus::Cancelled,
                _ => CampaignStatus::Pending,
            },
            targets: serde_json::from_str(&targets).unwrap_or_default(),
            results_count,
            successful_count,
            created_at,
            started_at,
            completed_at,
            customer_id,
            customer_name,
            asset_ids: asset_ids.and_then(|a| serde_json::from_str(&a).ok()).unwrap_or_default(),
            engagement_id,
        });
    }

    Ok(HttpResponse::Ok().json(responses))
}

/// Get campaign details
pub async fn get_campaign(
    claims: web::ReqData<Claims>,
    pool: web::Data<SqlitePool>,
    path: web::Path<String>,
) -> Result<HttpResponse, ApiError> {
    let campaign_id = path.into_inner();

    let campaign: Option<(String, String, String, String, String, String, i32, i32, String, Option<String>, Option<String>, Option<String>)> = sqlx::query_as(
        r#"
        SELECT id, name, attack_type, status, config, targets, results_count, successful_count, created_at, started_at, completed_at, error_message
        FROM exploitation_campaigns
        WHERE id = ? AND user_id = ?
        "#,
    )
    .bind(&campaign_id)
    .bind(&claims.sub)
    .fetch_optional(pool.get_ref())
    .await?;

    match campaign {
        Some((id, name, attack_type, status, config, targets, results_count, successful_count, created_at, started_at, completed_at, error_message)) => {
            Ok(HttpResponse::Ok().json(serde_json::json!({
                "id": id,
                "name": name,
                "attack_type": serde_json::from_str::<AttackType>(&attack_type).ok(),
                "status": status,
                "config": serde_json::from_str::<serde_json::Value>(&config).ok(),
                "targets": serde_json::from_str::<Vec<String>>(&targets).unwrap_or_default(),
                "results_count": results_count,
                "successful_count": successful_count,
                "created_at": created_at,
                "started_at": started_at,
                "completed_at": completed_at,
                "error_message": error_message
            })))
        }
        None => Err(ApiError::not_found("Campaign not found")),
    }
}

/// Authorize and start campaign
pub async fn start_campaign(
    claims: web::ReqData<Claims>,
    pool: web::Data<SqlitePool>,
    path: web::Path<String>,
    body: web::Json<AuthorizeCampaignRequest>,
) -> Result<HttpResponse, ApiError> {
    let campaign_id = path.into_inner();

    if !body.authorized {
        return Err(ApiError::bad_request(
            "You must explicitly authorize the campaign execution",
        ));
    }

    // Verify campaign exists and belongs to user
    let campaign: Option<(String, String, String, String, String)> = sqlx::query_as(
        "SELECT id, status, attack_type, config, targets FROM exploitation_campaigns WHERE id = ? AND user_id = ?",
    )
    .bind(&campaign_id)
    .bind(&claims.sub)
    .fetch_optional(pool.get_ref())
    .await?;

    let (id, status, attack_type_json, config_json, targets_json) = campaign
        .ok_or_else(|| ApiError::not_found("Campaign not found"))?;

    if status != "pending" {
        return Err(ApiError::bad_request(format!(
            "Campaign is already {}",
            status
        )));
    }

    // Parse attack type and config
    let attack_type: AttackType = serde_json::from_str(&attack_type_json)
        .map_err(|_| ApiError::internal("Invalid attack type in database"))?;
    let config: serde_json::Value = serde_json::from_str(&config_json)
        .unwrap_or(serde_json::json!({}));
    let targets: Vec<String> = serde_json::from_str(&targets_json)
        .unwrap_or_default();

    // Update status to running
    let now = Utc::now().to_rfc3339();
    sqlx::query("UPDATE exploitation_campaigns SET status = 'running', started_at = ? WHERE id = ?")
        .bind(&now)
        .bind(&id)
        .execute(pool.get_ref())
        .await?;

    // Log authorization
    log_exploitation_action(
        pool.get_ref(),
        &claims.sub,
        Some(&id),
        "campaign_authorized",
        None,
        serde_json::json!({"authorized": true}),
    )
    .await?;

    // Create broadcast channel for real-time updates
    let progress_tx = exploitation_broadcast::create_campaign_channel(id.clone()).await;

    // Clone values for background task
    let campaign_id_clone = id.clone();
    let pool_clone = pool.get_ref().clone();
    let user_id = claims.sub.clone();

    // Spawn background task to run the campaign
    tokio::spawn(async move {
        run_campaign_task(
            campaign_id_clone,
            attack_type,
            config,
            targets,
            pool_clone,
            user_id,
            progress_tx,
        )
        .await;
    });

    Ok(HttpResponse::Accepted().json(serde_json::json!({
        "id": id,
        "status": "running",
        "message": "Campaign authorized and started",
        "websocket_url": format!("/api/ws/exploitation/{}", id)
    })))
}

/// Background task to run exploitation campaign
async fn run_campaign_task(
    campaign_id: String,
    attack_type: AttackType,
    config: serde_json::Value,
    targets: Vec<String>,
    pool: SqlitePool,
    user_id: String,
    progress_tx: tokio::sync::broadcast::Sender<ExploitationProgress>,
) {
    use std::time::Instant;
    let start_time = Instant::now();

    log::info!("Starting campaign execution: {} ({:?})", campaign_id, attack_type);

    // Create engine with progress channel
    let mut engine = ExploitationEngine::with_default_safety();
    engine.set_progress_channel(progress_tx.clone());
    engine.authorize_campaign(&campaign_id).await;

    // Forward progress to broadcast channel
    let campaign_id_for_broadcast = campaign_id.clone();
    let _progress_tx_clone = progress_tx.clone();
    let mut progress_rx = progress_tx.subscribe();
    tokio::spawn(async move {
        while let Ok(progress) = progress_rx.recv().await {
            exploitation_broadcast::send_progress(&campaign_id_for_broadcast, progress).await;
        }
    });

    let result: Result<(usize, usize), String> = match attack_type {
        AttackType::PasswordSpray => {
            run_password_spray_campaign(&engine, &campaign_id, config, targets, &pool).await
        }
        AttackType::Kerberoast => {
            run_kerberoast_campaign(&engine, &campaign_id, config, &pool).await
        }
        AttackType::AsrepRoast => {
            run_asrep_roast_campaign(&engine, &campaign_id, config, &pool).await
        }
        AttackType::SmbRelay => {
            run_smb_relay_campaign(&engine, &campaign_id, config, targets, &pool).await
        }
        AttackType::CredentialDump | AttackType::PrivilegeEscalation |
        AttackType::Persistence | AttackType::LateralMovement => {
            run_post_exploit_campaign(&engine, &campaign_id, attack_type, config, targets, &pool).await
        }
        _ => {
            Err(format!("Attack type {:?} not yet implemented for execution", attack_type))
        }
    };

    let duration_ms = start_time.elapsed().as_millis() as u64;

    // Update campaign status
    let (final_status, error_message, total_results, successful) = match result {
        Ok((total, success)) => ("completed", None, total as i32, success as i32),
        Err(e) => {
            log::error!("Campaign {} failed: {}", campaign_id, e);
            ("failed", Some(e), 0, 0)
        }
    };

    // Send completion message
    let _ = progress_tx.send(ExploitationProgress::CampaignCompleted {
        campaign_id: campaign_id.clone(),
        total_results: total_results as usize,
        successful: successful as usize,
        duration_ms,
    });

    // Update database
    let now = Utc::now().to_rfc3339();
    let _ = sqlx::query(
        "UPDATE exploitation_campaigns SET status = ?, completed_at = ?, results_count = ?, successful_count = ?, error_message = ? WHERE id = ?"
    )
    .bind(final_status)
    .bind(&now)
    .bind(total_results)
    .bind(successful)
    .bind(&error_message)
    .bind(&campaign_id)
    .execute(&pool)
    .await;

    // Log completion
    let _ = log_exploitation_action(
        &pool,
        &user_id,
        Some(&campaign_id),
        if final_status == "completed" { "campaign_completed" } else { "campaign_failed" },
        None,
        serde_json::json!({
            "status": final_status,
            "total_results": total_results,
            "successful": successful,
            "duration_ms": duration_ms,
            "error": error_message
        }),
    )
    .await;

    log::info!(
        "Campaign {} {}: {} results, {} successful, {}ms",
        campaign_id, final_status, total_results, successful, duration_ms
    );
}

/// Run password spray campaign
async fn run_password_spray_campaign(
    engine: &ExploitationEngine,
    campaign_id: &str,
    config: serde_json::Value,
    targets: Vec<String>,
    pool: &SqlitePool,
) -> Result<(usize, usize), String> {
    let spray_config = PasswordSprayConfig {
        targets,
        usernames: config.get("usernames")
            .and_then(|v| serde_json::from_value(v.clone()).ok())
            .unwrap_or_default(),
        passwords: config.get("passwords")
            .and_then(|v| serde_json::from_value(v.clone()).ok())
            .unwrap_or_default(),
        protocol: config.get("protocol")
            .and_then(|v| serde_json::from_value(v.clone()).ok())
            .unwrap_or(SprayProtocol::Smb),
        domain: config.get("domain").and_then(|v| v.as_str()).map(String::from),
        port: config.get("port").and_then(|v| v.as_u64()).map(|p| p as u16),
        use_ssl: config.get("use_ssl").and_then(|v| v.as_bool()).unwrap_or(false),
        delay_between_attempts_ms: config.get("delay_between_attempts_ms")
            .and_then(|v| v.as_u64())
            .unwrap_or(1000),
        delay_between_users_ms: config.get("delay_between_users_ms")
            .and_then(|v| v.as_u64())
            .unwrap_or(0),
        max_attempts_per_user: config.get("max_attempts_per_user")
            .and_then(|v| v.as_u64())
            .map(|v| v as u32)
            .unwrap_or(3),
        stop_on_success: config.get("stop_on_success")
            .and_then(|v| v.as_bool())
            .unwrap_or(false),
        threads: config.get("threads")
            .and_then(|v| v.as_u64())
            .map(|v| v as u32)
            .unwrap_or(5),
    };

    let results = engine.run_password_spray(campaign_id, spray_config)
        .await
        .map_err(|e| e.to_string())?;

    let successful = results.iter().filter(|r| r.success).count();

    // Store results
    for result in &results {
        let result_id = Uuid::new_v4().to_string();
        let now = Utc::now().to_rfc3339();
        let severity = if result.success { Some("critical") } else { None };

        let _ = sqlx::query(
            "INSERT INTO exploitation_results (id, campaign_id, target, result_type, data, severity, created_at) VALUES (?, ?, ?, ?, ?, ?, ?)"
        )
        .bind(&result_id)
        .bind(campaign_id)
        .bind(&result.target)
        .bind(if result.success { "credential_found" } else { "attempt_failed" })
        .bind(serde_json::to_string(&result).unwrap_or_default())
        .bind(severity)
        .bind(&now)
        .execute(pool)
        .await;
    }

    Ok((results.len(), successful))
}

/// Run Kerberoast campaign
async fn run_kerberoast_campaign(
    engine: &ExploitationEngine,
    campaign_id: &str,
    config: serde_json::Value,
    pool: &SqlitePool,
) -> Result<(usize, usize), String> {
    let kerb_config = KerberoastConfig {
        domain_controller: config.get("domain_controller")
            .and_then(|v| v.as_str())
            .unwrap_or("")
            .to_string(),
        domain: config.get("domain")
            .and_then(|v| v.as_str())
            .unwrap_or("")
            .to_string(),
        username: config.get("username")
            .and_then(|v| v.as_str())
            .unwrap_or("")
            .to_string(),
        password: config.get("password")
            .and_then(|v| v.as_str())
            .map(String::from),
        ntlm_hash: config.get("ntlm_hash")
            .and_then(|v| v.as_str())
            .map(String::from),
        target_spns: config.get("target_spns")
            .and_then(|v| serde_json::from_value(v.clone()).ok()),
        output_format: config.get("output_format")
            .and_then(|v| serde_json::from_value(v.clone()).ok())
            .unwrap_or(HashFormat::Hashcat),
        request_rc4: config.get("request_rc4")
            .and_then(|v| v.as_bool())
            .unwrap_or(true),
    };

    let results = engine.run_kerberoast(campaign_id, kerb_config)
        .await
        .map_err(|e| e.to_string())?;

    // Store results
    for result in &results {
        let result_id = Uuid::new_v4().to_string();
        let now = Utc::now().to_rfc3339();

        let _ = sqlx::query(
            "INSERT INTO exploitation_results (id, campaign_id, target, result_type, data, severity, created_at) VALUES (?, ?, ?, ?, ?, ?, ?)"
        )
        .bind(&result_id)
        .bind(campaign_id)
        .bind(&result.spn)
        .bind("hash_extracted")
        .bind(serde_json::to_string(&result).unwrap_or_default())
        .bind("high")
        .bind(&now)
        .execute(pool)
        .await;
    }

    Ok((results.len(), results.len()))
}

/// Run AS-REP Roast campaign
async fn run_asrep_roast_campaign(
    engine: &ExploitationEngine,
    campaign_id: &str,
    config: serde_json::Value,
    pool: &SqlitePool,
) -> Result<(usize, usize), String> {
    let asrep_config = AsrepRoastConfig {
        domain_controller: config.get("domain_controller")
            .and_then(|v| v.as_str())
            .unwrap_or("")
            .to_string(),
        domain: config.get("domain")
            .and_then(|v| v.as_str())
            .unwrap_or("")
            .to_string(),
        usernames: config.get("usernames")
            .and_then(|v| serde_json::from_value(v.clone()).ok())
            .unwrap_or_default(),
        enumerate_users: config.get("enumerate_users")
            .and_then(|v| v.as_bool())
            .unwrap_or(true),
        output_format: config.get("output_format")
            .and_then(|v| serde_json::from_value(v.clone()).ok())
            .unwrap_or(HashFormat::Hashcat),
    };

    let results = engine.run_asrep_roast(campaign_id, asrep_config)
        .await
        .map_err(|e| e.to_string())?;

    // Store results
    for result in &results {
        let result_id = Uuid::new_v4().to_string();
        let now = Utc::now().to_rfc3339();

        let _ = sqlx::query(
            "INSERT INTO exploitation_results (id, campaign_id, target, result_type, data, severity, created_at) VALUES (?, ?, ?, ?, ?, ?, ?)"
        )
        .bind(&result_id)
        .bind(campaign_id)
        .bind(&result.username)
        .bind("hash_extracted")
        .bind(serde_json::to_string(&result).unwrap_or_default())
        .bind("high")
        .bind(&now)
        .execute(pool)
        .await;
    }

    Ok((results.len(), results.len()))
}

/// Run SMB Relay campaign
async fn run_smb_relay_campaign(
    engine: &ExploitationEngine,
    campaign_id: &str,
    config: serde_json::Value,
    targets: Vec<String>,
    pool: &SqlitePool,
) -> Result<(usize, usize), String> {
    // SMB Relay uses post-exploit module infrastructure
    let module = config.get("module")
        .and_then(|v| v.as_str())
        .unwrap_or("ntlm_relay");

    let post_config = PostExploitConfig {
        module: match module {
            "ldap_relay" => PostExploitModule::PassTheHash, // Placeholder
            "http_relay" => PostExploitModule::PassTheHash, // Placeholder
            _ => PostExploitModule::PassTheHash,
        },
        target: targets.first().cloned().unwrap_or_default(),
        credentials: Some(Credentials {
            username: config.get("username").and_then(|v| v.as_str()).unwrap_or("").to_string(),
            password: config.get("password").and_then(|v| v.as_str()).map(String::from),
            ntlm_hash: config.get("ntlm_hash").and_then(|v| v.as_str()).map(String::from),
            domain: config.get("domain").and_then(|v| v.as_str()).map(String::from),
            ssh_key: config.get("ssh_key").and_then(|v| v.as_str()).map(String::from),
        }),
        options: std::collections::HashMap::new(),
    };

    let result = engine.run_post_exploit(campaign_id, post_config)
        .await
        .map_err(|e| e.to_string())?;

    let successful = if result.success { 1 } else { 0 };

    // Store result
    let result_id = Uuid::new_v4().to_string();
    let now = Utc::now().to_rfc3339();
    let _ = sqlx::query(
        "INSERT INTO exploitation_results (id, campaign_id, target, result_type, data, severity, created_at) VALUES (?, ?, ?, ?, ?, ?, ?)"
    )
    .bind(&result_id)
    .bind(campaign_id)
    .bind(&result.target)
    .bind(if result.success { "relay_success" } else { "relay_failed" })
    .bind(serde_json::to_string(&result).unwrap_or_default())
    .bind(if result.success { Some("critical") } else { None::<&str> })
    .bind(&now)
    .execute(pool)
    .await;

    Ok((1, successful))
}

/// Run post-exploitation campaign
async fn run_post_exploit_campaign(
    engine: &ExploitationEngine,
    campaign_id: &str,
    attack_type: AttackType,
    config: serde_json::Value,
    targets: Vec<String>,
    pool: &SqlitePool,
) -> Result<(usize, usize), String> {
    let module = match attack_type {
        AttackType::CredentialDump => {
            match config.get("module").and_then(|v| v.as_str()).unwrap_or("dump_sam") {
                "dump_lsass" => PostExploitModule::DumpLsass,
                "browser_creds" => PostExploitModule::ExtractBrowserCreds,
                "wifi_passwords" => PostExploitModule::ExtractWifiPasswords,
                "keepass" => PostExploitModule::DumpKeePass,
                _ => PostExploitModule::DumpSam,
            }
        }
        AttackType::PrivilegeEscalation => {
            match config.get("module").and_then(|v| v.as_str()).unwrap_or("always_install_elevated") {
                "unquoted_paths" => PostExploitModule::CheckUnquotedPaths,
                "weak_service_perms" => PostExploitModule::CheckWeakServicePerms,
                "se_impersonate" => PostExploitModule::CheckSeImpersonate,
                "sudoers" => PostExploitModule::CheckSudoers,
                "suid_binaries" => PostExploitModule::CheckSuid,
                _ => PostExploitModule::CheckAlwaysInstallElevated,
            }
        }
        AttackType::Persistence => {
            match config.get("module").and_then(|v| v.as_str()).unwrap_or("scheduled_task") {
                "registry_run" => PostExploitModule::AddRegistryRunKey,
                "service" => PostExploitModule::CreateService,
                "cron_job" => PostExploitModule::AddCronJob,
                "ssh_key" => PostExploitModule::AddSshKey,
                _ => PostExploitModule::CreateScheduledTask,
            }
        }
        AttackType::LateralMovement => {
            match config.get("module").and_then(|v| v.as_str()).unwrap_or("pass_the_hash") {
                "pass_the_ticket" => PostExploitModule::PassTheTicket,
                "psexec" => PostExploitModule::PsExec,
                "wmi_exec" => PostExploitModule::WmiExec,
                "ssh_pivot" => PostExploitModule::SshPivot,
                _ => PostExploitModule::PassTheHash,
            }
        }
        _ => return Err("Invalid attack type for post-exploitation".to_string()),
    };

    let mut total = 0;
    let mut successful = 0;

    for target in targets {
        let post_config = PostExploitConfig {
            module: module.clone(),
            target: target.clone(),
            credentials: Some(Credentials {
                username: config.get("username").and_then(|v| v.as_str()).unwrap_or("").to_string(),
                password: config.get("password").and_then(|v| v.as_str()).map(String::from),
                ntlm_hash: config.get("ntlm_hash").and_then(|v| v.as_str()).map(String::from),
                domain: config.get("domain").and_then(|v| v.as_str()).map(String::from),
                ssh_key: None,
            }),
            options: std::collections::HashMap::new(),
        };

        match engine.run_post_exploit(campaign_id, post_config).await {
            Ok(result) => {
                total += 1;
                if result.success {
                    successful += 1;
                }

                // Store result
                let result_id = Uuid::new_v4().to_string();
                let now = Utc::now().to_rfc3339();
                let _ = sqlx::query(
                    "INSERT INTO exploitation_results (id, campaign_id, target, result_type, data, severity, created_at) VALUES (?, ?, ?, ?, ?, ?, ?)"
                )
                .bind(&result_id)
                .bind(campaign_id)
                .bind(&target)
                .bind(if result.success { "module_success" } else { "module_failed" })
                .bind(serde_json::to_string(&result).unwrap_or_default())
                .bind(if result.success { Some("high") } else { None::<&str> })
                .bind(&now)
                .execute(pool)
                .await;
            }
            Err(e) => {
                log::error!("Post-exploit module failed on {}: {}", target, e);
                total += 1;
            }
        }
    }

    Ok((total, successful))
}

/// Stop a running campaign
pub async fn stop_campaign(
    claims: web::ReqData<Claims>,
    pool: web::Data<SqlitePool>,
    engine: web::Data<std::sync::Arc<ExploitationEngine>>,
    path: web::Path<String>,
) -> Result<HttpResponse, ApiError> {
    let campaign_id = path.into_inner();

    // First, try to cancel the running campaign via the engine
    let was_running = engine.cancel_campaign(&campaign_id).await;

    // Update database status regardless
    let result = sqlx::query(
        "UPDATE exploitation_campaigns SET status = 'cancelled', completed_at = ? WHERE id = ? AND user_id = ? AND status = 'running'",
    )
    .bind(Utc::now().to_rfc3339())
    .bind(&campaign_id)
    .bind(&claims.sub)
    .execute(pool.get_ref())
    .await?;

    if result.rows_affected() == 0 && !was_running {
        return Err(ApiError::not_found(
            "Campaign not found or not running",
        ));
    }

    log_exploitation_action(
        pool.get_ref(),
        &claims.sub,
        Some(&campaign_id),
        "campaign_cancelled",
        None,
        serde_json::json!({"was_running_in_memory": was_running}),
    )
    .await?;

    Ok(HttpResponse::Ok().json(serde_json::json!({
        "id": campaign_id,
        "status": "cancelled",
        "message": if was_running { "Campaign stopped" } else { "Campaign marked as cancelled" }
    })))
}

/// Delete a campaign
pub async fn delete_campaign(
    claims: web::ReqData<Claims>,
    pool: web::Data<SqlitePool>,
    path: web::Path<String>,
) -> Result<HttpResponse, ApiError> {
    let campaign_id = path.into_inner();

    let result = sqlx::query(
        "DELETE FROM exploitation_campaigns WHERE id = ? AND user_id = ?",
    )
    .bind(&campaign_id)
    .bind(&claims.sub)
    .execute(pool.get_ref())
    .await?;

    if result.rows_affected() == 0 {
        return Err(ApiError::not_found("Campaign not found"));
    }

    Ok(HttpResponse::Ok().json(serde_json::json!({
        "message": "Campaign deleted"
    })))
}

/// Get campaign results
pub async fn get_campaign_results(
    claims: web::ReqData<Claims>,
    pool: web::Data<SqlitePool>,
    path: web::Path<String>,
) -> Result<HttpResponse, ApiError> {
    let campaign_id = path.into_inner();

    // Verify ownership
    let campaign: Option<(String,)> = sqlx::query_as(
        "SELECT id FROM exploitation_campaigns WHERE id = ? AND user_id = ?",
    )
    .bind(&campaign_id)
    .bind(&claims.sub)
    .fetch_optional(pool.get_ref())
    .await?;

    if campaign.is_none() {
        return Err(ApiError::not_found("Campaign not found"));
    }

    let results: Vec<(String, String, String, String, Option<String>, String)> = sqlx::query_as(
        "SELECT id, target, result_type, data, severity, created_at FROM exploitation_results WHERE campaign_id = ? ORDER BY created_at DESC",
    )
    .bind(&campaign_id)
    .fetch_all(pool.get_ref())
    .await?;

    let response: Vec<serde_json::Value> = results
        .into_iter()
        .map(|(id, target, result_type, data, severity, created_at)| {
            serde_json::json!({
                "id": id,
                "target": target,
                "result_type": result_type,
                "data": serde_json::from_str::<serde_json::Value>(&data).ok(),
                "severity": severity,
                "created_at": created_at
            })
        })
        .collect();

    Ok(HttpResponse::Ok().json(response))
}

#[derive(Debug, Deserialize)]
pub struct ExportRequest {
    /// Export format: json, csv, hashcat, john, markdown, html
    pub format: String,
}

/// Export campaign results
pub async fn export_campaign_results(
    claims: web::ReqData<Claims>,
    pool: web::Data<SqlitePool>,
    path: web::Path<String>,
    body: web::Json<ExportRequest>,
) -> Result<HttpResponse, ApiError> {
    let campaign_id = path.into_inner();

    // Verify ownership and get campaign details
    let campaign: Option<(String, String, String, String, String, Option<String>)> = sqlx::query_as(
        "SELECT id, name, attack_type, status, created_at, completed_at FROM exploitation_campaigns WHERE id = ? AND user_id = ?",
    )
    .bind(&campaign_id)
    .bind(&claims.sub)
    .fetch_optional(pool.get_ref())
    .await?;

    let campaign = campaign.ok_or_else(|| ApiError::not_found("Campaign not found"))?;
    let (_, campaign_name, attack_type, status, created_at, completed_at) = campaign;

    let results: Vec<(String, String, String, String, Option<String>, String)> = sqlx::query_as(
        "SELECT id, target, result_type, data, severity, created_at FROM exploitation_results WHERE campaign_id = ? ORDER BY created_at DESC",
    )
    .bind(&campaign_id)
    .fetch_all(pool.get_ref())
    .await?;

    match body.format.as_str() {
        "csv" => {
            let mut csv_output = String::from("id,target,result_type,severity,created_at,data\n");
            for (id, target, result_type, data, severity, created_at) in results {
                let escaped_data = data.replace('"', "\"\"");
                csv_output.push_str(&format!(
                    "{},{},{},{},{},\"{}\"\n",
                    id,
                    target,
                    result_type,
                    severity.unwrap_or_default(),
                    created_at,
                    escaped_data
                ));
            }
            Ok(HttpResponse::Ok()
                .content_type("text/csv")
                .insert_header(("Content-Disposition", format!("attachment; filename=\"campaign_{}.csv\"", campaign_id)))
                .body(csv_output))
        }

        "hashcat" => {
            // Export hashes in hashcat-compatible format
            let mut hash_output = String::new();
            for (_, _, result_type, data, _, _) in results {
                if result_type.contains("hash") || result_type.contains("kerberoast") || result_type.contains("asrep") {
                    if let Ok(parsed) = serde_json::from_str::<serde_json::Value>(&data) {
                        if let Some(hash) = parsed.get("hash").and_then(|h| h.as_str()) {
                            hash_output.push_str(hash);
                            hash_output.push('\n');
                        }
                        if let Some(hash) = parsed.get("nt_hash").and_then(|h| h.as_str()) {
                            // NTLM hash format for hashcat mode 1000
                            hash_output.push_str(hash);
                            hash_output.push('\n');
                        }
                    }
                }
            }
            Ok(HttpResponse::Ok()
                .content_type("text/plain")
                .insert_header(("Content-Disposition", format!("attachment; filename=\"hashes_{}.txt\"", campaign_id)))
                .body(hash_output))
        }

        "john" => {
            // Export hashes in John the Ripper format
            let mut hash_output = String::new();
            for (_, _target, result_type, data, _, _) in results {
                if result_type.contains("hash") || result_type.contains("kerberoast") || result_type.contains("asrep") {
                    if let Ok(parsed) = serde_json::from_str::<serde_json::Value>(&data) {
                        if let Some(user) = parsed.get("user").or(parsed.get("username")).and_then(|u| u.as_str()) {
                            if let Some(hash) = parsed.get("hash").and_then(|h| h.as_str()) {
                                // user:hash format
                                hash_output.push_str(&format!("{}:{}\n", user, hash));
                            }
                            if let Some(nt_hash) = parsed.get("nt_hash").and_then(|h| h.as_str()) {
                                // NTLM format: user:$NT$hash
                                hash_output.push_str(&format!("{}:$NT${}\n", user, nt_hash));
                            }
                        }
                    }
                }
            }
            Ok(HttpResponse::Ok()
                .content_type("text/plain")
                .insert_header(("Content-Disposition", format!("attachment; filename=\"john_hashes_{}.txt\"", campaign_id)))
                .body(hash_output))
        }

        "markdown" => {
            // Export as Markdown report
            let mut md = format!("# Exploitation Campaign Report\n\n");
            md.push_str(&format!("**Campaign:** {}\n\n", campaign_name));
            md.push_str(&format!("**Attack Type:** {}\n\n", attack_type));
            md.push_str(&format!("**Status:** {}\n\n", status));
            md.push_str(&format!("**Started:** {}\n\n", created_at));
            if let Some(ref completed) = completed_at {
                md.push_str(&format!("**Completed:** {}\n\n", completed));
            }
            md.push_str("---\n\n");
            md.push_str("## Results\n\n");

            // Group results by severity
            let critical: Vec<_> = results.iter().filter(|r| r.4.as_deref() == Some("critical")).collect();
            let high: Vec<_> = results.iter().filter(|r| r.4.as_deref() == Some("high")).collect();
            let medium: Vec<_> = results.iter().filter(|r| r.4.as_deref() == Some("medium")).collect();
            let other: Vec<_> = results.iter().filter(|r| !["critical", "high", "medium"].contains(&r.4.as_deref().unwrap_or(""))).collect();

            if !critical.is_empty() {
                md.push_str("### ðŸ”´ Critical Findings\n\n");
                for (_, target, result_type, data, _, created_at) in critical {
                    md.push_str(&format!("- **{}** on `{}` ({})\n", result_type, target, created_at));
                    if let Ok(parsed) = serde_json::from_str::<serde_json::Value>(&data) {
                        md.push_str(&format!("  ```json\n  {}\n  ```\n", serde_json::to_string_pretty(&parsed).unwrap_or_default()));
                    }
                }
                md.push_str("\n");
            }

            if !high.is_empty() {
                md.push_str("### ðŸŸ  High Severity Findings\n\n");
                for (_, target, result_type, _, _, _) in high {
                    md.push_str(&format!("- **{}** on `{}`\n", result_type, target));
                }
                md.push_str("\n");
            }

            if !medium.is_empty() {
                md.push_str("### ðŸŸ¡ Medium Severity Findings\n\n");
                for (_, target, result_type, _, _, _) in medium {
                    md.push_str(&format!("- **{}** on `{}`\n", result_type, target));
                }
                md.push_str("\n");
            }

            if !other.is_empty() {
                md.push_str("### â„¹ï¸ Other Findings\n\n");
                for (_, target, result_type, _, _, _) in other {
                    md.push_str(&format!("- **{}** on `{}`\n", result_type, target));
                }
                md.push_str("\n");
            }

            md.push_str("---\n\n");
            md.push_str(&format!("*Generated by HeroForge - Total Results: {}*\n", results.len()));

            Ok(HttpResponse::Ok()
                .content_type("text/markdown")
                .insert_header(("Content-Disposition", format!("attachment; filename=\"report_{}.md\"", campaign_id)))
                .body(md))
        }

        "html" => {
            // Export as HTML report
            let mut html = format!(r#"<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Campaign Report: {}</title>
    <style>
        body {{ font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; max-width: 1200px; margin: 0 auto; padding: 20px; background: #1a1a2e; color: #eee; }}
        h1 {{ color: #00d9ff; }}
        h2 {{ color: #00d9ff; border-bottom: 1px solid #333; padding-bottom: 10px; }}
        .meta {{ background: #16213e; padding: 15px; border-radius: 8px; margin-bottom: 20px; }}
        .meta p {{ margin: 5px 0; }}
        .result {{ background: #16213e; padding: 15px; border-radius: 8px; margin: 10px 0; border-left: 4px solid #666; }}
        .result.critical {{ border-left-color: #ff4444; }}
        .result.high {{ border-left-color: #ff8800; }}
        .result.medium {{ border-left-color: #ffcc00; }}
        .result h3 {{ margin: 0 0 10px 0; color: #00d9ff; }}
        .target {{ font-family: monospace; background: #0a0a1a; padding: 2px 6px; border-radius: 4px; }}
        pre {{ background: #0a0a1a; padding: 10px; border-radius: 4px; overflow-x: auto; }}
    </style>
</head>
<body>
    <h1>Exploitation Campaign Report</h1>
    <div class="meta">
        <p><strong>Campaign:</strong> {}</p>
        <p><strong>Attack Type:</strong> {}</p>
        <p><strong>Status:</strong> {}</p>
        <p><strong>Started:</strong> {}</p>
        <p><strong>Completed:</strong> {}</p>
        <p><strong>Total Results:</strong> {}</p>
    </div>
    <h2>Results</h2>
"#, campaign_name, campaign_name, attack_type, status, created_at, completed_at.as_deref().unwrap_or("In Progress"), results.len());

            for (_, target, result_type, data, severity, created_at) in &results {
                let severity_class = severity.as_deref().unwrap_or("info");
                html.push_str(&format!(
                    r#"    <div class="result {}">
        <h3>{}</h3>
        <p>Target: <span class="target">{}</span></p>
        <p>Time: {}</p>
        <pre>{}</pre>
    </div>
"#,
                    severity_class,
                    result_type,
                    target,
                    created_at,
                    serde_json::from_str::<serde_json::Value>(&data)
                        .map(|v| serde_json::to_string_pretty(&v).unwrap_or_default())
                        .unwrap_or_else(|_| data.clone())
                ));
            }

            html.push_str(r#"
    <hr>
    <p style="text-align: center; color: #666;">Generated by HeroForge</p>
</body>
</html>"#);

            Ok(HttpResponse::Ok()
                .content_type("text/html")
                .insert_header(("Content-Disposition", format!("attachment; filename=\"report_{}.html\"", campaign_id)))
                .body(html))
        }

        _ => {
            // Default to JSON
            let response: Vec<serde_json::Value> = results
                .into_iter()
                .map(|(id, target, result_type, data, severity, created_at)| {
                    serde_json::json!({
                        "id": id,
                        "target": target,
                        "result_type": result_type,
                        "data": serde_json::from_str::<serde_json::Value>(&data).ok(),
                        "severity": severity,
                        "created_at": created_at
                    })
                })
                .collect();

            Ok(HttpResponse::Ok()
                .content_type("application/json")
                .insert_header(("Content-Disposition", format!("attachment; filename=\"results_{}.json\"", campaign_id)))
                .json(response))
        }
    }
}

/// Generate shell payload
pub async fn generate_shell(
    claims: web::ReqData<Claims>,
    pool: web::Data<SqlitePool>,
    body: web::Json<GenerateShellRequest>,
) -> Result<HttpResponse, ApiError> {
    let config = ShellConfig {
        shell_type: body.shell_type.clone(),
        platform: body.platform.clone(),
        format: body.format.clone(),
        lhost: body.lhost.clone(),
        lport: body.lport,
        encoding: body.encoding.clone(),
        obfuscation_level: body.obfuscation_level,
        staged: body.staged,
        xor_key: body.xor_key.clone(),
        architecture: body.architecture.clone(),
        msf_encoder: body.msf_encoder.clone(),
        encoder_iterations: body.encoder_iterations,
        bad_chars: body.bad_chars.clone(),
        exit_func: body.exit_func.clone(),
    };

    // Create engine and generate shell
    let engine = ExploitationEngine::with_default_safety();
    let result = engine.generate_shell(config).await.map_err(|e| {
        ApiError::internal(format!("Failed to generate shell: {}", e))
    })?;

    // Save to database
    let config_json = serde_json::to_string(&body.0).unwrap_or_default();
    let shell_type_json = serde_json::to_string(&body.shell_type).unwrap_or_default();
    let platform_json = serde_json::to_string(&body.platform).unwrap_or_default();
    let format_json = serde_json::to_string(&body.format).unwrap_or_default();
    sqlx::query(
        r#"
        INSERT INTO generated_payloads (id, user_id, payload_type, platform, format, config, payload_hash, created_at)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?)
        "#,
    )
    .bind(&result.id)
    .bind(&claims.sub)
    .bind(&shell_type_json)
    .bind(&platform_json)
    .bind(&format_json)
    .bind(&config_json)
    .bind(&result.payload_hash)
    .bind(result.created_at.to_rfc3339())
    .execute(pool.get_ref())
    .await?;

    // Log the action
    log_exploitation_action(
        pool.get_ref(),
        &claims.sub,
        None,
        "shell_generated",
        None,
        serde_json::json!({
            "payload_id": result.id,
            "format": result.format,
            "platform": result.platform
        }),
    )
    .await?;

    Ok(HttpResponse::Ok().json(serde_json::json!({
        "id": result.id,
        "payload": result.payload,
        "payload_hash": result.payload_hash,
        "format": result.format,
        "platform": result.platform,
        "listener_command": result.listener_command,
        "one_liner": result.one_liner,
        "created_at": result.created_at
    })))
}

/// List shell templates
pub async fn list_shell_templates() -> Result<HttpResponse, ApiError> {
    let templates = vec![
        ShellTemplateInfo {
            format: ShellFormat::Bash,
            platform: Platform::Linux,
            name: "Bash Reverse Shell".to_string(),
            description: "Simple bash reverse shell using /dev/tcp".to_string(),
            requires_msfvenom: false,
        },
        ShellTemplateInfo {
            format: ShellFormat::PowerShell,
            platform: Platform::Windows,
            name: "PowerShell Reverse Shell".to_string(),
            description: "PowerShell TCP reverse shell with optional obfuscation".to_string(),
            requires_msfvenom: false,
        },
        ShellTemplateInfo {
            format: ShellFormat::Python,
            platform: Platform::Universal,
            name: "Python Reverse Shell".to_string(),
            description: "Cross-platform Python reverse shell".to_string(),
            requires_msfvenom: false,
        },
        ShellTemplateInfo {
            format: ShellFormat::Php,
            platform: Platform::Universal,
            name: "PHP Reverse Shell".to_string(),
            description: "PHP reverse shell for web exploitation".to_string(),
            requires_msfvenom: false,
        },
        ShellTemplateInfo {
            format: ShellFormat::Php,
            platform: Platform::Universal,
            name: "PHP Web Shell".to_string(),
            description: "Simple PHP web shell for command execution".to_string(),
            requires_msfvenom: false,
        },
        ShellTemplateInfo {
            format: ShellFormat::MeterpreterExe,
            platform: Platform::Windows,
            name: "Meterpreter EXE".to_string(),
            description: "Windows Meterpreter reverse TCP executable".to_string(),
            requires_msfvenom: true,
        },
        ShellTemplateInfo {
            format: ShellFormat::MeterpreterElf,
            platform: Platform::Linux,
            name: "Meterpreter ELF".to_string(),
            description: "Linux Meterpreter reverse TCP executable".to_string(),
            requires_msfvenom: true,
        },
        ShellTemplateInfo {
            format: ShellFormat::MeterpreterPowerShell,
            platform: Platform::Windows,
            name: "Meterpreter PowerShell".to_string(),
            description: "Windows Meterpreter PowerShell payload".to_string(),
            requires_msfvenom: true,
        },
    ];

    Ok(HttpResponse::Ok().json(templates))
}

/// List post-exploitation modules
pub async fn list_post_exploit_modules() -> Result<HttpResponse, ApiError> {
    let modules = get_all_post_exploit_modules();
    Ok(HttpResponse::Ok().json(modules))
}

/// Get all available post-exploitation modules
fn get_all_post_exploit_modules() -> Vec<PostExploitModuleInfo> {
    vec![
        // Credential Harvesting
        PostExploitModuleInfo {
            module: PostExploitModule::DumpSam,
            name: "Dump SAM".to_string(),
            description: PostExploitModule::DumpSam.description().to_string(),
            category: PostExploitCategory::CredentialHarvesting,
            platforms: PostExploitModule::DumpSam.supported_platforms(),
        },
        PostExploitModuleInfo {
            module: PostExploitModule::DumpLsass,
            name: "Dump LSASS".to_string(),
            description: PostExploitModule::DumpLsass.description().to_string(),
            category: PostExploitCategory::CredentialHarvesting,
            platforms: PostExploitModule::DumpLsass.supported_platforms(),
        },
        PostExploitModuleInfo {
            module: PostExploitModule::ExtractBrowserCreds,
            name: "Extract Browser Credentials".to_string(),
            description: PostExploitModule::ExtractBrowserCreds.description().to_string(),
            category: PostExploitCategory::CredentialHarvesting,
            platforms: PostExploitModule::ExtractBrowserCreds.supported_platforms(),
        },
        PostExploitModuleInfo {
            module: PostExploitModule::ExtractWifiPasswords,
            name: "Extract WiFi Passwords".to_string(),
            description: PostExploitModule::ExtractWifiPasswords.description().to_string(),
            category: PostExploitCategory::CredentialHarvesting,
            platforms: PostExploitModule::ExtractWifiPasswords.supported_platforms(),
        },
        PostExploitModuleInfo {
            module: PostExploitModule::ExtractSshKeys,
            name: "Extract SSH Keys".to_string(),
            description: PostExploitModule::ExtractSshKeys.description().to_string(),
            category: PostExploitCategory::CredentialHarvesting,
            platforms: PostExploitModule::ExtractSshKeys.supported_platforms(),
        },
        PostExploitModuleInfo {
            module: PostExploitModule::DumpCredMan,
            name: "Dump Credential Manager".to_string(),
            description: PostExploitModule::DumpCredMan.description().to_string(),
            category: PostExploitCategory::CredentialHarvesting,
            platforms: PostExploitModule::DumpCredMan.supported_platforms(),
        },
        // Privilege Escalation
        PostExploitModuleInfo {
            module: PostExploitModule::CheckAlwaysInstallElevated,
            name: "Check AlwaysInstallElevated".to_string(),
            description: PostExploitModule::CheckAlwaysInstallElevated.description().to_string(),
            category: PostExploitCategory::PrivilegeEscalation,
            platforms: PostExploitModule::CheckAlwaysInstallElevated.supported_platforms(),
        },
        PostExploitModuleInfo {
            module: PostExploitModule::CheckUnquotedPaths,
            name: "Check Unquoted Paths".to_string(),
            description: PostExploitModule::CheckUnquotedPaths.description().to_string(),
            category: PostExploitCategory::PrivilegeEscalation,
            platforms: PostExploitModule::CheckUnquotedPaths.supported_platforms(),
        },
        PostExploitModuleInfo {
            module: PostExploitModule::CheckWeakServicePerms,
            name: "Check Weak Service Permissions".to_string(),
            description: PostExploitModule::CheckWeakServicePerms.description().to_string(),
            category: PostExploitCategory::PrivilegeEscalation,
            platforms: PostExploitModule::CheckWeakServicePerms.supported_platforms(),
        },
        PostExploitModuleInfo {
            module: PostExploitModule::CheckSeImpersonate,
            name: "Check SeImpersonate".to_string(),
            description: PostExploitModule::CheckSeImpersonate.description().to_string(),
            category: PostExploitCategory::PrivilegeEscalation,
            platforms: PostExploitModule::CheckSeImpersonate.supported_platforms(),
        },
        PostExploitModuleInfo {
            module: PostExploitModule::CheckSuid,
            name: "Check SUID Binaries".to_string(),
            description: PostExploitModule::CheckSuid.description().to_string(),
            category: PostExploitCategory::PrivilegeEscalation,
            platforms: PostExploitModule::CheckSuid.supported_platforms(),
        },
        PostExploitModuleInfo {
            module: PostExploitModule::CheckSudoers,
            name: "Check Sudoers".to_string(),
            description: PostExploitModule::CheckSudoers.description().to_string(),
            category: PostExploitCategory::PrivilegeEscalation,
            platforms: PostExploitModule::CheckSudoers.supported_platforms(),
        },
        PostExploitModuleInfo {
            module: PostExploitModule::CheckCapabilities,
            name: "Check Linux Capabilities".to_string(),
            description: PostExploitModule::CheckCapabilities.description().to_string(),
            category: PostExploitCategory::PrivilegeEscalation,
            platforms: PostExploitModule::CheckCapabilities.supported_platforms(),
        },
        // Persistence
        PostExploitModuleInfo {
            module: PostExploitModule::CreateScheduledTask,
            name: "Create Scheduled Task".to_string(),
            description: PostExploitModule::CreateScheduledTask.description().to_string(),
            category: PostExploitCategory::Persistence,
            platforms: PostExploitModule::CreateScheduledTask.supported_platforms(),
        },
        PostExploitModuleInfo {
            module: PostExploitModule::AddRegistryRunKey,
            name: "Add Registry Run Key".to_string(),
            description: PostExploitModule::AddRegistryRunKey.description().to_string(),
            category: PostExploitCategory::Persistence,
            platforms: PostExploitModule::AddRegistryRunKey.supported_platforms(),
        },
        PostExploitModuleInfo {
            module: PostExploitModule::AddCronJob,
            name: "Add Cron Job".to_string(),
            description: PostExploitModule::AddCronJob.description().to_string(),
            category: PostExploitCategory::Persistence,
            platforms: PostExploitModule::AddCronJob.supported_platforms(),
        },
        PostExploitModuleInfo {
            module: PostExploitModule::AddSshKey,
            name: "Add SSH Key".to_string(),
            description: PostExploitModule::AddSshKey.description().to_string(),
            category: PostExploitCategory::Persistence,
            platforms: PostExploitModule::AddSshKey.supported_platforms(),
        },
        // Lateral Movement
        PostExploitModuleInfo {
            module: PostExploitModule::PassTheHash,
            name: "Pass-the-Hash".to_string(),
            description: PostExploitModule::PassTheHash.description().to_string(),
            category: PostExploitCategory::LateralMovement,
            platforms: PostExploitModule::PassTheHash.supported_platforms(),
        },
        PostExploitModuleInfo {
            module: PostExploitModule::PassTheTicket,
            name: "Pass-the-Ticket".to_string(),
            description: PostExploitModule::PassTheTicket.description().to_string(),
            category: PostExploitCategory::LateralMovement,
            platforms: PostExploitModule::PassTheTicket.supported_platforms(),
        },
        PostExploitModuleInfo {
            module: PostExploitModule::PsExec,
            name: "PsExec".to_string(),
            description: PostExploitModule::PsExec.description().to_string(),
            category: PostExploitCategory::LateralMovement,
            platforms: PostExploitModule::PsExec.supported_platforms(),
        },
        PostExploitModuleInfo {
            module: PostExploitModule::WmiExec,
            name: "WMI Exec".to_string(),
            description: PostExploitModule::WmiExec.description().to_string(),
            category: PostExploitCategory::LateralMovement,
            platforms: PostExploitModule::WmiExec.supported_platforms(),
        },
        PostExploitModuleInfo {
            module: PostExploitModule::SshPivot,
            name: "SSH Pivot".to_string(),
            description: PostExploitModule::SshPivot.description().to_string(),
            category: PostExploitCategory::LateralMovement,
            platforms: PostExploitModule::SshPivot.supported_platforms(),
        },
        // Discovery
        PostExploitModuleInfo {
            module: PostExploitModule::NetworkShares,
            name: "Network Shares".to_string(),
            description: PostExploitModule::NetworkShares.description().to_string(),
            category: PostExploitCategory::Discovery,
            platforms: PostExploitModule::NetworkShares.supported_platforms(),
        },
        PostExploitModuleInfo {
            module: PostExploitModule::LocalUsers,
            name: "Local Users".to_string(),
            description: PostExploitModule::LocalUsers.description().to_string(),
            category: PostExploitCategory::Discovery,
            platforms: PostExploitModule::LocalUsers.supported_platforms(),
        },
        PostExploitModuleInfo {
            module: PostExploitModule::InstalledSoftware,
            name: "Installed Software".to_string(),
            description: PostExploitModule::InstalledSoftware.description().to_string(),
            category: PostExploitCategory::Discovery,
            platforms: PostExploitModule::InstalledSoftware.supported_platforms(),
        },
    ]
}

#[derive(Debug, Deserialize)]
pub struct RelevantModulesQuery {
    /// Asset IDs to check relevance for
    pub asset_ids: String,
}

/// Extended module info with relevance data
#[derive(Debug, Serialize)]
pub struct RelevantModuleInfo {
    pub module: PostExploitModule,
    pub name: String,
    pub description: String,
    pub category: PostExploitCategory,
    pub platforms: Vec<Platform>,
    /// Whether this module is relevant for the selected assets
    pub is_relevant: bool,
    /// Why this module is relevant or not
    pub relevance_reason: String,
    /// Services that make this module relevant
    pub relevant_services: Vec<String>,
}

/// Get relevant exploitation modules for selected assets
/// SAFEGUARD: Only shows modules applicable to the target OS and services
pub async fn get_relevant_modules(
    claims: web::ReqData<Claims>,
    pool: web::Data<SqlitePool>,
    query: web::Query<RelevantModulesQuery>,
) -> Result<HttpResponse, ApiError> {
    let asset_ids: Vec<String> = serde_json::from_str(&query.asset_ids)
        .unwrap_or_else(|_| query.asset_ids.split(',').map(|s| s.trim().to_string()).collect());

    if asset_ids.is_empty() {
        return Err(ApiError::bad_request("No assets selected"));
    }

    // Get asset information including OS and services
    let mut detected_os: Vec<String> = Vec::new();
    let mut detected_services: Vec<String> = Vec::new();

    for asset_id in &asset_ids {
        // Get asset OS
        let asset: Option<(Option<String>, Option<String>)> = sqlx::query_as(
            "SELECT os_family, os_version FROM assets WHERE id = ? AND user_id = ?"
        )
        .bind(asset_id)
        .bind(&claims.sub)
        .fetch_optional(pool.get_ref())
        .await?;

        if let Some((os_family, _os_version)) = asset {
            if let Some(os) = os_family {
                detected_os.push(os.to_lowercase());
            }
        }

        // Get asset services/ports
        let ports: Vec<(Option<String>,)> = sqlx::query_as(
            "SELECT service_name FROM asset_ports WHERE asset_id = ?"
        )
        .bind(asset_id)
        .fetch_all(pool.get_ref())
        .await
        .unwrap_or_default();

        for (service,) in ports {
            if let Some(svc) = service {
                detected_services.push(svc.to_lowercase());
            }
        }
    }

    // Determine platform from OS
    let has_windows = detected_os.iter().any(|os| os.contains("windows"));
    let has_linux = detected_os.iter().any(|os| os.contains("linux") || os.contains("unix") || os.contains("debian") || os.contains("ubuntu") || os.contains("centos") || os.contains("rhel"));
    let has_macos = detected_os.iter().any(|os| os.contains("mac") || os.contains("darwin") || os.contains("osx"));

    // Service-based attack relevance
    let has_smb = detected_services.iter().any(|s| s.contains("smb") || s.contains("microsoft-ds") || s.contains("445"));
    let has_ssh = detected_services.iter().any(|s| s.contains("ssh") || s.contains("22"));
    let has_rdp = detected_services.iter().any(|s| s.contains("rdp") || s.contains("remote desktop") || s.contains("3389"));
    let has_ldap = detected_services.iter().any(|s| s.contains("ldap") || s.contains("389") || s.contains("636"));
    let has_kerberos = detected_services.iter().any(|s| s.contains("kerberos") || s.contains("88"));
    let _has_winrm = detected_services.iter().any(|s| s.contains("winrm") || s.contains("wsman") || s.contains("5985") || s.contains("5986"));
    let _has_http = detected_services.iter().any(|s| s.contains("http") || s.contains("80") || s.contains("443") || s.contains("web"));

    let all_modules = get_all_post_exploit_modules();
    let mut relevant_modules: Vec<RelevantModuleInfo> = Vec::new();

    for module_info in all_modules {
        let mut is_relevant = false;
        let mut relevance_reason;
        let mut relevant_services: Vec<String> = Vec::new();

        // Check platform relevance
        let platform_matches = module_info.platforms.iter().any(|p| match p {
            Platform::Windows => has_windows,
            Platform::Linux => has_linux,
            Platform::MacOS => has_macos,
            Platform::Universal => true,
        });

        if !platform_matches {
            relevance_reason = format!(
                "Requires {:?} but target OS is {:?}",
                module_info.platforms,
                detected_os
            );
        } else {
            is_relevant = true;
            relevance_reason = "Compatible with target OS".to_string();

            // Additional service-based relevance for specific modules
            match module_info.module {
                PostExploitModule::PassTheHash | PostExploitModule::PsExec | PostExploitModule::WmiExec => {
                    if has_smb {
                        relevant_services.push("SMB".to_string());
                        relevance_reason = "SMB service detected - ideal for lateral movement".to_string();
                    }
                }
                PostExploitModule::PassTheTicket | PostExploitModule::DumpLsass => {
                    if has_kerberos || has_ldap {
                        relevant_services.push("Kerberos/LDAP".to_string());
                        relevance_reason = "Kerberos/LDAP detected - Active Directory environment".to_string();
                    }
                }
                PostExploitModule::SshPivot | PostExploitModule::AddSshKey | PostExploitModule::ExtractSshKeys => {
                    if has_ssh {
                        relevant_services.push("SSH".to_string());
                        relevance_reason = "SSH service detected".to_string();
                    }
                }
                PostExploitModule::RdpHijack => {
                    if has_rdp {
                        relevant_services.push("RDP".to_string());
                        relevance_reason = "RDP service detected".to_string();
                    }
                }
                _ => {}
            }
        }

        relevant_modules.push(RelevantModuleInfo {
            module: module_info.module,
            name: module_info.name,
            description: module_info.description,
            category: module_info.category,
            platforms: module_info.platforms,
            is_relevant,
            relevance_reason,
            relevant_services,
        });
    }

    // Sort: relevant first, then by category
    relevant_modules.sort_by(|a, b| {
        b.is_relevant.cmp(&a.is_relevant)
            .then_with(|| format!("{:?}", a.category).cmp(&format!("{:?}", b.category)))
    });

    Ok(HttpResponse::Ok().json(serde_json::json!({
        "modules": relevant_modules,
        "detected_os": detected_os,
        "detected_services": detected_services.into_iter().collect::<std::collections::HashSet<_>>().into_iter().collect::<Vec<_>>(),
        "summary": {
            "has_windows": has_windows,
            "has_linux": has_linux,
            "has_macos": has_macos,
            "has_smb": has_smb,
            "has_ssh": has_ssh,
            "has_rdp": has_rdp,
            "has_kerberos": has_kerberos,
            "has_ldap": has_ldap
        }
    })))
}

/// Get relevant attack types for selected assets
/// SAFEGUARD: Only shows attack types applicable to the target
pub async fn get_relevant_attacks(
    claims: web::ReqData<Claims>,
    pool: web::Data<SqlitePool>,
    query: web::Query<RelevantModulesQuery>,
) -> Result<HttpResponse, ApiError> {
    let asset_ids: Vec<String> = serde_json::from_str(&query.asset_ids)
        .unwrap_or_else(|_| query.asset_ids.split(',').map(|s| s.trim().to_string()).collect());

    if asset_ids.is_empty() {
        return Err(ApiError::bad_request("No assets selected"));
    }

    // Get asset information
    let mut detected_os: Vec<String> = Vec::new();
    let mut detected_services: Vec<String> = Vec::new();

    for asset_id in &asset_ids {
        let asset: Option<(Option<String>,)> = sqlx::query_as(
            "SELECT os_family FROM assets WHERE id = ? AND user_id = ?"
        )
        .bind(asset_id)
        .bind(&claims.sub)
        .fetch_optional(pool.get_ref())
        .await?;

        if let Some((os_family,)) = asset {
            if let Some(os) = os_family {
                detected_os.push(os.to_lowercase());
            }
        }

        let ports: Vec<(Option<String>,)> = sqlx::query_as(
            "SELECT service_name FROM asset_ports WHERE asset_id = ?"
        )
        .bind(asset_id)
        .fetch_all(pool.get_ref())
        .await
        .unwrap_or_default();

        for (service,) in ports {
            if let Some(svc) = service {
                detected_services.push(svc.to_lowercase());
            }
        }
    }

    // Determine relevance
    let has_windows = detected_os.iter().any(|os| os.contains("windows"));
    let has_linux = detected_os.iter().any(|os| os.contains("linux") || os.contains("unix"));
    let has_smb = detected_services.iter().any(|s| s.contains("smb") || s.contains("445"));
    let has_ssh = detected_services.iter().any(|s| s.contains("ssh") || s.contains("22"));
    let has_rdp = detected_services.iter().any(|s| s.contains("rdp") || s.contains("3389"));
    let has_ldap = detected_services.iter().any(|s| s.contains("ldap") || s.contains("389"));
    let has_kerberos = detected_services.iter().any(|s| s.contains("kerberos") || s.contains("88"));
    let has_http = detected_services.iter().any(|s| s.contains("http"));

    #[derive(Serialize)]
    struct AttackRelevance {
        attack_type: AttackType,
        name: String,
        description: String,
        is_relevant: bool,
        relevance_reason: String,
        required_services: Vec<String>,
    }

    let mut attacks = vec![
        AttackRelevance {
            attack_type: AttackType::PasswordSpray,
            name: "Password Spray".to_string(),
            description: "Test common passwords against multiple accounts".to_string(),
            is_relevant: has_smb || has_ssh || has_rdp || has_ldap || has_http,
            relevance_reason: if has_smb || has_ssh || has_rdp || has_ldap {
                "Authentication services detected".to_string()
            } else {
                "No authentication services detected".to_string()
            },
            required_services: vec!["SMB".to_string(), "SSH".to_string(), "RDP".to_string(), "LDAP".to_string()],
        },
        AttackRelevance {
            attack_type: AttackType::Kerberoast,
            name: "Kerberoasting".to_string(),
            description: "Extract TGS tickets for offline cracking".to_string(),
            is_relevant: has_kerberos && has_windows,
            relevance_reason: if has_kerberos && has_windows {
                "Windows with Kerberos detected - AD environment".to_string()
            } else {
                "Requires Windows Active Directory with Kerberos".to_string()
            },
            required_services: vec!["Kerberos (88)".to_string()],
        },
        AttackRelevance {
            attack_type: AttackType::AsrepRoast,
            name: "AS-REP Roasting".to_string(),
            description: "Target accounts without Kerberos pre-authentication".to_string(),
            is_relevant: has_kerberos && has_windows,
            relevance_reason: if has_kerberos && has_windows {
                "Windows with Kerberos detected - AD environment".to_string()
            } else {
                "Requires Windows Active Directory".to_string()
            },
            required_services: vec!["Kerberos (88)".to_string()],
        },
        AttackRelevance {
            attack_type: AttackType::SmbRelay,
            name: "SMB Relay".to_string(),
            description: "Relay NTLM authentication to other targets".to_string(),
            is_relevant: has_smb && has_windows,
            relevance_reason: if has_smb && has_windows {
                "SMB service on Windows detected".to_string()
            } else {
                "Requires Windows with SMB".to_string()
            },
            required_services: vec!["SMB (445)".to_string()],
        },
        AttackRelevance {
            attack_type: AttackType::CredentialDump,
            name: "Credential Dump".to_string(),
            description: "Extract credentials from memory or registry".to_string(),
            is_relevant: has_windows || has_linux,
            relevance_reason: "Compatible with target OS".to_string(),
            required_services: vec![],
        },
        AttackRelevance {
            attack_type: AttackType::PrivilegeEscalation,
            name: "Privilege Escalation".to_string(),
            description: "Check for privilege escalation vectors".to_string(),
            is_relevant: has_windows || has_linux,
            relevance_reason: "Compatible with target OS".to_string(),
            required_services: vec![],
        },
        AttackRelevance {
            attack_type: AttackType::Persistence,
            name: "Persistence".to_string(),
            description: "Establish persistent access mechanisms".to_string(),
            is_relevant: has_windows || has_linux,
            relevance_reason: "Compatible with target OS".to_string(),
            required_services: vec![],
        },
        AttackRelevance {
            attack_type: AttackType::LateralMovement,
            name: "Lateral Movement".to_string(),
            description: "Move to other systems in the network".to_string(),
            is_relevant: has_smb || has_ssh,
            relevance_reason: if has_smb || has_ssh {
                "Remote access services detected".to_string()
            } else {
                "Requires SMB or SSH".to_string()
            },
            required_services: vec!["SMB (445)".to_string(), "SSH (22)".to_string()],
        },
    ];

    // Sort: relevant first
    attacks.sort_by(|a, b| b.is_relevant.cmp(&a.is_relevant));

    Ok(HttpResponse::Ok().json(serde_json::json!({
        "attacks": attacks,
        "detected_os": detected_os,
        "detected_services": detected_services.into_iter().collect::<std::collections::HashSet<_>>().into_iter().collect::<Vec<_>>()
    })))
}

/// List user's generated payloads
pub async fn list_payloads(
    claims: web::ReqData<Claims>,
    pool: web::Data<SqlitePool>,
) -> Result<HttpResponse, ApiError> {
    let payloads: Vec<(String, String, String, String, String, String)> = sqlx::query_as(
        "SELECT id, payload_type, platform, format, payload_hash, created_at FROM generated_payloads WHERE user_id = ? ORDER BY created_at DESC LIMIT 50",
    )
    .bind(&claims.sub)
    .fetch_all(pool.get_ref())
    .await?;

    let response: Vec<serde_json::Value> = payloads
        .into_iter()
        .map(|(id, payload_type, platform, format, hash, created_at)| {
            serde_json::json!({
                "id": id,
                "payload_type": payload_type,
                "platform": platform,
                "format": format,
                "payload_hash": hash,
                "created_at": created_at
            })
        })
        .collect();

    Ok(HttpResponse::Ok().json(response))
}

// ============================================================================
// Helper Functions
// ============================================================================

async fn log_exploitation_action(
    pool: &SqlitePool,
    user_id: &str,
    campaign_id: Option<&str>,
    action: &str,
    target: Option<&str>,
    details: serde_json::Value,
) -> Result<(), ApiError> {
    let id = Uuid::new_v4().to_string();
    let now = Utc::now().to_rfc3339();

    sqlx::query(
        r#"
        INSERT INTO exploitation_audit_logs (id, user_id, campaign_id, action, target, details, created_at)
        VALUES (?, ?, ?, ?, ?, ?, ?)
        "#,
    )
    .bind(&id)
    .bind(user_id)
    .bind(campaign_id)
    .bind(action)
    .bind(target)
    .bind(details.to_string())
    .bind(&now)
    .execute(pool)
    .await?;

    Ok(())
}

// ============================================================================
// Route Configuration
// ============================================================================

pub fn configure(cfg: &mut web::ServiceConfig) {
    cfg.service(
        web::scope("/exploitation")
            .route("/status", web::get().to(get_status))
            .route("/campaigns", web::post().to(create_campaign))
            .route("/campaigns", web::get().to(list_campaigns))
            .route("/campaigns/{id}", web::get().to(get_campaign))
            .route("/campaigns/{id}/start", web::post().to(start_campaign))
            .route("/campaigns/{id}/stop", web::post().to(stop_campaign))
            .route("/campaigns/{id}", web::delete().to(delete_campaign))
            .route("/campaigns/{id}/results", web::get().to(get_campaign_results))
            .route("/campaigns/{id}/export", web::post().to(export_campaign_results))
            .route("/shells/generate", web::post().to(generate_shell))
            .route("/shells/templates", web::get().to(list_shell_templates))
            .route("/shells", web::get().to(list_payloads))
            .route("/modules", web::get().to(list_post_exploit_modules))
            // Relevance filtering endpoints (SAFEGUARD)
            .route("/modules/relevant", web::get().to(get_relevant_modules))
            .route("/attacks/relevant", web::get().to(get_relevant_attacks)),
    );
}
