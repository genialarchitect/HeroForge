//! Exploit Research API endpoints
//!
//! Provides REST API access to exploit database integration, PoC repository,
//! and research workspace functionality.
//!
//! ## Endpoints
//!
//! ### Exploit Search & Database
//! - GET /api/exploit-research/exploits - Search exploits across all sources
//! - GET /api/exploit-research/exploits/{id} - Get exploit details
//! - GET /api/exploit-research/exploits/cve/{cve_id} - Get exploits for a CVE
//! - GET /api/exploit-research/sync-status - Get sync status for all sources
//! - POST /api/exploit-research/sync/{source} - Trigger sync for a source
//!
//! ### CVE Mapping
//! - GET /api/exploit-research/cve-mapping/{cve_id} - Get CVE to exploit mapping
//! - POST /api/exploit-research/cve-mapping/batch - Get mappings for multiple CVEs
//!
//! ### PoC Repository
//! - GET /api/exploit-research/pocs - List PoCs
//! - POST /api/exploit-research/pocs - Create PoC
//! - GET /api/exploit-research/pocs/{id} - Get PoC details
//! - PUT /api/exploit-research/pocs/{id} - Update PoC
//! - DELETE /api/exploit-research/pocs/{id} - Delete PoC
//! - GET /api/exploit-research/pocs/{id}/code - Get PoC code
//! - POST /api/exploit-research/pocs/{id}/test - Add test result
//!
//! ### Research Notes & Workspaces
//! - GET /api/exploit-research/notes - List research notes
//! - POST /api/exploit-research/notes - Create note
//! - GET /api/exploit-research/notes/{id} - Get note
//! - PUT /api/exploit-research/notes/{id} - Update note
//! - DELETE /api/exploit-research/notes/{id} - Delete note
//! - GET /api/exploit-research/workspaces - List workspaces
//! - POST /api/exploit-research/workspaces - Create workspace
//! - GET /api/exploit-research/workspaces/{id} - Get workspace
//! - PUT /api/exploit-research/workspaces/{id} - Update workspace
//! - DELETE /api/exploit-research/workspaces/{id} - Delete workspace
//! - GET /api/exploit-research/workspaces/{id}/export - Export workspace as markdown
//!
//! ### Favorites & History
//! - GET /api/exploit-research/favorites - Get user's favorites
//! - POST /api/exploit-research/favorites - Add to favorites
//! - DELETE /api/exploit-research/favorites/{exploit_id} - Remove from favorites
//! - GET /api/exploit-research/history - Get search history

use actix_web::{web, HttpResponse, Result};
use chrono::Utc;
use log::{debug, error, info};
use serde::{Deserialize, Serialize};
use sqlx::SqlitePool;
use std::sync::Arc;
use tokio::sync::RwLock;

use crate::exploit_research::{
    CveMappingEngine, ExploitDbClient, MetasploitClient, PacketStormClient,
    PocRepository, ResearchNotesManager, ExploitSearchQuery, Exploit,
    CveExploitMapping, ExploitSource, ExploitPlatform, ExploitType, ExploitLanguage,
    PocEntry, PocStatus, CreatePocRequest, UpdatePocRequest, PocTestResults,
    ResearchNote, CveResearchWorkspace, CreateResearchNoteRequest, UpdateResearchNoteRequest,
    ExternalReference, ReferenceType, NoteVisibility, WorkspaceStatus,
};
use crate::exploit_research::research_notes::{NoteFilter, WorkspaceFilter, WorkspaceUpdate};
use crate::exploit_research::poc_repository::PocFilter;
use crate::web::auth::Claims;

/// Shared state for exploit research
pub struct ExploitResearchState {
    pub cve_engine: RwLock<CveMappingEngine>,
    pub poc_repo: RwLock<PocRepository>,
    pub notes_manager: RwLock<ResearchNotesManager>,
}

impl ExploitResearchState {
    pub fn new() -> anyhow::Result<Self> {
        Ok(Self {
            cve_engine: RwLock::new(CveMappingEngine::new()?),
            poc_repo: RwLock::new(PocRepository::new(None)?),
            notes_manager: RwLock::new(ResearchNotesManager::new()),
        })
    }
}

// ==================== Request/Response Types ====================

/// Search request for exploits
#[derive(Debug, Deserialize)]
pub struct ExploitSearchRequest {
    pub query: Option<String>,
    pub cve_id: Option<String>,
    pub platform: Option<String>,
    pub exploit_type: Option<String>,
    pub source: Option<String>,
    pub verified_only: Option<bool>,
    pub has_code: Option<bool>,
    #[serde(default = "default_page")]
    pub page: u32,
    #[serde(default = "default_per_page")]
    pub per_page: u32,
}

fn default_page() -> u32 { 1 }
fn default_per_page() -> u32 { 20 }

/// Response for exploit search
#[derive(Debug, Serialize)]
pub struct ExploitSearchResponse {
    pub success: bool,
    pub exploits: Vec<Exploit>,
    pub total_count: u64,
    pub page: u32,
    pub per_page: u32,
    pub total_pages: u32,
}

/// Response for single exploit
#[derive(Debug, Serialize)]
pub struct ExploitDetailResponse {
    pub success: bool,
    pub exploit: Exploit,
}

/// Batch CVE mapping request
#[derive(Debug, Deserialize)]
pub struct BatchCveMappingRequest {
    pub cve_ids: Vec<String>,
}

/// Response for CVE mapping
#[derive(Debug, Serialize)]
pub struct CveMappingResponse {
    pub success: bool,
    pub mapping: CveExploitMapping,
}

/// Response for batch CVE mapping
#[derive(Debug, Serialize)]
pub struct BatchCveMappingResponse {
    pub success: bool,
    pub mappings: std::collections::HashMap<String, CveExploitMapping>,
}

/// Sync status response
#[derive(Debug, Serialize)]
pub struct SyncStatusResponse {
    pub success: bool,
    pub sources: Vec<SourceSyncStatus>,
}

#[derive(Debug, Serialize)]
pub struct SourceSyncStatus {
    pub source: String,
    pub last_sync_at: Option<String>,
    pub total_exploits: u64,
    pub new_since_last_sync: u64,
    pub sync_in_progress: bool,
    pub last_error: Option<String>,
}

/// PoC list response
#[derive(Debug, Serialize)]
pub struct PocListResponse {
    pub success: bool,
    pub pocs: Vec<PocEntry>,
    pub total: usize,
}

/// PoC detail response
#[derive(Debug, Serialize)]
pub struct PocDetailResponse {
    pub success: bool,
    pub poc: PocEntry,
}

/// PoC code response
#[derive(Debug, Serialize)]
pub struct PocCodeResponse {
    pub success: bool,
    pub code: String,
    pub version: Option<String>,
}

/// Create PoC request (API)
#[derive(Debug, Deserialize)]
pub struct CreatePocApiRequest {
    pub cve_id: Option<String>,
    pub exploit_id: Option<String>,
    pub title: String,
    pub description: Option<String>,
    pub language: Option<String>,
    pub code: String,
    pub tags: Option<Vec<String>>,
    pub target_info: Option<String>,
    pub requirements: Option<Vec<String>>,
}

/// Update PoC request (API)
#[derive(Debug, Deserialize)]
pub struct UpdatePocApiRequest {
    pub title: Option<String>,
    pub description: Option<String>,
    pub status: Option<String>,
    pub code: Option<String>,
    pub changelog: Option<String>,
    pub tags: Option<Vec<String>>,
    pub target_info: Option<String>,
    pub requirements: Option<Vec<String>>,
}

/// Test result request
#[derive(Debug, Deserialize)]
pub struct TestResultRequest {
    pub success: bool,
    pub target_info: String,
    pub output: Option<String>,
    pub error_message: Option<String>,
    pub execution_time_ms: Option<u64>,
}

/// Research note list response
#[derive(Debug, Serialize)]
pub struct NoteListResponse {
    pub success: bool,
    pub notes: Vec<ResearchNote>,
    pub total: usize,
}

/// Research note detail response
#[derive(Debug, Serialize)]
pub struct NoteDetailResponse {
    pub success: bool,
    pub note: ResearchNote,
}

/// Create note request (API)
#[derive(Debug, Deserialize)]
pub struct CreateNoteApiRequest {
    pub title: String,
    pub content: String,
    pub cve_ids: Option<Vec<String>>,
    pub exploit_ids: Option<Vec<String>>,
    pub poc_ids: Option<Vec<String>>,
    pub tags: Option<Vec<String>>,
    pub references: Option<Vec<ExternalReferenceRequest>>,
    pub visibility: Option<String>,
}

#[derive(Debug, Deserialize)]
pub struct ExternalReferenceRequest {
    pub title: String,
    pub url: String,
    pub reference_type: String,
    pub notes: Option<String>,
}

/// Update note request (API)
#[derive(Debug, Deserialize)]
pub struct UpdateNoteApiRequest {
    pub title: Option<String>,
    pub content: Option<String>,
    pub cve_ids: Option<Vec<String>>,
    pub exploit_ids: Option<Vec<String>>,
    pub poc_ids: Option<Vec<String>>,
    pub tags: Option<Vec<String>>,
    pub references: Option<Vec<ExternalReferenceRequest>>,
    pub visibility: Option<String>,
}

/// Workspace list response
#[derive(Debug, Serialize)]
pub struct WorkspaceListResponse {
    pub success: bool,
    pub workspaces: Vec<CveResearchWorkspace>,
    pub total: usize,
}

/// Workspace detail response
#[derive(Debug, Serialize)]
pub struct WorkspaceDetailResponse {
    pub success: bool,
    pub workspace: CveResearchWorkspace,
}

/// Create workspace request
#[derive(Debug, Deserialize)]
pub struct CreateWorkspaceRequest {
    pub cve_id: String,
    pub title: Option<String>,
}

/// Update workspace request
#[derive(Debug, Deserialize)]
pub struct UpdateWorkspaceApiRequest {
    pub title: Option<String>,
    pub status: Option<String>,
}

/// Add to workspace request
#[derive(Debug, Deserialize)]
pub struct AddToWorkspaceRequest {
    pub item_type: String, // "exploit", "poc", "note", "reference"
    pub item_id: Option<String>,
    pub reference: Option<ExternalReferenceRequest>,
}

/// Favorites response
#[derive(Debug, Serialize)]
pub struct FavoritesResponse {
    pub success: bool,
    pub favorites: Vec<FavoriteEntry>,
}

#[derive(Debug, Serialize)]
pub struct FavoriteEntry {
    pub exploit_id: String,
    pub notes: Option<String>,
    pub created_at: String,
}

/// Add favorite request
#[derive(Debug, Deserialize)]
pub struct AddFavoriteRequest {
    pub exploit_id: String,
    pub notes: Option<String>,
}

/// Search history response
#[derive(Debug, Serialize)]
pub struct SearchHistoryResponse {
    pub success: bool,
    pub history: Vec<SearchHistoryEntry>,
}

#[derive(Debug, Serialize)]
pub struct SearchHistoryEntry {
    pub query: String,
    pub filters: String,
    pub result_count: u32,
    pub searched_at: String,
}

/// Stats response
#[derive(Debug, Serialize)]
pub struct ExploitResearchStatsResponse {
    pub success: bool,
    pub total_exploits_cached: u64,
    pub total_pocs: usize,
    pub total_notes: usize,
    pub total_workspaces: usize,
    pub active_workspaces: usize,
    pub sources: Vec<SourceSyncStatus>,
}

// ==================== Exploit Search Endpoints ====================

/// GET /api/exploit-research/exploits - Search exploits
pub async fn search_exploits(
    state: web::Data<ExploitResearchState>,
    query: web::Query<ExploitSearchRequest>,
    _claims: web::ReqData<Claims>,
) -> Result<HttpResponse> {
    debug!("Searching exploits: {:?}", query);

    let search_query = ExploitSearchQuery {
        query: query.query.clone(),
        cve_id: query.cve_id.clone(),
        platform: query.platform.as_ref().and_then(|p| parse_platform(p)),
        exploit_type: query.exploit_type.as_ref().and_then(|t| parse_exploit_type(t)),
        source: query.source.as_ref().and_then(|s| parse_source(s)),
        language: None,
        author: None,
        verified_only: query.verified_only.unwrap_or(false),
        has_code: query.has_code.unwrap_or(false),
        min_reliability: None,
        date_from: None,
        date_to: None,
        page: query.page,
        per_page: query.per_page,
    };

    let mut engine = state.cve_engine.write().await;
    match engine.search_all(&search_query).await {
        Ok(results) => {
            Ok(HttpResponse::Ok().json(ExploitSearchResponse {
                success: true,
                exploits: results.exploits,
                total_count: results.total_count,
                page: results.page,
                per_page: results.per_page,
                total_pages: results.total_pages,
            }))
        }
        Err(e) => {
            error!("Failed to search exploits: {}", e);
            Ok(HttpResponse::InternalServerError().json(serde_json::json!({
                "success": false,
                "error": format!("Search failed: {}", e)
            })))
        }
    }
}

/// GET /api/exploit-research/exploits/cve/{cve_id} - Get exploits for CVE
pub async fn get_exploits_for_cve(
    state: web::Data<ExploitResearchState>,
    path: web::Path<String>,
    _claims: web::ReqData<Claims>,
) -> Result<HttpResponse> {
    let cve_id = path.into_inner();
    debug!("Getting exploits for CVE: {}", cve_id);

    let mut engine = state.cve_engine.write().await;
    match engine.get_all_exploits(&cve_id).await {
        Ok(exploits) => {
            Ok(HttpResponse::Ok().json(serde_json::json!({
                "success": true,
                "cve_id": cve_id,
                "exploits": exploits,
                "count": exploits.len()
            })))
        }
        Err(e) => {
            error!("Failed to get exploits for CVE {}: {}", cve_id, e);
            Ok(HttpResponse::InternalServerError().json(serde_json::json!({
                "success": false,
                "error": format!("Failed to get exploits: {}", e)
            })))
        }
    }
}

/// GET /api/exploit-research/cve-mapping/{cve_id} - Get CVE to exploit mapping
pub async fn get_cve_mapping(
    state: web::Data<ExploitResearchState>,
    path: web::Path<String>,
    _claims: web::ReqData<Claims>,
) -> Result<HttpResponse> {
    let cve_id = path.into_inner();
    debug!("Getting CVE mapping for: {}", cve_id);

    let mut engine = state.cve_engine.write().await;
    match engine.get_mapping(&cve_id).await {
        Ok(mapping) => {
            Ok(HttpResponse::Ok().json(CveMappingResponse {
                success: true,
                mapping,
            }))
        }
        Err(e) => {
            error!("Failed to get CVE mapping for {}: {}", cve_id, e);
            Ok(HttpResponse::InternalServerError().json(serde_json::json!({
                "success": false,
                "error": format!("Failed to get mapping: {}", e)
            })))
        }
    }
}

/// POST /api/exploit-research/cve-mapping/batch - Get mappings for multiple CVEs
pub async fn get_batch_cve_mappings(
    state: web::Data<ExploitResearchState>,
    body: web::Json<BatchCveMappingRequest>,
    _claims: web::ReqData<Claims>,
) -> Result<HttpResponse> {
    debug!("Getting batch CVE mappings for {} CVEs", body.cve_ids.len());

    let mut engine = state.cve_engine.write().await;
    match engine.get_mappings(&body.cve_ids).await {
        Ok(mappings) => {
            Ok(HttpResponse::Ok().json(BatchCveMappingResponse {
                success: true,
                mappings,
            }))
        }
        Err(e) => {
            error!("Failed to get batch CVE mappings: {}", e);
            Ok(HttpResponse::InternalServerError().json(serde_json::json!({
                "success": false,
                "error": format!("Failed to get mappings: {}", e)
            })))
        }
    }
}

/// GET /api/exploit-research/sync-status - Get sync status for all sources
pub async fn get_sync_status(
    state: web::Data<ExploitResearchState>,
    _claims: web::ReqData<Claims>,
) -> Result<HttpResponse> {
    let engine = state.cve_engine.read().await;
    let statuses = engine.get_all_sync_status();

    let sources: Vec<SourceSyncStatus> = statuses.into_iter().map(|s| {
        SourceSyncStatus {
            source: format!("{:?}", s.source),
            last_sync_at: s.last_sync_at.map(|t| t.to_rfc3339()),
            total_exploits: s.total_exploits,
            new_since_last_sync: s.new_since_last_sync,
            sync_in_progress: s.sync_in_progress,
            last_error: s.last_error,
        }
    }).collect();

    Ok(HttpResponse::Ok().json(SyncStatusResponse {
        success: true,
        sources,
    }))
}

/// GET /api/exploit-research/stats - Get overall statistics
pub async fn get_stats(
    state: web::Data<ExploitResearchState>,
    pool: web::Data<SqlitePool>,
    _claims: web::ReqData<Claims>,
) -> Result<HttpResponse> {
    let engine = state.cve_engine.read().await;
    let poc_repo = state.poc_repo.read().await;
    let notes_manager = state.notes_manager.read().await;

    let sync_statuses = engine.get_all_sync_status();
    let poc_stats = poc_repo.stats();
    let notes_stats = notes_manager.stats();

    // Get cached exploit count from database
    let cached_count: i64 = sqlx::query_scalar("SELECT COUNT(*) FROM exploits")
        .fetch_one(pool.get_ref())
        .await
        .unwrap_or(0);

    let sources: Vec<SourceSyncStatus> = sync_statuses.into_iter().map(|s| {
        SourceSyncStatus {
            source: format!("{:?}", s.source),
            last_sync_at: s.last_sync_at.map(|t| t.to_rfc3339()),
            total_exploits: s.total_exploits,
            new_since_last_sync: s.new_since_last_sync,
            sync_in_progress: s.sync_in_progress,
            last_error: s.last_error,
        }
    }).collect();

    Ok(HttpResponse::Ok().json(ExploitResearchStatsResponse {
        success: true,
        total_exploits_cached: cached_count as u64,
        total_pocs: poc_stats.total_pocs,
        total_notes: notes_stats.total_notes,
        total_workspaces: notes_stats.total_workspaces,
        active_workspaces: notes_stats.active_workspaces,
        sources,
    }))
}

// ==================== PoC Repository Endpoints ====================

/// GET /api/exploit-research/pocs - List PoCs
pub async fn list_pocs(
    state: web::Data<ExploitResearchState>,
    query: web::Query<PocFilterQuery>,
    _claims: web::ReqData<Claims>,
) -> Result<HttpResponse> {
    let poc_repo = state.poc_repo.read().await;

    let filter = if query.status.is_some() || query.language.is_some() ||
                    query.cve_id.is_some() || query.author.is_some() || query.query.is_some() {
        Some(PocFilter {
            status: query.status.as_ref().and_then(|s| parse_poc_status(s)),
            language: query.language.as_ref().and_then(|l| parse_language(l)),
            cve_id: query.cve_id.clone(),
            author: query.author.clone(),
            query: query.query.clone(),
        })
    } else {
        None
    };

    let pocs: Vec<PocEntry> = poc_repo.list(filter).into_iter().cloned().collect();
    let total = pocs.len();

    Ok(HttpResponse::Ok().json(PocListResponse {
        success: true,
        pocs,
        total,
    }))
}

#[derive(Debug, Deserialize)]
pub struct PocFilterQuery {
    pub status: Option<String>,
    pub language: Option<String>,
    pub cve_id: Option<String>,
    pub author: Option<String>,
    pub query: Option<String>,
}

/// POST /api/exploit-research/pocs - Create PoC
pub async fn create_poc(
    state: web::Data<ExploitResearchState>,
    body: web::Json<CreatePocApiRequest>,
    claims: web::ReqData<Claims>,
) -> Result<HttpResponse> {
    let mut poc_repo = state.poc_repo.write().await;

    let request = CreatePocRequest {
        cve_id: body.cve_id.clone(),
        exploit_id: body.exploit_id.clone(),
        title: body.title.clone(),
        description: body.description.clone(),
        language: body.language.as_ref().and_then(|l| parse_language(l)),
        code: body.code.clone(),
        author: Some(claims.username.clone()),
        tags: body.tags.clone().unwrap_or_default(),
        target_info: body.target_info.clone(),
        requirements: body.requirements.clone(),
    };

    match poc_repo.create(request) {
        Ok(poc) => {
            info!("Created PoC: {} by {}", poc.id, claims.username);
            Ok(HttpResponse::Created().json(PocDetailResponse {
                success: true,
                poc,
            }))
        }
        Err(e) => {
            error!("Failed to create PoC: {}", e);
            Ok(HttpResponse::InternalServerError().json(serde_json::json!({
                "success": false,
                "error": format!("Failed to create PoC: {}", e)
            })))
        }
    }
}

/// GET /api/exploit-research/pocs/{id} - Get PoC details
pub async fn get_poc(
    state: web::Data<ExploitResearchState>,
    path: web::Path<String>,
    _claims: web::ReqData<Claims>,
) -> Result<HttpResponse> {
    let id = path.into_inner();
    let poc_repo = state.poc_repo.read().await;

    match poc_repo.get(&id) {
        Some(poc) => {
            Ok(HttpResponse::Ok().json(PocDetailResponse {
                success: true,
                poc: poc.clone(),
            }))
        }
        None => {
            Ok(HttpResponse::NotFound().json(serde_json::json!({
                "success": false,
                "error": "PoC not found"
            })))
        }
    }
}

/// PUT /api/exploit-research/pocs/{id} - Update PoC
pub async fn update_poc(
    state: web::Data<ExploitResearchState>,
    path: web::Path<String>,
    body: web::Json<UpdatePocApiRequest>,
    claims: web::ReqData<Claims>,
) -> Result<HttpResponse> {
    let id = path.into_inner();
    let mut poc_repo = state.poc_repo.write().await;

    let request = UpdatePocRequest {
        title: body.title.clone(),
        description: body.description.clone(),
        status: body.status.as_ref().and_then(|s| parse_poc_status(s)),
        tags: body.tags.clone(),
        target_info: body.target_info.clone(),
        requirements: body.requirements.clone(),
        code: body.code.clone(),
        changelog: body.changelog.clone(),
        updated_by: Some(claims.username.clone()),
    };

    match poc_repo.update(&id, request) {
        Ok(poc) => {
            info!("Updated PoC: {} by {}", id, claims.username);
            Ok(HttpResponse::Ok().json(PocDetailResponse {
                success: true,
                poc,
            }))
        }
        Err(e) => {
            error!("Failed to update PoC {}: {}", id, e);
            Ok(HttpResponse::InternalServerError().json(serde_json::json!({
                "success": false,
                "error": format!("Failed to update PoC: {}", e)
            })))
        }
    }
}

/// DELETE /api/exploit-research/pocs/{id} - Delete PoC
pub async fn delete_poc(
    state: web::Data<ExploitResearchState>,
    path: web::Path<String>,
    claims: web::ReqData<Claims>,
) -> Result<HttpResponse> {
    let id = path.into_inner();
    let mut poc_repo = state.poc_repo.write().await;

    match poc_repo.delete(&id) {
        Ok(()) => {
            info!("Deleted PoC: {} by {}", id, claims.username);
            Ok(HttpResponse::Ok().json(serde_json::json!({
                "success": true,
                "message": "PoC deleted"
            })))
        }
        Err(e) => {
            error!("Failed to delete PoC {}: {}", id, e);
            Ok(HttpResponse::InternalServerError().json(serde_json::json!({
                "success": false,
                "error": format!("Failed to delete PoC: {}", e)
            })))
        }
    }
}

/// GET /api/exploit-research/pocs/{id}/code - Get PoC code
pub async fn get_poc_code(
    state: web::Data<ExploitResearchState>,
    path: web::Path<String>,
    query: web::Query<CodeVersionQuery>,
    _claims: web::ReqData<Claims>,
) -> Result<HttpResponse> {
    let id = path.into_inner();
    let poc_repo = state.poc_repo.read().await;

    let result = if let Some(ref version) = query.version {
        poc_repo.get_code_version(&id, version)
    } else {
        poc_repo.get_code(&id)
    };

    match result {
        Ok(code) => {
            Ok(HttpResponse::Ok().json(PocCodeResponse {
                success: true,
                code,
                version: query.version.clone(),
            }))
        }
        Err(e) => {
            Ok(HttpResponse::NotFound().json(serde_json::json!({
                "success": false,
                "error": format!("Failed to get code: {}", e)
            })))
        }
    }
}

#[derive(Debug, Deserialize)]
pub struct CodeVersionQuery {
    pub version: Option<String>,
}

/// POST /api/exploit-research/pocs/{id}/test - Add test result
pub async fn add_poc_test_result(
    state: web::Data<ExploitResearchState>,
    path: web::Path<String>,
    body: web::Json<TestResultRequest>,
    claims: web::ReqData<Claims>,
) -> Result<HttpResponse> {
    let id = path.into_inner();
    let mut poc_repo = state.poc_repo.write().await;

    // Check if PoC exists
    if poc_repo.get(&id).is_none() {
        return Ok(HttpResponse::NotFound().json(serde_json::json!({
            "success": false,
            "error": "PoC not found"
        })));
    }

    let result = PocTestResults {
        tested_at: Utc::now(),
        success: body.success,
        target_info: body.target_info.clone(),
        output: body.output.clone(),
        error: body.error_message.clone(),
        execution_time_ms: body.execution_time_ms.unwrap_or(0),
        notes: Some(format!("Tested by {}", claims.username)),
    };

    match poc_repo.add_test_result(&id, result) {
        Ok(()) => {
            info!("Added test result for PoC {} by {}", id, claims.username);
            Ok(HttpResponse::Ok().json(serde_json::json!({
                "success": true,
                "message": "Test result added"
            })))
        }
        Err(e) => {
            error!("Failed to add test result for PoC {}: {}", id, e);
            Ok(HttpResponse::InternalServerError().json(serde_json::json!({
                "success": false,
                "error": format!("Failed to add test result: {}", e)
            })))
        }
    }
}

// ==================== Research Notes Endpoints ====================

/// GET /api/exploit-research/notes - List research notes
pub async fn list_notes(
    state: web::Data<ExploitResearchState>,
    query: web::Query<NoteFilterQuery>,
    claims: web::ReqData<Claims>,
) -> Result<HttpResponse> {
    let notes_manager = state.notes_manager.read().await;

    let filter = if query.visibility.is_some() || query.tag.is_some() || query.query.is_some() {
        Some(NoteFilter {
            author: Some(claims.username.clone()), // Only show user's own notes by default
            visibility: query.visibility.as_ref().and_then(|v| parse_visibility(v)),
            query: query.query.clone(),
            tag: query.tag.clone(),
        })
    } else {
        Some(NoteFilter {
            author: Some(claims.username.clone()),
            ..Default::default()
        })
    };

    let notes: Vec<ResearchNote> = notes_manager.list_notes(filter).into_iter().cloned().collect();
    let total = notes.len();

    Ok(HttpResponse::Ok().json(NoteListResponse {
        success: true,
        notes,
        total,
    }))
}

#[derive(Debug, Deserialize)]
pub struct NoteFilterQuery {
    pub visibility: Option<String>,
    pub tag: Option<String>,
    pub query: Option<String>,
}

/// POST /api/exploit-research/notes - Create research note
pub async fn create_note(
    state: web::Data<ExploitResearchState>,
    body: web::Json<CreateNoteApiRequest>,
    claims: web::ReqData<Claims>,
) -> Result<HttpResponse> {
    let mut notes_manager = state.notes_manager.write().await;

    let references: Vec<ExternalReference> = body.references.as_ref()
        .map(|refs| refs.iter().map(|r| ExternalReference {
            title: r.title.clone(),
            url: r.url.clone(),
            reference_type: parse_reference_type(&r.reference_type),
            notes: r.notes.clone(),
        }).collect())
        .unwrap_or_default();

    let request = CreateResearchNoteRequest {
        title: body.title.clone(),
        content: body.content.clone(),
        cve_ids: body.cve_ids.clone().unwrap_or_default(),
        exploit_ids: body.exploit_ids.clone().unwrap_or_default(),
        poc_ids: body.poc_ids.clone().unwrap_or_default(),
        tags: body.tags.clone().unwrap_or_default(),
        references,
        author: Some(claims.username.clone()),
        visibility: parse_visibility(body.visibility.as_deref().unwrap_or("private")),
    };

    match notes_manager.create_note(request) {
        Ok(note) => {
            info!("Created research note: {} by {}", note.id, claims.username);
            Ok(HttpResponse::Created().json(NoteDetailResponse {
                success: true,
                note,
            }))
        }
        Err(e) => {
            error!("Failed to create note: {}", e);
            Ok(HttpResponse::InternalServerError().json(serde_json::json!({
                "success": false,
                "error": format!("Failed to create note: {}", e)
            })))
        }
    }
}

/// GET /api/exploit-research/notes/{id} - Get research note
pub async fn get_note(
    state: web::Data<ExploitResearchState>,
    path: web::Path<String>,
    _claims: web::ReqData<Claims>,
) -> Result<HttpResponse> {
    let id = path.into_inner();
    let notes_manager = state.notes_manager.read().await;

    match notes_manager.get_note(&id) {
        Some(note) => {
            Ok(HttpResponse::Ok().json(NoteDetailResponse {
                success: true,
                note: note.clone(),
            }))
        }
        None => {
            Ok(HttpResponse::NotFound().json(serde_json::json!({
                "success": false,
                "error": "Note not found"
            })))
        }
    }
}

/// PUT /api/exploit-research/notes/{id} - Update research note
pub async fn update_note(
    state: web::Data<ExploitResearchState>,
    path: web::Path<String>,
    body: web::Json<UpdateNoteApiRequest>,
    claims: web::ReqData<Claims>,
) -> Result<HttpResponse> {
    let id = path.into_inner();
    let mut notes_manager = state.notes_manager.write().await;

    let references: Option<Vec<ExternalReference>> = body.references.as_ref()
        .map(|refs| refs.iter().map(|r| ExternalReference {
            title: r.title.clone(),
            url: r.url.clone(),
            reference_type: parse_reference_type(&r.reference_type),
            notes: r.notes.clone(),
        }).collect());

    let request = UpdateResearchNoteRequest {
        title: body.title.clone(),
        content: body.content.clone(),
        cve_ids: body.cve_ids.clone(),
        exploit_ids: body.exploit_ids.clone(),
        poc_ids: body.poc_ids.clone(),
        tags: body.tags.clone(),
        references,
        visibility: body.visibility.as_ref().and_then(|v| parse_visibility(v)),
    };

    match notes_manager.update_note(&id, request) {
        Ok(note) => {
            info!("Updated research note: {} by {}", id, claims.username);
            Ok(HttpResponse::Ok().json(NoteDetailResponse {
                success: true,
                note,
            }))
        }
        Err(e) => {
            error!("Failed to update note {}: {}", id, e);
            Ok(HttpResponse::InternalServerError().json(serde_json::json!({
                "success": false,
                "error": format!("Failed to update note: {}", e)
            })))
        }
    }
}

/// DELETE /api/exploit-research/notes/{id} - Delete research note
pub async fn delete_note(
    state: web::Data<ExploitResearchState>,
    path: web::Path<String>,
    claims: web::ReqData<Claims>,
) -> Result<HttpResponse> {
    let id = path.into_inner();
    let mut notes_manager = state.notes_manager.write().await;

    match notes_manager.delete_note(&id) {
        Ok(()) => {
            info!("Deleted research note: {} by {}", id, claims.username);
            Ok(HttpResponse::Ok().json(serde_json::json!({
                "success": true,
                "message": "Note deleted"
            })))
        }
        Err(e) => {
            error!("Failed to delete note {}: {}", id, e);
            Ok(HttpResponse::InternalServerError().json(serde_json::json!({
                "success": false,
                "error": format!("Failed to delete note: {}", e)
            })))
        }
    }
}

// ==================== Research Workspaces Endpoints ====================

/// GET /api/exploit-research/workspaces - List workspaces
pub async fn list_workspaces(
    state: web::Data<ExploitResearchState>,
    query: web::Query<WorkspaceFilterQuery>,
    _claims: web::ReqData<Claims>,
) -> Result<HttpResponse> {
    let notes_manager = state.notes_manager.read().await;

    let filter = if query.status.is_some() || query.query.is_some() {
        Some(WorkspaceFilter {
            status: query.status.as_ref().and_then(|s| parse_workspace_status(s)),
            query: query.query.clone(),
        })
    } else {
        None
    };

    let workspaces: Vec<CveResearchWorkspace> = notes_manager.list_workspaces(filter)
        .into_iter().cloned().collect();
    let total = workspaces.len();

    Ok(HttpResponse::Ok().json(WorkspaceListResponse {
        success: true,
        workspaces,
        total,
    }))
}

#[derive(Debug, Deserialize)]
pub struct WorkspaceFilterQuery {
    pub status: Option<String>,
    pub query: Option<String>,
}

/// POST /api/exploit-research/workspaces - Create workspace
pub async fn create_workspace(
    state: web::Data<ExploitResearchState>,
    body: web::Json<CreateWorkspaceRequest>,
    claims: web::ReqData<Claims>,
) -> Result<HttpResponse> {
    let mut notes_manager = state.notes_manager.write().await;

    match notes_manager.create_workspace(&body.cve_id, body.title.clone()) {
        Ok(workspace) => {
            info!("Created workspace: {} for {} by {}", workspace.id, body.cve_id, claims.username);
            Ok(HttpResponse::Created().json(WorkspaceDetailResponse {
                success: true,
                workspace,
            }))
        }
        Err(e) => {
            error!("Failed to create workspace: {}", e);
            Ok(HttpResponse::InternalServerError().json(serde_json::json!({
                "success": false,
                "error": format!("Failed to create workspace: {}", e)
            })))
        }
    }
}

/// GET /api/exploit-research/workspaces/{id} - Get workspace
pub async fn get_workspace(
    state: web::Data<ExploitResearchState>,
    path: web::Path<String>,
    _claims: web::ReqData<Claims>,
) -> Result<HttpResponse> {
    let id = path.into_inner();
    let notes_manager = state.notes_manager.read().await;

    match notes_manager.get_workspace(&id) {
        Some(workspace) => {
            Ok(HttpResponse::Ok().json(WorkspaceDetailResponse {
                success: true,
                workspace: workspace.clone(),
            }))
        }
        None => {
            Ok(HttpResponse::NotFound().json(serde_json::json!({
                "success": false,
                "error": "Workspace not found"
            })))
        }
    }
}

/// PUT /api/exploit-research/workspaces/{id} - Update workspace
pub async fn update_workspace(
    state: web::Data<ExploitResearchState>,
    path: web::Path<String>,
    body: web::Json<UpdateWorkspaceApiRequest>,
    claims: web::ReqData<Claims>,
) -> Result<HttpResponse> {
    let id = path.into_inner();
    let mut notes_manager = state.notes_manager.write().await;

    let update = WorkspaceUpdate {
        title: body.title.clone(),
        status: body.status.as_ref().and_then(|s| parse_workspace_status(s)),
    };

    match notes_manager.update_workspace(&id, update) {
        Ok(workspace) => {
            info!("Updated workspace: {} by {}", id, claims.username);
            Ok(HttpResponse::Ok().json(WorkspaceDetailResponse {
                success: true,
                workspace,
            }))
        }
        Err(e) => {
            error!("Failed to update workspace {}: {}", id, e);
            Ok(HttpResponse::InternalServerError().json(serde_json::json!({
                "success": false,
                "error": format!("Failed to update workspace: {}", e)
            })))
        }
    }
}

/// DELETE /api/exploit-research/workspaces/{id} - Delete workspace
pub async fn delete_workspace(
    state: web::Data<ExploitResearchState>,
    path: web::Path<String>,
    claims: web::ReqData<Claims>,
) -> Result<HttpResponse> {
    let id = path.into_inner();
    let mut notes_manager = state.notes_manager.write().await;

    match notes_manager.delete_workspace(&id) {
        Ok(()) => {
            info!("Deleted workspace: {} by {}", id, claims.username);
            Ok(HttpResponse::Ok().json(serde_json::json!({
                "success": true,
                "message": "Workspace deleted"
            })))
        }
        Err(e) => {
            error!("Failed to delete workspace {}: {}", id, e);
            Ok(HttpResponse::InternalServerError().json(serde_json::json!({
                "success": false,
                "error": format!("Failed to delete workspace: {}", e)
            })))
        }
    }
}

/// POST /api/exploit-research/workspaces/{id}/items - Add item to workspace
pub async fn add_item_to_workspace(
    state: web::Data<ExploitResearchState>,
    path: web::Path<String>,
    body: web::Json<AddToWorkspaceRequest>,
    claims: web::ReqData<Claims>,
) -> Result<HttpResponse> {
    let id = path.into_inner();
    let mut notes_manager = state.notes_manager.write().await;

    let result = match body.item_type.as_str() {
        "exploit" => {
            if let Some(ref item_id) = body.item_id {
                notes_manager.add_exploit_to_workspace(&id, item_id)
            } else {
                return Ok(HttpResponse::BadRequest().json(serde_json::json!({
                    "success": false,
                    "error": "item_id required for exploit"
                })));
            }
        }
        "poc" => {
            if let Some(ref item_id) = body.item_id {
                notes_manager.add_poc_to_workspace(&id, item_id)
            } else {
                return Ok(HttpResponse::BadRequest().json(serde_json::json!({
                    "success": false,
                    "error": "item_id required for poc"
                })));
            }
        }
        "note" => {
            if let Some(ref item_id) = body.item_id {
                notes_manager.add_note_to_workspace(&id, item_id)
            } else {
                return Ok(HttpResponse::BadRequest().json(serde_json::json!({
                    "success": false,
                    "error": "item_id required for note"
                })));
            }
        }
        "reference" => {
            if let Some(ref ref_req) = body.reference {
                let reference = ExternalReference {
                    title: ref_req.title.clone(),
                    url: ref_req.url.clone(),
                    reference_type: parse_reference_type(&ref_req.reference_type),
                    notes: ref_req.notes.clone(),
                };
                notes_manager.add_reference_to_workspace(&id, reference)
            } else {
                return Ok(HttpResponse::BadRequest().json(serde_json::json!({
                    "success": false,
                    "error": "reference required for reference type"
                })));
            }
        }
        _ => {
            return Ok(HttpResponse::BadRequest().json(serde_json::json!({
                "success": false,
                "error": "Invalid item_type. Must be: exploit, poc, note, or reference"
            })));
        }
    };

    match result {
        Ok(()) => {
            info!("Added {} to workspace {} by {}", body.item_type, id, claims.username);
            Ok(HttpResponse::Ok().json(serde_json::json!({
                "success": true,
                "message": format!("{} added to workspace", body.item_type)
            })))
        }
        Err(e) => {
            error!("Failed to add item to workspace {}: {}", id, e);
            Ok(HttpResponse::InternalServerError().json(serde_json::json!({
                "success": false,
                "error": format!("Failed to add item: {}", e)
            })))
        }
    }
}

/// GET /api/exploit-research/workspaces/{id}/export - Export workspace as markdown
pub async fn export_workspace(
    state: web::Data<ExploitResearchState>,
    path: web::Path<String>,
    _claims: web::ReqData<Claims>,
) -> Result<HttpResponse> {
    let id = path.into_inner();
    let notes_manager = state.notes_manager.read().await;

    match notes_manager.export_workspace_markdown(&id) {
        Ok(markdown) => {
            Ok(HttpResponse::Ok()
                .content_type("text/markdown")
                .body(markdown))
        }
        Err(e) => {
            Ok(HttpResponse::NotFound().json(serde_json::json!({
                "success": false,
                "error": format!("Failed to export workspace: {}", e)
            })))
        }
    }
}

// ==================== Helper Functions ====================

fn parse_platform(s: &str) -> Option<ExploitPlatform> {
    match s.to_lowercase().as_str() {
        "windows" => Some(ExploitPlatform::Windows),
        "linux" => Some(ExploitPlatform::Linux),
        "macos" | "osx" => Some(ExploitPlatform::MacOS),
        "unix" => Some(ExploitPlatform::Unix),
        "freebsd" => Some(ExploitPlatform::FreeBSD),
        "android" => Some(ExploitPlatform::Android),
        "ios" => Some(ExploitPlatform::IOS),
        "multiple" => Some(ExploitPlatform::Multiple),
        "hardware" => Some(ExploitPlatform::Hardware),
        "php" => Some(ExploitPlatform::Php),
        "java" => Some(ExploitPlatform::Java),
        "webapps" => Some(ExploitPlatform::WebApps),
        _ => None,
    }
}

fn parse_exploit_type(s: &str) -> Option<ExploitType> {
    match s.to_lowercase().as_str() {
        "remote" => Some(ExploitType::Remote),
        "local" => Some(ExploitType::Local),
        "webapps" => Some(ExploitType::WebApps),
        "dos" => Some(ExploitType::Dos),
        "shellcode" => Some(ExploitType::Shellcode),
        "papers" => Some(ExploitType::Papers),
        _ => None,
    }
}

fn parse_source(s: &str) -> Option<ExploitSource> {
    match s.to_lowercase().as_str() {
        "exploitdb" | "exploit_db" | "exploit-db" => Some(ExploitSource::ExploitDb),
        "metasploit" | "msf" => Some(ExploitSource::Metasploit),
        "packetstorm" | "packet_storm" => Some(ExploitSource::PacketStorm),
        "github" => Some(ExploitSource::GitHub),
        "custom" => Some(ExploitSource::Custom),
        _ => None,
    }
}

fn parse_poc_status(s: &str) -> Option<PocStatus> {
    match s.to_lowercase().as_str() {
        "development" => Some(PocStatus::Development),
        "testing" => Some(PocStatus::Testing),
        "verified" => Some(PocStatus::Verified),
        "failed" => Some(PocStatus::Failed),
        "archived" => Some(PocStatus::Archived),
        _ => None,
    }
}

fn parse_language(s: &str) -> Option<crate::exploit_research::ExploitLanguage> {
    use crate::exploit_research::ExploitLanguage;
    match s.to_lowercase().as_str() {
        "python" => Some(ExploitLanguage::Python),
        "ruby" => Some(ExploitLanguage::Ruby),
        "perl" => Some(ExploitLanguage::Perl),
        "c" => Some(ExploitLanguage::C),
        "cpp" | "c++" => Some(ExploitLanguage::Cpp),
        "java" => Some(ExploitLanguage::Java),
        "javascript" | "js" => Some(ExploitLanguage::Javascript),
        "php" => Some(ExploitLanguage::Php),
        "bash" | "shell" => Some(ExploitLanguage::Bash),
        "powershell" | "ps1" => Some(ExploitLanguage::Powershell),
        "go" | "golang" => Some(ExploitLanguage::Go),
        "rust" => Some(ExploitLanguage::Rust),
        "assembly" | "asm" => Some(ExploitLanguage::Assembly),
        _ => None,
    }
}

fn parse_visibility(s: &str) -> Option<NoteVisibility> {
    match s.to_lowercase().as_str() {
        "private" => Some(NoteVisibility::Private),
        "team" => Some(NoteVisibility::Team),
        "public" => Some(NoteVisibility::Public),
        _ => None,
    }
}

fn parse_workspace_status(s: &str) -> Option<WorkspaceStatus> {
    match s.to_lowercase().as_str() {
        "active" => Some(WorkspaceStatus::Active),
        "paused" => Some(WorkspaceStatus::Paused),
        "completed" => Some(WorkspaceStatus::Completed),
        "archived" => Some(WorkspaceStatus::Archived),
        _ => None,
    }
}

fn parse_reference_type(s: &str) -> ReferenceType {
    match s.to_lowercase().as_str() {
        "cve" => ReferenceType::Cve,
        "advisory" => ReferenceType::Advisory,
        "blog" | "blog_post" | "blogpost" => ReferenceType::BlogPost,
        "github" => ReferenceType::GitHub,
        "exploit" | "exploit_db" => ReferenceType::ExploitDb,
        "paper" => ReferenceType::Paper,
        "vendor" => ReferenceType::Vendor,
        _ => ReferenceType::Other,
    }
}

// ==================== Route Configuration ====================

/// Configure exploit research routes
pub fn configure(cfg: &mut web::ServiceConfig) {
    cfg.service(
        web::scope("/exploit-research")
            // Exploits
            .route("/exploits", web::get().to(search_exploits))
            .route("/exploits/cve/{cve_id}", web::get().to(get_exploits_for_cve))
            // CVE Mapping
            .route("/cve-mapping/{cve_id}", web::get().to(get_cve_mapping))
            .route("/cve-mapping/batch", web::post().to(get_batch_cve_mappings))
            // Sync & Stats
            .route("/sync-status", web::get().to(get_sync_status))
            .route("/stats", web::get().to(get_stats))
            // PoCs
            .route("/pocs", web::get().to(list_pocs))
            .route("/pocs", web::post().to(create_poc))
            .route("/pocs/{id}", web::get().to(get_poc))
            .route("/pocs/{id}", web::put().to(update_poc))
            .route("/pocs/{id}", web::delete().to(delete_poc))
            .route("/pocs/{id}/code", web::get().to(get_poc_code))
            .route("/pocs/{id}/test", web::post().to(add_poc_test_result))
            // Research Notes
            .route("/notes", web::get().to(list_notes))
            .route("/notes", web::post().to(create_note))
            .route("/notes/{id}", web::get().to(get_note))
            .route("/notes/{id}", web::put().to(update_note))
            .route("/notes/{id}", web::delete().to(delete_note))
            // Workspaces
            .route("/workspaces", web::get().to(list_workspaces))
            .route("/workspaces", web::post().to(create_workspace))
            .route("/workspaces/{id}", web::get().to(get_workspace))
            .route("/workspaces/{id}", web::put().to(update_workspace))
            .route("/workspaces/{id}", web::delete().to(delete_workspace))
            .route("/workspaces/{id}/items", web::post().to(add_item_to_workspace))
            .route("/workspaces/{id}/export", web::get().to(export_workspace))
    );
}
