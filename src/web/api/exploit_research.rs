//! Exploit Research API endpoints
//!
//! Provides REST API access to exploit database integration, PoC repository,
//! and research workspace functionality.
//!
//! ## Endpoints
//!
//! ### Exploit Search & Database
//! - GET /api/exploit-research/exploits - Search exploits across all sources
//! - GET /api/exploit-research/exploits/{id} - Get exploit details
//! - GET /api/exploit-research/exploits/cve/{cve_id} - Get exploits for a CVE
//! - GET /api/exploit-research/sync-status - Get sync status for all sources
//! - POST /api/exploit-research/sync/{source} - Trigger sync for a source
//!
//! ### CVE Mapping
//! - GET /api/exploit-research/cve-mapping/{cve_id} - Get CVE to exploit mapping
//! - POST /api/exploit-research/cve-mapping/batch - Get mappings for multiple CVEs
//!
//! ### PoC Repository
//! - GET /api/exploit-research/pocs - List PoCs
//! - POST /api/exploit-research/pocs - Create PoC
//! - GET /api/exploit-research/pocs/{id} - Get PoC details
//! - PUT /api/exploit-research/pocs/{id} - Update PoC
//! - DELETE /api/exploit-research/pocs/{id} - Delete PoC
//! - GET /api/exploit-research/pocs/{id}/code - Get PoC code
//! - POST /api/exploit-research/pocs/{id}/test - Add test result
//!
//! ### Research Notes & Workspaces
//! - GET /api/exploit-research/notes - List research notes
//! - POST /api/exploit-research/notes - Create note
//! - GET /api/exploit-research/notes/{id} - Get note
//! - PUT /api/exploit-research/notes/{id} - Update note
//! - DELETE /api/exploit-research/notes/{id} - Delete note
//! - GET /api/exploit-research/workspaces - List workspaces
//! - POST /api/exploit-research/workspaces - Create workspace
//! - GET /api/exploit-research/workspaces/{id} - Get workspace
//! - PUT /api/exploit-research/workspaces/{id} - Update workspace
//! - DELETE /api/exploit-research/workspaces/{id} - Delete workspace
//! - GET /api/exploit-research/workspaces/{id}/export - Export workspace as markdown
//!
//! ### Favorites & History
//! - GET /api/exploit-research/favorites - Get user's favorites
//! - POST /api/exploit-research/favorites - Add to favorites
//! - DELETE /api/exploit-research/favorites/{exploit_id} - Remove from favorites
//! - GET /api/exploit-research/history - Get search history

use actix_web::{web, HttpResponse, Result};
use chrono::Utc;
use log::{debug, error, info};
use serde::{Deserialize, Serialize};
use sqlx::SqlitePool;
use tokio::sync::RwLock;

use crate::exploit_research::{
    CveMappingEngine,
    PocRepository, ResearchNotesManager, ExploitSearchQuery, Exploit,
    CveExploitMapping, ExploitSource, ExploitPlatform, ExploitType,
    PocEntry, PocStatus, CreatePocRequest, UpdatePocRequest, PocTestResults,
    ResearchNote, CveResearchWorkspace, CreateResearchNoteRequest, UpdateResearchNoteRequest,
    ExternalReference, ReferenceType, NoteVisibility, WorkspaceStatus,
    // Sprint 2: Sandbox and Effectiveness
    SandboxManager, SandboxConfig, SandboxExecutionRequest,
    SandboxType, SandboxOS, SandboxStatus, NetworkConfig, ResourceLimits,
    TargetInfo, SuccessIndicator,
    EffectivenessCalculator,
    EffectivenessInput, ComplexityLevel, ImpactSeverity, ExternalRating,
};
use crate::exploit_research::research_notes::{NoteFilter, WorkspaceFilter, WorkspaceUpdate};
use crate::exploit_research::poc_repository::PocFilter;
use crate::web::auth::Claims;

/// Shared state for exploit research
pub struct ExploitResearchState {
    pub cve_engine: RwLock<CveMappingEngine>,
    pub poc_repo: RwLock<PocRepository>,
    pub notes_manager: RwLock<ResearchNotesManager>,
    pub sandbox_manager: RwLock<SandboxManager>,
    pub effectiveness_calculator: EffectivenessCalculator,
}

impl ExploitResearchState {
    pub fn new() -> anyhow::Result<Self> {
        Ok(Self {
            cve_engine: RwLock::new(CveMappingEngine::new()?),
            poc_repo: RwLock::new(PocRepository::new(None)?),
            notes_manager: RwLock::new(ResearchNotesManager::new()),
            sandbox_manager: RwLock::new(SandboxManager::new()),
            effectiveness_calculator: EffectivenessCalculator::new(),
        })
    }
}

// ==================== Request/Response Types ====================

/// Search request for exploits
#[derive(Debug, Deserialize)]
pub struct ExploitSearchRequest {
    pub query: Option<String>,
    pub cve_id: Option<String>,
    pub platform: Option<String>,
    pub exploit_type: Option<String>,
    pub source: Option<String>,
    pub verified_only: Option<bool>,
    pub has_code: Option<bool>,
    #[serde(default = "default_page")]
    pub page: u32,
    #[serde(default = "default_per_page")]
    pub per_page: u32,
}

fn default_page() -> u32 { 1 }
fn default_per_page() -> u32 { 20 }

/// Response for exploit search
#[derive(Debug, Serialize)]
pub struct ExploitSearchResponse {
    pub success: bool,
    pub exploits: Vec<Exploit>,
    pub total_count: u64,
    pub page: u32,
    pub per_page: u32,
    pub total_pages: u32,
}

/// Response for single exploit
#[derive(Debug, Serialize)]
pub struct ExploitDetailResponse {
    pub success: bool,
    pub exploit: Exploit,
}

/// Batch CVE mapping request
#[derive(Debug, Deserialize)]
pub struct BatchCveMappingRequest {
    pub cve_ids: Vec<String>,
}

/// Response for CVE mapping
#[derive(Debug, Serialize)]
pub struct CveMappingResponse {
    pub success: bool,
    pub mapping: CveExploitMapping,
}

/// Response for batch CVE mapping
#[derive(Debug, Serialize)]
pub struct BatchCveMappingResponse {
    pub success: bool,
    pub mappings: std::collections::HashMap<String, CveExploitMapping>,
}

/// Sync status response
#[derive(Debug, Serialize)]
pub struct SyncStatusResponse {
    pub success: bool,
    pub sources: Vec<SourceSyncStatus>,
}

#[derive(Debug, Serialize)]
pub struct SourceSyncStatus {
    pub source: String,
    pub last_sync_at: Option<String>,
    pub total_exploits: u64,
    pub new_since_last_sync: u64,
    pub sync_in_progress: bool,
    pub last_error: Option<String>,
}

/// PoC list response
#[derive(Debug, Serialize)]
pub struct PocListResponse {
    pub success: bool,
    pub pocs: Vec<PocEntry>,
    pub total: usize,
}

/// PoC detail response
#[derive(Debug, Serialize)]
pub struct PocDetailResponse {
    pub success: bool,
    pub poc: PocEntry,
}

/// PoC code response
#[derive(Debug, Serialize)]
pub struct PocCodeResponse {
    pub success: bool,
    pub code: String,
    pub version: Option<String>,
}

/// Create PoC request (API)
#[derive(Debug, Deserialize)]
pub struct CreatePocApiRequest {
    pub cve_id: Option<String>,
    pub exploit_id: Option<String>,
    pub title: String,
    pub description: Option<String>,
    pub language: Option<String>,
    pub code: String,
    pub tags: Option<Vec<String>>,
    pub target_info: Option<String>,
    pub requirements: Option<Vec<String>>,
}

/// Update PoC request (API)
#[derive(Debug, Deserialize)]
pub struct UpdatePocApiRequest {
    pub title: Option<String>,
    pub description: Option<String>,
    pub status: Option<String>,
    pub code: Option<String>,
    pub changelog: Option<String>,
    pub tags: Option<Vec<String>>,
    pub target_info: Option<String>,
    pub requirements: Option<Vec<String>>,
}

/// Test result request
#[derive(Debug, Deserialize)]
pub struct TestResultRequest {
    pub success: bool,
    pub target_info: String,
    pub output: Option<String>,
    pub error_message: Option<String>,
    pub execution_time_ms: Option<u64>,
}

/// Research note list response
#[derive(Debug, Serialize)]
pub struct NoteListResponse {
    pub success: bool,
    pub notes: Vec<ResearchNote>,
    pub total: usize,
}

/// Research note detail response
#[derive(Debug, Serialize)]
pub struct NoteDetailResponse {
    pub success: bool,
    pub note: ResearchNote,
}

/// Create note request (API)
#[derive(Debug, Deserialize)]
pub struct CreateNoteApiRequest {
    pub title: String,
    pub content: String,
    pub cve_ids: Option<Vec<String>>,
    pub exploit_ids: Option<Vec<String>>,
    pub poc_ids: Option<Vec<String>>,
    pub tags: Option<Vec<String>>,
    pub references: Option<Vec<ExternalReferenceRequest>>,
    pub visibility: Option<String>,
}

#[derive(Debug, Deserialize)]
pub struct ExternalReferenceRequest {
    pub title: String,
    pub url: String,
    pub reference_type: String,
    pub notes: Option<String>,
}

/// Update note request (API)
#[derive(Debug, Deserialize)]
pub struct UpdateNoteApiRequest {
    pub title: Option<String>,
    pub content: Option<String>,
    pub cve_ids: Option<Vec<String>>,
    pub exploit_ids: Option<Vec<String>>,
    pub poc_ids: Option<Vec<String>>,
    pub tags: Option<Vec<String>>,
    pub references: Option<Vec<ExternalReferenceRequest>>,
    pub visibility: Option<String>,
}

/// Workspace list response
#[derive(Debug, Serialize)]
pub struct WorkspaceListResponse {
    pub success: bool,
    pub workspaces: Vec<CveResearchWorkspace>,
    pub total: usize,
}

/// Workspace detail response
#[derive(Debug, Serialize)]
pub struct WorkspaceDetailResponse {
    pub success: bool,
    pub workspace: CveResearchWorkspace,
}

/// Create workspace request
#[derive(Debug, Deserialize)]
pub struct CreateWorkspaceRequest {
    pub cve_id: String,
    pub title: Option<String>,
}

/// Update workspace request
#[derive(Debug, Deserialize)]
pub struct UpdateWorkspaceApiRequest {
    pub title: Option<String>,
    pub status: Option<String>,
}

/// Add to workspace request
#[derive(Debug, Deserialize)]
pub struct AddToWorkspaceRequest {
    pub item_type: String, // "exploit", "poc", "note", "reference"
    pub item_id: Option<String>,
    pub reference: Option<ExternalReferenceRequest>,
}

/// Favorites response
#[derive(Debug, Serialize)]
pub struct FavoritesResponse {
    pub success: bool,
    pub favorites: Vec<FavoriteEntry>,
}

#[derive(Debug, Serialize)]
pub struct FavoriteEntry {
    pub exploit_id: String,
    pub notes: Option<String>,
    pub created_at: String,
}

/// Add favorite request
#[derive(Debug, Deserialize)]
pub struct AddFavoriteRequest {
    pub exploit_id: String,
    pub notes: Option<String>,
}

/// Search history response
#[derive(Debug, Serialize)]
pub struct SearchHistoryResponse {
    pub success: bool,
    pub history: Vec<SearchHistoryEntry>,
}

#[derive(Debug, Serialize)]
pub struct SearchHistoryEntry {
    pub query: String,
    pub filters: String,
    pub result_count: u32,
    pub searched_at: String,
}

/// Stats response
#[derive(Debug, Serialize)]
pub struct ExploitResearchStatsResponse {
    pub success: bool,
    pub total_exploits_cached: u64,
    pub total_pocs: usize,
    pub total_notes: usize,
    pub total_workspaces: usize,
    pub active_workspaces: usize,
    pub sources: Vec<SourceSyncStatus>,
}

// ==================== Sprint 2: Sandbox & Effectiveness Types ====================

/// Request to execute a PoC in a sandbox
#[derive(Debug, Deserialize)]
pub struct SandboxExecutionApiRequest {
    pub sandbox_type: String,
    pub target_os: String,
    pub timeout_seconds: Option<u64>,
    pub isolated_network: Option<bool>,
    pub target_host: Option<String>,
    pub target_port: Option<u16>,
    pub additional_args: Option<Vec<String>>,
    pub success_indicators: Option<Vec<SuccessIndicatorRequest>>,
}

#[derive(Debug, Deserialize)]
pub struct SuccessIndicatorRequest {
    pub indicator_type: String,  // "output_contains", "exit_code", "file_created", etc.
    pub value: String,
}

/// Response from sandbox execution
#[derive(Debug, Serialize)]
pub struct SandboxExecutionResponse {
    pub success: bool,
    pub execution_id: String,
    pub status: String,
    pub result: Option<SandboxExecutionResultResponse>,
    pub error: Option<String>,
}

#[derive(Debug, Serialize)]
pub struct SandboxExecutionResultResponse {
    pub exit_code: Option<i32>,
    pub stdout: String,
    pub stderr: String,
    pub execution_time_ms: u64,
    pub success_detected: bool,
    pub artifacts_collected: Vec<String>,
    pub network_connections: Vec<String>,
}

/// List sandbox environments response
#[derive(Debug, Serialize)]
pub struct SandboxEnvironmentsResponse {
    pub success: bool,
    pub environments: Vec<SandboxEnvironmentResponse>,
}

#[derive(Debug, Serialize)]
pub struct SandboxEnvironmentResponse {
    pub id: String,
    pub name: String,
    pub sandbox_type: String,
    pub os: String,
    pub status: String,
    pub is_ready: bool,
}

/// Request to calculate effectiveness score
#[derive(Debug, Deserialize)]
pub struct EffectivenessCalculateRequest {
    pub complexity: Option<String>,
    pub impact_severity: Option<String>,
    pub has_documentation: Option<bool>,
    pub version_count: Option<u32>,
    pub peer_reviewed: Option<bool>,
    pub target_coverage: Option<u32>,
    pub external_ratings: Option<Vec<ExternalRatingRequest>>,
}

#[derive(Debug, Deserialize)]
pub struct ExternalRatingRequest {
    pub source: String,
    pub rating: String,
    pub score: Option<f64>,
}

/// Effectiveness score response
#[derive(Debug, Serialize)]
pub struct EffectivenessScoreResponse {
    pub success: bool,
    pub poc_id: String,
    pub score: EffectivenessScoreDetail,
}

#[derive(Debug, Serialize)]
pub struct EffectivenessScoreDetail {
    pub total_score: u32,
    pub rating: String,
    pub reliability_score: u32,
    pub impact_score: u32,
    pub maturity_score: u32,
    pub community_score: u32,
    pub breakdown: ScoreBreakdown,
    pub recommendations: Vec<String>,
}

#[derive(Debug, Serialize)]
pub struct ScoreBreakdown {
    pub success_rate_contribution: u32,
    pub complexity_contribution: u32,
    pub target_range_contribution: u32,
    pub documentation_contribution: u32,
    pub external_ratings_contribution: u32,
}

/// Sandbox execution history response
#[derive(Debug, Serialize)]
pub struct SandboxHistoryResponse {
    pub success: bool,
    pub executions: Vec<SandboxExecutionHistoryEntry>,
    pub total: usize,
}

#[derive(Debug, Serialize)]
pub struct SandboxExecutionHistoryEntry {
    pub id: String,
    pub poc_id: String,
    pub sandbox_type: String,
    pub target_os: String,
    pub status: String,
    pub success_detected: bool,
    pub execution_time_ms: u64,
    pub executed_at: String,
    pub executed_by: String,
}

/// Timeline events response
#[derive(Debug, Serialize)]
pub struct TimelineEventsResponse {
    pub success: bool,
    pub events: Vec<TimelineEventResponse>,
    pub total: usize,
}

#[derive(Debug, Serialize)]
pub struct TimelineEventResponse {
    pub id: String,
    pub event_type: String,
    pub title: String,
    pub description: Option<String>,
    pub timestamp: String,
    pub user_id: Option<String>,
    pub metadata: Option<serde_json::Value>,
}

/// Create timeline event request
#[derive(Debug, Deserialize)]
pub struct CreateTimelineEventRequest {
    pub event_type: String,
    pub title: String,
    pub description: Option<String>,
    pub metadata: Option<serde_json::Value>,
}

// ==================== Exploit Search Endpoints ====================

/// GET /api/exploit-research/exploits - Search exploits
pub async fn search_exploits(
    state: web::Data<ExploitResearchState>,
    query: web::Query<ExploitSearchRequest>,
    _claims: web::ReqData<Claims>,
) -> Result<HttpResponse> {
    debug!("Searching exploits: {:?}", query);

    let search_query = ExploitSearchQuery {
        query: query.query.clone(),
        cve_id: query.cve_id.clone(),
        platform: query.platform.as_ref().and_then(|p| parse_platform(p)),
        exploit_type: query.exploit_type.as_ref().and_then(|t| parse_exploit_type(t)),
        source: query.source.as_ref().and_then(|s| parse_source(s)),
        language: None,
        author: None,
        verified_only: query.verified_only.unwrap_or(false),
        has_code: query.has_code.unwrap_or(false),
        min_reliability: None,
        date_from: None,
        date_to: None,
        page: query.page,
        per_page: query.per_page,
    };

    let mut engine = state.cve_engine.write().await;
    match engine.search_all(&search_query).await {
        Ok(results) => {
            Ok(HttpResponse::Ok().json(ExploitSearchResponse {
                success: true,
                exploits: results.exploits,
                total_count: results.total_count,
                page: results.page,
                per_page: results.per_page,
                total_pages: results.total_pages,
            }))
        }
        Err(e) => {
            error!("Failed to search exploits: {}", e);
            Ok(HttpResponse::InternalServerError().json(serde_json::json!({
                "success": false,
                "error": format!("Search failed: {}", e)
            })))
        }
    }
}

/// GET /api/exploit-research/exploits/cve/{cve_id} - Get exploits for CVE
pub async fn get_exploits_for_cve(
    state: web::Data<ExploitResearchState>,
    path: web::Path<String>,
    _claims: web::ReqData<Claims>,
) -> Result<HttpResponse> {
    let cve_id = path.into_inner();
    debug!("Getting exploits for CVE: {}", cve_id);

    let mut engine = state.cve_engine.write().await;
    match engine.get_all_exploits(&cve_id).await {
        Ok(exploits) => {
            Ok(HttpResponse::Ok().json(serde_json::json!({
                "success": true,
                "cve_id": cve_id,
                "exploits": exploits,
                "count": exploits.len()
            })))
        }
        Err(e) => {
            error!("Failed to get exploits for CVE {}: {}", cve_id, e);
            Ok(HttpResponse::InternalServerError().json(serde_json::json!({
                "success": false,
                "error": format!("Failed to get exploits: {}", e)
            })))
        }
    }
}

/// GET /api/exploit-research/cve-mapping/{cve_id} - Get CVE to exploit mapping
pub async fn get_cve_mapping(
    state: web::Data<ExploitResearchState>,
    path: web::Path<String>,
    _claims: web::ReqData<Claims>,
) -> Result<HttpResponse> {
    let cve_id = path.into_inner();
    debug!("Getting CVE mapping for: {}", cve_id);

    let mut engine = state.cve_engine.write().await;
    match engine.get_mapping(&cve_id).await {
        Ok(mapping) => {
            Ok(HttpResponse::Ok().json(CveMappingResponse {
                success: true,
                mapping,
            }))
        }
        Err(e) => {
            error!("Failed to get CVE mapping for {}: {}", cve_id, e);
            Ok(HttpResponse::InternalServerError().json(serde_json::json!({
                "success": false,
                "error": format!("Failed to get mapping: {}", e)
            })))
        }
    }
}

/// POST /api/exploit-research/cve-mapping/batch - Get mappings for multiple CVEs
pub async fn get_batch_cve_mappings(
    state: web::Data<ExploitResearchState>,
    body: web::Json<BatchCveMappingRequest>,
    _claims: web::ReqData<Claims>,
) -> Result<HttpResponse> {
    debug!("Getting batch CVE mappings for {} CVEs", body.cve_ids.len());

    let mut engine = state.cve_engine.write().await;
    match engine.get_mappings(&body.cve_ids).await {
        Ok(mappings) => {
            Ok(HttpResponse::Ok().json(BatchCveMappingResponse {
                success: true,
                mappings,
            }))
        }
        Err(e) => {
            error!("Failed to get batch CVE mappings: {}", e);
            Ok(HttpResponse::InternalServerError().json(serde_json::json!({
                "success": false,
                "error": format!("Failed to get mappings: {}", e)
            })))
        }
    }
}

/// GET /api/exploit-research/sync-status - Get sync status for all sources
pub async fn get_sync_status(
    state: web::Data<ExploitResearchState>,
    _claims: web::ReqData<Claims>,
) -> Result<HttpResponse> {
    let engine = state.cve_engine.read().await;
    let statuses = engine.get_all_sync_status();

    let sources: Vec<SourceSyncStatus> = statuses.into_iter().map(|s| {
        SourceSyncStatus {
            source: format!("{:?}", s.source),
            last_sync_at: s.last_sync_at.map(|t| t.to_rfc3339()),
            total_exploits: s.total_exploits,
            new_since_last_sync: s.new_since_last_sync,
            sync_in_progress: s.sync_in_progress,
            last_error: s.last_error,
        }
    }).collect();

    Ok(HttpResponse::Ok().json(SyncStatusResponse {
        success: true,
        sources,
    }))
}

/// GET /api/exploit-research/stats - Get overall statistics
pub async fn get_stats(
    state: web::Data<ExploitResearchState>,
    pool: web::Data<SqlitePool>,
    _claims: web::ReqData<Claims>,
) -> Result<HttpResponse> {
    let engine = state.cve_engine.read().await;
    let poc_repo = state.poc_repo.read().await;
    let notes_manager = state.notes_manager.read().await;

    let sync_statuses = engine.get_all_sync_status();
    let poc_stats = poc_repo.stats();
    let notes_stats = notes_manager.stats();

    // Get cached exploit count from database
    let cached_count: i64 = sqlx::query_scalar("SELECT COUNT(*) FROM exploits")
        .fetch_one(pool.get_ref())
        .await
        .unwrap_or(0);

    let sources: Vec<SourceSyncStatus> = sync_statuses.into_iter().map(|s| {
        SourceSyncStatus {
            source: format!("{:?}", s.source),
            last_sync_at: s.last_sync_at.map(|t| t.to_rfc3339()),
            total_exploits: s.total_exploits,
            new_since_last_sync: s.new_since_last_sync,
            sync_in_progress: s.sync_in_progress,
            last_error: s.last_error,
        }
    }).collect();

    Ok(HttpResponse::Ok().json(ExploitResearchStatsResponse {
        success: true,
        total_exploits_cached: cached_count as u64,
        total_pocs: poc_stats.total_pocs,
        total_notes: notes_stats.total_notes,
        total_workspaces: notes_stats.total_workspaces,
        active_workspaces: notes_stats.active_workspaces,
        sources,
    }))
}

// ==================== PoC Repository Endpoints ====================

/// GET /api/exploit-research/pocs - List PoCs
pub async fn list_pocs(
    state: web::Data<ExploitResearchState>,
    query: web::Query<PocFilterQuery>,
    _claims: web::ReqData<Claims>,
) -> Result<HttpResponse> {
    let poc_repo = state.poc_repo.read().await;

    let filter = if query.status.is_some() || query.language.is_some() ||
                    query.cve_id.is_some() || query.author.is_some() || query.query.is_some() {
        Some(PocFilter {
            status: query.status.as_ref().and_then(|s| parse_poc_status(s)),
            language: query.language.as_ref().and_then(|l| parse_language(l)),
            cve_id: query.cve_id.clone(),
            author: query.author.clone(),
            query: query.query.clone(),
        })
    } else {
        None
    };

    let pocs: Vec<PocEntry> = poc_repo.list(filter).into_iter().cloned().collect();
    let total = pocs.len();

    Ok(HttpResponse::Ok().json(PocListResponse {
        success: true,
        pocs,
        total,
    }))
}

#[derive(Debug, Deserialize)]
pub struct PocFilterQuery {
    pub status: Option<String>,
    pub language: Option<String>,
    pub cve_id: Option<String>,
    pub author: Option<String>,
    pub query: Option<String>,
}

/// POST /api/exploit-research/pocs - Create PoC
pub async fn create_poc(
    state: web::Data<ExploitResearchState>,
    body: web::Json<CreatePocApiRequest>,
    claims: web::ReqData<Claims>,
) -> Result<HttpResponse> {
    let mut poc_repo = state.poc_repo.write().await;

    let request = CreatePocRequest {
        cve_id: body.cve_id.clone(),
        exploit_id: body.exploit_id.clone(),
        title: body.title.clone(),
        description: body.description.clone(),
        language: body.language.as_ref().and_then(|l| parse_language(l)),
        code: body.code.clone(),
        author: Some(claims.username.clone()),
        tags: body.tags.clone().unwrap_or_default(),
        target_info: body.target_info.clone(),
        requirements: body.requirements.clone(),
    };

    match poc_repo.create(request) {
        Ok(poc) => {
            info!("Created PoC: {} by {}", poc.id, claims.username);
            Ok(HttpResponse::Created().json(PocDetailResponse {
                success: true,
                poc,
            }))
        }
        Err(e) => {
            error!("Failed to create PoC: {}", e);
            Ok(HttpResponse::InternalServerError().json(serde_json::json!({
                "success": false,
                "error": format!("Failed to create PoC: {}", e)
            })))
        }
    }
}

/// GET /api/exploit-research/pocs/{id} - Get PoC details
pub async fn get_poc(
    state: web::Data<ExploitResearchState>,
    path: web::Path<String>,
    _claims: web::ReqData<Claims>,
) -> Result<HttpResponse> {
    let id = path.into_inner();
    let poc_repo = state.poc_repo.read().await;

    match poc_repo.get(&id) {
        Some(poc) => {
            Ok(HttpResponse::Ok().json(PocDetailResponse {
                success: true,
                poc: poc.clone(),
            }))
        }
        None => {
            Ok(HttpResponse::NotFound().json(serde_json::json!({
                "success": false,
                "error": "PoC not found"
            })))
        }
    }
}

/// PUT /api/exploit-research/pocs/{id} - Update PoC
pub async fn update_poc(
    state: web::Data<ExploitResearchState>,
    path: web::Path<String>,
    body: web::Json<UpdatePocApiRequest>,
    claims: web::ReqData<Claims>,
) -> Result<HttpResponse> {
    let id = path.into_inner();
    let mut poc_repo = state.poc_repo.write().await;

    let request = UpdatePocRequest {
        title: body.title.clone(),
        description: body.description.clone(),
        status: body.status.as_ref().and_then(|s| parse_poc_status(s)),
        tags: body.tags.clone(),
        target_info: body.target_info.clone(),
        requirements: body.requirements.clone(),
        code: body.code.clone(),
        changelog: body.changelog.clone(),
        updated_by: Some(claims.username.clone()),
    };

    match poc_repo.update(&id, request) {
        Ok(poc) => {
            info!("Updated PoC: {} by {}", id, claims.username);
            Ok(HttpResponse::Ok().json(PocDetailResponse {
                success: true,
                poc,
            }))
        }
        Err(e) => {
            error!("Failed to update PoC {}: {}", id, e);
            Ok(HttpResponse::InternalServerError().json(serde_json::json!({
                "success": false,
                "error": format!("Failed to update PoC: {}", e)
            })))
        }
    }
}

/// DELETE /api/exploit-research/pocs/{id} - Delete PoC
pub async fn delete_poc(
    state: web::Data<ExploitResearchState>,
    path: web::Path<String>,
    claims: web::ReqData<Claims>,
) -> Result<HttpResponse> {
    let id = path.into_inner();
    let mut poc_repo = state.poc_repo.write().await;

    match poc_repo.delete(&id) {
        Ok(()) => {
            info!("Deleted PoC: {} by {}", id, claims.username);
            Ok(HttpResponse::Ok().json(serde_json::json!({
                "success": true,
                "message": "PoC deleted"
            })))
        }
        Err(e) => {
            error!("Failed to delete PoC {}: {}", id, e);
            Ok(HttpResponse::InternalServerError().json(serde_json::json!({
                "success": false,
                "error": format!("Failed to delete PoC: {}", e)
            })))
        }
    }
}

/// GET /api/exploit-research/pocs/{id}/code - Get PoC code
pub async fn get_poc_code(
    state: web::Data<ExploitResearchState>,
    path: web::Path<String>,
    query: web::Query<CodeVersionQuery>,
    _claims: web::ReqData<Claims>,
) -> Result<HttpResponse> {
    let id = path.into_inner();
    let poc_repo = state.poc_repo.read().await;

    let result = if let Some(ref version) = query.version {
        poc_repo.get_code_version(&id, version)
    } else {
        poc_repo.get_code(&id)
    };

    match result {
        Ok(code) => {
            Ok(HttpResponse::Ok().json(PocCodeResponse {
                success: true,
                code,
                version: query.version.clone(),
            }))
        }
        Err(e) => {
            Ok(HttpResponse::NotFound().json(serde_json::json!({
                "success": false,
                "error": format!("Failed to get code: {}", e)
            })))
        }
    }
}

#[derive(Debug, Deserialize)]
pub struct CodeVersionQuery {
    pub version: Option<String>,
}

/// POST /api/exploit-research/pocs/{id}/test - Add test result
pub async fn add_poc_test_result(
    state: web::Data<ExploitResearchState>,
    path: web::Path<String>,
    body: web::Json<TestResultRequest>,
    claims: web::ReqData<Claims>,
) -> Result<HttpResponse> {
    let id = path.into_inner();
    let mut poc_repo = state.poc_repo.write().await;

    // Check if PoC exists
    if poc_repo.get(&id).is_none() {
        return Ok(HttpResponse::NotFound().json(serde_json::json!({
            "success": false,
            "error": "PoC not found"
        })));
    }

    let result = PocTestResults {
        tested_at: Utc::now(),
        success: body.success,
        target_info: body.target_info.clone(),
        output: body.output.clone(),
        error: body.error_message.clone(),
        execution_time_ms: body.execution_time_ms.unwrap_or(0),
        notes: Some(format!("Tested by {}", claims.username)),
    };

    match poc_repo.add_test_result(&id, result) {
        Ok(()) => {
            info!("Added test result for PoC {} by {}", id, claims.username);
            Ok(HttpResponse::Ok().json(serde_json::json!({
                "success": true,
                "message": "Test result added"
            })))
        }
        Err(e) => {
            error!("Failed to add test result for PoC {}: {}", id, e);
            Ok(HttpResponse::InternalServerError().json(serde_json::json!({
                "success": false,
                "error": format!("Failed to add test result: {}", e)
            })))
        }
    }
}

// ==================== Research Notes Endpoints ====================

/// GET /api/exploit-research/notes - List research notes
pub async fn list_notes(
    state: web::Data<ExploitResearchState>,
    query: web::Query<NoteFilterQuery>,
    claims: web::ReqData<Claims>,
) -> Result<HttpResponse> {
    let notes_manager = state.notes_manager.read().await;

    let filter = if query.visibility.is_some() || query.tag.is_some() || query.query.is_some() {
        Some(NoteFilter {
            author: Some(claims.username.clone()), // Only show user's own notes by default
            visibility: query.visibility.as_ref().and_then(|v| parse_visibility(v)),
            query: query.query.clone(),
            tag: query.tag.clone(),
        })
    } else {
        Some(NoteFilter {
            author: Some(claims.username.clone()),
            ..Default::default()
        })
    };

    let notes: Vec<ResearchNote> = notes_manager.list_notes(filter).into_iter().cloned().collect();
    let total = notes.len();

    Ok(HttpResponse::Ok().json(NoteListResponse {
        success: true,
        notes,
        total,
    }))
}

#[derive(Debug, Deserialize)]
pub struct NoteFilterQuery {
    pub visibility: Option<String>,
    pub tag: Option<String>,
    pub query: Option<String>,
}

/// POST /api/exploit-research/notes - Create research note
pub async fn create_note(
    state: web::Data<ExploitResearchState>,
    body: web::Json<CreateNoteApiRequest>,
    claims: web::ReqData<Claims>,
) -> Result<HttpResponse> {
    let mut notes_manager = state.notes_manager.write().await;

    let references: Vec<ExternalReference> = body.references.as_ref()
        .map(|refs| refs.iter().map(|r| ExternalReference {
            title: r.title.clone(),
            url: r.url.clone(),
            reference_type: parse_reference_type(&r.reference_type),
            notes: r.notes.clone(),
        }).collect())
        .unwrap_or_default();

    let request = CreateResearchNoteRequest {
        title: body.title.clone(),
        content: body.content.clone(),
        cve_ids: body.cve_ids.clone().unwrap_or_default(),
        exploit_ids: body.exploit_ids.clone().unwrap_or_default(),
        poc_ids: body.poc_ids.clone().unwrap_or_default(),
        tags: body.tags.clone().unwrap_or_default(),
        references,
        author: Some(claims.username.clone()),
        visibility: parse_visibility(body.visibility.as_deref().unwrap_or("private")),
    };

    match notes_manager.create_note(request) {
        Ok(note) => {
            info!("Created research note: {} by {}", note.id, claims.username);
            Ok(HttpResponse::Created().json(NoteDetailResponse {
                success: true,
                note,
            }))
        }
        Err(e) => {
            error!("Failed to create note: {}", e);
            Ok(HttpResponse::InternalServerError().json(serde_json::json!({
                "success": false,
                "error": format!("Failed to create note: {}", e)
            })))
        }
    }
}

/// GET /api/exploit-research/notes/{id} - Get research note
pub async fn get_note(
    state: web::Data<ExploitResearchState>,
    path: web::Path<String>,
    _claims: web::ReqData<Claims>,
) -> Result<HttpResponse> {
    let id = path.into_inner();
    let notes_manager = state.notes_manager.read().await;

    match notes_manager.get_note(&id) {
        Some(note) => {
            Ok(HttpResponse::Ok().json(NoteDetailResponse {
                success: true,
                note: note.clone(),
            }))
        }
        None => {
            Ok(HttpResponse::NotFound().json(serde_json::json!({
                "success": false,
                "error": "Note not found"
            })))
        }
    }
}

/// PUT /api/exploit-research/notes/{id} - Update research note
pub async fn update_note(
    state: web::Data<ExploitResearchState>,
    path: web::Path<String>,
    body: web::Json<UpdateNoteApiRequest>,
    claims: web::ReqData<Claims>,
) -> Result<HttpResponse> {
    let id = path.into_inner();
    let mut notes_manager = state.notes_manager.write().await;

    let references: Option<Vec<ExternalReference>> = body.references.as_ref()
        .map(|refs| refs.iter().map(|r| ExternalReference {
            title: r.title.clone(),
            url: r.url.clone(),
            reference_type: parse_reference_type(&r.reference_type),
            notes: r.notes.clone(),
        }).collect());

    let request = UpdateResearchNoteRequest {
        title: body.title.clone(),
        content: body.content.clone(),
        cve_ids: body.cve_ids.clone(),
        exploit_ids: body.exploit_ids.clone(),
        poc_ids: body.poc_ids.clone(),
        tags: body.tags.clone(),
        references,
        visibility: body.visibility.as_ref().and_then(|v| parse_visibility(v)),
    };

    match notes_manager.update_note(&id, request) {
        Ok(note) => {
            info!("Updated research note: {} by {}", id, claims.username);
            Ok(HttpResponse::Ok().json(NoteDetailResponse {
                success: true,
                note,
            }))
        }
        Err(e) => {
            error!("Failed to update note {}: {}", id, e);
            Ok(HttpResponse::InternalServerError().json(serde_json::json!({
                "success": false,
                "error": format!("Failed to update note: {}", e)
            })))
        }
    }
}

/// DELETE /api/exploit-research/notes/{id} - Delete research note
pub async fn delete_note(
    state: web::Data<ExploitResearchState>,
    path: web::Path<String>,
    claims: web::ReqData<Claims>,
) -> Result<HttpResponse> {
    let id = path.into_inner();
    let mut notes_manager = state.notes_manager.write().await;

    match notes_manager.delete_note(&id) {
        Ok(()) => {
            info!("Deleted research note: {} by {}", id, claims.username);
            Ok(HttpResponse::Ok().json(serde_json::json!({
                "success": true,
                "message": "Note deleted"
            })))
        }
        Err(e) => {
            error!("Failed to delete note {}: {}", id, e);
            Ok(HttpResponse::InternalServerError().json(serde_json::json!({
                "success": false,
                "error": format!("Failed to delete note: {}", e)
            })))
        }
    }
}

// ==================== Research Workspaces Endpoints ====================

/// GET /api/exploit-research/workspaces - List workspaces
pub async fn list_workspaces(
    state: web::Data<ExploitResearchState>,
    query: web::Query<WorkspaceFilterQuery>,
    _claims: web::ReqData<Claims>,
) -> Result<HttpResponse> {
    let notes_manager = state.notes_manager.read().await;

    let filter = if query.status.is_some() || query.query.is_some() {
        Some(WorkspaceFilter {
            status: query.status.as_ref().and_then(|s| parse_workspace_status(s)),
            query: query.query.clone(),
        })
    } else {
        None
    };

    let workspaces: Vec<CveResearchWorkspace> = notes_manager.list_workspaces(filter)
        .into_iter().cloned().collect();
    let total = workspaces.len();

    Ok(HttpResponse::Ok().json(WorkspaceListResponse {
        success: true,
        workspaces,
        total,
    }))
}

#[derive(Debug, Deserialize)]
pub struct WorkspaceFilterQuery {
    pub status: Option<String>,
    pub query: Option<String>,
}

/// POST /api/exploit-research/workspaces - Create workspace
pub async fn create_workspace(
    state: web::Data<ExploitResearchState>,
    body: web::Json<CreateWorkspaceRequest>,
    claims: web::ReqData<Claims>,
) -> Result<HttpResponse> {
    let mut notes_manager = state.notes_manager.write().await;

    match notes_manager.create_workspace(&body.cve_id, body.title.clone()) {
        Ok(workspace) => {
            info!("Created workspace: {} for {} by {}", workspace.id, body.cve_id, claims.username);
            Ok(HttpResponse::Created().json(WorkspaceDetailResponse {
                success: true,
                workspace,
            }))
        }
        Err(e) => {
            error!("Failed to create workspace: {}", e);
            Ok(HttpResponse::InternalServerError().json(serde_json::json!({
                "success": false,
                "error": format!("Failed to create workspace: {}", e)
            })))
        }
    }
}

/// GET /api/exploit-research/workspaces/{id} - Get workspace
pub async fn get_workspace(
    state: web::Data<ExploitResearchState>,
    path: web::Path<String>,
    _claims: web::ReqData<Claims>,
) -> Result<HttpResponse> {
    let id = path.into_inner();
    let notes_manager = state.notes_manager.read().await;

    match notes_manager.get_workspace(&id) {
        Some(workspace) => {
            Ok(HttpResponse::Ok().json(WorkspaceDetailResponse {
                success: true,
                workspace: workspace.clone(),
            }))
        }
        None => {
            Ok(HttpResponse::NotFound().json(serde_json::json!({
                "success": false,
                "error": "Workspace not found"
            })))
        }
    }
}

/// PUT /api/exploit-research/workspaces/{id} - Update workspace
pub async fn update_workspace(
    state: web::Data<ExploitResearchState>,
    path: web::Path<String>,
    body: web::Json<UpdateWorkspaceApiRequest>,
    claims: web::ReqData<Claims>,
) -> Result<HttpResponse> {
    let id = path.into_inner();
    let mut notes_manager = state.notes_manager.write().await;

    let update = WorkspaceUpdate {
        title: body.title.clone(),
        status: body.status.as_ref().and_then(|s| parse_workspace_status(s)),
    };

    match notes_manager.update_workspace(&id, update) {
        Ok(workspace) => {
            info!("Updated workspace: {} by {}", id, claims.username);
            Ok(HttpResponse::Ok().json(WorkspaceDetailResponse {
                success: true,
                workspace,
            }))
        }
        Err(e) => {
            error!("Failed to update workspace {}: {}", id, e);
            Ok(HttpResponse::InternalServerError().json(serde_json::json!({
                "success": false,
                "error": format!("Failed to update workspace: {}", e)
            })))
        }
    }
}

/// DELETE /api/exploit-research/workspaces/{id} - Delete workspace
pub async fn delete_workspace(
    state: web::Data<ExploitResearchState>,
    path: web::Path<String>,
    claims: web::ReqData<Claims>,
) -> Result<HttpResponse> {
    let id = path.into_inner();
    let mut notes_manager = state.notes_manager.write().await;

    match notes_manager.delete_workspace(&id) {
        Ok(()) => {
            info!("Deleted workspace: {} by {}", id, claims.username);
            Ok(HttpResponse::Ok().json(serde_json::json!({
                "success": true,
                "message": "Workspace deleted"
            })))
        }
        Err(e) => {
            error!("Failed to delete workspace {}: {}", id, e);
            Ok(HttpResponse::InternalServerError().json(serde_json::json!({
                "success": false,
                "error": format!("Failed to delete workspace: {}", e)
            })))
        }
    }
}

/// POST /api/exploit-research/workspaces/{id}/items - Add item to workspace
pub async fn add_item_to_workspace(
    state: web::Data<ExploitResearchState>,
    path: web::Path<String>,
    body: web::Json<AddToWorkspaceRequest>,
    claims: web::ReqData<Claims>,
) -> Result<HttpResponse> {
    let id = path.into_inner();
    let mut notes_manager = state.notes_manager.write().await;

    let result = match body.item_type.as_str() {
        "exploit" => {
            if let Some(ref item_id) = body.item_id {
                notes_manager.add_exploit_to_workspace(&id, item_id)
            } else {
                return Ok(HttpResponse::BadRequest().json(serde_json::json!({
                    "success": false,
                    "error": "item_id required for exploit"
                })));
            }
        }
        "poc" => {
            if let Some(ref item_id) = body.item_id {
                notes_manager.add_poc_to_workspace(&id, item_id)
            } else {
                return Ok(HttpResponse::BadRequest().json(serde_json::json!({
                    "success": false,
                    "error": "item_id required for poc"
                })));
            }
        }
        "note" => {
            if let Some(ref item_id) = body.item_id {
                notes_manager.add_note_to_workspace(&id, item_id)
            } else {
                return Ok(HttpResponse::BadRequest().json(serde_json::json!({
                    "success": false,
                    "error": "item_id required for note"
                })));
            }
        }
        "reference" => {
            if let Some(ref ref_req) = body.reference {
                let reference = ExternalReference {
                    title: ref_req.title.clone(),
                    url: ref_req.url.clone(),
                    reference_type: parse_reference_type(&ref_req.reference_type),
                    notes: ref_req.notes.clone(),
                };
                notes_manager.add_reference_to_workspace(&id, reference)
            } else {
                return Ok(HttpResponse::BadRequest().json(serde_json::json!({
                    "success": false,
                    "error": "reference required for reference type"
                })));
            }
        }
        _ => {
            return Ok(HttpResponse::BadRequest().json(serde_json::json!({
                "success": false,
                "error": "Invalid item_type. Must be: exploit, poc, note, or reference"
            })));
        }
    };

    match result {
        Ok(()) => {
            info!("Added {} to workspace {} by {}", body.item_type, id, claims.username);
            Ok(HttpResponse::Ok().json(serde_json::json!({
                "success": true,
                "message": format!("{} added to workspace", body.item_type)
            })))
        }
        Err(e) => {
            error!("Failed to add item to workspace {}: {}", id, e);
            Ok(HttpResponse::InternalServerError().json(serde_json::json!({
                "success": false,
                "error": format!("Failed to add item: {}", e)
            })))
        }
    }
}

/// GET /api/exploit-research/workspaces/{id}/export - Export workspace as markdown
pub async fn export_workspace(
    state: web::Data<ExploitResearchState>,
    path: web::Path<String>,
    _claims: web::ReqData<Claims>,
) -> Result<HttpResponse> {
    let id = path.into_inner();
    let notes_manager = state.notes_manager.read().await;

    match notes_manager.export_workspace_markdown(&id) {
        Ok(markdown) => {
            Ok(HttpResponse::Ok()
                .content_type("text/markdown")
                .body(markdown))
        }
        Err(e) => {
            Ok(HttpResponse::NotFound().json(serde_json::json!({
                "success": false,
                "error": format!("Failed to export workspace: {}", e)
            })))
        }
    }
}

// ==================== Sprint 2: Sandbox Endpoints ====================

/// POST /api/exploit-research/pocs/{id}/sandbox - Execute PoC in sandbox
pub async fn execute_poc_in_sandbox(
    state: web::Data<ExploitResearchState>,
    pool: web::Data<SqlitePool>,
    path: web::Path<String>,
    body: web::Json<SandboxExecutionApiRequest>,
    claims: web::ReqData<Claims>,
) -> Result<HttpResponse> {
    let poc_id = path.into_inner();
    debug!("Executing PoC {} in sandbox", poc_id);

    // Verify PoC exists and get code
    let poc_repo = state.poc_repo.read().await;
    let poc = match poc_repo.get(&poc_id) {
        Some(p) => p.clone(),
        None => {
            return Ok(HttpResponse::NotFound().json(serde_json::json!({
                "success": false,
                "error": "PoC not found"
            })));
        }
    };

    // Get the actual code
    let code = match poc_repo.get_code(&poc_id) {
        Ok(c) => c,
        Err(e) => {
            return Ok(HttpResponse::InternalServerError().json(serde_json::json!({
                "success": false,
                "error": format!("Failed to get PoC code: {}", e)
            })));
        }
    };
    drop(poc_repo);

    // Parse sandbox type and OS
    let sandbox_type = parse_sandbox_type(&body.sandbox_type).unwrap_or(SandboxType::Docker);
    let target_os = parse_sandbox_os(&body.target_os).unwrap_or(SandboxOS::Ubuntu22);

    // Build execution request
    let execution_id = uuid::Uuid::new_v4().to_string();
    let target_info = body.target_host.as_ref().map(|host| {
        TargetInfo {
            host: host.clone(),
            port: body.target_port,
            service: None,
            version: None,
            metadata: std::collections::HashMap::new(),
        }
    });

    // Build sandbox config
    let mut limits = ResourceLimits::default();
    limits.timeout_seconds = body.timeout_seconds.unwrap_or(300) as u32;

    let config = SandboxConfig {
        sandbox_type: sandbox_type.clone(),
        target_os: target_os.clone(),
        network: NetworkConfig {
            enabled: true,
            capture_traffic: true,
            internet_access: !body.isolated_network.unwrap_or(false),
            dns_servers: vec!["8.8.8.8".to_string()],
            port_forwards: vec![],
        },
        limits,
        environment: std::collections::HashMap::new(),
        inject_files: vec![],
        setup_commands: vec![],
        cleanup_commands: vec![],
        capture_screenshots: false,
        record_video: false,
        monitor_api_calls: false,
        monitor_filesystem: true,
        monitor_registry: true,
        monitor_processes: true,
    };

    let request = SandboxExecutionRequest {
        poc_id: poc_id.clone(),
        code,
        language: format!("{:?}", poc.language),
        config,
        target_info,
        arguments: body.additional_args.clone().unwrap_or_default(),
        test_description: None,
    };

    // Execute in sandbox
    let sandbox_manager = state.sandbox_manager.read().await;
    let result = sandbox_manager.execute(request).await;
    drop(sandbox_manager);

    // Store execution record in database
    let status = match &result {
        Ok(r) if r.status == SandboxStatus::Completed => "completed",
        Ok(_) => "failed",
        Err(_) => "error",
    };

    let success_detected = result.as_ref()
        .map(|r| r.status == SandboxStatus::Completed && !r.success_indicators.is_empty())
        .unwrap_or(false);
    let execution_time_ms = result.as_ref().map(|r| r.duration_ms as i64).unwrap_or(0);
    let stdout = result.as_ref().map(|r| r.stdout.clone()).unwrap_or_default();
    let stderr = result.as_ref().map(|r| r.stderr.clone()).unwrap_or_default();
    let exit_code = result.as_ref().ok().and_then(|r| r.exit_code);
    let error_msg = result.as_ref().ok().and_then(|r| r.error_message.clone());

    let _ = sqlx::query(
        r#"INSERT INTO sandbox_executions
           (id, poc_id, user_id, sandbox_type, target_os, status, success_detected,
            execution_time_ms, stdout, stderr, exit_code, error_message, created_at)
           VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)"#
    )
    .bind(&execution_id)
    .bind(&poc_id)
    .bind(&claims.sub)
    .bind(format!("{:?}", sandbox_type))
    .bind(format!("{}", target_os))
    .bind(status)
    .bind(success_detected)
    .bind(execution_time_ms)
    .bind(&stdout)
    .bind(&stderr)
    .bind(exit_code)
    .bind(&error_msg)
    .execute(pool.get_ref())
    .await;

    // Also record a timeline event
    let _ = sqlx::query(
        r#"INSERT INTO exploit_timeline_events
           (id, poc_id, event_type, title, description, user_id, created_at)
           VALUES (?, ?, 'sandbox_execution', ?, ?, ?, CURRENT_TIMESTAMP)"#
    )
    .bind(uuid::Uuid::new_v4().to_string())
    .bind(&poc_id)
    .bind(format!("Sandbox execution: {}", if success_detected { "Success" } else { "Failed" }))
    .bind(format!("Executed in {:?} on {}", sandbox_type, target_os))
    .bind(&claims.sub)
    .execute(pool.get_ref())
    .await;

    info!("Sandbox execution {} for PoC {} by {}: {}", execution_id, poc_id, claims.username, status);

    match result {
        Ok(exec_result) => {
            let artifacts: Vec<String> = exec_result.artifacts.iter()
                .map(|a| format!("{}: {}", a.artifact_type, a.path))
                .collect();
            let network_connections: Vec<String> = exec_result.network_activity.iter()
                .map(|n| format!("{}:{} -> {}:{}", n.src_ip, n.src_port, n.dst_ip, n.dst_port))
                .collect();

            Ok(HttpResponse::Ok().json(SandboxExecutionResponse {
                success: true,
                execution_id,
                status: status.to_string(),
                result: Some(SandboxExecutionResultResponse {
                    exit_code: exec_result.exit_code,
                    stdout: exec_result.stdout,
                    stderr: exec_result.stderr,
                    execution_time_ms: exec_result.duration_ms,
                    success_detected,
                    artifacts_collected: artifacts,
                    network_connections,
                }),
                error: None,
            }))
        }
        Err(e) => {
            Ok(HttpResponse::Ok().json(SandboxExecutionResponse {
                success: false,
                execution_id,
                status: "error".to_string(),
                result: None,
                error: Some(e.to_string()),
            }))
        }
    }
}

/// GET /api/exploit-research/pocs/{id}/sandbox-history - Get sandbox execution history
pub async fn get_sandbox_history(
    pool: web::Data<SqlitePool>,
    path: web::Path<String>,
    _claims: web::ReqData<Claims>,
) -> Result<HttpResponse> {
    let poc_id = path.into_inner();

    let executions: Vec<(String, String, String, String, String, bool, i64, String, String)> = sqlx::query_as(
        r#"SELECT id, poc_id, sandbox_type, target_os, status, success_detected,
                  execution_time_ms, created_at, user_id
           FROM sandbox_executions
           WHERE poc_id = ?
           ORDER BY created_at DESC
           LIMIT 50"#
    )
    .bind(&poc_id)
    .fetch_all(pool.get_ref())
    .await
    .unwrap_or_default();

    let entries: Vec<SandboxExecutionHistoryEntry> = executions.into_iter().map(|row| {
        SandboxExecutionHistoryEntry {
            id: row.0,
            poc_id: row.1,
            sandbox_type: row.2,
            target_os: row.3,
            status: row.4,
            success_detected: row.5,
            execution_time_ms: row.6 as u64,
            executed_at: row.7,
            executed_by: row.8,
        }
    }).collect();

    let total = entries.len();
    Ok(HttpResponse::Ok().json(SandboxHistoryResponse {
        success: true,
        executions: entries,
        total,
    }))
}

/// GET /api/exploit-research/sandbox/environments - List available sandbox environments
pub async fn list_sandbox_environments(
    state: web::Data<ExploitResearchState>,
    _claims: web::ReqData<Claims>,
) -> Result<HttpResponse> {
    let sandbox_manager = state.sandbox_manager.read().await;
    let envs = sandbox_manager.list_environments();

    let environments: Vec<SandboxEnvironmentResponse> = envs.into_iter().map(|env| {
        SandboxEnvironmentResponse {
            id: env.image.clone(),
            name: format!("{} ({})", env.os, env.sandbox_type),
            sandbox_type: format!("{}", env.sandbox_type),
            os: format!("{}", env.os),
            status: if env.available { "ready".to_string() } else { "unavailable".to_string() },
            is_ready: env.available,
        }
    }).collect();

    Ok(HttpResponse::Ok().json(SandboxEnvironmentsResponse {
        success: true,
        environments,
    }))
}

// ==================== Sprint 2: Effectiveness Scoring Endpoints ====================

/// GET /api/exploit-research/pocs/{id}/effectiveness - Get effectiveness score
pub async fn get_poc_effectiveness(
    state: web::Data<ExploitResearchState>,
    pool: web::Data<SqlitePool>,
    path: web::Path<String>,
    _claims: web::ReqData<Claims>,
) -> Result<HttpResponse> {
    let poc_id = path.into_inner();

    // Check if we have a cached score
    let cached: Option<(i64, String, i64, i64, i64, i64, String)> = sqlx::query_as(
        r#"SELECT total_score, rating, reliability_score, impact_score, maturity_score,
                  community_score, recommendations
           FROM poc_effectiveness_scores
           WHERE poc_id = ?
           ORDER BY created_at DESC
           LIMIT 1"#
    )
    .bind(&poc_id)
    .fetch_optional(pool.get_ref())
    .await
    .ok()
    .flatten();

    if let Some(score) = cached {
        let recommendations: Vec<String> = serde_json::from_str(&score.6).unwrap_or_default();
        return Ok(HttpResponse::Ok().json(EffectivenessScoreResponse {
            success: true,
            poc_id,
            score: EffectivenessScoreDetail {
                total_score: score.0 as u32,
                rating: score.1,
                reliability_score: score.2 as u32,
                impact_score: score.3 as u32,
                maturity_score: score.4 as u32,
                community_score: score.5 as u32,
                breakdown: ScoreBreakdown {
                    success_rate_contribution: 0,
                    complexity_contribution: 0,
                    target_range_contribution: 0,
                    documentation_contribution: 0,
                    external_ratings_contribution: 0,
                },
                recommendations,
            },
        }));
    }

    // No cached score - compute from PoC data
    let poc_repo = state.poc_repo.read().await;
    let poc = match poc_repo.get(&poc_id) {
        Some(p) => p.clone(),
        None => {
            return Ok(HttpResponse::NotFound().json(serde_json::json!({
                "success": false,
                "error": "PoC not found"
            })));
        }
    };

    // Build effectiveness input from PoC data
    let input = EffectivenessInput {
        poc_id: poc_id.clone(),
        test_results: poc.test_results.clone(),
        sandbox_results: vec![], // Would need to fetch from DB
        complexity: Some(ComplexityLevel::Medium),
        impact: Some(ImpactSeverity::Medium),
        has_documentation: poc.description.is_some(),
        version_count: poc.versions.len() as u32,
        peer_reviewed: matches!(poc.status, PocStatus::Verified),
        external_ratings: vec![],
        target_coverage: 1,
    };

    let score = state.effectiveness_calculator.calculate(&input);

    Ok(HttpResponse::Ok().json(EffectivenessScoreResponse {
        success: true,
        poc_id,
        score: EffectivenessScoreDetail {
            total_score: score.total_score,
            rating: format!("{:?}", score.rating),
            reliability_score: score.reliability_score,
            impact_score: score.impact_score,
            maturity_score: score.maturity_score,
            community_score: score.community_score,
            breakdown: ScoreBreakdown {
                success_rate_contribution: (score.reliability_score as f64 * 0.5) as u32,
                complexity_contribution: (score.reliability_score as f64 * 0.3) as u32,
                target_range_contribution: (score.impact_score as f64 * 0.4) as u32,
                documentation_contribution: (score.maturity_score as f64 * 0.4) as u32,
                external_ratings_contribution: score.community_score,
            },
            recommendations: score.recommendations,
        },
    }))
}

/// POST /api/exploit-research/pocs/{id}/effectiveness/calculate - Calculate and store effectiveness score
pub async fn calculate_poc_effectiveness(
    state: web::Data<ExploitResearchState>,
    pool: web::Data<SqlitePool>,
    path: web::Path<String>,
    body: web::Json<EffectivenessCalculateRequest>,
    claims: web::ReqData<Claims>,
) -> Result<HttpResponse> {
    let poc_id = path.into_inner();

    // Verify PoC exists
    let poc_repo = state.poc_repo.read().await;
    if poc_repo.get(&poc_id).is_none() {
        return Ok(HttpResponse::NotFound().json(serde_json::json!({
            "success": false,
            "error": "PoC not found"
        })));
    }
    drop(poc_repo);

    // Build effectiveness input from request
    let complexity = body.complexity.as_ref()
        .map(|c| parse_complexity(c));

    let impact = body.impact_severity.as_ref()
        .map(|i| parse_impact_severity(i));

    let external_ratings: Vec<ExternalRating> = body.external_ratings
        .as_ref()
        .map(|ratings| {
            ratings.iter().map(|r| ExternalRating {
                source: r.source.clone(),
                rating: r.rating.clone(),
                score: r.score,
            }).collect()
        })
        .unwrap_or_default();

    let input = EffectivenessInput {
        poc_id: poc_id.clone(),
        test_results: vec![],  // Could be fetched from PoC
        sandbox_results: vec![],
        complexity,
        impact,
        has_documentation: body.has_documentation.unwrap_or(false),
        version_count: body.version_count.unwrap_or(1),
        peer_reviewed: body.peer_reviewed.unwrap_or(false),
        external_ratings,
        target_coverage: body.target_coverage.unwrap_or(1),
    };

    let score = state.effectiveness_calculator.calculate(&input);

    // Store the calculated score
    let score_id = uuid::Uuid::new_v4().to_string();
    let recommendations_json = serde_json::to_string(&score.recommendations).unwrap_or_default();

    let _ = sqlx::query(
        r#"INSERT INTO poc_effectiveness_scores
           (id, poc_id, total_score, rating, reliability_score, impact_score,
            maturity_score, community_score, recommendations, calculated_by, created_at)
           VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)"#
    )
    .bind(&score_id)
    .bind(&poc_id)
    .bind(score.total_score as i64)
    .bind(format!("{:?}", score.rating))
    .bind(score.reliability_score as i64)
    .bind(score.impact_score as i64)
    .bind(score.maturity_score as i64)
    .bind(score.community_score as i64)
    .bind(&recommendations_json)
    .bind(&claims.sub)
    .execute(pool.get_ref())
    .await;

    // Record timeline event
    let _ = sqlx::query(
        r#"INSERT INTO exploit_timeline_events
           (id, poc_id, event_type, title, description, user_id, created_at)
           VALUES (?, ?, 'effectiveness_calculated', ?, ?, ?, CURRENT_TIMESTAMP)"#
    )
    .bind(uuid::Uuid::new_v4().to_string())
    .bind(&poc_id)
    .bind(format!("Effectiveness score: {} ({:?})", score.total_score, score.rating))
    .bind(format!("Reliability: {}, Impact: {}, Maturity: {}",
                  score.reliability_score, score.impact_score, score.maturity_score))
    .bind(&claims.sub)
    .execute(pool.get_ref())
    .await;

    info!("Calculated effectiveness for PoC {} by {}: {} ({:?})",
          poc_id, claims.username, score.total_score, score.rating);

    Ok(HttpResponse::Ok().json(EffectivenessScoreResponse {
        success: true,
        poc_id,
        score: EffectivenessScoreDetail {
            total_score: score.total_score,
            rating: format!("{:?}", score.rating),
            reliability_score: score.reliability_score,
            impact_score: score.impact_score,
            maturity_score: score.maturity_score,
            community_score: score.community_score,
            breakdown: ScoreBreakdown {
                success_rate_contribution: (score.reliability_score as f64 * 0.5) as u32,
                complexity_contribution: (score.reliability_score as f64 * 0.3) as u32,
                target_range_contribution: (score.impact_score as f64 * 0.4) as u32,
                documentation_contribution: (score.maturity_score as f64 * 0.4) as u32,
                external_ratings_contribution: score.community_score,
            },
            recommendations: score.recommendations,
        },
    }))
}

// ==================== Sprint 2: Timeline Events Endpoints ====================

/// GET /api/exploit-research/pocs/{id}/timeline - Get timeline events for a PoC
pub async fn get_poc_timeline(
    pool: web::Data<SqlitePool>,
    path: web::Path<String>,
    _claims: web::ReqData<Claims>,
) -> Result<HttpResponse> {
    let poc_id = path.into_inner();

    let events: Vec<(String, String, String, Option<String>, String, Option<String>, Option<String>)> = sqlx::query_as(
        r#"SELECT id, event_type, title, description, created_at, user_id, metadata
           FROM exploit_timeline_events
           WHERE poc_id = ?
           ORDER BY created_at DESC
           LIMIT 100"#
    )
    .bind(&poc_id)
    .fetch_all(pool.get_ref())
    .await
    .unwrap_or_default();

    let timeline: Vec<TimelineEventResponse> = events.into_iter().map(|row| {
        TimelineEventResponse {
            id: row.0,
            event_type: row.1,
            title: row.2,
            description: row.3,
            timestamp: row.4,
            user_id: row.5,
            metadata: row.6.and_then(|m| serde_json::from_str(&m).ok()),
        }
    }).collect();

    let total = timeline.len();
    Ok(HttpResponse::Ok().json(TimelineEventsResponse {
        success: true,
        events: timeline,
        total,
    }))
}

/// POST /api/exploit-research/pocs/{id}/timeline - Add timeline event for a PoC
pub async fn add_poc_timeline_event(
    pool: web::Data<SqlitePool>,
    path: web::Path<String>,
    body: web::Json<CreateTimelineEventRequest>,
    claims: web::ReqData<Claims>,
) -> Result<HttpResponse> {
    let poc_id = path.into_inner();
    let event_id = uuid::Uuid::new_v4().to_string();

    let metadata_json = body.metadata.as_ref()
        .map(|m| serde_json::to_string(m).unwrap_or_default());

    let result = sqlx::query(
        r#"INSERT INTO exploit_timeline_events
           (id, poc_id, event_type, title, description, user_id, metadata, created_at)
           VALUES (?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)"#
    )
    .bind(&event_id)
    .bind(&poc_id)
    .bind(&body.event_type)
    .bind(&body.title)
    .bind(&body.description)
    .bind(&claims.sub)
    .bind(&metadata_json)
    .execute(pool.get_ref())
    .await;

    match result {
        Ok(_) => {
            info!("Added timeline event {} for PoC {} by {}", event_id, poc_id, claims.username);
            Ok(HttpResponse::Created().json(serde_json::json!({
                "success": true,
                "event_id": event_id,
                "message": "Timeline event added"
            })))
        }
        Err(e) => {
            error!("Failed to add timeline event for PoC {}: {}", poc_id, e);
            Ok(HttpResponse::InternalServerError().json(serde_json::json!({
                "success": false,
                "error": format!("Failed to add timeline event: {}", e)
            })))
        }
    }
}

/// GET /api/exploit-research/workspaces/{id}/timeline - Get timeline events for a workspace
pub async fn get_workspace_timeline(
    pool: web::Data<SqlitePool>,
    path: web::Path<String>,
    _claims: web::ReqData<Claims>,
) -> Result<HttpResponse> {
    let workspace_id = path.into_inner();

    let events: Vec<(String, String, String, Option<String>, String, Option<String>, Option<String>)> = sqlx::query_as(
        r#"SELECT id, event_type, title, description, created_at, user_id, metadata
           FROM exploit_timeline_events
           WHERE workspace_id = ?
           ORDER BY created_at DESC
           LIMIT 100"#
    )
    .bind(&workspace_id)
    .fetch_all(pool.get_ref())
    .await
    .unwrap_or_default();

    let timeline: Vec<TimelineEventResponse> = events.into_iter().map(|row| {
        TimelineEventResponse {
            id: row.0,
            event_type: row.1,
            title: row.2,
            description: row.3,
            timestamp: row.4,
            user_id: row.5,
            metadata: row.6.and_then(|m| serde_json::from_str(&m).ok()),
        }
    }).collect();

    let total = timeline.len();
    Ok(HttpResponse::Ok().json(TimelineEventsResponse {
        success: true,
        events: timeline,
        total,
    }))
}

// ==================== Helper Functions ====================

fn parse_platform(s: &str) -> Option<ExploitPlatform> {
    match s.to_lowercase().as_str() {
        "windows" => Some(ExploitPlatform::Windows),
        "linux" => Some(ExploitPlatform::Linux),
        "macos" | "osx" => Some(ExploitPlatform::MacOS),
        "unix" => Some(ExploitPlatform::Unix),
        "freebsd" => Some(ExploitPlatform::FreeBSD),
        "android" => Some(ExploitPlatform::Android),
        "ios" => Some(ExploitPlatform::IOS),
        "multiple" => Some(ExploitPlatform::Multiple),
        "hardware" => Some(ExploitPlatform::Hardware),
        "php" => Some(ExploitPlatform::Php),
        "java" => Some(ExploitPlatform::Java),
        "webapps" => Some(ExploitPlatform::WebApps),
        _ => None,
    }
}

fn parse_exploit_type(s: &str) -> Option<ExploitType> {
    match s.to_lowercase().as_str() {
        "remote" => Some(ExploitType::Remote),
        "local" => Some(ExploitType::Local),
        "webapps" => Some(ExploitType::WebApps),
        "dos" => Some(ExploitType::Dos),
        "shellcode" => Some(ExploitType::Shellcode),
        "papers" => Some(ExploitType::Papers),
        _ => None,
    }
}

fn parse_source(s: &str) -> Option<ExploitSource> {
    match s.to_lowercase().as_str() {
        "exploitdb" | "exploit_db" | "exploit-db" => Some(ExploitSource::ExploitDb),
        "metasploit" | "msf" => Some(ExploitSource::Metasploit),
        "packetstorm" | "packet_storm" => Some(ExploitSource::PacketStorm),
        "github" => Some(ExploitSource::GitHub),
        "custom" => Some(ExploitSource::Custom),
        _ => None,
    }
}

fn parse_poc_status(s: &str) -> Option<PocStatus> {
    match s.to_lowercase().as_str() {
        "development" => Some(PocStatus::Development),
        "testing" => Some(PocStatus::Testing),
        "verified" => Some(PocStatus::Verified),
        "failed" => Some(PocStatus::Failed),
        "archived" => Some(PocStatus::Archived),
        _ => None,
    }
}

fn parse_language(s: &str) -> Option<crate::exploit_research::ExploitLanguage> {
    use crate::exploit_research::ExploitLanguage;
    match s.to_lowercase().as_str() {
        "python" => Some(ExploitLanguage::Python),
        "ruby" => Some(ExploitLanguage::Ruby),
        "perl" => Some(ExploitLanguage::Perl),
        "c" => Some(ExploitLanguage::C),
        "cpp" | "c++" => Some(ExploitLanguage::Cpp),
        "java" => Some(ExploitLanguage::Java),
        "javascript" | "js" => Some(ExploitLanguage::Javascript),
        "php" => Some(ExploitLanguage::Php),
        "bash" | "shell" => Some(ExploitLanguage::Bash),
        "powershell" | "ps1" => Some(ExploitLanguage::Powershell),
        "go" | "golang" => Some(ExploitLanguage::Go),
        "rust" => Some(ExploitLanguage::Rust),
        "assembly" | "asm" => Some(ExploitLanguage::Assembly),
        _ => None,
    }
}

fn parse_visibility(s: &str) -> Option<NoteVisibility> {
    match s.to_lowercase().as_str() {
        "private" => Some(NoteVisibility::Private),
        "team" => Some(NoteVisibility::Team),
        "public" => Some(NoteVisibility::Public),
        _ => None,
    }
}

fn parse_workspace_status(s: &str) -> Option<WorkspaceStatus> {
    match s.to_lowercase().as_str() {
        "active" => Some(WorkspaceStatus::Active),
        "paused" => Some(WorkspaceStatus::Paused),
        "completed" => Some(WorkspaceStatus::Completed),
        "archived" => Some(WorkspaceStatus::Archived),
        _ => None,
    }
}

fn parse_reference_type(s: &str) -> ReferenceType {
    match s.to_lowercase().as_str() {
        "cve" => ReferenceType::Cve,
        "advisory" => ReferenceType::Advisory,
        "blog" | "blog_post" | "blogpost" => ReferenceType::BlogPost,
        "github" => ReferenceType::GitHub,
        "exploit" | "exploit_db" => ReferenceType::ExploitDb,
        "paper" => ReferenceType::Paper,
        "vendor" => ReferenceType::Vendor,
        _ => ReferenceType::Other,
    }
}

// Sprint 2: Sandbox and Effectiveness Helper Functions

fn parse_sandbox_type(s: &str) -> Option<SandboxType> {
    match s.to_lowercase().as_str() {
        "docker" => Some(SandboxType::Docker),
        "local_vm" | "localvm" | "vm" => Some(SandboxType::LocalVm),
        "anyrun" | "any.run" => Some(SandboxType::AnyRun),
        "hybrid_analysis" | "hybridanalysis" => Some(SandboxType::HybridAnalysis),
        "custom" => Some(SandboxType::Custom),
        _ => None,
    }
}

fn parse_sandbox_os(s: &str) -> Option<SandboxOS> {
    match s.to_lowercase().as_str() {
        "windows7" | "win7" => Some(SandboxOS::Windows7),
        "windows10" | "win10" => Some(SandboxOS::Windows10),
        "windows11" | "win11" => Some(SandboxOS::Windows11),
        "windowsserver2019" | "winserver2019" => Some(SandboxOS::WindowsServer2019),
        "ubuntu2004" | "ubuntu20" => Some(SandboxOS::Ubuntu20),
        "ubuntu2204" | "ubuntu22" | "ubuntu" => Some(SandboxOS::Ubuntu22),
        "debian11" => Some(SandboxOS::Debian11),
        "debian12" | "debian" => Some(SandboxOS::Debian12),
        "kali" | "kalilinux" => Some(SandboxOS::Kali),
        "alpine" => Some(SandboxOS::Alpine),
        "centos" | "centos7" => Some(SandboxOS::CentOS7),
        _ => Some(SandboxOS::Custom(s.to_string())),
    }
}

fn _parse_success_indicator(_req: &SuccessIndicatorRequest) -> Option<SuccessIndicator> {
    // SuccessIndicator is a struct filled in by the sandbox during execution,
    // not created from API input. This function is kept for potential future use.
    None
}

fn parse_complexity(s: &str) -> ComplexityLevel {
    match s.to_lowercase().as_str() {
        "trivial" => ComplexityLevel::Trivial,
        "low" => ComplexityLevel::Low,
        "medium" => ComplexityLevel::Medium,
        "high" => ComplexityLevel::High,
        "expert" => ComplexityLevel::Expert,
        _ => ComplexityLevel::Medium,
    }
}

fn parse_impact_severity(s: &str) -> ImpactSeverity {
    match s.to_lowercase().as_str() {
        "none" => ImpactSeverity::None,
        "low" => ImpactSeverity::Low,
        "medium" => ImpactSeverity::Medium,
        "high" => ImpactSeverity::High,
        "critical" => ImpactSeverity::Critical,
        _ => ImpactSeverity::Medium,
    }
}

fn parse_maturity_level(s: &str) -> crate::exploit_research::effectiveness::MaturityLevel {
    use crate::exploit_research::effectiveness::MaturityLevel;
    match s.to_lowercase().as_str() {
        "poc" | "proof_of_concept" => MaturityLevel::ProofOfConcept,
        "alpha" => MaturityLevel::Alpha,
        "beta" => MaturityLevel::Beta,
        "production" | "stable" => MaturityLevel::Production,
        "weaponized" => MaturityLevel::Weaponized,
        _ => MaturityLevel::Beta,
    }
}

// ==================== Route Configuration ====================

/// Configure exploit research routes
pub fn configure(cfg: &mut web::ServiceConfig) {
    cfg.service(
        web::scope("/exploit-research")
            // Exploits
            .route("/exploits", web::get().to(search_exploits))
            .route("/exploits/cve/{cve_id}", web::get().to(get_exploits_for_cve))
            // CVE Mapping
            .route("/cve-mapping/{cve_id}", web::get().to(get_cve_mapping))
            .route("/cve-mapping/batch", web::post().to(get_batch_cve_mappings))
            // Sync & Stats
            .route("/sync-status", web::get().to(get_sync_status))
            .route("/stats", web::get().to(get_stats))
            // PoCs
            .route("/pocs", web::get().to(list_pocs))
            .route("/pocs", web::post().to(create_poc))
            .route("/pocs/{id}", web::get().to(get_poc))
            .route("/pocs/{id}", web::put().to(update_poc))
            .route("/pocs/{id}", web::delete().to(delete_poc))
            .route("/pocs/{id}/code", web::get().to(get_poc_code))
            .route("/pocs/{id}/test", web::post().to(add_poc_test_result))
            // Sprint 2: Sandbox Testing
            .route("/pocs/{id}/sandbox", web::post().to(execute_poc_in_sandbox))
            .route("/pocs/{id}/sandbox-history", web::get().to(get_sandbox_history))
            .route("/sandbox/environments", web::get().to(list_sandbox_environments))
            // Sprint 2: Effectiveness Scoring
            .route("/pocs/{id}/effectiveness", web::get().to(get_poc_effectiveness))
            .route("/pocs/{id}/effectiveness/calculate", web::post().to(calculate_poc_effectiveness))
            // Sprint 2: Timeline Events
            .route("/pocs/{id}/timeline", web::get().to(get_poc_timeline))
            .route("/pocs/{id}/timeline", web::post().to(add_poc_timeline_event))
            // Research Notes
            .route("/notes", web::get().to(list_notes))
            .route("/notes", web::post().to(create_note))
            .route("/notes/{id}", web::get().to(get_note))
            .route("/notes/{id}", web::put().to(update_note))
            .route("/notes/{id}", web::delete().to(delete_note))
            // Workspaces
            .route("/workspaces", web::get().to(list_workspaces))
            .route("/workspaces", web::post().to(create_workspace))
            .route("/workspaces/{id}", web::get().to(get_workspace))
            .route("/workspaces/{id}", web::put().to(update_workspace))
            .route("/workspaces/{id}", web::delete().to(delete_workspace))
            .route("/workspaces/{id}/items", web::post().to(add_item_to_workspace))
            .route("/workspaces/{id}/export", web::get().to(export_workspace))
            // Sprint 2: Workspace Timeline
            .route("/workspaces/{id}/timeline", web::get().to(get_workspace_timeline))
    );
}
