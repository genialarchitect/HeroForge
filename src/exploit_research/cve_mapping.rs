//! CVE to Exploit Mapping Engine
//!
//! Provides automatic mapping between CVEs and available exploits
//! from multiple sources (Exploit-DB, Metasploit, PacketStorm).

use anyhow::Result;
use chrono::Utc;
use std::collections::HashMap;
use log::{debug, info};

use super::exploit_db::ExploitDbClient;
use super::metasploit::MetasploitClient;
use super::packetstorm::PacketStormClient;
use super::types::*;

/// CVE to Exploit mapping engine
pub struct CveMappingEngine {
    exploit_db: ExploitDbClient,
    metasploit: MetasploitClient,
    packetstorm: PacketStormClient,
    cache: HashMap<String, CveExploitMapping>,
}

impl CveMappingEngine {
    /// Create a new mapping engine
    pub fn new() -> Result<Self> {
        Ok(Self {
            exploit_db: ExploitDbClient::new()?,
            metasploit: MetasploitClient::new()?,
            packetstorm: PacketStormClient::new()?,
            cache: HashMap::new(),
        })
    }

    /// Get exploit mapping for a single CVE
    pub async fn get_mapping(&mut self, cve_id: &str) -> Result<CveExploitMapping> {
        // Check cache first (with 1-hour TTL)
        if let Some(cached) = self.cache.get(cve_id) {
            let age = Utc::now() - cached.updated_at;
            if age.num_hours() < 1 {
                return Ok(cached.clone());
            }
        }

        info!("Building exploit mapping for {}", cve_id);

        let mut all_exploits: Vec<Exploit> = Vec::new();
        let mut exploit_ids: Vec<String> = Vec::new();
        let mut has_metasploit = false;

        // Search Exploit-DB
        debug!("Searching Exploit-DB for {}", cve_id);
        match self.exploit_db.search_by_cve(cve_id).await {
            Ok(exploits) => {
                for e in exploits {
                    exploit_ids.push(e.id.clone());
                    all_exploits.push(e);
                }
            }
            Err(e) => debug!("Exploit-DB search failed: {}", e),
        }

        // Search Metasploit
        debug!("Searching Metasploit for {}", cve_id);
        match self.metasploit.search_by_cve(cve_id).await {
            Ok(modules) => {
                has_metasploit = !modules.is_empty();
                for m in modules {
                    let exploit = self.metasploit.to_exploit(&m);
                    exploit_ids.push(exploit.id.clone());
                    all_exploits.push(exploit);
                }
            }
            Err(e) => debug!("Metasploit search failed: {}", e),
        }

        // Search PacketStorm
        debug!("Searching PacketStorm for {}", cve_id);
        match self.packetstorm.search_by_cve(cve_id).await {
            Ok(files) => {
                for f in files {
                    let exploit = self.packetstorm.to_exploit(&f);
                    exploit_ids.push(exploit.id.clone());
                    all_exploits.push(exploit);
                }
            }
            Err(e) => debug!("PacketStorm search failed: {}", e),
        }

        // Calculate highest reliability
        let highest_reliability = all_exploits
            .iter()
            .map(|e| &e.reliability)
            .max_by(|a, b| {
                let score_a = reliability_score(a);
                let score_b = reliability_score(b);
                score_a.cmp(&score_b)
            })
            .cloned()
            .unwrap_or(ExploitReliability::Unknown);

        // Collect platforms
        let mut platforms: Vec<ExploitPlatform> = all_exploits
            .iter()
            .map(|e| e.platform.clone())
            .collect();
        platforms.sort_by(|a, b| a.to_string().cmp(&b.to_string()));
        platforms.dedup();

        let mapping = CveExploitMapping {
            cve_id: cve_id.to_string(),
            exploit_count: all_exploits.len() as u32,
            exploit_ids,
            has_public_exploit: !all_exploits.is_empty(),
            has_metasploit_module: has_metasploit,
            highest_reliability,
            platforms,
            updated_at: Utc::now(),
        };

        // Cache the result
        self.cache.insert(cve_id.to_string(), mapping.clone());

        Ok(mapping)
    }

    /// Get mappings for multiple CVEs
    pub async fn get_mappings(&mut self, cve_ids: &[String]) -> Result<HashMap<String, CveExploitMapping>> {
        let mut results = HashMap::new();

        for cve_id in cve_ids {
            match self.get_mapping(cve_id).await {
                Ok(mapping) => {
                    results.insert(cve_id.clone(), mapping);
                }
                Err(e) => {
                    debug!("Failed to get mapping for {}: {}", cve_id, e);
                }
            }
        }

        Ok(results)
    }

    /// Get all exploits for a CVE from all sources
    pub async fn get_all_exploits(&mut self, cve_id: &str) -> Result<Vec<Exploit>> {
        let mut all_exploits: Vec<Exploit> = Vec::new();

        // Exploit-DB
        if let Ok(exploits) = self.exploit_db.search_by_cve(cve_id).await {
            all_exploits.extend(exploits);
        }

        // Metasploit
        if let Ok(modules) = self.metasploit.search_by_cve(cve_id).await {
            for m in modules {
                all_exploits.push(self.metasploit.to_exploit(&m));
            }
        }

        // PacketStorm
        if let Ok(files) = self.packetstorm.search_by_cve(cve_id).await {
            for f in files {
                all_exploits.push(self.packetstorm.to_exploit(&f));
            }
        }

        // Sort by reliability
        all_exploits.sort_by(|a, b| {
            let score_a = reliability_score(&a.reliability);
            let score_b = reliability_score(&b.reliability);
            score_b.cmp(&score_a)
        });

        Ok(all_exploits)
    }

    /// Search all sources with a unified query
    pub async fn search_all(&mut self, query: &ExploitSearchQuery) -> Result<ExploitSearchResults> {
        let mut all_exploits: Vec<Exploit> = Vec::new();

        // Search by CVE if specified
        if let Some(ref cve_id) = query.cve_id {
            return Ok(ExploitSearchResults {
                exploits: self.get_all_exploits(cve_id).await?,
                total_count: 0,
                page: 1,
                per_page: 100,
                total_pages: 1,
            });
        }

        // Search Exploit-DB
        if let Ok(results) = self.exploit_db.search(query).await {
            all_exploits.extend(results.exploits);
        }

        // For text queries, we can also search Metasploit and PacketStorm
        if let Some(ref q) = query.query {
            // Metasploit
            let msf_query = super::metasploit::MetasploitSearchQuery {
                query: Some(q.clone()),
                ..Default::default()
            };
            if let Ok(modules) = self.metasploit.search(&msf_query).await {
                for m in modules {
                    all_exploits.push(self.metasploit.to_exploit(&m));
                }
            }

            // PacketStorm
            if let Ok(files) = self.packetstorm.search(q).await {
                for f in files {
                    all_exploits.push(self.packetstorm.to_exploit(&f));
                }
            }
        }

        // Apply filters
        if let Some(ref platform) = query.platform {
            all_exploits.retain(|e| &e.platform == platform);
        }

        if let Some(ref exploit_type) = query.exploit_type {
            all_exploits.retain(|e| &e.exploit_type == exploit_type);
        }

        if let Some(ref source) = query.source {
            all_exploits.retain(|e| &e.source == source);
        }

        if query.verified_only {
            all_exploits.retain(|e| e.verified);
        }

        if query.has_code {
            all_exploits.retain(|e| e.code.is_some());
        }

        // Deduplicate by title similarity (basic)
        all_exploits = deduplicate_exploits(all_exploits);

        // Sort by reliability
        all_exploits.sort_by(|a, b| {
            let score_a = reliability_score(&a.reliability);
            let score_b = reliability_score(&b.reliability);
            score_b.cmp(&score_a)
        });

        let total = all_exploits.len() as u64;

        // Paginate
        let start = ((query.page - 1) * query.per_page) as usize;
        let end = (start + query.per_page as usize).min(all_exploits.len());
        let page_exploits = if start < all_exploits.len() {
            all_exploits[start..end].to_vec()
        } else {
            Vec::new()
        };

        Ok(ExploitSearchResults {
            exploits: page_exploits,
            total_count: total,
            page: query.page,
            per_page: query.per_page,
            total_pages: ((total as f64) / (query.per_page as f64)).ceil() as u32,
        })
    }

    /// Get sync status for all sources
    pub fn get_all_sync_status(&self) -> Vec<ExploitSyncStatus> {
        vec![
            self.exploit_db.get_sync_status(),
            self.metasploit.get_sync_status(),
            self.packetstorm.get_sync_status(),
        ]
    }

    /// Clear the mapping cache
    pub fn clear_cache(&mut self) {
        self.cache.clear();
    }
}

/// Convert reliability to numeric score for sorting
fn reliability_score(reliability: &ExploitReliability) -> u8 {
    match reliability {
        ExploitReliability::Excellent => 5,
        ExploitReliability::Good => 4,
        ExploitReliability::Average => 3,
        ExploitReliability::Low => 2,
        ExploitReliability::Unknown => 1,
    }
}

/// Basic deduplication based on title similarity
fn deduplicate_exploits(mut exploits: Vec<Exploit>) -> Vec<Exploit> {
    if exploits.len() <= 1 {
        return exploits;
    }

    let mut seen_titles: Vec<String> = Vec::new();

    exploits.retain(|e| {
        let title_lower = e.title.to_lowercase();

        // Check if we've seen a very similar title
        for seen in &seen_titles {
            if title_similarity(&title_lower, seen) > 0.8 {
                return false;
            }
        }

        seen_titles.push(title_lower);
        true
    });

    exploits
}

/// Simple title similarity check (Jaccard similarity on words)
fn title_similarity(a: &str, b: &str) -> f64 {
    let words_a: std::collections::HashSet<&str> = a.split_whitespace().collect();
    let words_b: std::collections::HashSet<&str> = b.split_whitespace().collect();

    if words_a.is_empty() || words_b.is_empty() {
        return 0.0;
    }

    let intersection = words_a.intersection(&words_b).count();
    let union = words_a.union(&words_b).count();

    intersection as f64 / union as f64
}

impl Default for CveMappingEngine {
    fn default() -> Self {
        Self::new().expect("Failed to create CveMappingEngine")
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_reliability_score() {
        assert_eq!(reliability_score(&ExploitReliability::Excellent), 5);
        assert_eq!(reliability_score(&ExploitReliability::Unknown), 1);
    }

    #[test]
    fn test_title_similarity() {
        assert!(title_similarity("hello world", "hello world") > 0.99);
        assert!(title_similarity("hello world", "hello there") > 0.3);
        assert!(title_similarity("completely different", "nothing alike") < 0.1);
    }

    #[tokio::test]
    async fn test_engine_creation() {
        let engine = CveMappingEngine::new();
        assert!(engine.is_ok());
    }
}
