//! Exploit-DB API Client
//!
//! Integrates with Exploit-DB to search, download, and cache exploits.
//! Uses both the API and the GitLab mirror for exploit code.

use anyhow::{anyhow, Result};
use chrono::{NaiveDate, Utc};
use reqwest::Client;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::time::Duration;
use log::{debug, info, warn};

use super::types::*;

const EXPLOIT_DB_API_BASE: &str = "https://www.exploit-db.com/api/v1";
const EXPLOIT_DB_GITLAB: &str = "https://gitlab.com/exploit-database/exploitdb/-/raw/main";
const EXPLOIT_DB_SEARCH: &str = "https://www.exploit-db.com/search";

/// Exploit-DB API client
pub struct ExploitDbClient {
    client: Client,
    cache: HashMap<String, CachedExploit>,
}

#[derive(Debug, Clone)]
struct CachedExploit {
    exploit: Exploit,
    cached_at: chrono::DateTime<Utc>,
}

/// Response from Exploit-DB search
#[derive(Debug, Deserialize)]
struct ExploitDbSearchResponse {
    #[serde(default)]
    data: Vec<ExploitDbSearchResult>,
    #[serde(rename = "recordsTotal")]
    records_total: Option<u64>,
    #[serde(rename = "recordsFiltered")]
    records_filtered: Option<u64>,
}

#[derive(Debug, Deserialize)]
struct ExploitDbSearchResult {
    id: String,
    date_published: Option<String>,
    #[serde(rename = "download_link")]
    download: Option<String>,
    application_link: Option<String>,
    source_url: Option<String>,
    #[serde(default)]
    description: Vec<DescriptionField>,
    #[serde(rename = "type_id")]
    type_id: Option<String>,
    #[serde(rename = "platform_id")]
    platform_id: Option<String>,
    #[serde(default)]
    author: AuthorField,
    verified: Option<String>,
    #[serde(default)]
    codes: Vec<CodeField>,
    #[serde(default)]
    tags: Vec<TagField>,
}

#[derive(Debug, Deserialize, Default)]
struct DescriptionField {
    #[serde(rename = "cve_title")]
    cve_title: Option<String>,
}

#[derive(Debug, Deserialize, Default)]
struct AuthorField {
    name: Option<String>,
}

#[derive(Debug, Deserialize)]
struct CodeField {
    code: String,
}

#[derive(Debug, Deserialize)]
struct TagField {
    name: String,
}

impl ExploitDbClient {
    /// Create a new Exploit-DB client
    pub fn new() -> Result<Self> {
        let client = Client::builder()
            .timeout(Duration::from_secs(30))
            .user_agent("Genial Architect Scanner/1.0")
            .build()?;

        Ok(Self {
            client,
            cache: HashMap::new(),
        })
    }

    /// Search Exploit-DB for exploits
    pub async fn search(&self, query: &ExploitSearchQuery) -> Result<ExploitSearchResults> {
        let mut params: Vec<(&str, String)> = Vec::new();

        // Build search parameters
        if let Some(ref q) = query.query {
            params.push(("text", q.clone()));
        }

        if let Some(ref cve) = query.cve_id {
            params.push(("cve", cve.clone()));
        }

        if let Some(ref platform) = query.platform {
            params.push(("platform", Self::platform_to_id(platform)));
        }

        if let Some(ref exploit_type) = query.exploit_type {
            params.push(("type", Self::type_to_id(exploit_type)));
        }

        if query.verified_only {
            params.push(("verified", "1".to_string()));
        }

        params.push(("start", ((query.page - 1) * query.per_page).to_string()));
        params.push(("length", query.per_page.to_string()));

        // Make request
        let url = format!("{}/search", EXPLOIT_DB_API_BASE);
        debug!("Searching Exploit-DB: {}", url);

        let response = self
            .client
            .get(&url)
            .header("Accept", "application/json")
            .query(&params)
            .send()
            .await;

        match response {
            Ok(resp) => {
                if resp.status().is_success() {
                    let search_response: ExploitDbSearchResponse = resp.json().await?;
                    let exploits = self.convert_search_results(search_response.data);
                    let total = search_response.records_filtered.unwrap_or(0);

                    Ok(ExploitSearchResults {
                        exploits,
                        total_count: total,
                        page: query.page,
                        per_page: query.per_page,
                        total_pages: ((total as f64) / (query.per_page as f64)).ceil() as u32,
                    })
                } else {
                    // Fallback to CSV/local search
                    warn!("Exploit-DB API returned {}, using fallback", resp.status());
                    self.search_fallback(query).await
                }
            }
            Err(e) => {
                warn!("Exploit-DB API error: {}, using fallback", e);
                self.search_fallback(query).await
            }
        }
    }

    /// Fallback search using the GitLab files_exploits.csv
    async fn search_fallback(&self, query: &ExploitSearchQuery) -> Result<ExploitSearchResults> {
        // For fallback, we search the local database or return empty
        // In a full implementation, this would query a local SQLite cache
        info!("Using fallback search for Exploit-DB");

        Ok(ExploitSearchResults {
            exploits: Vec::new(),
            total_count: 0,
            page: query.page,
            per_page: query.per_page,
            total_pages: 0,
        })
    }

    /// Get exploit by Exploit-DB ID
    pub async fn get_exploit(&self, edb_id: &str) -> Result<Exploit> {
        // Check cache first
        if let Some(cached) = self.cache.get(edb_id) {
            let age = Utc::now() - cached.cached_at;
            if age.num_hours() < 24 {
                return Ok(cached.exploit.clone());
            }
        }

        // Fetch from API
        let url = format!("{}/exploits/{}", EXPLOIT_DB_API_BASE, edb_id);
        debug!("Fetching exploit from Exploit-DB: {}", url);

        let response = self
            .client
            .get(&url)
            .header("Accept", "application/json")
            .send()
            .await?;

        if response.status().is_success() {
            let data: serde_json::Value = response.json().await?;
            let exploit = self.parse_exploit_response(edb_id, &data)?;
            Ok(exploit)
        } else {
            Err(anyhow!("Failed to fetch exploit {}: {}", edb_id, response.status()))
        }
    }

    /// Get exploit code from GitLab mirror
    pub async fn get_exploit_code(&self, edb_id: &str, file_path: &str) -> Result<String> {
        let url = format!("{}/{}", EXPLOIT_DB_GITLAB, file_path);
        debug!("Fetching exploit code from: {}", url);

        let response = self.client.get(&url).send().await?;

        if response.status().is_success() {
            Ok(response.text().await?)
        } else {
            Err(anyhow!("Failed to fetch exploit code: {}", response.status()))
        }
    }

    /// Search exploits by CVE ID
    pub async fn search_by_cve(&self, cve_id: &str) -> Result<Vec<Exploit>> {
        let query = ExploitSearchQuery::for_cve(cve_id);
        let results = self.search(&query).await?;
        Ok(results.exploits)
    }

    /// Get all exploits for multiple CVEs
    pub async fn search_by_cves(&self, cve_ids: &[String]) -> Result<HashMap<String, Vec<Exploit>>> {
        let mut results: HashMap<String, Vec<Exploit>> = HashMap::new();

        for cve_id in cve_ids {
            match self.search_by_cve(cve_id).await {
                Ok(exploits) => {
                    if !exploits.is_empty() {
                        results.insert(cve_id.clone(), exploits);
                    }
                }
                Err(e) => {
                    warn!("Failed to search exploits for {}: {}", cve_id, e);
                }
            }
        }

        Ok(results)
    }

    /// Convert search results to Exploit structs
    fn convert_search_results(&self, results: Vec<ExploitDbSearchResult>) -> Vec<Exploit> {
        results
            .into_iter()
            .map(|r| self.convert_result(r))
            .collect()
    }

    fn convert_result(&self, result: ExploitDbSearchResult) -> Exploit {
        let now = Utc::now();

        // Extract CVE IDs from codes
        let cve_ids: Vec<String> = result
            .codes
            .iter()
            .filter(|c| c.code.starts_with("CVE-"))
            .map(|c| c.code.clone())
            .collect();

        // Extract tags
        let tags: Vec<String> = result.tags.iter().map(|t| t.name.clone()).collect();

        // Get title from description
        let title = result
            .description
            .first()
            .and_then(|d| d.cve_title.clone())
            .unwrap_or_else(|| format!("EDB-{}", result.id));

        // Parse date
        let published_date = result
            .date_published
            .as_ref()
            .and_then(|d| NaiveDate::parse_from_str(d, "%Y-%m-%d").ok());

        // Map platform
        let platform = result
            .platform_id
            .as_ref()
            .map(|p| Self::id_to_platform(p))
            .unwrap_or(ExploitPlatform::Multiple);

        // Map type
        let exploit_type = result
            .type_id
            .as_ref()
            .map(|t| Self::id_to_type(t))
            .unwrap_or(ExploitType::Remote);

        // Check verification
        let verified = result.verified.as_ref().map(|v| v == "1").unwrap_or(false);

        Exploit {
            id: uuid::Uuid::new_v4().to_string(),
            exploit_db_id: Some(result.id.clone()),
            metasploit_module: None,
            cve_ids,
            title,
            description: None,
            platform,
            architecture: ExploitArchitecture::Unknown,
            exploit_type,
            author: result.author.name,
            source_url: result.download.or(result.source_url),
            source: ExploitSource::ExploitDb,
            code: None,
            language: None,
            verified,
            reliability: if verified {
                ExploitReliability::Good
            } else {
                ExploitReliability::Unknown
            },
            tags,
            published_date,
            created_at: now,
            updated_at: now,
        }
    }

    fn parse_exploit_response(&self, edb_id: &str, data: &serde_json::Value) -> Result<Exploit> {
        let now = Utc::now();

        Ok(Exploit {
            id: uuid::Uuid::new_v4().to_string(),
            exploit_db_id: Some(edb_id.to_string()),
            metasploit_module: None,
            cve_ids: Vec::new(),
            title: data["title"]
                .as_str()
                .unwrap_or("Unknown")
                .to_string(),
            description: data["description"].as_str().map(|s| s.to_string()),
            platform: ExploitPlatform::Multiple,
            architecture: ExploitArchitecture::Unknown,
            exploit_type: ExploitType::Remote,
            author: data["author"].as_str().map(|s| s.to_string()),
            source_url: data["source_url"].as_str().map(|s| s.to_string()),
            source: ExploitSource::ExploitDb,
            code: data["code"].as_str().map(|s| s.to_string()),
            language: None,
            verified: data["verified"].as_bool().unwrap_or(false),
            reliability: ExploitReliability::Unknown,
            tags: Vec::new(),
            published_date: None,
            created_at: now,
            updated_at: now,
        })
    }

    /// Map platform name to Exploit-DB platform ID
    fn platform_to_id(platform: &ExploitPlatform) -> String {
        match platform {
            ExploitPlatform::Windows => "1".to_string(),
            ExploitPlatform::Linux => "2".to_string(),
            ExploitPlatform::MacOS => "9".to_string(),
            ExploitPlatform::Unix => "10".to_string(),
            ExploitPlatform::FreeBSD => "3".to_string(),
            ExploitPlatform::Hardware => "16".to_string(),
            ExploitPlatform::Multiple => "14".to_string(),
            ExploitPlatform::Php => "5".to_string(),
            ExploitPlatform::Java => "11".to_string(),
            ExploitPlatform::Aspx => "4".to_string(),
            ExploitPlatform::Jsp => "6".to_string(),
            ExploitPlatform::Cgi => "8".to_string(),
            _ => "14".to_string(), // Default to multiple
        }
    }

    /// Map Exploit-DB platform ID to platform enum
    fn id_to_platform(id: &str) -> ExploitPlatform {
        match id {
            "1" => ExploitPlatform::Windows,
            "2" => ExploitPlatform::Linux,
            "3" => ExploitPlatform::FreeBSD,
            "4" => ExploitPlatform::Aspx,
            "5" => ExploitPlatform::Php,
            "6" => ExploitPlatform::Jsp,
            "7" => ExploitPlatform::WebApps,
            "8" => ExploitPlatform::Cgi,
            "9" => ExploitPlatform::MacOS,
            "10" => ExploitPlatform::Unix,
            "11" => ExploitPlatform::Java,
            "14" => ExploitPlatform::Multiple,
            "15" => ExploitPlatform::Android,
            "16" => ExploitPlatform::Hardware,
            _ => ExploitPlatform::Other(id.to_string()),
        }
    }

    /// Map exploit type to Exploit-DB type ID
    fn type_to_id(exploit_type: &ExploitType) -> String {
        match exploit_type {
            ExploitType::Remote => "1".to_string(),
            ExploitType::WebApps => "2".to_string(),
            ExploitType::Local => "3".to_string(),
            ExploitType::Dos => "4".to_string(),
            ExploitType::Shellcode => "5".to_string(),
            ExploitType::Papers => "6".to_string(),
            _ => "1".to_string(),
        }
    }

    /// Map Exploit-DB type ID to type enum
    fn id_to_type(id: &str) -> ExploitType {
        match id {
            "1" => ExploitType::Remote,
            "2" => ExploitType::WebApps,
            "3" => ExploitType::Local,
            "4" => ExploitType::Dos,
            "5" => ExploitType::Shellcode,
            "6" => ExploitType::Papers,
            _ => ExploitType::Other(id.to_string()),
        }
    }

    /// Get sync status
    pub fn get_sync_status(&self) -> ExploitSyncStatus {
        ExploitSyncStatus {
            source: ExploitSource::ExploitDb,
            last_sync_at: None,
            total_exploits: self.cache.len() as u64,
            new_since_last_sync: 0,
            sync_in_progress: false,
            last_error: None,
        }
    }
}

impl Default for ExploitDbClient {
    fn default() -> Self {
        Self::new().expect("Failed to create ExploitDbClient")
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_platform_mapping() {
        assert_eq!(ExploitDbClient::platform_to_id(&ExploitPlatform::Windows), "1");
        assert_eq!(ExploitDbClient::platform_to_id(&ExploitPlatform::Linux), "2");
    }

    #[test]
    fn test_type_mapping() {
        assert_eq!(ExploitDbClient::type_to_id(&ExploitType::Remote), "1");
        assert_eq!(ExploitDbClient::type_to_id(&ExploitType::Local), "3");
    }

    #[tokio::test]
    async fn test_client_creation() {
        let client = ExploitDbClient::new();
        assert!(client.is_ok());
    }
}
