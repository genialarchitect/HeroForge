//! PoC Testing Sandbox Integration
//!
//! Provides isolated execution environments for testing proof-of-concept exploits.
//! Supports both local Docker-based sandboxes and external sandbox APIs.

use anyhow::{anyhow, Result};
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::process::Command;
use std::time::Duration;
use log::{debug, info, warn, error};

/// Sandbox execution environment type
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]
#[serde(rename_all = "snake_case")]
pub enum SandboxType {
    /// Local Docker container
    Docker,
    /// Local VM (VirtualBox/QEMU)
    LocalVm,
    /// Any.Run cloud sandbox
    AnyRun,
    /// Hybrid Analysis cloud sandbox
    HybridAnalysis,
    /// Custom sandbox endpoint
    Custom,
}

impl std::fmt::Display for SandboxType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            SandboxType::Docker => write!(f, "Docker"),
            SandboxType::LocalVm => write!(f, "Local VM"),
            SandboxType::AnyRun => write!(f, "Any.Run"),
            SandboxType::HybridAnalysis => write!(f, "Hybrid Analysis"),
            SandboxType::Custom => write!(f, "Custom"),
        }
    }
}

/// Target operating system for sandbox
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]
#[serde(rename_all = "snake_case")]
pub enum SandboxOS {
    Windows7,
    Windows10,
    Windows11,
    WindowsServer2019,
    Ubuntu20,
    Ubuntu22,
    Debian11,
    Debian12,
    Kali,
    CentOS7,
    Alpine,
    Custom(String),
}

impl std::fmt::Display for SandboxOS {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            SandboxOS::Windows7 => write!(f, "Windows 7"),
            SandboxOS::Windows10 => write!(f, "Windows 10"),
            SandboxOS::Windows11 => write!(f, "Windows 11"),
            SandboxOS::WindowsServer2019 => write!(f, "Windows Server 2019"),
            SandboxOS::Ubuntu20 => write!(f, "Ubuntu 20.04"),
            SandboxOS::Ubuntu22 => write!(f, "Ubuntu 22.04"),
            SandboxOS::Debian11 => write!(f, "Debian 11"),
            SandboxOS::Debian12 => write!(f, "Debian 12"),
            SandboxOS::Kali => write!(f, "Kali Linux"),
            SandboxOS::CentOS7 => write!(f, "CentOS 7"),
            SandboxOS::Alpine => write!(f, "Alpine Linux"),
            SandboxOS::Custom(name) => write!(f, "{}", name),
        }
    }
}

/// Sandbox execution status
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum SandboxStatus {
    Pending,
    Preparing,
    Running,
    Completed,
    Failed,
    Timeout,
    Cancelled,
}

/// Network configuration for sandbox
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NetworkConfig {
    /// Enable network access
    pub enabled: bool,
    /// Capture network traffic
    pub capture_traffic: bool,
    /// Allow internet access
    pub internet_access: bool,
    /// Custom DNS servers
    pub dns_servers: Vec<String>,
    /// Port forwarding rules (host:container)
    pub port_forwards: Vec<(u16, u16)>,
}

impl Default for NetworkConfig {
    fn default() -> Self {
        Self {
            enabled: true,
            capture_traffic: true,
            internet_access: false, // Isolated by default
            dns_servers: vec!["8.8.8.8".to_string()],
            port_forwards: vec![],
        }
    }
}

/// Resource limits for sandbox execution
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResourceLimits {
    /// Maximum memory in MB
    pub max_memory_mb: u32,
    /// Maximum CPU cores
    pub max_cpus: u32,
    /// Maximum disk space in MB
    pub max_disk_mb: u32,
    /// Maximum execution time in seconds
    pub timeout_seconds: u32,
}

impl Default for ResourceLimits {
    fn default() -> Self {
        Self {
            max_memory_mb: 2048,
            max_cpus: 2,
            max_disk_mb: 10240,
            timeout_seconds: 300, // 5 minutes
        }
    }
}

/// Configuration for a sandbox execution
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SandboxConfig {
    /// Sandbox type
    pub sandbox_type: SandboxType,
    /// Target operating system
    pub target_os: SandboxOS,
    /// Network configuration
    pub network: NetworkConfig,
    /// Resource limits
    pub limits: ResourceLimits,
    /// Environment variables
    pub environment: HashMap<String, String>,
    /// Files to inject into sandbox
    pub inject_files: Vec<InjectedFile>,
    /// Commands to run before PoC
    pub setup_commands: Vec<String>,
    /// Commands to run after PoC
    pub cleanup_commands: Vec<String>,
    /// Capture screenshots during execution
    pub capture_screenshots: bool,
    /// Record full execution video
    pub record_video: bool,
    /// Enable API monitoring
    pub monitor_api_calls: bool,
    /// Enable file system monitoring
    pub monitor_filesystem: bool,
    /// Enable registry monitoring (Windows)
    pub monitor_registry: bool,
    /// Enable process monitoring
    pub monitor_processes: bool,
}

impl Default for SandboxConfig {
    fn default() -> Self {
        Self {
            sandbox_type: SandboxType::Docker,
            target_os: SandboxOS::Ubuntu22,
            network: NetworkConfig::default(),
            limits: ResourceLimits::default(),
            environment: HashMap::new(),
            inject_files: vec![],
            setup_commands: vec![],
            cleanup_commands: vec![],
            capture_screenshots: true,
            record_video: false,
            monitor_api_calls: true,
            monitor_filesystem: true,
            monitor_registry: true,
            monitor_processes: true,
        }
    }
}

/// File to inject into sandbox
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InjectedFile {
    /// File content (base64 encoded for binary)
    pub content: String,
    /// Destination path in sandbox
    pub dest_path: String,
    /// File permissions (Unix style)
    pub permissions: Option<String>,
    /// Whether content is base64 encoded
    pub is_base64: bool,
}

/// Request to execute a PoC in sandbox
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SandboxExecutionRequest {
    /// PoC ID being tested
    pub poc_id: String,
    /// PoC code to execute
    pub code: String,
    /// Language of the PoC
    pub language: String,
    /// Sandbox configuration
    pub config: SandboxConfig,
    /// Target information (IP, hostname, etc.)
    pub target_info: Option<TargetInfo>,
    /// Additional arguments for the PoC
    pub arguments: Vec<String>,
    /// Description of what this test is validating
    pub test_description: Option<String>,
}

/// Target information for PoC execution
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TargetInfo {
    /// Target IP or hostname
    pub host: String,
    /// Target port
    pub port: Option<u16>,
    /// Target service
    pub service: Option<String>,
    /// Target version
    pub version: Option<String>,
    /// Additional target metadata
    pub metadata: HashMap<String, String>,
}

/// Result of a sandbox execution
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SandboxExecutionResult {
    /// Unique execution ID
    pub execution_id: String,
    /// PoC ID tested
    pub poc_id: String,
    /// Execution status
    pub status: SandboxStatus,
    /// Exit code from PoC execution
    pub exit_code: Option<i32>,
    /// Standard output
    pub stdout: String,
    /// Standard error
    pub stderr: String,
    /// Execution duration in milliseconds
    pub duration_ms: u64,
    /// Network activity captured
    pub network_activity: Vec<NetworkEvent>,
    /// File system activity
    pub filesystem_activity: Vec<FilesystemEvent>,
    /// Process activity
    pub process_activity: Vec<ProcessEvent>,
    /// Registry activity (Windows)
    pub registry_activity: Vec<RegistryEvent>,
    /// API calls monitored
    pub api_calls: Vec<ApiCall>,
    /// Screenshots captured
    pub screenshots: Vec<String>,
    /// Artifacts created/modified
    pub artifacts: Vec<Artifact>,
    /// Exploit success indicators
    pub success_indicators: Vec<SuccessIndicator>,
    /// Error message if failed
    pub error_message: Option<String>,
    /// Started at timestamp
    pub started_at: DateTime<Utc>,
    /// Completed at timestamp
    pub completed_at: Option<DateTime<Utc>>,
}

/// Network event during sandbox execution
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NetworkEvent {
    pub timestamp: DateTime<Utc>,
    pub event_type: String, // connect, send, receive, dns
    pub protocol: String,
    pub src_ip: String,
    pub src_port: u16,
    pub dst_ip: String,
    pub dst_port: u16,
    pub data_size: u64,
    pub data_preview: Option<String>,
}

/// File system event during execution
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FilesystemEvent {
    pub timestamp: DateTime<Utc>,
    pub operation: String, // create, modify, delete, read
    pub path: String,
    pub process: String,
    pub size: Option<u64>,
    pub hash: Option<String>,
}

/// Process event during execution
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProcessEvent {
    pub timestamp: DateTime<Utc>,
    pub event_type: String, // start, stop, inject
    pub pid: u32,
    pub parent_pid: Option<u32>,
    pub name: String,
    pub command_line: String,
    pub user: Option<String>,
}

/// Registry event (Windows)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RegistryEvent {
    pub timestamp: DateTime<Utc>,
    pub operation: String, // create_key, set_value, delete_key
    pub key_path: String,
    pub value_name: Option<String>,
    pub value_data: Option<String>,
    pub process: String,
}

/// API call monitored during execution
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ApiCall {
    pub timestamp: DateTime<Utc>,
    pub api_name: String,
    pub module: String,
    pub arguments: Vec<String>,
    pub return_value: Option<String>,
    pub process: String,
    pub suspicious: bool,
}

/// Artifact created during execution
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Artifact {
    pub artifact_type: String, // file, memory_dump, screenshot, pcap
    pub name: String,
    pub path: String,
    pub size: u64,
    pub hash: Option<String>,
    pub description: Option<String>,
}

/// Indicator that exploit succeeded
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SuccessIndicator {
    pub indicator_type: String, // shell_obtained, privilege_escalated, file_created, etc.
    pub description: String,
    pub evidence: String,
    pub confidence: f64, // 0.0 - 1.0
    pub timestamp: DateTime<Utc>,
}

/// Sandbox manager for executing PoCs
pub struct SandboxManager {
    /// Docker socket path
    docker_socket: String,
    /// Default configuration
    default_config: SandboxConfig,
    /// Available sandbox images
    available_images: HashMap<SandboxOS, String>,
    /// API keys for cloud sandboxes
    api_keys: HashMap<SandboxType, String>,
}

impl SandboxManager {
    /// Create a new sandbox manager
    pub fn new() -> Self {
        let mut available_images = HashMap::new();
        available_images.insert(SandboxOS::Ubuntu22, "heroforge/sandbox-ubuntu:22.04".to_string());
        available_images.insert(SandboxOS::Ubuntu20, "heroforge/sandbox-ubuntu:20.04".to_string());
        available_images.insert(SandboxOS::Debian12, "heroforge/sandbox-debian:12".to_string());
        available_images.insert(SandboxOS::Kali, "heroforge/sandbox-kali:latest".to_string());
        available_images.insert(SandboxOS::Alpine, "heroforge/sandbox-alpine:latest".to_string());

        Self {
            docker_socket: "/var/run/docker.sock".to_string(),
            default_config: SandboxConfig::default(),
            available_images,
            api_keys: HashMap::new(),
        }
    }

    /// Set API key for cloud sandbox
    pub fn set_api_key(&mut self, sandbox_type: SandboxType, api_key: String) {
        self.api_keys.insert(sandbox_type, api_key);
    }

    /// Execute a PoC in a sandbox
    pub async fn execute(&self, request: SandboxExecutionRequest) -> Result<SandboxExecutionResult> {
        let execution_id = uuid::Uuid::new_v4().to_string();
        let started_at = Utc::now();

        info!("Starting sandbox execution {} for PoC {}", execution_id, request.poc_id);

        match request.config.sandbox_type {
            SandboxType::Docker => {
                self.execute_docker(&execution_id, &request, started_at).await
            }
            SandboxType::AnyRun => {
                self.execute_anyrun(&execution_id, &request, started_at).await
            }
            SandboxType::HybridAnalysis => {
                self.execute_hybrid_analysis(&execution_id, &request, started_at).await
            }
            _ => {
                Err(anyhow!("Sandbox type {:?} not yet implemented", request.config.sandbox_type))
            }
        }
    }

    /// Execute PoC in Docker sandbox
    async fn execute_docker(
        &self,
        execution_id: &str,
        request: &SandboxExecutionRequest,
        started_at: DateTime<Utc>,
    ) -> Result<SandboxExecutionResult> {
        let image = self.available_images
            .get(&request.config.target_os)
            .ok_or_else(|| anyhow!("No Docker image available for {:?}", request.config.target_os))?;

        // Build Docker run command
        let container_name = format!("heroforge-sandbox-{}", execution_id);

        // Create temporary directory for PoC code
        let temp_dir = std::env::temp_dir().join(format!("heroforge-poc-{}", execution_id));
        std::fs::create_dir_all(&temp_dir)?;

        // Write PoC code to file
        let poc_file = temp_dir.join(self.get_filename_for_language(&request.language));
        std::fs::write(&poc_file, &request.code)?;

        // Build Docker command
        let mut cmd = Command::new("docker");
        cmd.arg("run")
            .arg("--rm")
            .arg("--name").arg(&container_name)
            .arg("--memory").arg(format!("{}m", request.config.limits.max_memory_mb))
            .arg("--cpus").arg(request.config.limits.max_cpus.to_string())
            .arg("-v").arg(format!("{}:/poc:ro", temp_dir.display()));

        // Network configuration
        if !request.config.network.enabled {
            cmd.arg("--network").arg("none");
        }

        // Environment variables
        for (key, value) in &request.config.environment {
            cmd.arg("-e").arg(format!("{}={}", key, value));
        }

        // Add the image and command
        cmd.arg(image);
        cmd.arg(self.get_interpreter_for_language(&request.language));
        cmd.arg(format!("/poc/{}", poc_file.file_name().unwrap().to_string_lossy()));

        // Add arguments
        for arg in &request.arguments {
            cmd.arg(arg);
        }

        debug!("Running Docker command: {:?}", cmd);

        // Execute with timeout
        let output = tokio::time::timeout(
            Duration::from_secs(request.config.limits.timeout_seconds as u64),
            tokio::task::spawn_blocking(move || cmd.output()),
        ).await;

        // Cleanup temp directory
        let _ = std::fs::remove_dir_all(&temp_dir);

        let completed_at = Utc::now();
        let duration_ms = (completed_at - started_at).num_milliseconds() as u64;

        match output {
            Ok(Ok(Ok(output))) => {
                let stdout = String::from_utf8_lossy(&output.stdout).to_string();
                let stderr = String::from_utf8_lossy(&output.stderr).to_string();
                let exit_code = output.status.code();

                // Analyze output for success indicators
                let success_indicators = self.analyze_output_for_success(&stdout, &stderr);

                Ok(SandboxExecutionResult {
                    execution_id: execution_id.to_string(),
                    poc_id: request.poc_id.clone(),
                    status: if output.status.success() { SandboxStatus::Completed } else { SandboxStatus::Failed },
                    exit_code,
                    stdout,
                    stderr,
                    duration_ms,
                    network_activity: vec![],
                    filesystem_activity: vec![],
                    process_activity: vec![],
                    registry_activity: vec![],
                    api_calls: vec![],
                    screenshots: vec![],
                    artifacts: vec![],
                    success_indicators,
                    error_message: if output.status.success() { None } else { Some("PoC execution failed".to_string()) },
                    started_at,
                    completed_at: Some(completed_at),
                })
            }
            Ok(Ok(Err(e))) => {
                Ok(SandboxExecutionResult {
                    execution_id: execution_id.to_string(),
                    poc_id: request.poc_id.clone(),
                    status: SandboxStatus::Failed,
                    exit_code: None,
                    stdout: String::new(),
                    stderr: String::new(),
                    duration_ms,
                    network_activity: vec![],
                    filesystem_activity: vec![],
                    process_activity: vec![],
                    registry_activity: vec![],
                    api_calls: vec![],
                    screenshots: vec![],
                    artifacts: vec![],
                    success_indicators: vec![],
                    error_message: Some(format!("Failed to execute Docker: {}", e)),
                    started_at,
                    completed_at: Some(completed_at),
                })
            }
            Ok(Err(e)) => {
                Ok(SandboxExecutionResult {
                    execution_id: execution_id.to_string(),
                    poc_id: request.poc_id.clone(),
                    status: SandboxStatus::Failed,
                    exit_code: None,
                    stdout: String::new(),
                    stderr: String::new(),
                    duration_ms,
                    network_activity: vec![],
                    filesystem_activity: vec![],
                    process_activity: vec![],
                    registry_activity: vec![],
                    api_calls: vec![],
                    screenshots: vec![],
                    artifacts: vec![],
                    success_indicators: vec![],
                    error_message: Some(format!("Task join error: {}", e)),
                    started_at,
                    completed_at: Some(completed_at),
                })
            }
            Err(_) => {
                // Timeout - try to kill the container
                let _ = Command::new("docker")
                    .args(["kill", &container_name])
                    .output();

                Ok(SandboxExecutionResult {
                    execution_id: execution_id.to_string(),
                    poc_id: request.poc_id.clone(),
                    status: SandboxStatus::Timeout,
                    exit_code: None,
                    stdout: String::new(),
                    stderr: String::new(),
                    duration_ms,
                    network_activity: vec![],
                    filesystem_activity: vec![],
                    process_activity: vec![],
                    registry_activity: vec![],
                    api_calls: vec![],
                    screenshots: vec![],
                    artifacts: vec![],
                    success_indicators: vec![],
                    error_message: Some(format!("Execution timed out after {} seconds", request.config.limits.timeout_seconds)),
                    started_at,
                    completed_at: Some(completed_at),
                })
            }
        }
    }

    /// Execute PoC via Any.Run API (placeholder)
    async fn execute_anyrun(
        &self,
        execution_id: &str,
        request: &SandboxExecutionRequest,
        started_at: DateTime<Utc>,
    ) -> Result<SandboxExecutionResult> {
        let api_key = self.api_keys.get(&SandboxType::AnyRun)
            .ok_or_else(|| anyhow!("Any.Run API key not configured"))?;

        // TODO: Implement actual Any.Run API integration
        // For now, return a placeholder result
        warn!("Any.Run integration not fully implemented");

        Ok(SandboxExecutionResult {
            execution_id: execution_id.to_string(),
            poc_id: request.poc_id.clone(),
            status: SandboxStatus::Failed,
            exit_code: None,
            stdout: String::new(),
            stderr: String::new(),
            duration_ms: 0,
            network_activity: vec![],
            filesystem_activity: vec![],
            process_activity: vec![],
            registry_activity: vec![],
            api_calls: vec![],
            screenshots: vec![],
            artifacts: vec![],
            success_indicators: vec![],
            error_message: Some("Any.Run integration not yet implemented".to_string()),
            started_at,
            completed_at: Some(Utc::now()),
        })
    }

    /// Execute PoC via Hybrid Analysis API (placeholder)
    async fn execute_hybrid_analysis(
        &self,
        execution_id: &str,
        request: &SandboxExecutionRequest,
        started_at: DateTime<Utc>,
    ) -> Result<SandboxExecutionResult> {
        let api_key = self.api_keys.get(&SandboxType::HybridAnalysis)
            .ok_or_else(|| anyhow!("Hybrid Analysis API key not configured"))?;

        // TODO: Implement actual Hybrid Analysis API integration
        warn!("Hybrid Analysis integration not fully implemented");

        Ok(SandboxExecutionResult {
            execution_id: execution_id.to_string(),
            poc_id: request.poc_id.clone(),
            status: SandboxStatus::Failed,
            exit_code: None,
            stdout: String::new(),
            stderr: String::new(),
            duration_ms: 0,
            network_activity: vec![],
            filesystem_activity: vec![],
            process_activity: vec![],
            registry_activity: vec![],
            api_calls: vec![],
            screenshots: vec![],
            artifacts: vec![],
            success_indicators: vec![],
            error_message: Some("Hybrid Analysis integration not yet implemented".to_string()),
            started_at,
            completed_at: Some(Utc::now()),
        })
    }

    /// Get appropriate filename for language
    fn get_filename_for_language(&self, language: &str) -> String {
        match language.to_lowercase().as_str() {
            "python" | "python3" => "poc.py".to_string(),
            "ruby" => "poc.rb".to_string(),
            "perl" => "poc.pl".to_string(),
            "bash" | "sh" => "poc.sh".to_string(),
            "powershell" | "ps1" => "poc.ps1".to_string(),
            "javascript" | "js" | "node" => "poc.js".to_string(),
            "go" => "poc.go".to_string(),
            "rust" => "poc.rs".to_string(),
            "c" => "poc.c".to_string(),
            "cpp" | "c++" => "poc.cpp".to_string(),
            _ => "poc.txt".to_string(),
        }
    }

    /// Get interpreter command for language
    fn get_interpreter_for_language(&self, language: &str) -> String {
        match language.to_lowercase().as_str() {
            "python" | "python3" => "python3".to_string(),
            "ruby" => "ruby".to_string(),
            "perl" => "perl".to_string(),
            "bash" | "sh" => "/bin/bash".to_string(),
            "powershell" | "ps1" => "pwsh".to_string(),
            "javascript" | "js" | "node" => "node".to_string(),
            "go" => "go run".to_string(),
            _ => "/bin/sh".to_string(),
        }
    }

    /// Analyze execution output for success indicators
    fn analyze_output_for_success(&self, stdout: &str, stderr: &str) -> Vec<SuccessIndicator> {
        let mut indicators = vec![];
        let now = Utc::now();
        let combined = format!("{}\n{}", stdout, stderr);

        // Check for shell indicators
        let shell_patterns = [
            "uid=0", "root@", "NT AUTHORITY\\SYSTEM", "Administrator",
            "shell>", "meterpreter>", "cmd.exe", "/bin/sh", "/bin/bash",
        ];
        for pattern in shell_patterns {
            if combined.contains(pattern) {
                indicators.push(SuccessIndicator {
                    indicator_type: "shell_obtained".to_string(),
                    description: "Shell access indicator detected".to_string(),
                    evidence: pattern.to_string(),
                    confidence: 0.8,
                    timestamp: now,
                });
                break;
            }
        }

        // Check for privilege escalation
        let privesc_patterns = [
            "privilege escalation successful", "elevated to",
            "now running as root", "admin access granted",
        ];
        for pattern in privesc_patterns {
            if combined.to_lowercase().contains(&pattern.to_lowercase()) {
                indicators.push(SuccessIndicator {
                    indicator_type: "privilege_escalated".to_string(),
                    description: "Privilege escalation indicator detected".to_string(),
                    evidence: pattern.to_string(),
                    confidence: 0.7,
                    timestamp: now,
                });
                break;
            }
        }

        // Check for successful exploitation messages
        let success_patterns = [
            "exploit successful", "exploitation complete",
            "payload executed", "code execution achieved",
            "vulnerability confirmed", "rce confirmed",
        ];
        for pattern in success_patterns {
            if combined.to_lowercase().contains(&pattern.to_lowercase()) {
                indicators.push(SuccessIndicator {
                    indicator_type: "exploit_successful".to_string(),
                    description: "Explicit success message detected".to_string(),
                    evidence: pattern.to_string(),
                    confidence: 0.9,
                    timestamp: now,
                });
                break;
            }
        }

        indicators
    }

    /// List available sandbox environments
    pub fn list_environments(&self) -> Vec<SandboxEnvironment> {
        self.available_images
            .iter()
            .map(|(os, image)| SandboxEnvironment {
                os: os.clone(),
                image: image.clone(),
                sandbox_type: SandboxType::Docker,
                available: true,
            })
            .collect()
    }

    /// Check if sandbox is available
    pub fn is_available(&self, sandbox_type: &SandboxType, os: &SandboxOS) -> bool {
        match sandbox_type {
            SandboxType::Docker => self.available_images.contains_key(os),
            SandboxType::AnyRun => self.api_keys.contains_key(&SandboxType::AnyRun),
            SandboxType::HybridAnalysis => self.api_keys.contains_key(&SandboxType::HybridAnalysis),
            _ => false,
        }
    }
}

impl Default for SandboxManager {
    fn default() -> Self {
        Self::new()
    }
}

/// Available sandbox environment
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SandboxEnvironment {
    pub os: SandboxOS,
    pub image: String,
    pub sandbox_type: SandboxType,
    pub available: bool,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_sandbox_manager_creation() {
        let manager = SandboxManager::new();
        assert!(!manager.available_images.is_empty());
    }

    #[test]
    fn test_get_filename_for_language() {
        let manager = SandboxManager::new();
        assert_eq!(manager.get_filename_for_language("python"), "poc.py");
        assert_eq!(manager.get_filename_for_language("ruby"), "poc.rb");
        assert_eq!(manager.get_filename_for_language("bash"), "poc.sh");
    }

    #[test]
    fn test_success_indicator_detection() {
        let manager = SandboxManager::new();

        let indicators = manager.analyze_output_for_success(
            "uid=0(root) gid=0(root) groups=0(root)",
            "",
        );

        assert!(!indicators.is_empty());
        assert!(indicators.iter().any(|i| i.indicator_type == "shell_obtained"));
    }
}
