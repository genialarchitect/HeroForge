//! PoC Testing Sandbox Integration
//!
//! Provides isolated execution environments for testing proof-of-concept exploits.
//! Supports both local Docker-based sandboxes and external sandbox APIs.

use anyhow::{anyhow, Result};
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::process::Command;
use std::time::Duration;
use log::{debug, info, warn, error};

/// Sandbox execution environment type
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]
#[serde(rename_all = "snake_case")]
pub enum SandboxType {
    /// Local Docker container
    Docker,
    /// Local VM (VirtualBox/QEMU)
    LocalVm,
    /// Any.Run cloud sandbox
    AnyRun,
    /// Hybrid Analysis cloud sandbox
    HybridAnalysis,
    /// Custom sandbox endpoint
    Custom,
}

impl std::fmt::Display for SandboxType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            SandboxType::Docker => write!(f, "Docker"),
            SandboxType::LocalVm => write!(f, "Local VM"),
            SandboxType::AnyRun => write!(f, "Any.Run"),
            SandboxType::HybridAnalysis => write!(f, "Hybrid Analysis"),
            SandboxType::Custom => write!(f, "Custom"),
        }
    }
}

/// Target operating system for sandbox
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]
#[serde(rename_all = "snake_case")]
pub enum SandboxOS {
    Windows7,
    Windows10,
    Windows11,
    WindowsServer2019,
    Ubuntu20,
    Ubuntu22,
    Debian11,
    Debian12,
    Kali,
    CentOS7,
    Alpine,
    Custom(String),
}

impl std::fmt::Display for SandboxOS {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            SandboxOS::Windows7 => write!(f, "Windows 7"),
            SandboxOS::Windows10 => write!(f, "Windows 10"),
            SandboxOS::Windows11 => write!(f, "Windows 11"),
            SandboxOS::WindowsServer2019 => write!(f, "Windows Server 2019"),
            SandboxOS::Ubuntu20 => write!(f, "Ubuntu 20.04"),
            SandboxOS::Ubuntu22 => write!(f, "Ubuntu 22.04"),
            SandboxOS::Debian11 => write!(f, "Debian 11"),
            SandboxOS::Debian12 => write!(f, "Debian 12"),
            SandboxOS::Kali => write!(f, "Kali Linux"),
            SandboxOS::CentOS7 => write!(f, "CentOS 7"),
            SandboxOS::Alpine => write!(f, "Alpine Linux"),
            SandboxOS::Custom(name) => write!(f, "{}", name),
        }
    }
}

/// Sandbox execution status
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum SandboxStatus {
    Pending,
    Preparing,
    Running,
    Completed,
    Failed,
    Timeout,
    Cancelled,
}

/// Network configuration for sandbox
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NetworkConfig {
    /// Enable network access
    pub enabled: bool,
    /// Capture network traffic
    pub capture_traffic: bool,
    /// Allow internet access
    pub internet_access: bool,
    /// Custom DNS servers
    pub dns_servers: Vec<String>,
    /// Port forwarding rules (host:container)
    pub port_forwards: Vec<(u16, u16)>,
}

impl Default for NetworkConfig {
    fn default() -> Self {
        Self {
            enabled: true,
            capture_traffic: true,
            internet_access: false, // Isolated by default
            dns_servers: vec!["8.8.8.8".to_string()],
            port_forwards: vec![],
        }
    }
}

/// Resource limits for sandbox execution
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResourceLimits {
    /// Maximum memory in MB
    pub max_memory_mb: u32,
    /// Maximum CPU cores
    pub max_cpus: u32,
    /// Maximum disk space in MB
    pub max_disk_mb: u32,
    /// Maximum execution time in seconds
    pub timeout_seconds: u32,
}

impl Default for ResourceLimits {
    fn default() -> Self {
        Self {
            max_memory_mb: 2048,
            max_cpus: 2,
            max_disk_mb: 10240,
            timeout_seconds: 300, // 5 minutes
        }
    }
}

/// Configuration for a sandbox execution
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SandboxConfig {
    /// Sandbox type
    pub sandbox_type: SandboxType,
    /// Target operating system
    pub target_os: SandboxOS,
    /// Network configuration
    pub network: NetworkConfig,
    /// Resource limits
    pub limits: ResourceLimits,
    /// Environment variables
    pub environment: HashMap<String, String>,
    /// Files to inject into sandbox
    pub inject_files: Vec<InjectedFile>,
    /// Commands to run before PoC
    pub setup_commands: Vec<String>,
    /// Commands to run after PoC
    pub cleanup_commands: Vec<String>,
    /// Capture screenshots during execution
    pub capture_screenshots: bool,
    /// Record full execution video
    pub record_video: bool,
    /// Enable API monitoring
    pub monitor_api_calls: bool,
    /// Enable file system monitoring
    pub monitor_filesystem: bool,
    /// Enable registry monitoring (Windows)
    pub monitor_registry: bool,
    /// Enable process monitoring
    pub monitor_processes: bool,
}

impl Default for SandboxConfig {
    fn default() -> Self {
        Self {
            sandbox_type: SandboxType::Docker,
            target_os: SandboxOS::Ubuntu22,
            network: NetworkConfig::default(),
            limits: ResourceLimits::default(),
            environment: HashMap::new(),
            inject_files: vec![],
            setup_commands: vec![],
            cleanup_commands: vec![],
            capture_screenshots: true,
            record_video: false,
            monitor_api_calls: true,
            monitor_filesystem: true,
            monitor_registry: true,
            monitor_processes: true,
        }
    }
}

/// File to inject into sandbox
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InjectedFile {
    /// File content (base64 encoded for binary)
    pub content: String,
    /// Destination path in sandbox
    pub dest_path: String,
    /// File permissions (Unix style)
    pub permissions: Option<String>,
    /// Whether content is base64 encoded
    pub is_base64: bool,
}

/// Request to execute a PoC in sandbox
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SandboxExecutionRequest {
    /// PoC ID being tested
    pub poc_id: String,
    /// PoC code to execute
    pub code: String,
    /// Language of the PoC
    pub language: String,
    /// Sandbox configuration
    pub config: SandboxConfig,
    /// Target information (IP, hostname, etc.)
    pub target_info: Option<TargetInfo>,
    /// Additional arguments for the PoC
    pub arguments: Vec<String>,
    /// Description of what this test is validating
    pub test_description: Option<String>,
}

/// Target information for PoC execution
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TargetInfo {
    /// Target IP or hostname
    pub host: String,
    /// Target port
    pub port: Option<u16>,
    /// Target service
    pub service: Option<String>,
    /// Target version
    pub version: Option<String>,
    /// Additional target metadata
    pub metadata: HashMap<String, String>,
}

/// Result of a sandbox execution
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SandboxExecutionResult {
    /// Unique execution ID
    pub execution_id: String,
    /// PoC ID tested
    pub poc_id: String,
    /// Execution status
    pub status: SandboxStatus,
    /// Exit code from PoC execution
    pub exit_code: Option<i32>,
    /// Standard output
    pub stdout: String,
    /// Standard error
    pub stderr: String,
    /// Execution duration in milliseconds
    pub duration_ms: u64,
    /// Network activity captured
    pub network_activity: Vec<NetworkEvent>,
    /// File system activity
    pub filesystem_activity: Vec<FilesystemEvent>,
    /// Process activity
    pub process_activity: Vec<ProcessEvent>,
    /// Registry activity (Windows)
    pub registry_activity: Vec<RegistryEvent>,
    /// API calls monitored
    pub api_calls: Vec<ApiCall>,
    /// Screenshots captured
    pub screenshots: Vec<String>,
    /// Artifacts created/modified
    pub artifacts: Vec<Artifact>,
    /// Exploit success indicators
    pub success_indicators: Vec<SuccessIndicator>,
    /// Error message if failed
    pub error_message: Option<String>,
    /// Started at timestamp
    pub started_at: DateTime<Utc>,
    /// Completed at timestamp
    pub completed_at: Option<DateTime<Utc>>,
}

/// Network event during sandbox execution
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NetworkEvent {
    pub timestamp: DateTime<Utc>,
    pub event_type: String, // connect, send, receive, dns
    pub protocol: String,
    pub src_ip: String,
    pub src_port: u16,
    pub dst_ip: String,
    pub dst_port: u16,
    pub data_size: u64,
    pub data_preview: Option<String>,
}

/// File system event during execution
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FilesystemEvent {
    pub timestamp: DateTime<Utc>,
    pub operation: String, // create, modify, delete, read
    pub path: String,
    pub process: String,
    pub size: Option<u64>,
    pub hash: Option<String>,
}

/// Process event during execution
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProcessEvent {
    pub timestamp: DateTime<Utc>,
    pub event_type: String, // start, stop, inject
    pub pid: u32,
    pub parent_pid: Option<u32>,
    pub name: String,
    pub command_line: String,
    pub user: Option<String>,
}

/// Registry event (Windows)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RegistryEvent {
    pub timestamp: DateTime<Utc>,
    pub operation: String, // create_key, set_value, delete_key
    pub key_path: String,
    pub value_name: Option<String>,
    pub value_data: Option<String>,
    pub process: String,
}

/// API call monitored during execution
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ApiCall {
    pub timestamp: DateTime<Utc>,
    pub api_name: String,
    pub module: String,
    pub arguments: Vec<String>,
    pub return_value: Option<String>,
    pub process: String,
    pub suspicious: bool,
}

/// Artifact created during execution
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Artifact {
    pub artifact_type: String, // file, memory_dump, screenshot, pcap
    pub name: String,
    pub path: String,
    pub size: u64,
    pub hash: Option<String>,
    pub description: Option<String>,
}

/// Indicator that exploit succeeded
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SuccessIndicator {
    pub indicator_type: String, // shell_obtained, privilege_escalated, file_created, etc.
    pub description: String,
    pub evidence: String,
    pub confidence: f64, // 0.0 - 1.0
    pub timestamp: DateTime<Utc>,
}

/// Sandbox manager for executing PoCs
pub struct SandboxManager {
    /// Docker socket path
    docker_socket: String,
    /// Default configuration
    default_config: SandboxConfig,
    /// Available sandbox images
    available_images: HashMap<SandboxOS, String>,
    /// API keys for cloud sandboxes
    api_keys: HashMap<SandboxType, String>,
}

impl SandboxManager {
    /// Create a new sandbox manager
    pub fn new() -> Self {
        let mut available_images = HashMap::new();
        available_images.insert(SandboxOS::Ubuntu22, "heroforge/sandbox-ubuntu:22.04".to_string());
        available_images.insert(SandboxOS::Ubuntu20, "heroforge/sandbox-ubuntu:20.04".to_string());
        available_images.insert(SandboxOS::Debian12, "heroforge/sandbox-debian:12".to_string());
        available_images.insert(SandboxOS::Kali, "heroforge/sandbox-kali:latest".to_string());
        available_images.insert(SandboxOS::Alpine, "heroforge/sandbox-alpine:latest".to_string());

        Self {
            docker_socket: "/var/run/docker.sock".to_string(),
            default_config: SandboxConfig::default(),
            available_images,
            api_keys: HashMap::new(),
        }
    }

    /// Set API key for cloud sandbox
    pub fn set_api_key(&mut self, sandbox_type: SandboxType, api_key: String) {
        self.api_keys.insert(sandbox_type, api_key);
    }

    /// Execute a PoC in a sandbox
    pub async fn execute(&self, request: SandboxExecutionRequest) -> Result<SandboxExecutionResult> {
        let execution_id = uuid::Uuid::new_v4().to_string();
        let started_at = Utc::now();

        info!("Starting sandbox execution {} for PoC {}", execution_id, request.poc_id);

        match request.config.sandbox_type {
            SandboxType::Docker => {
                self.execute_docker(&execution_id, &request, started_at).await
            }
            SandboxType::LocalVm => {
                self.execute_local_vm(&execution_id, &request, started_at).await
            }
            SandboxType::AnyRun => {
                self.execute_anyrun(&execution_id, &request, started_at).await
            }
            SandboxType::HybridAnalysis => {
                self.execute_hybrid_analysis(&execution_id, &request, started_at).await
            }
            SandboxType::Custom => {
                self.execute_custom(&execution_id, &request, started_at).await
            }
        }
    }

    /// Execute PoC in Docker sandbox
    async fn execute_docker(
        &self,
        execution_id: &str,
        request: &SandboxExecutionRequest,
        started_at: DateTime<Utc>,
    ) -> Result<SandboxExecutionResult> {
        let image = self.available_images
            .get(&request.config.target_os)
            .ok_or_else(|| anyhow!("No Docker image available for {:?}", request.config.target_os))?;

        // Build Docker run command
        let container_name = format!("heroforge-sandbox-{}", execution_id);

        // Create temporary directory for PoC code
        let temp_dir = std::env::temp_dir().join(format!("heroforge-poc-{}", execution_id));
        std::fs::create_dir_all(&temp_dir)?;

        // Write PoC code to file
        let poc_file = temp_dir.join(self.get_filename_for_language(&request.language));
        std::fs::write(&poc_file, &request.code)?;

        // Build Docker command
        let mut cmd = Command::new("docker");
        cmd.arg("run")
            .arg("--rm")
            .arg("--name").arg(&container_name)
            .arg("--memory").arg(format!("{}m", request.config.limits.max_memory_mb))
            .arg("--cpus").arg(request.config.limits.max_cpus.to_string())
            .arg("-v").arg(format!("{}:/poc:ro", temp_dir.display()));

        // Network configuration
        if !request.config.network.enabled {
            cmd.arg("--network").arg("none");
        }

        // Environment variables
        for (key, value) in &request.config.environment {
            cmd.arg("-e").arg(format!("{}={}", key, value));
        }

        // Add the image and command
        cmd.arg(image);
        cmd.arg(self.get_interpreter_for_language(&request.language));
        cmd.arg(format!("/poc/{}", poc_file.file_name().unwrap().to_string_lossy()));

        // Add arguments
        for arg in &request.arguments {
            cmd.arg(arg);
        }

        debug!("Running Docker command: {:?}", cmd);

        // Execute with timeout
        let output = tokio::time::timeout(
            Duration::from_secs(request.config.limits.timeout_seconds as u64),
            tokio::task::spawn_blocking(move || cmd.output()),
        ).await;

        // Cleanup temp directory
        let _ = std::fs::remove_dir_all(&temp_dir);

        let completed_at = Utc::now();
        let duration_ms = (completed_at - started_at).num_milliseconds() as u64;

        match output {
            Ok(Ok(Ok(output))) => {
                let stdout = String::from_utf8_lossy(&output.stdout).to_string();
                let stderr = String::from_utf8_lossy(&output.stderr).to_string();
                let exit_code = output.status.code();

                // Analyze output for success indicators
                let success_indicators = self.analyze_output_for_success(&stdout, &stderr);

                Ok(SandboxExecutionResult {
                    execution_id: execution_id.to_string(),
                    poc_id: request.poc_id.clone(),
                    status: if output.status.success() { SandboxStatus::Completed } else { SandboxStatus::Failed },
                    exit_code,
                    stdout,
                    stderr,
                    duration_ms,
                    network_activity: vec![],
                    filesystem_activity: vec![],
                    process_activity: vec![],
                    registry_activity: vec![],
                    api_calls: vec![],
                    screenshots: vec![],
                    artifacts: vec![],
                    success_indicators,
                    error_message: if output.status.success() { None } else { Some("PoC execution failed".to_string()) },
                    started_at,
                    completed_at: Some(completed_at),
                })
            }
            Ok(Ok(Err(e))) => {
                Ok(SandboxExecutionResult {
                    execution_id: execution_id.to_string(),
                    poc_id: request.poc_id.clone(),
                    status: SandboxStatus::Failed,
                    exit_code: None,
                    stdout: String::new(),
                    stderr: String::new(),
                    duration_ms,
                    network_activity: vec![],
                    filesystem_activity: vec![],
                    process_activity: vec![],
                    registry_activity: vec![],
                    api_calls: vec![],
                    screenshots: vec![],
                    artifacts: vec![],
                    success_indicators: vec![],
                    error_message: Some(format!("Failed to execute Docker: {}", e)),
                    started_at,
                    completed_at: Some(completed_at),
                })
            }
            Ok(Err(e)) => {
                Ok(SandboxExecutionResult {
                    execution_id: execution_id.to_string(),
                    poc_id: request.poc_id.clone(),
                    status: SandboxStatus::Failed,
                    exit_code: None,
                    stdout: String::new(),
                    stderr: String::new(),
                    duration_ms,
                    network_activity: vec![],
                    filesystem_activity: vec![],
                    process_activity: vec![],
                    registry_activity: vec![],
                    api_calls: vec![],
                    screenshots: vec![],
                    artifacts: vec![],
                    success_indicators: vec![],
                    error_message: Some(format!("Task join error: {}", e)),
                    started_at,
                    completed_at: Some(completed_at),
                })
            }
            Err(_) => {
                // Timeout - try to kill the container
                let _ = Command::new("docker")
                    .args(["kill", &container_name])
                    .output();

                Ok(SandboxExecutionResult {
                    execution_id: execution_id.to_string(),
                    poc_id: request.poc_id.clone(),
                    status: SandboxStatus::Timeout,
                    exit_code: None,
                    stdout: String::new(),
                    stderr: String::new(),
                    duration_ms,
                    network_activity: vec![],
                    filesystem_activity: vec![],
                    process_activity: vec![],
                    registry_activity: vec![],
                    api_calls: vec![],
                    screenshots: vec![],
                    artifacts: vec![],
                    success_indicators: vec![],
                    error_message: Some(format!("Execution timed out after {} seconds", request.config.limits.timeout_seconds)),
                    started_at,
                    completed_at: Some(completed_at),
                })
            }
        }
    }

    /// Execute PoC via Any.Run API
    ///
    /// Any.Run is a cloud-based interactive malware analysis sandbox.
    /// API Documentation: https://any.run/api-documentation/
    async fn execute_anyrun(
        &self,
        execution_id: &str,
        request: &SandboxExecutionRequest,
        started_at: DateTime<Utc>,
    ) -> Result<SandboxExecutionResult> {
        let api_key = self.api_keys.get(&SandboxType::AnyRun)
            .ok_or_else(|| anyhow!("Any.Run API key not configured"))?;

        let client = reqwest::Client::new();
        let anyrun_api_base = "https://api.any.run/v1";

        // Create a temporary file with the PoC code
        let temp_dir = std::env::temp_dir().join(format!("heroforge-anyrun-{}", execution_id));
        std::fs::create_dir_all(&temp_dir)?;
        let poc_file = temp_dir.join(self.get_filename_for_language(&request.language));
        std::fs::write(&poc_file, &request.code)?;

        // Prepare multipart form for file submission
        let file_content = std::fs::read(&poc_file)?;
        let file_part = reqwest::multipart::Part::bytes(file_content)
            .file_name(poc_file.file_name().unwrap().to_string_lossy().to_string())
            .mime_str("application/octet-stream")?;

        // Map SandboxOS to Any.Run environment ID
        let env_os = match &request.config.target_os {
            SandboxOS::Windows7 => "7",
            SandboxOS::Windows10 => "10",
            SandboxOS::Windows11 => "11",
            _ => "10", // Default to Windows 10 for unsupported OS
        };

        let form = reqwest::multipart::Form::new()
            .part("file", file_part)
            .text("env_os", env_os.to_string())
            .text("env_bitness", "64")
            .text("env_type", "complete")
            .text("opt_network_connect", if request.config.network.internet_access { "true" } else { "false" })
            .text("opt_privacy_type", "bylink"); // Analysis results accessible by link

        // Submit file for analysis
        let submit_url = format!("{}/analysis", anyrun_api_base);
        let submit_response = client
            .post(&submit_url)
            .header("Authorization", format!("API-Key {}", api_key))
            .multipart(form)
            .send()
            .await;

        // Cleanup temp file
        let _ = std::fs::remove_dir_all(&temp_dir);

        match submit_response {
            Ok(response) => {
                if !response.status().is_success() {
                    let status = response.status();
                    let body = response.text().await.unwrap_or_default();
                    return Ok(SandboxExecutionResult {
                        execution_id: execution_id.to_string(),
                        poc_id: request.poc_id.clone(),
                        status: SandboxStatus::Failed,
                        exit_code: None,
                        stdout: String::new(),
                        stderr: format!("Any.Run API error ({}): {}", status, body),
                        duration_ms: 0,
                        network_activity: vec![],
                        filesystem_activity: vec![],
                        process_activity: vec![],
                        registry_activity: vec![],
                        api_calls: vec![],
                        screenshots: vec![],
                        artifacts: vec![],
                        success_indicators: vec![],
                        error_message: Some(format!("Any.Run submission failed: {}", status)),
                        started_at,
                        completed_at: Some(Utc::now()),
                    });
                }

                // Parse submission response to get task ID
                let submit_data: serde_json::Value = response.json().await
                    .map_err(|e| anyhow!("Failed to parse Any.Run response: {}", e))?;

                let task_id = submit_data.get("data")
                    .and_then(|d| d.get("taskid"))
                    .and_then(|t| t.as_str())
                    .ok_or_else(|| anyhow!("No task ID in Any.Run response"))?;

                info!("Any.Run analysis submitted, task ID: {}", task_id);

                // Poll for analysis completion (with timeout)
                let poll_timeout = Duration::from_secs(request.config.limits.timeout_seconds as u64);
                let poll_start = std::time::Instant::now();
                let poll_interval = Duration::from_secs(10);

                let mut final_result = None;

                while poll_start.elapsed() < poll_timeout {
                    tokio::time::sleep(poll_interval).await;

                    let status_url = format!("{}/analysis/{}", anyrun_api_base, task_id);
                    let status_response = client
                        .get(&status_url)
                        .header("Authorization", format!("API-Key {}", api_key))
                        .send()
                        .await;

                    if let Ok(resp) = status_response {
                        if resp.status().is_success() {
                            if let Ok(status_data) = resp.json::<serde_json::Value>().await {
                                let status = status_data.get("data")
                                    .and_then(|d| d.get("status"))
                                    .and_then(|s| s.as_str())
                                    .unwrap_or("unknown");

                                debug!("Any.Run task {} status: {}", task_id, status);

                                if status == "done" {
                                    final_result = Some(status_data);
                                    break;
                                } else if status == "failed" || status == "error" {
                                    return Ok(SandboxExecutionResult {
                                        execution_id: execution_id.to_string(),
                                        poc_id: request.poc_id.clone(),
                                        status: SandboxStatus::Failed,
                                        exit_code: None,
                                        stdout: String::new(),
                                        stderr: String::new(),
                                        duration_ms: poll_start.elapsed().as_millis() as u64,
                                        network_activity: vec![],
                                        filesystem_activity: vec![],
                                        process_activity: vec![],
                                        registry_activity: vec![],
                                        api_calls: vec![],
                                        screenshots: vec![],
                                        artifacts: vec![],
                                        success_indicators: vec![],
                                        error_message: Some("Any.Run analysis failed".to_string()),
                                        started_at,
                                        completed_at: Some(Utc::now()),
                                    });
                                }
                            }
                        }
                    }
                }

                let completed_at = Utc::now();
                let duration_ms = (completed_at - started_at).num_milliseconds() as u64;

                // Process results if we have them
                if let Some(result_data) = final_result {
                    let data = result_data.get("data").cloned().unwrap_or_default();

                    // Extract network activity
                    let network_activity = self.parse_anyrun_network(&data);

                    // Extract process activity
                    let process_activity = self.parse_anyrun_processes(&data);

                    // Extract file activity
                    let filesystem_activity = self.parse_anyrun_files(&data);

                    // Check for malicious indicators
                    let threat_level = data.get("scores")
                        .and_then(|s| s.get("verdict"))
                        .and_then(|v| v.as_str())
                        .unwrap_or("unknown");

                    let mut success_indicators = vec![];
                    if threat_level == "malicious" || threat_level == "suspicious" {
                        success_indicators.push(SuccessIndicator {
                            indicator_type: "malicious_behavior".to_string(),
                            description: format!("Any.Run verdict: {}", threat_level),
                            evidence: serde_json::to_string(&data.get("scores")).unwrap_or_default(),
                            confidence: if threat_level == "malicious" { 0.9 } else { 0.6 },
                            timestamp: completed_at,
                        });
                    }

                    // Get report URL for artifacts
                    let report_url = data.get("permanentUrl")
                        .and_then(|u| u.as_str())
                        .unwrap_or("")
                        .to_string();

                    let artifacts = if !report_url.is_empty() {
                        vec![Artifact {
                            artifact_type: "report".to_string(),
                            name: "Any.Run Report".to_string(),
                            path: report_url,
                            size: 0,
                            hash: None,
                            description: Some("Full analysis report on Any.Run".to_string()),
                        }]
                    } else {
                        vec![]
                    };

                    Ok(SandboxExecutionResult {
                        execution_id: execution_id.to_string(),
                        poc_id: request.poc_id.clone(),
                        status: SandboxStatus::Completed,
                        exit_code: Some(0),
                        stdout: serde_json::to_string_pretty(&data).unwrap_or_default(),
                        stderr: String::new(),
                        duration_ms,
                        network_activity,
                        filesystem_activity,
                        process_activity,
                        registry_activity: vec![],
                        api_calls: vec![],
                        screenshots: vec![],
                        artifacts,
                        success_indicators,
                        error_message: None,
                        started_at,
                        completed_at: Some(completed_at),
                    })
                } else {
                    Ok(SandboxExecutionResult {
                        execution_id: execution_id.to_string(),
                        poc_id: request.poc_id.clone(),
                        status: SandboxStatus::Timeout,
                        exit_code: None,
                        stdout: String::new(),
                        stderr: String::new(),
                        duration_ms,
                        network_activity: vec![],
                        filesystem_activity: vec![],
                        process_activity: vec![],
                        registry_activity: vec![],
                        api_calls: vec![],
                        screenshots: vec![],
                        artifacts: vec![],
                        success_indicators: vec![],
                        error_message: Some("Any.Run analysis timed out".to_string()),
                        started_at,
                        completed_at: Some(completed_at),
                    })
                }
            }
            Err(e) => {
                Ok(SandboxExecutionResult {
                    execution_id: execution_id.to_string(),
                    poc_id: request.poc_id.clone(),
                    status: SandboxStatus::Failed,
                    exit_code: None,
                    stdout: String::new(),
                    stderr: String::new(),
                    duration_ms: 0,
                    network_activity: vec![],
                    filesystem_activity: vec![],
                    process_activity: vec![],
                    registry_activity: vec![],
                    api_calls: vec![],
                    screenshots: vec![],
                    artifacts: vec![],
                    success_indicators: vec![],
                    error_message: Some(format!("Failed to connect to Any.Run API: {}", e)),
                    started_at,
                    completed_at: Some(Utc::now()),
                })
            }
        }
    }

    /// Parse network activity from Any.Run results
    fn parse_anyrun_network(&self, data: &serde_json::Value) -> Vec<NetworkEvent> {
        let mut events = vec![];

        if let Some(network) = data.get("network") {
            // Parse HTTP requests
            if let Some(http) = network.get("http").and_then(|h| h.as_array()) {
                for req in http {
                    events.push(NetworkEvent {
                        timestamp: Utc::now(),
                        event_type: "http".to_string(),
                        protocol: "HTTP".to_string(),
                        src_ip: "sandbox".to_string(),
                        src_port: 0,
                        dst_ip: req.get("ip").and_then(|i| i.as_str()).unwrap_or("").to_string(),
                        dst_port: req.get("port").and_then(|p| p.as_u64()).unwrap_or(80) as u16,
                        data_size: 0,
                        data_preview: req.get("url").and_then(|u| u.as_str()).map(|s| s.to_string()),
                    });
                }
            }

            // Parse DNS queries
            if let Some(dns) = network.get("dns").and_then(|d| d.as_array()) {
                for query in dns {
                    events.push(NetworkEvent {
                        timestamp: Utc::now(),
                        event_type: "dns".to_string(),
                        protocol: "DNS".to_string(),
                        src_ip: "sandbox".to_string(),
                        src_port: 0,
                        dst_ip: "8.8.8.8".to_string(),
                        dst_port: 53,
                        data_size: 0,
                        data_preview: query.get("domain").and_then(|d| d.as_str()).map(|s| s.to_string()),
                    });
                }
            }

            // Parse connections
            if let Some(connections) = network.get("connections").and_then(|c| c.as_array()) {
                for conn in connections {
                    events.push(NetworkEvent {
                        timestamp: Utc::now(),
                        event_type: "connect".to_string(),
                        protocol: conn.get("protocol").and_then(|p| p.as_str()).unwrap_or("TCP").to_string(),
                        src_ip: "sandbox".to_string(),
                        src_port: 0,
                        dst_ip: conn.get("ip").and_then(|i| i.as_str()).unwrap_or("").to_string(),
                        dst_port: conn.get("port").and_then(|p| p.as_u64()).unwrap_or(0) as u16,
                        data_size: 0,
                        data_preview: None,
                    });
                }
            }
        }

        events
    }

    /// Parse process activity from Any.Run results
    fn parse_anyrun_processes(&self, data: &serde_json::Value) -> Vec<ProcessEvent> {
        let mut events = vec![];

        if let Some(processes) = data.get("processes").and_then(|p| p.as_array()) {
            for proc in processes {
                events.push(ProcessEvent {
                    timestamp: Utc::now(),
                    event_type: "start".to_string(),
                    pid: proc.get("pid").and_then(|p| p.as_u64()).unwrap_or(0) as u32,
                    parent_pid: proc.get("ppid").and_then(|p| p.as_u64()).map(|p| p as u32),
                    name: proc.get("name").and_then(|n| n.as_str()).unwrap_or("").to_string(),
                    command_line: proc.get("commandLine").and_then(|c| c.as_str()).unwrap_or("").to_string(),
                    user: None,
                });
            }
        }

        events
    }

    /// Parse file activity from Any.Run results
    fn parse_anyrun_files(&self, data: &serde_json::Value) -> Vec<FilesystemEvent> {
        let mut events = vec![];

        if let Some(files) = data.get("files").and_then(|f| f.as_array()) {
            for file in files {
                let operation = file.get("op").and_then(|o| o.as_str()).unwrap_or("unknown");
                events.push(FilesystemEvent {
                    timestamp: Utc::now(),
                    operation: operation.to_string(),
                    path: file.get("path").and_then(|p| p.as_str()).unwrap_or("").to_string(),
                    process: file.get("process").and_then(|p| p.as_str()).unwrap_or("").to_string(),
                    size: file.get("size").and_then(|s| s.as_u64()),
                    hash: file.get("hash").and_then(|h| h.as_str()).map(|s| s.to_string()),
                });
            }
        }

        events
    }

    /// Execute PoC via Hybrid Analysis API
    ///
    /// Hybrid Analysis is a free malware analysis service powered by Falcon Sandbox.
    /// API Documentation: https://www.hybrid-analysis.com/docs/api/v2
    async fn execute_hybrid_analysis(
        &self,
        execution_id: &str,
        request: &SandboxExecutionRequest,
        started_at: DateTime<Utc>,
    ) -> Result<SandboxExecutionResult> {
        let api_key = self.api_keys.get(&SandboxType::HybridAnalysis)
            .ok_or_else(|| anyhow!("Hybrid Analysis API key not configured"))?;

        let client = reqwest::Client::new();
        let ha_api_base = "https://www.hybrid-analysis.com/api/v2";

        // Create a temporary file with the PoC code
        let temp_dir = std::env::temp_dir().join(format!("heroforge-ha-{}", execution_id));
        std::fs::create_dir_all(&temp_dir)?;
        let poc_file = temp_dir.join(self.get_filename_for_language(&request.language));
        std::fs::write(&poc_file, &request.code)?;

        // Prepare multipart form for file submission
        let file_content = std::fs::read(&poc_file)?;
        let file_part = reqwest::multipart::Part::bytes(file_content)
            .file_name(poc_file.file_name().unwrap().to_string_lossy().to_string())
            .mime_str("application/octet-stream")?;

        // Map SandboxOS to Hybrid Analysis environment ID
        // Environment IDs: 100=Win7 32bit, 110=Win7 64bit, 120=Win10 64bit, etc.
        let environment_id = match &request.config.target_os {
            SandboxOS::Windows7 => "110",   // Windows 7 64-bit
            SandboxOS::Windows10 => "120",  // Windows 10 64-bit
            SandboxOS::Windows11 => "140",  // Windows 11 64-bit (if available)
            SandboxOS::Ubuntu20 | SandboxOS::Ubuntu22 => "300", // Linux
            _ => "120", // Default to Windows 10 64-bit
        };

        let form = reqwest::multipart::Form::new()
            .part("file", file_part)
            .text("environment_id", environment_id.to_string())
            .text("no_share_third_party", "true")
            .text("allow_community_access", "false");

        // Submit file for analysis
        let submit_url = format!("{}/submit/file", ha_api_base);
        let submit_response = client
            .post(&submit_url)
            .header("api-key", api_key.as_str())
            .header("User-Agent", "HeroForge Security Platform")
            .header("Accept", "application/json")
            .multipart(form)
            .send()
            .await;

        // Cleanup temp file
        let _ = std::fs::remove_dir_all(&temp_dir);

        match submit_response {
            Ok(response) => {
                if !response.status().is_success() {
                    let status = response.status();
                    let body = response.text().await.unwrap_or_default();
                    return Ok(SandboxExecutionResult {
                        execution_id: execution_id.to_string(),
                        poc_id: request.poc_id.clone(),
                        status: SandboxStatus::Failed,
                        exit_code: None,
                        stdout: String::new(),
                        stderr: format!("Hybrid Analysis API error ({}): {}", status, body),
                        duration_ms: 0,
                        network_activity: vec![],
                        filesystem_activity: vec![],
                        process_activity: vec![],
                        registry_activity: vec![],
                        api_calls: vec![],
                        screenshots: vec![],
                        artifacts: vec![],
                        success_indicators: vec![],
                        error_message: Some(format!("Hybrid Analysis submission failed: {}", status)),
                        started_at,
                        completed_at: Some(Utc::now()),
                    });
                }

                // Parse submission response to get job ID
                let submit_data: serde_json::Value = response.json().await
                    .map_err(|e| anyhow!("Failed to parse Hybrid Analysis response: {}", e))?;

                let job_id = submit_data.get("job_id")
                    .and_then(|j| j.as_str())
                    .ok_or_else(|| anyhow!("No job_id in Hybrid Analysis response"))?;

                let sha256 = submit_data.get("sha256")
                    .and_then(|s| s.as_str())
                    .map(|s| s.to_string());

                info!("Hybrid Analysis job submitted, job ID: {}", job_id);

                // Poll for analysis completion (with timeout)
                let poll_timeout = Duration::from_secs(request.config.limits.timeout_seconds as u64);
                let poll_start = std::time::Instant::now();
                let poll_interval = Duration::from_secs(15);

                let mut final_result = None;

                while poll_start.elapsed() < poll_timeout {
                    tokio::time::sleep(poll_interval).await;

                    // Check job state
                    let state_url = format!("{}/report/{}/state", ha_api_base, job_id);
                    let state_response = client
                        .get(&state_url)
                        .header("api-key", api_key.as_str())
                        .header("User-Agent", "HeroForge Security Platform")
                        .header("Accept", "application/json")
                        .send()
                        .await;

                    if let Ok(resp) = state_response {
                        if resp.status().is_success() {
                            if let Ok(state_data) = resp.json::<serde_json::Value>().await {
                                let state = state_data.get("state")
                                    .and_then(|s| s.as_str())
                                    .unwrap_or("unknown");

                                debug!("Hybrid Analysis job {} state: {}", job_id, state);

                                if state == "SUCCESS" {
                                    // Fetch the full report
                                    let report_url = format!("{}/report/{}/summary", ha_api_base, job_id);
                                    if let Ok(report_resp) = client
                                        .get(&report_url)
                                        .header("api-key", api_key.as_str())
                                        .header("User-Agent", "HeroForge Security Platform")
                                        .header("Accept", "application/json")
                                        .send()
                                        .await
                                    {
                                        if let Ok(report_data) = report_resp.json::<serde_json::Value>().await {
                                            final_result = Some(report_data);
                                            break;
                                        }
                                    }
                                } else if state == "ERROR" || state == "FAILED" {
                                    return Ok(SandboxExecutionResult {
                                        execution_id: execution_id.to_string(),
                                        poc_id: request.poc_id.clone(),
                                        status: SandboxStatus::Failed,
                                        exit_code: None,
                                        stdout: String::new(),
                                        stderr: String::new(),
                                        duration_ms: poll_start.elapsed().as_millis() as u64,
                                        network_activity: vec![],
                                        filesystem_activity: vec![],
                                        process_activity: vec![],
                                        registry_activity: vec![],
                                        api_calls: vec![],
                                        screenshots: vec![],
                                        artifacts: vec![],
                                        success_indicators: vec![],
                                        error_message: Some("Hybrid Analysis job failed".to_string()),
                                        started_at,
                                        completed_at: Some(Utc::now()),
                                    });
                                }
                            }
                        }
                    }
                }

                let completed_at = Utc::now();
                let duration_ms = (completed_at - started_at).num_milliseconds() as u64;

                // Process results if we have them
                if let Some(report_data) = final_result {
                    // Extract threat analysis
                    let threat_score = report_data.get("threat_score")
                        .and_then(|t| t.as_u64())
                        .unwrap_or(0);

                    let verdict = report_data.get("verdict")
                        .and_then(|v| v.as_str())
                        .unwrap_or("unknown");

                    // Extract network activity
                    let network_activity = self.parse_ha_network(&report_data);

                    // Extract process activity
                    let process_activity = self.parse_ha_processes(&report_data);

                    // Extract file activity
                    let filesystem_activity = self.parse_ha_files(&report_data);

                    // Determine success indicators
                    let mut success_indicators = vec![];

                    if threat_score > 50 || verdict == "malicious" {
                        success_indicators.push(SuccessIndicator {
                            indicator_type: "malicious_behavior".to_string(),
                            description: format!("Hybrid Analysis verdict: {} (score: {})", verdict, threat_score),
                            evidence: format!("Threat score: {}/100", threat_score),
                            confidence: (threat_score as f64) / 100.0,
                            timestamp: completed_at,
                        });
                    }

                    // Build artifacts list
                    let mut artifacts = vec![];

                    // Add report link
                    if let Some(sha) = &sha256 {
                        artifacts.push(Artifact {
                            artifact_type: "report".to_string(),
                            name: "Hybrid Analysis Report".to_string(),
                            path: format!("https://www.hybrid-analysis.com/sample/{}", sha),
                            size: 0,
                            hash: sha256.clone(),
                            description: Some("Full analysis report on Hybrid Analysis".to_string()),
                        });
                    }

                    // Extract MITRE ATT&CK techniques if available
                    if let Some(mitre) = report_data.get("mitre_attcks").and_then(|m| m.as_array()) {
                        for technique in mitre {
                            if let Some(technique_id) = technique.get("technique_id").and_then(|t| t.as_str()) {
                                success_indicators.push(SuccessIndicator {
                                    indicator_type: "mitre_attack".to_string(),
                                    description: format!("MITRE ATT&CK: {}", technique_id),
                                    evidence: technique.get("technique").and_then(|t| t.as_str())
                                        .unwrap_or("").to_string(),
                                    confidence: 0.85,
                                    timestamp: completed_at,
                                });
                            }
                        }
                    }

                    Ok(SandboxExecutionResult {
                        execution_id: execution_id.to_string(),
                        poc_id: request.poc_id.clone(),
                        status: SandboxStatus::Completed,
                        exit_code: Some(0),
                        stdout: serde_json::to_string_pretty(&report_data).unwrap_or_default(),
                        stderr: String::new(),
                        duration_ms,
                        network_activity,
                        filesystem_activity,
                        process_activity,
                        registry_activity: vec![],
                        api_calls: vec![],
                        screenshots: vec![],
                        artifacts,
                        success_indicators,
                        error_message: None,
                        started_at,
                        completed_at: Some(completed_at),
                    })
                } else {
                    Ok(SandboxExecutionResult {
                        execution_id: execution_id.to_string(),
                        poc_id: request.poc_id.clone(),
                        status: SandboxStatus::Timeout,
                        exit_code: None,
                        stdout: String::new(),
                        stderr: String::new(),
                        duration_ms,
                        network_activity: vec![],
                        filesystem_activity: vec![],
                        process_activity: vec![],
                        registry_activity: vec![],
                        api_calls: vec![],
                        screenshots: vec![],
                        artifacts: vec![],
                        success_indicators: vec![],
                        error_message: Some("Hybrid Analysis job timed out".to_string()),
                        started_at,
                        completed_at: Some(completed_at),
                    })
                }
            }
            Err(e) => {
                Ok(SandboxExecutionResult {
                    execution_id: execution_id.to_string(),
                    poc_id: request.poc_id.clone(),
                    status: SandboxStatus::Failed,
                    exit_code: None,
                    stdout: String::new(),
                    stderr: String::new(),
                    duration_ms: 0,
                    network_activity: vec![],
                    filesystem_activity: vec![],
                    process_activity: vec![],
                    registry_activity: vec![],
                    api_calls: vec![],
                    screenshots: vec![],
                    artifacts: vec![],
                    success_indicators: vec![],
                    error_message: Some(format!("Failed to connect to Hybrid Analysis API: {}", e)),
                    started_at,
                    completed_at: Some(Utc::now()),
                })
            }
        }
    }

    /// Execute PoC in Local VM sandbox (VirtualBox/QEMU)
    async fn execute_local_vm(
        &self,
        execution_id: &str,
        request: &SandboxExecutionRequest,
        started_at: DateTime<Utc>,
    ) -> Result<SandboxExecutionResult> {
        info!("Executing PoC {} in Local VM sandbox", request.poc_id);

        // Determine VM management tool (VirtualBox or QEMU)
        let vm_tool = if Command::new("VBoxManage").arg("--version").output().is_ok() {
            "virtualbox"
        } else if Command::new("qemu-system-x86_64").arg("--version").output().is_ok() {
            "qemu"
        } else {
            return Err(anyhow!("No VM management tool found. Install VirtualBox or QEMU."));
        };

        // Get VM image name based on OS
        let vm_name = match &request.config.target_os {
            SandboxOS::Windows7 => "heroforge-win7",
            SandboxOS::Windows10 => "heroforge-win10",
            SandboxOS::Windows11 => "heroforge-win11",
            SandboxOS::WindowsServer2019 => "heroforge-winserver2019",
            SandboxOS::Ubuntu20 => "heroforge-ubuntu20",
            SandboxOS::Ubuntu22 => "heroforge-ubuntu22",
            SandboxOS::Debian11 => "heroforge-debian11",
            SandboxOS::Debian12 => "heroforge-debian12",
            SandboxOS::Kali => "heroforge-kali",
            SandboxOS::CentOS7 => "heroforge-centos7",
            SandboxOS::Alpine => "heroforge-alpine",
            SandboxOS::Custom(name) => name.as_str(),
        };

        // Create temporary directory for PoC
        let temp_dir = std::env::temp_dir().join(format!("heroforge-poc-{}", execution_id));
        std::fs::create_dir_all(&temp_dir)?;

        let poc_file = temp_dir.join(self.get_filename_for_language(&request.language));
        std::fs::write(&poc_file, &request.code)?;

        let mut stdout_output = String::new();
        let mut stderr_output = String::new();
        let mut exit_code = None;

        // Execute based on VM tool
        match vm_tool {
            "virtualbox" => {
                // Start VM if not running
                let start_output = Command::new("VBoxManage")
                    .args(["startvm", vm_name, "--type", "headless"])
                    .output();

                if let Err(e) = start_output {
                    warn!("Failed to start VM {}: {}", vm_name, e);
                }

                // Wait for VM to boot
                tokio::time::sleep(Duration::from_secs(30)).await;

                // Copy PoC file to VM using VBoxManage guestcontrol
                let copy_result = Command::new("VBoxManage")
                    .args([
                        "guestcontrol", vm_name, "copyto",
                        &poc_file.display().to_string(),
                        "/tmp/poc",
                        "--username", "sandbox",
                        "--password", "sandbox",
                    ])
                    .output();

                if let Ok(output) = copy_result {
                    if !output.status.success() {
                        stderr_output = format!("Failed to copy PoC to VM: {}",
                            String::from_utf8_lossy(&output.stderr));
                    }
                }

                // Execute PoC in VM
                let interpreter = self.get_interpreter_for_language(&request.language);
                let vm_name_str = vm_name.to_string();
                let exec_result = tokio::time::timeout(
                    Duration::from_secs(request.config.limits.timeout_seconds as u64),
                    tokio::task::spawn_blocking(move || {
                        Command::new("VBoxManage")
                            .arg("guestcontrol")
                            .arg(&vm_name_str)
                            .arg("run")
                            .arg("--exe")
                            .arg(&interpreter)
                            .arg("--username")
                            .arg("sandbox")
                            .arg("--password")
                            .arg("sandbox")
                            .arg("--")
                            .arg("/tmp/poc")
                            .output()
                    })
                ).await;

                match exec_result {
                    Ok(Ok(Ok(output))) => {
                        stdout_output = String::from_utf8_lossy(&output.stdout).to_string();
                        stderr_output = String::from_utf8_lossy(&output.stderr).to_string();
                        exit_code = output.status.code();
                    }
                    Ok(Ok(Err(e))) => {
                        stderr_output = format!("VM execution failed: {}", e);
                    }
                    Ok(Err(e)) => {
                        stderr_output = format!("VM task panicked: {}", e);
                    }
                    Err(_) => {
                        stderr_output = "VM execution timed out".to_string();
                    }
                }

                // Stop VM
                let _ = Command::new("VBoxManage")
                    .args(["controlvm", vm_name, "poweroff"])
                    .output();
            }
            "qemu" => {
                // For QEMU, we use SSH to communicate with the VM
                // This assumes QEMU VMs are configured with port forwarding
                let ssh_port = 2222; // Default SSH port forward

                // Copy PoC via SCP
                let scp_result = Command::new("sshpass")
                    .args([
                        "-p", "sandbox",
                        "scp", "-P", &ssh_port.to_string(),
                        "-o", "StrictHostKeyChecking=no",
                        &poc_file.display().to_string(),
                        "sandbox@localhost:/tmp/poc",
                    ])
                    .output();

                if let Ok(output) = scp_result {
                    if !output.status.success() {
                        warn!("SCP failed: {}", String::from_utf8_lossy(&output.stderr));
                    }
                }

                // Execute via SSH
                let interpreter = self.get_interpreter_for_language(&request.language);
                let exec_result = tokio::time::timeout(
                    Duration::from_secs(request.config.limits.timeout_seconds as u64),
                    tokio::task::spawn_blocking(move || {
                        Command::new("sshpass")
                            .args([
                                "-p", "sandbox",
                                "ssh", "-p", &ssh_port.to_string(),
                                "-o", "StrictHostKeyChecking=no",
                                "sandbox@localhost",
                                &format!("{} /tmp/poc", interpreter),
                            ])
                            .output()
                    })
                ).await;

                match exec_result {
                    Ok(Ok(Ok(output))) => {
                        stdout_output = String::from_utf8_lossy(&output.stdout).to_string();
                        stderr_output = String::from_utf8_lossy(&output.stderr).to_string();
                        exit_code = output.status.code();
                    }
                    Ok(Ok(Err(e))) => {
                        stderr_output = format!("SSH execution failed: {}", e);
                    }
                    Ok(Err(e)) => {
                        stderr_output = format!("SSH task panicked: {}", e);
                    }
                    Err(_) => {
                        stderr_output = "SSH execution timed out".to_string();
                    }
                }
            }
            _ => {
                return Err(anyhow!("Unknown VM tool: {}", vm_tool));
            }
        }

        // Cleanup
        let _ = std::fs::remove_dir_all(&temp_dir);

        let completed_at = Utc::now();
        let duration_ms = (completed_at - started_at).num_milliseconds() as u64;

        // Analyze output for success indicators
        let success_indicators = self.analyze_output_for_success(&stdout_output, &stderr_output);

        let (status, error_message) = if exit_code == Some(0) {
            (SandboxStatus::Completed, None)
        } else if stderr_output.contains("timed out") {
            (SandboxStatus::Timeout, Some("VM execution timed out".to_string()))
        } else {
            (SandboxStatus::Failed, Some("VM execution failed".to_string()))
        };

        Ok(SandboxExecutionResult {
            execution_id: execution_id.to_string(),
            poc_id: request.poc_id.clone(),
            status,
            exit_code,
            stdout: stdout_output,
            stderr: stderr_output,
            duration_ms,
            network_activity: vec![],
            filesystem_activity: vec![],
            process_activity: vec![],
            registry_activity: vec![],
            api_calls: vec![],
            screenshots: vec![],
            artifacts: vec![],
            success_indicators,
            error_message,
            started_at,
            completed_at: Some(completed_at),
        })
    }

    /// Execute PoC using a custom sandbox endpoint
    async fn execute_custom(
        &self,
        execution_id: &str,
        request: &SandboxExecutionRequest,
        started_at: DateTime<Utc>,
    ) -> Result<SandboxExecutionResult> {
        info!("Executing PoC {} via custom sandbox endpoint", request.poc_id);

        // Get custom endpoint from environment or config
        let endpoint = if let Some(ep) = request.config.environment.get("SANDBOX_ENDPOINT") {
            ep.clone()
        } else if let Ok(ep) = std::env::var("HEROFORGE_CUSTOM_SANDBOX_URL") {
            ep
        } else {
            return Err(anyhow!("Custom sandbox endpoint not configured. Set SANDBOX_ENDPOINT in environment or config."));
        };

        let api_key = request.config.environment.get("SANDBOX_API_KEY")
            .cloned()
            .or_else(|| std::env::var("HEROFORGE_CUSTOM_SANDBOX_KEY").ok());

        let client = reqwest::Client::builder()
            .timeout(Duration::from_secs(request.config.limits.timeout_seconds as u64))
            .build()
            .map_err(|e| anyhow!("Failed to create HTTP client: {}", e))?;

        // Build request payload
        let payload = serde_json::json!({
            "execution_id": execution_id,
            "poc_id": request.poc_id,
            "code": request.code,
            "language": request.language,
            "target_os": format!("{:?}", request.config.target_os),
            "timeout_seconds": request.config.limits.timeout_seconds,
            "network_enabled": request.config.network.enabled,
            "internet_access": request.config.network.internet_access,
            "arguments": request.arguments,
            "environment": request.config.environment,
        });

        // Submit to custom sandbox
        let mut req_builder = client.post(&endpoint)
            .header("Content-Type", "application/json")
            .json(&payload);

        if let Some(key) = api_key {
            req_builder = req_builder.header("Authorization", format!("Bearer {}", key));
        }

        let response = req_builder.send().await;

        let completed_at = Utc::now();
        let duration_ms = (completed_at - started_at).num_milliseconds() as u64;

        match response {
            Ok(resp) => {
                if resp.status().is_success() {
                    // Parse response from custom sandbox
                    match resp.json::<serde_json::Value>().await {
                        Ok(data) => {
                            let status_str = data.get("status").and_then(|s| s.as_str()).unwrap_or("unknown");
                            let status = match status_str {
                                "completed" | "success" => SandboxStatus::Completed,
                                "failed" | "error" => SandboxStatus::Failed,
                                "timeout" => SandboxStatus::Timeout,
                                _ => SandboxStatus::Completed,
                            };

                            let stdout = data.get("stdout").and_then(|s| s.as_str()).unwrap_or("").to_string();
                            let stderr = data.get("stderr").and_then(|s| s.as_str()).unwrap_or("").to_string();
                            let exit_code = data.get("exit_code").and_then(|e| e.as_i64()).map(|e| e as i32);

                            let success_indicators = self.analyze_output_for_success(&stdout, &stderr);

                            Ok(SandboxExecutionResult {
                                execution_id: execution_id.to_string(),
                                poc_id: request.poc_id.clone(),
                                status,
                                exit_code,
                                stdout,
                                stderr,
                                duration_ms,
                                network_activity: vec![],
                                filesystem_activity: vec![],
                                process_activity: vec![],
                                registry_activity: vec![],
                                api_calls: vec![],
                                screenshots: vec![],
                                artifacts: vec![],
                                success_indicators,
                                error_message: data.get("error").and_then(|e| e.as_str()).map(String::from),
                                started_at,
                                completed_at: Some(completed_at),
                            })
                        }
                        Err(e) => {
                            Ok(SandboxExecutionResult {
                                execution_id: execution_id.to_string(),
                                poc_id: request.poc_id.clone(),
                                status: SandboxStatus::Failed,
                                exit_code: None,
                                stdout: String::new(),
                                stderr: String::new(),
                                duration_ms,
                                network_activity: vec![],
                                filesystem_activity: vec![],
                                process_activity: vec![],
                                registry_activity: vec![],
                                api_calls: vec![],
                                screenshots: vec![],
                                artifacts: vec![],
                                success_indicators: vec![],
                                error_message: Some(format!("Failed to parse sandbox response: {}", e)),
                                started_at,
                                completed_at: Some(completed_at),
                            })
                        }
                    }
                } else {
                    let status_code = resp.status();
                    let body = resp.text().await.unwrap_or_default();
                    Ok(SandboxExecutionResult {
                        execution_id: execution_id.to_string(),
                        poc_id: request.poc_id.clone(),
                        status: SandboxStatus::Failed,
                        exit_code: None,
                        stdout: String::new(),
                        stderr: format!("Custom sandbox returned error: {} - {}", status_code, body),
                        duration_ms,
                        network_activity: vec![],
                        filesystem_activity: vec![],
                        process_activity: vec![],
                        registry_activity: vec![],
                        api_calls: vec![],
                        screenshots: vec![],
                        artifacts: vec![],
                        success_indicators: vec![],
                        error_message: Some(format!("Custom sandbox error: {}", status_code)),
                        started_at,
                        completed_at: Some(completed_at),
                    })
                }
            }
            Err(e) => {
                Ok(SandboxExecutionResult {
                    execution_id: execution_id.to_string(),
                    poc_id: request.poc_id.clone(),
                    status: SandboxStatus::Failed,
                    exit_code: None,
                    stdout: String::new(),
                    stderr: String::new(),
                    duration_ms,
                    network_activity: vec![],
                    filesystem_activity: vec![],
                    process_activity: vec![],
                    registry_activity: vec![],
                    api_calls: vec![],
                    screenshots: vec![],
                    artifacts: vec![],
                    success_indicators: vec![],
                    error_message: Some(format!("Failed to connect to custom sandbox: {}", e)),
                    started_at,
                    completed_at: Some(completed_at),
                })
            }
        }
    }

    /// Parse network activity from Hybrid Analysis report
    fn parse_ha_network(&self, data: &serde_json::Value) -> Vec<NetworkEvent> {
        let mut events = vec![];

        // Parse domains contacted
        if let Some(domains) = data.get("domains").and_then(|d| d.as_array()) {
            for domain in domains {
                if let Some(domain_str) = domain.as_str() {
                    events.push(NetworkEvent {
                        timestamp: Utc::now(),
                        event_type: "dns".to_string(),
                        protocol: "DNS".to_string(),
                        src_ip: "sandbox".to_string(),
                        src_port: 0,
                        dst_ip: "dns_server".to_string(),
                        dst_port: 53,
                        data_size: 0,
                        data_preview: Some(domain_str.to_string()),
                    });
                }
            }
        }

        // Parse hosts contacted
        if let Some(hosts) = data.get("hosts").and_then(|h| h.as_array()) {
            for host in hosts {
                if let Some(host_str) = host.as_str() {
                    events.push(NetworkEvent {
                        timestamp: Utc::now(),
                        event_type: "connect".to_string(),
                        protocol: "TCP".to_string(),
                        src_ip: "sandbox".to_string(),
                        src_port: 0,
                        dst_ip: host_str.to_string(),
                        dst_port: 0,
                        data_size: 0,
                        data_preview: None,
                    });
                }
            }
        }

        // Parse HTTP requests
        if let Some(http_requests) = data.get("http_requests").and_then(|h| h.as_array()) {
            for req in http_requests {
                events.push(NetworkEvent {
                    timestamp: Utc::now(),
                    event_type: "http".to_string(),
                    protocol: "HTTP".to_string(),
                    src_ip: "sandbox".to_string(),
                    src_port: 0,
                    dst_ip: req.get("host").and_then(|h| h.as_str()).unwrap_or("").to_string(),
                    dst_port: req.get("port").and_then(|p| p.as_u64()).unwrap_or(80) as u16,
                    data_size: 0,
                    data_preview: req.get("url").and_then(|u| u.as_str()).map(|s| s.to_string()),
                });
            }
        }

        events
    }

    /// Parse process activity from Hybrid Analysis report
    fn parse_ha_processes(&self, data: &serde_json::Value) -> Vec<ProcessEvent> {
        let mut events = vec![];

        if let Some(processes) = data.get("processes").and_then(|p| p.as_array()) {
            for proc in processes {
                events.push(ProcessEvent {
                    timestamp: Utc::now(),
                    event_type: "start".to_string(),
                    pid: proc.get("pid").and_then(|p| p.as_u64()).unwrap_or(0) as u32,
                    parent_pid: proc.get("parentpid").and_then(|p| p.as_u64()).map(|p| p as u32),
                    name: proc.get("name").and_then(|n| n.as_str()).unwrap_or("").to_string(),
                    command_line: proc.get("cmd").and_then(|c| c.as_str()).unwrap_or("").to_string(),
                    user: None,
                });
            }
        }

        events
    }

    /// Parse file activity from Hybrid Analysis report
    fn parse_ha_files(&self, data: &serde_json::Value) -> Vec<FilesystemEvent> {
        let mut events = vec![];

        // Parse extracted files
        if let Some(files) = data.get("extracted_files").and_then(|f| f.as_array()) {
            for file in files {
                events.push(FilesystemEvent {
                    timestamp: Utc::now(),
                    operation: "create".to_string(),
                    path: file.get("name").and_then(|n| n.as_str()).unwrap_or("").to_string(),
                    process: file.get("description").and_then(|d| d.as_str()).unwrap_or("").to_string(),
                    size: file.get("size").and_then(|s| s.as_u64()),
                    hash: file.get("sha256").and_then(|h| h.as_str()).map(|s| s.to_string()),
                });
            }
        }

        // Parse dropped files
        if let Some(dropped) = data.get("compromised_hosts").and_then(|c| c.as_array()) {
            for item in dropped {
                if let Some(files) = item.get("files").and_then(|f| f.as_array()) {
                    for file in files {
                        events.push(FilesystemEvent {
                            timestamp: Utc::now(),
                            operation: "drop".to_string(),
                            path: file.get("path").and_then(|p| p.as_str()).unwrap_or("").to_string(),
                            process: "malware".to_string(),
                            size: None,
                            hash: file.get("sha256").and_then(|h| h.as_str()).map(|s| s.to_string()),
                        });
                    }
                }
            }
        }

        events
    }

    /// Get appropriate filename for language
    fn get_filename_for_language(&self, language: &str) -> String {
        match language.to_lowercase().as_str() {
            "python" | "python3" => "poc.py".to_string(),
            "ruby" => "poc.rb".to_string(),
            "perl" => "poc.pl".to_string(),
            "bash" | "sh" => "poc.sh".to_string(),
            "powershell" | "ps1" => "poc.ps1".to_string(),
            "javascript" | "js" | "node" => "poc.js".to_string(),
            "go" => "poc.go".to_string(),
            "rust" => "poc.rs".to_string(),
            "c" => "poc.c".to_string(),
            "cpp" | "c++" => "poc.cpp".to_string(),
            _ => "poc.txt".to_string(),
        }
    }

    /// Get interpreter command for language
    fn get_interpreter_for_language(&self, language: &str) -> String {
        match language.to_lowercase().as_str() {
            "python" | "python3" => "python3".to_string(),
            "ruby" => "ruby".to_string(),
            "perl" => "perl".to_string(),
            "bash" | "sh" => "/bin/bash".to_string(),
            "powershell" | "ps1" => "pwsh".to_string(),
            "javascript" | "js" | "node" => "node".to_string(),
            "go" => "go run".to_string(),
            _ => "/bin/sh".to_string(),
        }
    }

    /// Analyze execution output for success indicators
    fn analyze_output_for_success(&self, stdout: &str, stderr: &str) -> Vec<SuccessIndicator> {
        let mut indicators = vec![];
        let now = Utc::now();
        let combined = format!("{}\n{}", stdout, stderr);

        // Check for shell indicators
        let shell_patterns = [
            "uid=0", "root@", "NT AUTHORITY\\SYSTEM", "Administrator",
            "shell>", "meterpreter>", "cmd.exe", "/bin/sh", "/bin/bash",
        ];
        for pattern in shell_patterns {
            if combined.contains(pattern) {
                indicators.push(SuccessIndicator {
                    indicator_type: "shell_obtained".to_string(),
                    description: "Shell access indicator detected".to_string(),
                    evidence: pattern.to_string(),
                    confidence: 0.8,
                    timestamp: now,
                });
                break;
            }
        }

        // Check for privilege escalation
        let privesc_patterns = [
            "privilege escalation successful", "elevated to",
            "now running as root", "admin access granted",
        ];
        for pattern in privesc_patterns {
            if combined.to_lowercase().contains(&pattern.to_lowercase()) {
                indicators.push(SuccessIndicator {
                    indicator_type: "privilege_escalated".to_string(),
                    description: "Privilege escalation indicator detected".to_string(),
                    evidence: pattern.to_string(),
                    confidence: 0.7,
                    timestamp: now,
                });
                break;
            }
        }

        // Check for successful exploitation messages
        let success_patterns = [
            "exploit successful", "exploitation complete",
            "payload executed", "code execution achieved",
            "vulnerability confirmed", "rce confirmed",
        ];
        for pattern in success_patterns {
            if combined.to_lowercase().contains(&pattern.to_lowercase()) {
                indicators.push(SuccessIndicator {
                    indicator_type: "exploit_successful".to_string(),
                    description: "Explicit success message detected".to_string(),
                    evidence: pattern.to_string(),
                    confidence: 0.9,
                    timestamp: now,
                });
                break;
            }
        }

        indicators
    }

    /// List available sandbox environments
    pub fn list_environments(&self) -> Vec<SandboxEnvironment> {
        self.available_images
            .iter()
            .map(|(os, image)| SandboxEnvironment {
                os: os.clone(),
                image: image.clone(),
                sandbox_type: SandboxType::Docker,
                available: true,
            })
            .collect()
    }

    /// Check if sandbox is available
    pub fn is_available(&self, sandbox_type: &SandboxType, _os: &SandboxOS) -> bool {
        match sandbox_type {
            SandboxType::Docker => true, // Always available if Docker is installed
            SandboxType::LocalVm => {
                // Check if VirtualBox or QEMU is available
                std::process::Command::new("VBoxManage").arg("--version").output().is_ok()
                    || std::process::Command::new("qemu-system-x86_64").arg("--version").output().is_ok()
            }
            SandboxType::AnyRun => self.api_keys.contains_key(&SandboxType::AnyRun),
            SandboxType::HybridAnalysis => self.api_keys.contains_key(&SandboxType::HybridAnalysis),
            SandboxType::Custom => {
                // Check if custom sandbox endpoint is configured
                std::env::var("HEROFORGE_CUSTOM_SANDBOX_URL").is_ok()
            }
        }
    }
}

impl Default for SandboxManager {
    fn default() -> Self {
        Self::new()
    }
}

/// Available sandbox environment
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SandboxEnvironment {
    pub os: SandboxOS,
    pub image: String,
    pub sandbox_type: SandboxType,
    pub available: bool,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_sandbox_manager_creation() {
        let manager = SandboxManager::new();
        assert!(!manager.available_images.is_empty());
    }

    #[test]
    fn test_get_filename_for_language() {
        let manager = SandboxManager::new();
        assert_eq!(manager.get_filename_for_language("python"), "poc.py");
        assert_eq!(manager.get_filename_for_language("ruby"), "poc.rb");
        assert_eq!(manager.get_filename_for_language("bash"), "poc.sh");
    }

    #[test]
    fn test_success_indicator_detection() {
        let manager = SandboxManager::new();

        let indicators = manager.analyze_output_for_success(
            "uid=0(root) gid=0(root) groups=0(root)",
            "",
        );

        assert!(!indicators.is_empty());
        assert!(indicators.iter().any(|i| i.indicator_type == "shell_obtained"));
    }
}
