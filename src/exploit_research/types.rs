//! Types for exploit research module

use chrono::{DateTime, NaiveDate, Utc};
use serde::{Deserialize, Serialize};

/// Platform targeted by an exploit
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum ExploitPlatform {
    Windows,
    Linux,
    MacOS,
    Unix,
    FreeBSD,
    Android,
    IOS,
    Hardware,
    Multiple,
    WebApps,
    Php,
    Java,
    Python,
    Nodejs,
    Ruby,
    Aspx,
    Jsp,
    Cgi,
    Other(String),
}

impl std::fmt::Display for ExploitPlatform {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Windows => write!(f, "windows"),
            Self::Linux => write!(f, "linux"),
            Self::MacOS => write!(f, "macos"),
            Self::Unix => write!(f, "unix"),
            Self::FreeBSD => write!(f, "freebsd"),
            Self::Android => write!(f, "android"),
            Self::IOS => write!(f, "ios"),
            Self::Hardware => write!(f, "hardware"),
            Self::Multiple => write!(f, "multiple"),
            Self::WebApps => write!(f, "webapps"),
            Self::Php => write!(f, "php"),
            Self::Java => write!(f, "java"),
            Self::Python => write!(f, "python"),
            Self::Nodejs => write!(f, "nodejs"),
            Self::Ruby => write!(f, "ruby"),
            Self::Aspx => write!(f, "aspx"),
            Self::Jsp => write!(f, "jsp"),
            Self::Cgi => write!(f, "cgi"),
            Self::Other(s) => write!(f, "{}", s),
        }
    }
}

impl From<&str> for ExploitPlatform {
    fn from(s: &str) -> Self {
        match s.to_lowercase().as_str() {
            "windows" => Self::Windows,
            "linux" => Self::Linux,
            "macos" | "osx" | "mac" => Self::MacOS,
            "unix" => Self::Unix,
            "freebsd" => Self::FreeBSD,
            "android" => Self::Android,
            "ios" => Self::IOS,
            "hardware" => Self::Hardware,
            "multiple" | "multi" => Self::Multiple,
            "webapps" | "web" => Self::WebApps,
            "php" => Self::Php,
            "java" => Self::Java,
            "python" => Self::Python,
            "nodejs" | "node" => Self::Nodejs,
            "ruby" => Self::Ruby,
            "aspx" | "asp" => Self::Aspx,
            "jsp" => Self::Jsp,
            "cgi" => Self::Cgi,
            other => Self::Other(other.to_string()),
        }
    }
}

/// Architecture targeted by an exploit
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum ExploitArchitecture {
    X86,
    X64,
    Arm,
    Arm64,
    Mips,
    Ppc,
    Sparc,
    Multiple,
    Unknown,
}

impl std::fmt::Display for ExploitArchitecture {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::X86 => write!(f, "x86"),
            Self::X64 => write!(f, "x64"),
            Self::Arm => write!(f, "arm"),
            Self::Arm64 => write!(f, "arm64"),
            Self::Mips => write!(f, "mips"),
            Self::Ppc => write!(f, "ppc"),
            Self::Sparc => write!(f, "sparc"),
            Self::Multiple => write!(f, "multiple"),
            Self::Unknown => write!(f, "unknown"),
        }
    }
}

/// Type of exploit
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum ExploitType {
    Remote,
    Local,
    WebApps,
    Dos,
    PrivilegeEscalation,
    Shellcode,
    Papers,
    Other(String),
}

impl std::fmt::Display for ExploitType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Remote => write!(f, "remote"),
            Self::Local => write!(f, "local"),
            Self::WebApps => write!(f, "webapps"),
            Self::Dos => write!(f, "dos"),
            Self::PrivilegeEscalation => write!(f, "privilege_escalation"),
            Self::Shellcode => write!(f, "shellcode"),
            Self::Papers => write!(f, "papers"),
            Self::Other(s) => write!(f, "{}", s),
        }
    }
}

impl From<&str> for ExploitType {
    fn from(s: &str) -> Self {
        match s.to_lowercase().as_str() {
            "remote" => Self::Remote,
            "local" => Self::Local,
            "webapps" | "web" => Self::WebApps,
            "dos" | "denial of service" => Self::Dos,
            "privilege_escalation" | "privesc" | "priv_esc" => Self::PrivilegeEscalation,
            "shellcode" => Self::Shellcode,
            "papers" => Self::Papers,
            other => Self::Other(other.to_string()),
        }
    }
}

/// Source of the exploit
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum ExploitSource {
    ExploitDb,
    Metasploit,
    PacketStorm,
    GitHub,
    Custom,
    NucleiTemplates,
    Other(String),
}

impl std::fmt::Display for ExploitSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ExploitDb => write!(f, "exploit_db"),
            Self::Metasploit => write!(f, "metasploit"),
            Self::PacketStorm => write!(f, "packetstorm"),
            Self::GitHub => write!(f, "github"),
            Self::Custom => write!(f, "custom"),
            Self::NucleiTemplates => write!(f, "nuclei"),
            Self::Other(s) => write!(f, "{}", s),
        }
    }
}

/// Reliability rating for exploits
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum ExploitReliability {
    Excellent,
    Good,
    Average,
    Low,
    Unknown,
}

impl std::fmt::Display for ExploitReliability {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Excellent => write!(f, "excellent"),
            Self::Good => write!(f, "good"),
            Self::Average => write!(f, "average"),
            Self::Low => write!(f, "low"),
            Self::Unknown => write!(f, "unknown"),
        }
    }
}

/// Programming language of the exploit
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]
#[serde(rename_all = "snake_case")]
pub enum ExploitLanguage {
    Python,
    Ruby,
    Perl,
    C,
    Cpp,
    Java,
    Javascript,
    Bash,
    Powershell,
    Php,
    Go,
    Rust,
    Assembly,
    Html,
    Text,
    Multiple,
    Other(String),
}

impl From<&str> for ExploitLanguage {
    fn from(s: &str) -> Self {
        match s.to_lowercase().as_str() {
            "python" | "py" => Self::Python,
            "ruby" | "rb" => Self::Ruby,
            "perl" | "pl" => Self::Perl,
            "c" => Self::C,
            "c++" | "cpp" => Self::Cpp,
            "java" => Self::Java,
            "javascript" | "js" => Self::Javascript,
            "bash" | "sh" | "shell" => Self::Bash,
            "powershell" | "ps1" => Self::Powershell,
            "php" => Self::Php,
            "go" | "golang" => Self::Go,
            "rust" | "rs" => Self::Rust,
            "assembly" | "asm" => Self::Assembly,
            "html" => Self::Html,
            "text" | "txt" => Self::Text,
            "multiple" => Self::Multiple,
            other => Self::Other(other.to_string()),
        }
    }
}

/// Main exploit structure
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Exploit {
    pub id: String,
    pub exploit_db_id: Option<String>,
    pub metasploit_module: Option<String>,
    pub cve_ids: Vec<String>,
    pub title: String,
    pub description: Option<String>,
    pub platform: ExploitPlatform,
    pub architecture: ExploitArchitecture,
    pub exploit_type: ExploitType,
    pub author: Option<String>,
    pub source_url: Option<String>,
    pub source: ExploitSource,
    pub code: Option<String>,
    pub language: Option<ExploitLanguage>,
    pub verified: bool,
    pub reliability: ExploitReliability,
    pub tags: Vec<String>,
    pub published_date: Option<NaiveDate>,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

impl Exploit {
    pub fn new(title: String, source: ExploitSource) -> Self {
        let now = Utc::now();
        Self {
            id: uuid::Uuid::new_v4().to_string(),
            exploit_db_id: None,
            metasploit_module: None,
            cve_ids: Vec::new(),
            title,
            description: None,
            platform: ExploitPlatform::Multiple,
            architecture: ExploitArchitecture::Unknown,
            exploit_type: ExploitType::Remote,
            author: None,
            source_url: None,
            source,
            code: None,
            language: None,
            verified: false,
            reliability: ExploitReliability::Unknown,
            tags: Vec::new(),
            published_date: None,
            created_at: now,
            updated_at: now,
        }
    }
}

/// Target information for an exploit
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExploitTarget {
    pub id: String,
    pub exploit_id: String,
    pub product: String,
    pub version: Option<String>,
    pub os: Option<String>,
    pub notes: Option<String>,
}

/// Search filters for exploits
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct ExploitSearchQuery {
    pub query: Option<String>,
    pub cve_id: Option<String>,
    pub platform: Option<ExploitPlatform>,
    pub exploit_type: Option<ExploitType>,
    pub source: Option<ExploitSource>,
    pub language: Option<ExploitLanguage>,
    pub author: Option<String>,
    pub verified_only: bool,
    pub has_code: bool,
    pub min_reliability: Option<ExploitReliability>,
    pub date_from: Option<NaiveDate>,
    pub date_to: Option<NaiveDate>,
    pub page: u32,
    pub per_page: u32,
}

impl ExploitSearchQuery {
    pub fn new() -> Self {
        Self {
            page: 1,
            per_page: 50,
            ..Default::default()
        }
    }

    pub fn for_cve(cve_id: &str) -> Self {
        Self {
            cve_id: Some(cve_id.to_string()),
            ..Self::new()
        }
    }
}

/// Search results for exploits
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExploitSearchResults {
    pub exploits: Vec<Exploit>,
    pub total_count: u64,
    pub page: u32,
    pub per_page: u32,
    pub total_pages: u32,
}

/// Status of a PoC
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]
#[serde(rename_all = "snake_case")]
pub enum PocStatus {
    Development,
    Testing,
    Verified,
    Failed,
    Archived,
}

impl std::fmt::Display for PocStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Development => write!(f, "development"),
            Self::Testing => write!(f, "testing"),
            Self::Verified => write!(f, "verified"),
            Self::Failed => write!(f, "failed"),
            Self::Archived => write!(f, "archived"),
        }
    }
}

/// Proof of Concept code entry
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PocEntry {
    pub id: String,
    pub cve_id: Option<String>,
    pub exploit_id: Option<String>,
    pub title: String,
    pub description: Option<String>,
    pub language: ExploitLanguage,
    pub code_path: String,
    pub author: Option<String>,
    pub status: PocStatus,
    pub tags: Vec<String>,
    pub target_info: Option<String>,
    pub requirements: Option<Vec<String>>,
    pub versions: Vec<PocVersion>,
    pub test_results: Vec<PocTestResults>,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

/// Test results for a PoC
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PocTestResults {
    pub tested_at: DateTime<Utc>,
    pub success: bool,
    pub target_info: String,
    pub output: Option<String>,
    pub error: Option<String>,
    pub execution_time_ms: u64,
    pub notes: Option<String>,
}

/// Version history entry for PoC
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PocVersion {
    pub version: String,
    pub code: String,
    pub changelog: Option<String>,
    pub created_at: DateTime<Utc>,
    pub created_by: Option<String>,
}

/// Research note entry
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResearchNote {
    pub id: String,
    pub title: String,
    pub content: String,
    pub cve_ids: Vec<String>,
    pub exploit_ids: Vec<String>,
    pub poc_ids: Vec<String>,
    pub tags: Vec<String>,
    pub references: Vec<ExternalReference>,
    pub author: Option<String>,
    pub visibility: NoteVisibility,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

/// Note visibility
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]
#[serde(rename_all = "snake_case")]
pub enum NoteVisibility {
    Private,
    Team,
    Public,
}

/// CVE to Exploit mapping
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CveExploitMapping {
    pub cve_id: String,
    pub exploit_count: u32,
    pub exploit_ids: Vec<String>,
    pub has_public_exploit: bool,
    pub has_metasploit_module: bool,
    pub highest_reliability: ExploitReliability,
    pub platforms: Vec<ExploitPlatform>,
    pub updated_at: DateTime<Utc>,
}

/// Sync status for exploit sources
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExploitSyncStatus {
    pub source: ExploitSource,
    pub last_sync_at: Option<DateTime<Utc>>,
    pub total_exploits: u64,
    pub new_since_last_sync: u64,
    pub sync_in_progress: bool,
    pub last_error: Option<String>,
}

/// Exploit-DB specific response structure
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExploitDbEntry {
    pub id: String,
    pub file: String,
    pub description: String,
    pub date_published: String,
    pub author: String,
    pub platform: String,
    pub r#type: String,
    pub port: Option<String>,
    pub verified: Option<String>,
    pub codes: Option<Vec<String>>,
    pub tags: Option<Vec<String>>,
    pub aliases: Option<String>,
    pub screenshot_url: Option<String>,
    pub application_url: Option<String>,
    pub source_url: Option<String>,
}

/// Metasploit module structure
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MetasploitModule {
    pub name: String,
    pub fullname: String,
    pub rank: String,
    pub disclosure_date: Option<String>,
    pub description: String,
    pub author: Vec<String>,
    pub references: Vec<MetasploitReference>,
    pub platform: Vec<String>,
    pub arch: Vec<String>,
    pub targets: Vec<MetasploitTarget>,
    pub mod_time: Option<String>,
    pub r#type: String,
    pub privileged: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MetasploitReference {
    pub r#type: String,
    pub value: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MetasploitTarget {
    pub name: String,
    pub opts: Option<serde_json::Value>,
}

/// PacketStorm entry structure
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PacketStormEntry {
    pub id: String,
    pub title: String,
    pub url: String,
    pub date: String,
    pub author: Option<String>,
    pub cve: Option<Vec<String>>,
    pub tags: Option<Vec<String>>,
    pub content: Option<String>,
}

/// Request to create a new PoC
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CreatePocRequest {
    pub cve_id: Option<String>,
    pub exploit_id: Option<String>,
    pub title: String,
    pub description: Option<String>,
    pub language: Option<ExploitLanguage>,
    pub code: String,
    pub author: Option<String>,
    pub tags: Vec<String>,
    pub target_info: Option<String>,
    pub requirements: Option<Vec<String>>,
}

/// Request to update a PoC
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct UpdatePocRequest {
    pub title: Option<String>,
    pub description: Option<String>,
    pub status: Option<PocStatus>,
    pub tags: Option<Vec<String>>,
    pub target_info: Option<String>,
    pub requirements: Option<Vec<String>>,
    pub code: Option<String>,
    pub changelog: Option<String>,
    pub updated_by: Option<String>,
}

/// Request to create a research note
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CreateResearchNoteRequest {
    pub title: String,
    pub content: String,
    pub cve_ids: Vec<String>,
    pub exploit_ids: Vec<String>,
    pub poc_ids: Vec<String>,
    pub tags: Vec<String>,
    pub references: Vec<ExternalReference>,
    pub author: Option<String>,
    pub visibility: Option<NoteVisibility>,
}

/// Request to update a research note
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateResearchNoteRequest {
    pub title: Option<String>,
    pub content: Option<String>,
    pub cve_ids: Option<Vec<String>>,
    pub exploit_ids: Option<Vec<String>>,
    pub poc_ids: Option<Vec<String>>,
    pub tags: Option<Vec<String>>,
    pub references: Option<Vec<ExternalReference>>,
    pub visibility: Option<NoteVisibility>,
}

/// Research workspace view for a CVE
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CveResearchWorkspace {
    pub id: String,
    pub cve_id: String,
    pub title: String,
    pub exploits: Vec<String>,
    pub pocs: Vec<String>,
    pub notes: Vec<String>,
    pub external_references: Vec<ExternalReference>,
    pub timeline: Vec<TimelineEntry>,
    pub status: WorkspaceStatus,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

/// Workspace status
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum WorkspaceStatus {
    Active,
    Paused,
    Completed,
    Archived,
}

/// Timeline entry for workspace
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TimelineEntry {
    pub timestamp: DateTime<Utc>,
    pub event_type: TimelineEventType,
    pub description: String,
    pub reference_id: Option<String>,
}

/// Timeline event types
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum TimelineEventType {
    WorkspaceCreated,
    ExploitAdded,
    PocAdded,
    NoteAdded,
    ReferenceAdded,
    StatusChanged,
    Custom,
}

/// Reference type for external links
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum ReferenceType {
    Cve,
    Advisory,
    BlogPost,
    GitHub,
    ExploitDb,
    Paper,
    Vendor,
    Other,
}

/// External reference link
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExternalReference {
    pub title: String,
    pub url: String,
    pub reference_type: ReferenceType,
    pub notes: Option<String>,
}
