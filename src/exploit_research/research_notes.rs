//! Research Notes Module
//!
//! Manages vulnerability research notes with linking to CVEs,
//! exploits, and PoCs.

use anyhow::{anyhow, Result};
use chrono::Utc;
use std::collections::HashMap;
use log::info;

use super::types::*;

/// Research Notes Manager
pub struct ResearchNotesManager {
    notes: HashMap<String, ResearchNote>,
    workspaces: HashMap<String, CveResearchWorkspace>,
}

impl ResearchNotesManager {
    /// Create a new research notes manager
    pub fn new() -> Self {
        Self {
            notes: HashMap::new(),
            workspaces: HashMap::new(),
        }
    }

    /// Create a new research note
    pub fn create_note(&mut self, request: CreateResearchNoteRequest) -> Result<ResearchNote> {
        let now = Utc::now();
        let id = uuid::Uuid::new_v4().to_string();

        let note = ResearchNote {
            id: id.clone(),
            title: request.title,
            content: request.content,
            cve_ids: request.cve_ids,
            exploit_ids: request.exploit_ids,
            poc_ids: request.poc_ids,
            tags: request.tags,
            references: request.references,
            author: request.author,
            visibility: request.visibility.unwrap_or(NoteVisibility::Private),
            created_at: now,
            updated_at: now,
        };

        self.notes.insert(id.clone(), note.clone());
        info!("Created research note: {} - {}", id, note.title);

        Ok(note)
    }

    /// Get a note by ID
    pub fn get_note(&self, id: &str) -> Option<&ResearchNote> {
        self.notes.get(id)
    }

    /// Get notes by CVE ID
    pub fn get_notes_by_cve(&self, cve_id: &str) -> Vec<&ResearchNote> {
        self.notes
            .values()
            .filter(|n| n.cve_ids.contains(&cve_id.to_string()))
            .collect()
    }

    /// Get notes by exploit ID
    pub fn get_notes_by_exploit(&self, exploit_id: &str) -> Vec<&ResearchNote> {
        self.notes
            .values()
            .filter(|n| n.exploit_ids.contains(&exploit_id.to_string()))
            .collect()
    }

    /// Get notes by PoC ID
    pub fn get_notes_by_poc(&self, poc_id: &str) -> Vec<&ResearchNote> {
        self.notes
            .values()
            .filter(|n| n.poc_ids.contains(&poc_id.to_string()))
            .collect()
    }

    /// Update a research note
    pub fn update_note(&mut self, id: &str, request: UpdateResearchNoteRequest) -> Result<ResearchNote> {
        let note = self.notes.get_mut(id)
            .ok_or_else(|| anyhow!("Note not found: {}", id))?;

        if let Some(title) = request.title {
            note.title = title;
        }
        if let Some(content) = request.content {
            note.content = content;
        }
        if let Some(cve_ids) = request.cve_ids {
            note.cve_ids = cve_ids;
        }
        if let Some(exploit_ids) = request.exploit_ids {
            note.exploit_ids = exploit_ids;
        }
        if let Some(poc_ids) = request.poc_ids {
            note.poc_ids = poc_ids;
        }
        if let Some(tags) = request.tags {
            note.tags = tags;
        }
        if let Some(references) = request.references {
            note.references = references;
        }
        if let Some(visibility) = request.visibility {
            note.visibility = visibility;
        }

        note.updated_at = Utc::now();
        let updated = note.clone();

        info!("Updated research note: {}", id);
        Ok(updated)
    }

    /// Delete a research note
    pub fn delete_note(&mut self, id: &str) -> Result<()> {
        if self.notes.remove(id).is_some() {
            info!("Deleted research note: {}", id);
            Ok(())
        } else {
            Err(anyhow!("Note not found: {}", id))
        }
    }

    /// List all notes with optional filters
    pub fn list_notes(&self, filter: Option<NoteFilter>) -> Vec<&ResearchNote> {
        let mut results: Vec<&ResearchNote> = self.notes.values().collect();

        if let Some(f) = filter {
            if let Some(ref author) = f.author {
                results.retain(|n| n.author.as_deref() == Some(author.as_str()));
            }
            if let Some(visibility) = f.visibility {
                results.retain(|n| n.visibility == visibility);
            }
            if let Some(ref query) = f.query {
                let q_lower = query.to_lowercase();
                results.retain(|n| {
                    n.title.to_lowercase().contains(&q_lower) ||
                    n.content.to_lowercase().contains(&q_lower) ||
                    n.tags.iter().any(|t| t.to_lowercase().contains(&q_lower))
                });
            }
            if let Some(ref tag) = f.tag {
                results.retain(|n| n.tags.contains(tag));
            }
        }

        // Sort by updated_at descending
        results.sort_by(|a, b| b.updated_at.cmp(&a.updated_at));

        results
    }

    /// Create a CVE research workspace
    pub fn create_workspace(&mut self, cve_id: &str, title: Option<String>) -> Result<CveResearchWorkspace> {
        let now = Utc::now();
        let id = uuid::Uuid::new_v4().to_string();

        let workspace = CveResearchWorkspace {
            id: id.clone(),
            cve_id: cve_id.to_string(),
            title: title.unwrap_or_else(|| format!("Research: {}", cve_id)),
            exploits: Vec::new(),
            pocs: Vec::new(),
            notes: Vec::new(),
            external_references: Vec::new(),
            timeline: Vec::new(),
            status: WorkspaceStatus::Active,
            created_at: now,
            updated_at: now,
        };

        self.workspaces.insert(id.clone(), workspace.clone());
        info!("Created research workspace: {} for {}", id, cve_id);

        Ok(workspace)
    }

    /// Get a workspace by ID
    pub fn get_workspace(&self, id: &str) -> Option<&CveResearchWorkspace> {
        self.workspaces.get(id)
    }

    /// Get workspace by CVE ID
    pub fn get_workspace_by_cve(&self, cve_id: &str) -> Option<&CveResearchWorkspace> {
        self.workspaces.values().find(|w| w.cve_id == cve_id)
    }

    /// Update a workspace
    pub fn update_workspace(&mut self, id: &str, update: WorkspaceUpdate) -> Result<CveResearchWorkspace> {
        let workspace = self.workspaces.get_mut(id)
            .ok_or_else(|| anyhow!("Workspace not found: {}", id))?;

        if let Some(title) = update.title {
            workspace.title = title;
        }
        if let Some(status) = update.status {
            workspace.status = status;
        }

        workspace.updated_at = Utc::now();
        let updated = workspace.clone();

        Ok(updated)
    }

    /// Add an exploit to a workspace
    pub fn add_exploit_to_workspace(&mut self, workspace_id: &str, exploit_id: &str) -> Result<()> {
        let workspace = self.workspaces.get_mut(workspace_id)
            .ok_or_else(|| anyhow!("Workspace not found: {}", workspace_id))?;

        if !workspace.exploits.contains(&exploit_id.to_string()) {
            workspace.exploits.push(exploit_id.to_string());
            workspace.updated_at = Utc::now();

            // Add timeline entry
            workspace.timeline.push(TimelineEntry {
                timestamp: Utc::now(),
                event_type: TimelineEventType::ExploitAdded,
                description: format!("Added exploit: {}", exploit_id),
                reference_id: Some(exploit_id.to_string()),
            });
        }

        Ok(())
    }

    /// Add a PoC to a workspace
    pub fn add_poc_to_workspace(&mut self, workspace_id: &str, poc_id: &str) -> Result<()> {
        let workspace = self.workspaces.get_mut(workspace_id)
            .ok_or_else(|| anyhow!("Workspace not found: {}", workspace_id))?;

        if !workspace.pocs.contains(&poc_id.to_string()) {
            workspace.pocs.push(poc_id.to_string());
            workspace.updated_at = Utc::now();

            workspace.timeline.push(TimelineEntry {
                timestamp: Utc::now(),
                event_type: TimelineEventType::PocAdded,
                description: format!("Added PoC: {}", poc_id),
                reference_id: Some(poc_id.to_string()),
            });
        }

        Ok(())
    }

    /// Add a note to a workspace
    pub fn add_note_to_workspace(&mut self, workspace_id: &str, note_id: &str) -> Result<()> {
        let workspace = self.workspaces.get_mut(workspace_id)
            .ok_or_else(|| anyhow!("Workspace not found: {}", workspace_id))?;

        if !workspace.notes.contains(&note_id.to_string()) {
            workspace.notes.push(note_id.to_string());
            workspace.updated_at = Utc::now();

            workspace.timeline.push(TimelineEntry {
                timestamp: Utc::now(),
                event_type: TimelineEventType::NoteAdded,
                description: format!("Added note: {}", note_id),
                reference_id: Some(note_id.to_string()),
            });
        }

        Ok(())
    }

    /// Add external reference to workspace
    pub fn add_reference_to_workspace(&mut self, workspace_id: &str, reference: ExternalReference) -> Result<()> {
        let workspace = self.workspaces.get_mut(workspace_id)
            .ok_or_else(|| anyhow!("Workspace not found: {}", workspace_id))?;

        workspace.external_references.push(reference.clone());
        workspace.updated_at = Utc::now();

        workspace.timeline.push(TimelineEntry {
            timestamp: Utc::now(),
            event_type: TimelineEventType::ReferenceAdded,
            description: format!("Added reference: {}", reference.title),
            reference_id: None,
        });

        Ok(())
    }

    /// Add timeline event to workspace
    pub fn add_timeline_event(&mut self, workspace_id: &str, event_type: TimelineEventType, description: &str) -> Result<()> {
        let workspace = self.workspaces.get_mut(workspace_id)
            .ok_or_else(|| anyhow!("Workspace not found: {}", workspace_id))?;

        workspace.timeline.push(TimelineEntry {
            timestamp: Utc::now(),
            event_type,
            description: description.to_string(),
            reference_id: None,
        });

        workspace.updated_at = Utc::now();
        Ok(())
    }

    /// List workspaces with optional filter
    pub fn list_workspaces(&self, filter: Option<WorkspaceFilter>) -> Vec<&CveResearchWorkspace> {
        let mut results: Vec<&CveResearchWorkspace> = self.workspaces.values().collect();

        if let Some(f) = filter {
            if let Some(status) = f.status {
                results.retain(|w| w.status == status);
            }
            if let Some(ref query) = f.query {
                let q_lower = query.to_lowercase();
                results.retain(|w| {
                    w.title.to_lowercase().contains(&q_lower) ||
                    w.cve_id.to_lowercase().contains(&q_lower)
                });
            }
        }

        results.sort_by(|a, b| b.updated_at.cmp(&a.updated_at));
        results
    }

    /// Delete a workspace
    pub fn delete_workspace(&mut self, id: &str) -> Result<()> {
        if self.workspaces.remove(id).is_some() {
            info!("Deleted workspace: {}", id);
            Ok(())
        } else {
            Err(anyhow!("Workspace not found: {}", id))
        }
    }

    /// Export workspace as markdown
    pub fn export_workspace_markdown(&self, id: &str) -> Result<String> {
        let workspace = self.get_workspace(id)
            .ok_or_else(|| anyhow!("Workspace not found: {}", id))?;

        let mut md = String::new();

        // Header
        md.push_str(&format!("# {}\n\n", workspace.title));
        md.push_str(&format!("**CVE:** {}\n", workspace.cve_id));
        md.push_str(&format!("**Status:** {:?}\n", workspace.status));
        md.push_str(&format!("**Created:** {}\n", workspace.created_at.format("%Y-%m-%d %H:%M:%S UTC")));
        md.push_str(&format!("**Updated:** {}\n\n", workspace.updated_at.format("%Y-%m-%d %H:%M:%S UTC")));

        // Exploits
        if !workspace.exploits.is_empty() {
            md.push_str("## Exploits\n\n");
            for exploit_id in &workspace.exploits {
                md.push_str(&format!("- {}\n", exploit_id));
            }
            md.push('\n');
        }

        // PoCs
        if !workspace.pocs.is_empty() {
            md.push_str("## Proof of Concepts\n\n");
            for poc_id in &workspace.pocs {
                md.push_str(&format!("- {}\n", poc_id));
            }
            md.push('\n');
        }

        // Notes
        if !workspace.notes.is_empty() {
            md.push_str("## Research Notes\n\n");
            for note_id in &workspace.notes {
                if let Some(note) = self.get_note(note_id) {
                    md.push_str(&format!("### {}\n\n", note.title));
                    md.push_str(&format!("{}\n\n", note.content));
                }
            }
        }

        // External References
        if !workspace.external_references.is_empty() {
            md.push_str("## References\n\n");
            for reference in &workspace.external_references {
                md.push_str(&format!("- [{}]({}) - {:?}\n", reference.title, reference.url, reference.reference_type));
            }
            md.push('\n');
        }

        // Timeline
        if !workspace.timeline.is_empty() {
            md.push_str("## Timeline\n\n");
            for entry in &workspace.timeline {
                md.push_str(&format!("- **{}** [{:?}]: {}\n",
                    entry.timestamp.format("%Y-%m-%d %H:%M"),
                    entry.event_type,
                    entry.description
                ));
            }
        }

        Ok(md)
    }

    /// Get statistics
    pub fn stats(&self) -> ResearchStats {
        ResearchStats {
            total_notes: self.notes.len(),
            total_workspaces: self.workspaces.len(),
            active_workspaces: self.workspaces.values()
                .filter(|w| matches!(w.status, WorkspaceStatus::Active))
                .count(),
            notes_by_visibility: self.notes.values()
                .fold(HashMap::new(), |mut acc, n| {
                    *acc.entry(n.visibility.clone()).or_insert(0) += 1;
                    acc
                }),
        }
    }
}

/// Filter for listing notes
#[derive(Debug, Clone, Default)]
pub struct NoteFilter {
    pub author: Option<String>,
    pub visibility: Option<NoteVisibility>,
    pub query: Option<String>,
    pub tag: Option<String>,
}

/// Filter for listing workspaces
#[derive(Debug, Clone, Default)]
pub struct WorkspaceFilter {
    pub status: Option<WorkspaceStatus>,
    pub query: Option<String>,
}

/// Update for workspace
#[derive(Debug, Clone, Default)]
pub struct WorkspaceUpdate {
    pub title: Option<String>,
    pub status: Option<WorkspaceStatus>,
}

// Types imported from types.rs:
// WorkspaceStatus, TimelineEntry, TimelineEventType, NoteVisibility, ReferenceType

/// Research statistics
#[derive(Debug, Clone)]
pub struct ResearchStats {
    pub total_notes: usize,
    pub total_workspaces: usize,
    pub active_workspaces: usize,
    pub notes_by_visibility: HashMap<NoteVisibility, usize>,
}

impl Default for ResearchNotesManager {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_create_note() {
        let mut manager = ResearchNotesManager::new();

        let request = CreateResearchNoteRequest {
            title: "Test Note".to_string(),
            content: "This is a test note".to_string(),
            cve_ids: vec!["CVE-2024-1234".to_string()],
            exploit_ids: Vec::new(),
            poc_ids: Vec::new(),
            tags: vec!["test".to_string()],
            references: Vec::new(),
            author: Some("tester".to_string()),
            visibility: Some(NoteVisibility::Private),
        };

        let note = manager.create_note(request).unwrap();
        assert_eq!(note.title, "Test Note");
        assert!(matches!(note.visibility, NoteVisibility::Private));

        // Verify retrieval
        let retrieved = manager.get_note(&note.id).unwrap();
        assert_eq!(retrieved.cve_ids, vec!["CVE-2024-1234".to_string()]);
    }

    #[test]
    fn test_workspace_lifecycle() {
        let mut manager = ResearchNotesManager::new();

        // Create workspace
        let workspace = manager.create_workspace("CVE-2024-5678", None).unwrap();
        assert!(matches!(workspace.status, WorkspaceStatus::Active));

        // Add items
        manager.add_exploit_to_workspace(&workspace.id, "exploit-1").unwrap();
        manager.add_poc_to_workspace(&workspace.id, "poc-1").unwrap();

        let reference = ExternalReference {
            title: "Blog Post".to_string(),
            url: "https://example.com/blog".to_string(),
            reference_type: ReferenceType::BlogPost,
            notes: None,
        };
        manager.add_reference_to_workspace(&workspace.id, reference).unwrap();

        // Verify
        let updated = manager.get_workspace(&workspace.id).unwrap();
        assert_eq!(updated.exploits.len(), 1);
        assert_eq!(updated.pocs.len(), 1);
        assert_eq!(updated.external_references.len(), 1);
        assert!(updated.timeline.len() >= 3);

        // Export markdown
        let md = manager.export_workspace_markdown(&workspace.id).unwrap();
        assert!(md.contains("CVE-2024-5678"));
        assert!(md.contains("exploit-1"));
    }

    #[test]
    fn test_note_filtering() {
        let mut manager = ResearchNotesManager::new();

        // Create multiple notes
        for i in 1..=5 {
            let request = CreateResearchNoteRequest {
                title: format!("Note {}", i),
                content: format!("Content for note {}", i),
                cve_ids: Vec::new(),
                exploit_ids: Vec::new(),
                poc_ids: Vec::new(),
                tags: if i % 2 == 0 { vec!["even".to_string()] } else { vec!["odd".to_string()] },
                references: Vec::new(),
                author: Some("author".to_string()),
                visibility: Some(NoteVisibility::Private),
            };
            manager.create_note(request).unwrap();
        }

        // Filter by tag
        let filter = NoteFilter {
            tag: Some("even".to_string()),
            ..Default::default()
        };
        let even_notes = manager.list_notes(Some(filter));
        assert_eq!(even_notes.len(), 2);

        // Filter by query
        let filter = NoteFilter {
            query: Some("Note 3".to_string()),
            ..Default::default()
        };
        let matched = manager.list_notes(Some(filter));
        assert_eq!(matched.len(), 1);
    }
}
