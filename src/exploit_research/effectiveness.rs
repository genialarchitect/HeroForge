//! Exploit Effectiveness Scoring System
//!
//! Provides comprehensive scoring and rating of exploit/PoC effectiveness
//! based on multiple factors including test results, reliability, and impact.

use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

use super::sandbox::{SandboxExecutionResult, SandboxStatus};
use super::types::PocTestResults;

/// Overall effectiveness rating
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]
#[serde(rename_all = "snake_case")]
pub enum EffectivenessRating {
    /// Highly reliable, works consistently
    Excellent,
    /// Good reliability, works in most cases
    Good,
    /// Average reliability, may require specific conditions
    Average,
    /// Low reliability, often fails or requires heavy modification
    Low,
    /// Unreliable or untested
    Unknown,
}

impl EffectivenessRating {
    /// Get numeric score for rating (0-100)
    pub fn score(&self) -> u32 {
        match self {
            EffectivenessRating::Excellent => 95,
            EffectivenessRating::Good => 75,
            EffectivenessRating::Average => 50,
            EffectivenessRating::Low => 25,
            EffectivenessRating::Unknown => 0,
        }
    }

    /// Create rating from numeric score
    pub fn from_score(score: u32) -> Self {
        match score {
            85..=100 => EffectivenessRating::Excellent,
            65..=84 => EffectivenessRating::Good,
            40..=64 => EffectivenessRating::Average,
            1..=39 => EffectivenessRating::Low,
            _ => EffectivenessRating::Unknown,
        }
    }
}

impl std::fmt::Display for EffectivenessRating {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            EffectivenessRating::Excellent => write!(f, "Excellent"),
            EffectivenessRating::Good => write!(f, "Good"),
            EffectivenessRating::Average => write!(f, "Average"),
            EffectivenessRating::Low => write!(f, "Low"),
            EffectivenessRating::Unknown => write!(f, "Unknown"),
        }
    }
}

/// Exploit complexity level
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum ComplexityLevel {
    /// Simple, one-click exploit
    Trivial,
    /// Easy to use with minimal configuration
    Low,
    /// Requires some configuration or setup
    Medium,
    /// Requires significant setup or expertise
    High,
    /// Extremely complex, requires deep expertise
    Expert,
}

impl ComplexityLevel {
    /// Complexity penalty for scoring (0-30 points deducted)
    pub fn penalty(&self) -> u32 {
        match self {
            ComplexityLevel::Trivial => 0,
            ComplexityLevel::Low => 5,
            ComplexityLevel::Medium => 10,
            ComplexityLevel::High => 20,
            ComplexityLevel::Expert => 30,
        }
    }
}

/// Impact severity of the exploit
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum ImpactSeverity {
    /// No impact
    None,
    /// Critical - full system compromise
    Critical,
    /// High - significant access gained
    High,
    /// Medium - partial access or data exposure
    Medium,
    /// Low - minor impact
    Low,
    /// Informational - detection/verification only
    Informational,
}

impl ImpactSeverity {
    /// Impact score bonus (0-30 points added)
    pub fn bonus(&self) -> u32 {
        match self {
            ImpactSeverity::None => 0,
            ImpactSeverity::Critical => 30,
            ImpactSeverity::High => 20,
            ImpactSeverity::Medium => 10,
            ImpactSeverity::Low => 5,
            ImpactSeverity::Informational => 0,
        }
    }
}

// Add None variant for ImpactSeverity
impl Default for ImpactSeverity {
    fn default() -> Self {
        ImpactSeverity::Medium
    }
}

/// Maturity level of the exploit/PoC
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum MaturityLevel {
    /// Proof of concept only
    ProofOfConcept,
    /// Alpha/early development
    Alpha,
    /// Beta/testing phase
    Beta,
    /// Production/stable
    Production,
    /// Fully weaponized/ready for use
    Weaponized,
}

impl MaturityLevel {
    /// Maturity score bonus (0-25 points added)
    pub fn bonus(&self) -> u32 {
        match self {
            MaturityLevel::ProofOfConcept => 5,
            MaturityLevel::Alpha => 10,
            MaturityLevel::Beta => 15,
            MaturityLevel::Production => 20,
            MaturityLevel::Weaponized => 25,
        }
    }
}

impl Default for MaturityLevel {
    fn default() -> Self {
        MaturityLevel::Beta
    }
}

/// Detailed effectiveness score breakdown
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EffectivenessScore {
    /// Overall numeric score (0-100)
    pub total_score: u32,
    /// Overall rating
    pub rating: EffectivenessRating,
    /// Reliability score (0-100 based on test success rate)
    pub reliability_score: u32,
    /// Impact score (0-30 bonus)
    pub impact_score: u32,
    /// Complexity penalty (0-30 deducted)
    pub complexity_penalty: u32,
    /// Maturity score (based on version, tests, documentation)
    pub maturity_score: u32,
    /// Community score (based on usage, ratings if available)
    pub community_score: u32,
    /// Individual scoring factors
    pub factors: Vec<ScoringFactor>,
    /// Recommendations for improvement
    pub recommendations: Vec<String>,
    /// Calculated at timestamp
    pub calculated_at: DateTime<Utc>,
}

/// Individual factor contributing to score
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ScoringFactor {
    /// Factor name
    pub name: String,
    /// Factor category
    pub category: String,
    /// Points contributed (can be negative)
    pub points: i32,
    /// Maximum possible points for this factor
    pub max_points: i32,
    /// Description of how this factor was evaluated
    pub description: String,
}

/// Input data for effectiveness calculation
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EffectivenessInput {
    /// PoC ID
    pub poc_id: String,
    /// Test results from sandbox executions
    pub test_results: Vec<PocTestResults>,
    /// Sandbox execution results
    pub sandbox_results: Vec<SandboxExecutionResult>,
    /// Complexity assessment
    pub complexity: Option<ComplexityLevel>,
    /// Impact assessment
    pub impact: Option<ImpactSeverity>,
    /// Has documentation
    pub has_documentation: bool,
    /// Number of versions/iterations
    pub version_count: u32,
    /// Has been peer reviewed
    pub peer_reviewed: bool,
    /// External ratings (e.g., from Exploit-DB)
    pub external_ratings: Vec<ExternalRating>,
    /// Target coverage (number of different targets tested)
    pub target_coverage: u32,
}

/// External rating from a source
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExternalRating {
    pub source: String,
    pub rating: String,
    pub score: Option<f64>,
}

/// Exploit effectiveness calculator
pub struct EffectivenessCalculator {
    /// Weights for different score components
    weights: ScoreWeights,
}

/// Weights for score components
#[derive(Debug, Clone)]
pub struct ScoreWeights {
    pub reliability: f64,
    pub impact: f64,
    pub maturity: f64,
    pub community: f64,
}

impl Default for ScoreWeights {
    fn default() -> Self {
        Self {
            reliability: 0.40, // 40% weight on test reliability
            impact: 0.25,     // 25% weight on impact
            maturity: 0.20,   // 20% weight on maturity
            community: 0.15,  // 15% weight on community/external ratings
        }
    }
}

impl EffectivenessCalculator {
    /// Create a new calculator with default weights
    pub fn new() -> Self {
        Self {
            weights: ScoreWeights::default(),
        }
    }

    /// Create a calculator with custom weights
    pub fn with_weights(weights: ScoreWeights) -> Self {
        Self { weights }
    }

    /// Calculate effectiveness score from input data
    pub fn calculate(&self, input: &EffectivenessInput) -> EffectivenessScore {
        let mut factors = vec![];
        let mut recommendations = vec![];

        // Calculate reliability score (0-100)
        let (reliability_score, reliability_factors) = self.calculate_reliability(input);
        factors.extend(reliability_factors);

        // Calculate impact score (0-30)
        let (impact_score, impact_factors) = self.calculate_impact(input);
        factors.extend(impact_factors);

        // Calculate complexity penalty (0-30)
        let (complexity_penalty, complexity_factors) = self.calculate_complexity(input);
        factors.extend(complexity_factors);

        // Calculate maturity score (0-100)
        let (maturity_score, maturity_factors) = self.calculate_maturity(input);
        factors.extend(maturity_factors);

        // Calculate community score (0-100)
        let (community_score, community_factors) = self.calculate_community(input);
        factors.extend(community_factors);

        // Combine scores using weights
        let weighted_reliability = (reliability_score as f64 * self.weights.reliability) as u32;
        let weighted_impact = (impact_score as f64 * self.weights.impact * 100.0 / 30.0) as u32;
        let weighted_maturity = (maturity_score as f64 * self.weights.maturity) as u32;
        let weighted_community = (community_score as f64 * self.weights.community) as u32;

        let mut total_score = weighted_reliability + weighted_impact + weighted_maturity + weighted_community;

        // Apply complexity penalty
        total_score = total_score.saturating_sub(complexity_penalty);

        // Cap at 100
        total_score = total_score.min(100);

        // Generate recommendations
        if reliability_score < 50 {
            recommendations.push("Run more tests to improve reliability confidence".to_string());
        }
        if input.test_results.is_empty() && input.sandbox_results.is_empty() {
            recommendations.push("Add test results from sandbox execution".to_string());
        }
        if !input.has_documentation {
            recommendations.push("Add documentation to improve maturity score".to_string());
        }
        if !input.peer_reviewed {
            recommendations.push("Submit for peer review to improve credibility".to_string());
        }
        if input.target_coverage < 3 {
            recommendations.push("Test against more target configurations".to_string());
        }
        if input.complexity.is_none() {
            recommendations.push("Assess and document exploit complexity".to_string());
        }

        let rating = EffectivenessRating::from_score(total_score);

        EffectivenessScore {
            total_score,
            rating,
            reliability_score,
            impact_score,
            complexity_penalty,
            maturity_score,
            community_score,
            factors,
            recommendations,
            calculated_at: Utc::now(),
        }
    }

    /// Calculate reliability score from test results
    fn calculate_reliability(&self, input: &EffectivenessInput) -> (u32, Vec<ScoringFactor>) {
        let mut factors = vec![];
        let mut total_tests = 0u32;
        let mut successful_tests = 0u32;

        // Count test results
        for result in &input.test_results {
            total_tests += 1;
            if result.success {
                successful_tests += 1;
            }
        }

        // Count sandbox execution results
        for result in &input.sandbox_results {
            total_tests += 1;
            match result.status {
                SandboxStatus::Completed => {
                    // Check for success indicators
                    if !result.success_indicators.is_empty() {
                        successful_tests += 1;
                    } else if result.exit_code == Some(0) {
                        // Assume success if clean exit
                        successful_tests += 1;
                    }
                }
                _ => {}
            }
        }

        let success_rate = if total_tests > 0 {
            (successful_tests as f64 / total_tests as f64 * 100.0) as u32
        } else {
            0
        };

        factors.push(ScoringFactor {
            name: "Test Success Rate".to_string(),
            category: "Reliability".to_string(),
            points: success_rate as i32,
            max_points: 100,
            description: format!("{}/{} tests successful ({}%)", successful_tests, total_tests, success_rate),
        });

        // Bonus for number of tests
        let test_count_bonus = (total_tests.min(10) * 2) as i32;
        factors.push(ScoringFactor {
            name: "Test Coverage".to_string(),
            category: "Reliability".to_string(),
            points: test_count_bonus,
            max_points: 20,
            description: format!("{} total tests conducted", total_tests),
        });

        // Check for success indicators in sandbox results
        let indicator_count: usize = input.sandbox_results
            .iter()
            .map(|r| r.success_indicators.len())
            .sum();

        if indicator_count > 0 {
            let indicator_bonus = (indicator_count.min(5) * 4) as i32;
            factors.push(ScoringFactor {
                name: "Success Indicators".to_string(),
                category: "Reliability".to_string(),
                points: indicator_bonus,
                max_points: 20,
                description: format!("{} success indicators detected", indicator_count),
            });
        }

        // Calculate weighted reliability score
        let base_score = success_rate;
        let bonus = test_count_bonus as u32 + (indicator_count.min(5) * 4) as u32;
        let reliability_score = (base_score + bonus).min(100);

        (reliability_score, factors)
    }

    /// Calculate impact score
    fn calculate_impact(&self, input: &EffectivenessInput) -> (u32, Vec<ScoringFactor>) {
        let mut factors = vec![];

        let impact = input.impact.clone().unwrap_or(ImpactSeverity::Medium);
        let impact_bonus = impact.bonus();

        factors.push(ScoringFactor {
            name: "Impact Severity".to_string(),
            category: "Impact".to_string(),
            points: impact_bonus as i32,
            max_points: 30,
            description: format!("Assessed impact: {:?}", impact),
        });

        // Check sandbox results for specific impacts
        for result in &input.sandbox_results {
            for indicator in &result.success_indicators {
                if indicator.indicator_type == "shell_obtained" ||
                   indicator.indicator_type == "privilege_escalated" {
                    factors.push(ScoringFactor {
                        name: "Verified Impact".to_string(),
                        category: "Impact".to_string(),
                        points: 10,
                        max_points: 10,
                        description: format!("Verified: {}", indicator.indicator_type),
                    });
                    return (impact_bonus.min(30) + 10, factors);
                }
            }
        }

        (impact_bonus, factors)
    }

    /// Calculate complexity penalty
    fn calculate_complexity(&self, input: &EffectivenessInput) -> (u32, Vec<ScoringFactor>) {
        let mut factors = vec![];

        let complexity = input.complexity.clone().unwrap_or(ComplexityLevel::Medium);
        let penalty = complexity.penalty();

        factors.push(ScoringFactor {
            name: "Exploit Complexity".to_string(),
            category: "Complexity".to_string(),
            points: -(penalty as i32),
            max_points: 0,
            description: format!("Complexity level: {:?}", complexity),
        });

        (penalty, factors)
    }

    /// Calculate maturity score
    fn calculate_maturity(&self, input: &EffectivenessInput) -> (u32, Vec<ScoringFactor>) {
        let mut factors = vec![];
        let mut score = 0u32;

        // Documentation
        if input.has_documentation {
            score += 25;
            factors.push(ScoringFactor {
                name: "Documentation".to_string(),
                category: "Maturity".to_string(),
                points: 25,
                max_points: 25,
                description: "Has documentation".to_string(),
            });
        } else {
            factors.push(ScoringFactor {
                name: "Documentation".to_string(),
                category: "Maturity".to_string(),
                points: 0,
                max_points: 25,
                description: "No documentation".to_string(),
            });
        }

        // Version count (iterations indicate refinement)
        let version_points = (input.version_count.min(5) * 10) as i32;
        score += version_points as u32;
        factors.push(ScoringFactor {
            name: "Version History".to_string(),
            category: "Maturity".to_string(),
            points: version_points,
            max_points: 50,
            description: format!("{} versions/iterations", input.version_count),
        });

        // Peer review
        if input.peer_reviewed {
            score += 25;
            factors.push(ScoringFactor {
                name: "Peer Reviewed".to_string(),
                category: "Maturity".to_string(),
                points: 25,
                max_points: 25,
                description: "Has been peer reviewed".to_string(),
            });
        } else {
            factors.push(ScoringFactor {
                name: "Peer Reviewed".to_string(),
                category: "Maturity".to_string(),
                points: 0,
                max_points: 25,
                description: "Not peer reviewed".to_string(),
            });
        }

        (score.min(100), factors)
    }

    /// Calculate community/external ratings score
    fn calculate_community(&self, input: &EffectivenessInput) -> (u32, Vec<ScoringFactor>) {
        let mut factors = vec![];

        if input.external_ratings.is_empty() {
            factors.push(ScoringFactor {
                name: "External Ratings".to_string(),
                category: "Community".to_string(),
                points: 0,
                max_points: 100,
                description: "No external ratings available".to_string(),
            });
            return (0, factors);
        }

        let mut total_score = 0.0;
        let mut count = 0;

        for rating in &input.external_ratings {
            if let Some(score) = rating.score {
                total_score += score;
                count += 1;
                factors.push(ScoringFactor {
                    name: format!("{} Rating", rating.source),
                    category: "Community".to_string(),
                    points: (score as i32).min(100),
                    max_points: 100,
                    description: format!("Rating: {} ({})", rating.rating, score),
                });
            }
        }

        let avg_score = if count > 0 {
            (total_score / count as f64) as u32
        } else {
            0
        };

        // Target coverage bonus
        let coverage_bonus = (input.target_coverage.min(10) * 5) as i32;
        factors.push(ScoringFactor {
            name: "Target Coverage".to_string(),
            category: "Community".to_string(),
            points: coverage_bonus,
            max_points: 50,
            description: format!("Tested against {} different targets", input.target_coverage),
        });

        ((avg_score + coverage_bonus as u32).min(100), factors)
    }

    /// Quick reliability check from a single sandbox result
    pub fn quick_score(&self, result: &SandboxExecutionResult) -> EffectivenessScore {
        let input = EffectivenessInput {
            poc_id: result.poc_id.clone(),
            test_results: vec![],
            sandbox_results: vec![result.clone()],
            complexity: None,
            impact: None,
            has_documentation: false,
            version_count: 1,
            peer_reviewed: false,
            external_ratings: vec![],
            target_coverage: 1,
        };

        self.calculate(&input)
    }
}

impl Default for EffectivenessCalculator {
    fn default() -> Self {
        Self::new()
    }
}

/// Summary statistics for effectiveness across multiple PoCs
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EffectivenessStats {
    /// Total PoCs analyzed
    pub total_pocs: u32,
    /// Distribution by rating
    pub by_rating: HashMap<EffectivenessRating, u32>,
    /// Average score
    pub average_score: f64,
    /// Highest scoring PoC
    pub top_poc_id: Option<String>,
    /// Top score
    pub top_score: u32,
    /// Most common recommendations
    pub common_recommendations: Vec<(String, u32)>,
}

/// Calculate aggregate effectiveness statistics
pub fn calculate_stats(scores: &[(String, EffectivenessScore)]) -> EffectivenessStats {
    let mut by_rating: HashMap<EffectivenessRating, u32> = HashMap::new();
    let mut total_score: u64 = 0;
    let mut top_poc_id = None;
    let mut top_score = 0u32;
    let mut recommendation_counts: HashMap<String, u32> = HashMap::new();

    for (poc_id, score) in scores {
        // Count ratings
        *by_rating.entry(score.rating.clone()).or_insert(0) += 1;

        // Sum scores
        total_score += score.total_score as u64;

        // Track top scorer
        if score.total_score > top_score {
            top_score = score.total_score;
            top_poc_id = Some(poc_id.clone());
        }

        // Count recommendations
        for rec in &score.recommendations {
            *recommendation_counts.entry(rec.clone()).or_insert(0) += 1;
        }
    }

    let total_pocs = scores.len() as u32;
    let average_score = if total_pocs > 0 {
        total_score as f64 / total_pocs as f64
    } else {
        0.0
    };

    // Sort recommendations by frequency
    let mut common_recommendations: Vec<_> = recommendation_counts.into_iter().collect();
    common_recommendations.sort_by(|a, b| b.1.cmp(&a.1));
    common_recommendations.truncate(5);

    EffectivenessStats {
        total_pocs,
        by_rating,
        average_score,
        top_poc_id,
        top_score,
        common_recommendations,
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_effectiveness_rating_from_score() {
        assert_eq!(EffectivenessRating::from_score(95), EffectivenessRating::Excellent);
        assert_eq!(EffectivenessRating::from_score(75), EffectivenessRating::Good);
        assert_eq!(EffectivenessRating::from_score(50), EffectivenessRating::Average);
        assert_eq!(EffectivenessRating::from_score(25), EffectivenessRating::Low);
        assert_eq!(EffectivenessRating::from_score(0), EffectivenessRating::Unknown);
    }

    #[test]
    fn test_calculator_with_no_data() {
        let calculator = EffectivenessCalculator::new();
        let input = EffectivenessInput {
            poc_id: "test-poc".to_string(),
            test_results: vec![],
            sandbox_results: vec![],
            complexity: None,
            impact: None,
            has_documentation: false,
            version_count: 1,
            peer_reviewed: false,
            external_ratings: vec![],
            target_coverage: 0,
        };

        let score = calculator.calculate(&input);
        assert!(score.total_score < 50); // Should be low without any data
        assert_eq!(score.rating, EffectivenessRating::Low);
    }

    #[test]
    fn test_calculator_with_good_data() {
        let calculator = EffectivenessCalculator::new();
        let input = EffectivenessInput {
            poc_id: "test-poc".to_string(),
            test_results: vec![
                PocTestResults {
                    tested_at: Utc::now(),
                    success: true,
                    target_info: "Ubuntu 22.04 x86_64".to_string(),
                    output: Some("Shell obtained".to_string()),
                    error: None,
                    execution_time_ms: 1000,
                    notes: None,
                },
            ],
            sandbox_results: vec![],
            complexity: Some(ComplexityLevel::Low),
            impact: Some(ImpactSeverity::High),
            has_documentation: true,
            version_count: 3,
            peer_reviewed: true,
            external_ratings: vec![
                ExternalRating {
                    source: "Exploit-DB".to_string(),
                    rating: "Excellent".to_string(),
                    score: Some(90.0),
                },
            ],
            target_coverage: 5,
        };

        let score = calculator.calculate(&input);
        assert!(score.total_score >= 50); // Should be reasonable with good data
    }
}
