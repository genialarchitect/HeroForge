//! PacketStorm Security Feed Integration
//!
//! Provides access to PacketStorm security advisories and exploits.

use anyhow::{anyhow, Result};
use chrono::{NaiveDate, Utc};
use reqwest::Client;
use scraper::{Html, Selector};
use serde::{Deserialize, Serialize};
use std::time::Duration;
use log::{debug, warn};

use super::types::*;

const PACKETSTORM_BASE: &str = "https://packetstormsecurity.com";
const PACKETSTORM_RSS: &str = "https://rss.packetstormsecurity.com/files/";

/// PacketStorm client
pub struct PacketStormClient {
    client: Client,
}

/// PacketStorm file entry
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PacketStormFile {
    pub id: String,
    pub title: String,
    pub url: String,
    pub date: Option<NaiveDate>,
    pub author: Option<String>,
    pub cve_ids: Vec<String>,
    pub tags: Vec<String>,
    pub description: Option<String>,
    pub file_type: PacketStormFileType,
}

/// Type of PacketStorm file
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum PacketStormFileType {
    Exploit,
    Advisory,
    Tool,
    Paper,
    Shellcode,
    DoS,
    Local,
    Remote,
    WebApps,
    Other(String),
}

impl From<&str> for PacketStormFileType {
    fn from(s: &str) -> Self {
        match s.to_lowercase().as_str() {
            "exploit" | "exploits" => Self::Exploit,
            "advisory" | "advisories" => Self::Advisory,
            "tool" | "tools" => Self::Tool,
            "paper" | "papers" => Self::Paper,
            "shellcode" => Self::Shellcode,
            "dos" | "denial of service" => Self::DoS,
            "local" => Self::Local,
            "remote" => Self::Remote,
            "webapps" | "web" => Self::WebApps,
            other => Self::Other(other.to_string()),
        }
    }
}

impl PacketStormClient {
    /// Create a new PacketStorm client
    pub fn new() -> Result<Self> {
        let client = Client::builder()
            .timeout(Duration::from_secs(30))
            .user_agent("HeroForge Security Scanner/1.0")
            .build()?;

        Ok(Self { client })
    }

    /// Search PacketStorm for exploits
    pub async fn search(&self, query: &str) -> Result<Vec<PacketStormFile>> {
        let url = format!("{}/search/?q={}", PACKETSTORM_BASE, urlencoding::encode(query));
        debug!("Searching PacketStorm: {}", url);

        let response = self.client.get(&url).send().await?;

        if !response.status().is_success() {
            return Err(anyhow!("PacketStorm search failed: {}", response.status()));
        }

        let html = response.text().await?;
        self.parse_search_results(&html)
    }

    /// Search by CVE ID
    pub async fn search_by_cve(&self, cve_id: &str) -> Result<Vec<PacketStormFile>> {
        self.search(cve_id).await
    }

    /// Get file details by ID
    pub async fn get_file(&self, file_id: &str) -> Result<PacketStormFile> {
        let url = format!("{}/files/{}/", PACKETSTORM_BASE, file_id);
        debug!("Fetching PacketStorm file: {}", url);

        let response = self.client.get(&url).send().await?;

        if !response.status().is_success() {
            return Err(anyhow!("Failed to fetch file: {}", response.status()));
        }

        let html = response.text().await?;
        self.parse_file_page(file_id, &html)
    }

    /// Get file content/code
    pub async fn get_file_content(&self, file_id: &str) -> Result<String> {
        let url = format!("{}/files/download/{}/", PACKETSTORM_BASE, file_id);
        debug!("Downloading PacketStorm file: {}", url);

        let response = self.client.get(&url).send().await?;

        if response.status().is_success() {
            Ok(response.text().await?)
        } else {
            Err(anyhow!("Failed to download file: {}", response.status()))
        }
    }

    /// Get latest files from RSS feed
    pub async fn get_latest(&self, category: Option<&str>) -> Result<Vec<PacketStormFile>> {
        let url = match category {
            Some(cat) => format!("{}tags/{}", PACKETSTORM_RSS, cat),
            None => PACKETSTORM_RSS.to_string(),
        };

        debug!("Fetching PacketStorm RSS: {}", url);

        let response = self.client.get(&url).send().await?;

        if !response.status().is_success() {
            return Err(anyhow!("Failed to fetch RSS: {}", response.status()));
        }

        let xml = response.text().await?;
        self.parse_rss_feed(&xml)
    }

    /// Convert PacketStorm file to generic Exploit
    pub fn to_exploit(&self, file: &PacketStormFile) -> Exploit {
        let now = Utc::now();

        let exploit_type = match file.file_type {
            PacketStormFileType::Local => ExploitType::Local,
            PacketStormFileType::Remote => ExploitType::Remote,
            PacketStormFileType::WebApps => ExploitType::WebApps,
            PacketStormFileType::DoS => ExploitType::Dos,
            PacketStormFileType::Shellcode => ExploitType::Shellcode,
            PacketStormFileType::Paper => ExploitType::Papers,
            _ => ExploitType::Remote,
        };

        Exploit {
            id: uuid::Uuid::new_v4().to_string(),
            exploit_db_id: None,
            metasploit_module: None,
            cve_ids: file.cve_ids.clone(),
            title: file.title.clone(),
            description: file.description.clone(),
            platform: ExploitPlatform::Multiple,
            architecture: ExploitArchitecture::Unknown,
            exploit_type,
            author: file.author.clone(),
            source_url: Some(file.url.clone()),
            source: ExploitSource::PacketStorm,
            code: None,
            language: None,
            verified: false,
            reliability: ExploitReliability::Unknown,
            tags: file.tags.clone(),
            published_date: file.date,
            created_at: now,
            updated_at: now,
        }
    }

    /// Parse search results HTML
    fn parse_search_results(&self, html: &str) -> Result<Vec<PacketStormFile>> {
        let document = Html::parse_document(html);
        let mut files = Vec::new();

        // Select result items
        let item_selector = Selector::parse("dl#702").unwrap_or_else(|_| {
            Selector::parse("dl.file").unwrap()
        });

        for element in document.select(&item_selector) {
            if let Some(file) = self.parse_result_item(&element) {
                files.push(file);
            }
        }

        // Fallback: try alternative selectors
        if files.is_empty() {
            let alt_selector = Selector::parse("div.packetstorm a.ico").ok();
            if let Some(selector) = alt_selector {
                for element in document.select(&selector) {
                    if let Some(href) = element.value().attr("href") {
                        if href.contains("/files/") {
                            let id = href
                                .split('/')
                                .filter(|s| !s.is_empty())
                                .last()
                                .unwrap_or("")
                                .to_string();

                            let title = element.text().collect::<String>();

                            if !id.is_empty() && !title.is_empty() {
                                files.push(PacketStormFile {
                                    id,
                                    title,
                                    url: format!("{}{}", PACKETSTORM_BASE, href),
                                    date: None,
                                    author: None,
                                    cve_ids: Vec::new(),
                                    tags: Vec::new(),
                                    description: None,
                                    file_type: PacketStormFileType::Exploit,
                                });
                            }
                        }
                    }
                }
            }
        }

        Ok(files)
    }

    fn parse_result_item(&self, element: &scraper::ElementRef) -> Option<PacketStormFile> {
        let title_selector = Selector::parse("dt a").ok()?;
        let title_elem = element.select(&title_selector).next()?;

        let title = title_elem.text().collect::<String>().trim().to_string();
        let url = title_elem.value().attr("href")?;

        let id = url
            .split('/')
            .filter(|s| !s.is_empty() && s.parse::<u64>().is_ok())
            .next()?
            .to_string();

        // Extract date
        let date_selector = Selector::parse("dd.datetime a").ok();
        let date = date_selector.and_then(|sel| {
            element.select(&sel).next().and_then(|e| {
                let date_str = e.text().collect::<String>();
                NaiveDate::parse_from_str(date_str.trim(), "%b %d, %Y").ok()
            })
        });

        // Extract author
        let author_selector = Selector::parse("dd.author a").ok();
        let author = author_selector.and_then(|sel| {
            element
                .select(&sel)
                .next()
                .map(|e| e.text().collect::<String>().trim().to_string())
        });

        // Extract CVEs
        let cve_selector = Selector::parse("dd.cve a").ok();
        let cve_ids: Vec<String> = cve_selector
            .map(|sel| {
                element
                    .select(&sel)
                    .map(|e| e.text().collect::<String>().trim().to_string())
                    .filter(|s| s.starts_with("CVE-"))
                    .collect()
            })
            .unwrap_or_default();

        // Extract tags
        let tag_selector = Selector::parse("dd.tags a").ok();
        let tags: Vec<String> = tag_selector
            .map(|sel| {
                element
                    .select(&sel)
                    .map(|e| e.text().collect::<String>().trim().to_string())
                    .collect()
            })
            .unwrap_or_default();

        // Determine file type from tags or title
        let file_type = tags
            .first()
            .map(|t| PacketStormFileType::from(t.as_str()))
            .unwrap_or(PacketStormFileType::Exploit);

        Some(PacketStormFile {
            id,
            title,
            url: format!("{}{}", PACKETSTORM_BASE, url),
            date,
            author,
            cve_ids,
            tags,
            description: None,
            file_type,
        })
    }

    /// Parse individual file page
    fn parse_file_page(&self, file_id: &str, html: &str) -> Result<PacketStormFile> {
        let document = Html::parse_document(html);

        // Extract title
        let title_selector = Selector::parse("h1").ok();
        let title = title_selector
            .and_then(|sel| {
                document
                    .select(&sel)
                    .next()
                    .map(|e| e.text().collect::<String>().trim().to_string())
            })
            .unwrap_or_else(|| format!("PacketStorm-{}", file_id));

        // Extract description
        let desc_selector = Selector::parse("div.detail p").ok();
        let description = desc_selector.and_then(|sel| {
            document
                .select(&sel)
                .next()
                .map(|e| e.text().collect::<String>().trim().to_string())
        });

        // Extract CVEs
        let cve_selector = Selector::parse("a[href*='cve']").ok();
        let cve_ids: Vec<String> = cve_selector
            .map(|sel| {
                document
                    .select(&sel)
                    .filter_map(|e| {
                        let text = e.text().collect::<String>().trim().to_string();
                        if text.starts_with("CVE-") {
                            Some(text)
                        } else {
                            None
                        }
                    })
                    .collect()
            })
            .unwrap_or_default();

        Ok(PacketStormFile {
            id: file_id.to_string(),
            title,
            url: format!("{}/files/{}/", PACKETSTORM_BASE, file_id),
            date: None,
            author: None,
            cve_ids,
            tags: Vec::new(),
            description,
            file_type: PacketStormFileType::Exploit,
        })
    }

    /// Parse RSS feed
    fn parse_rss_feed(&self, xml: &str) -> Result<Vec<PacketStormFile>> {
        let mut files = Vec::new();

        // Simple RSS parsing (could use a proper RSS library)
        let document = Html::parse_document(xml);

        let item_selector = Selector::parse("item").ok();

        if let Some(selector) = item_selector {
            for item in document.select(&selector) {
                let title_sel = Selector::parse("title").ok();
                let link_sel = Selector::parse("link").ok();
                let date_sel = Selector::parse("pubDate").ok();

                let title = title_sel
                    .and_then(|s| item.select(&s).next())
                    .map(|e| e.text().collect::<String>().trim().to_string())
                    .unwrap_or_default();

                let url = link_sel
                    .and_then(|s| item.select(&s).next())
                    .map(|e| e.text().collect::<String>().trim().to_string())
                    .unwrap_or_default();

                let id = url
                    .split('/')
                    .filter(|s| !s.is_empty() && s.parse::<u64>().is_ok())
                    .next()
                    .unwrap_or("")
                    .to_string();

                if !id.is_empty() && !title.is_empty() {
                    files.push(PacketStormFile {
                        id,
                        title,
                        url,
                        date: None,
                        author: None,
                        cve_ids: Vec::new(),
                        tags: Vec::new(),
                        description: None,
                        file_type: PacketStormFileType::Exploit,
                    });
                }
            }
        }

        Ok(files)
    }

    /// Get sync status
    pub fn get_sync_status(&self) -> ExploitSyncStatus {
        ExploitSyncStatus {
            source: ExploitSource::PacketStorm,
            last_sync_at: None,
            total_exploits: 0,
            new_since_last_sync: 0,
            sync_in_progress: false,
            last_error: None,
        }
    }
}

impl Default for PacketStormClient {
    fn default() -> Self {
        Self::new().expect("Failed to create PacketStormClient")
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_file_type_conversion() {
        assert_eq!(
            PacketStormFileType::from("exploit"),
            PacketStormFileType::Exploit
        );
        assert_eq!(
            PacketStormFileType::from("advisory"),
            PacketStormFileType::Advisory
        );
    }

    #[tokio::test]
    async fn test_client_creation() {
        let client = PacketStormClient::new();
        assert!(client.is_ok());
    }
}
