//! Metasploit Module Database Integration
//!
//! Provides access to Metasploit modules through the GitHub repository
//! and optional local Metasploit RPC integration.

use anyhow::{anyhow, Result};
use chrono::{NaiveDate, Utc};
use reqwest::Client;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::time::Duration;
use log::{debug, info};

use super::types::*;

const MSF_MODULES_RAW: &str = "https://raw.githubusercontent.com/rapid7/metasploit-framework/master";
const MSF_API_DOCS: &str = "https://docs.metasploit.com/api/Msf";

/// Metasploit module database client
pub struct MetasploitClient {
    client: Client,
    module_cache: HashMap<String, MetasploitModuleInfo>,
    rpc_url: Option<String>,
    rpc_token: Option<String>,
}

/// Detailed module information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MetasploitModuleInfo {
    pub name: String,
    pub fullname: String,
    pub module_type: MetasploitModuleType,
    pub rank: MetasploitRank,
    pub description: String,
    pub author: Vec<String>,
    pub license: Option<String>,
    pub references: Vec<ModuleReference>,
    pub platform: Vec<String>,
    pub arch: Vec<String>,
    pub targets: Vec<ModuleTarget>,
    pub options: Vec<ModuleOption>,
    pub privileged: bool,
    pub disclosure_date: Option<NaiveDate>,
    pub notes: Option<ModuleNotes>,
    pub path: String,
    pub cve_ids: Vec<String>,
}

/// Module type classification
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum MetasploitModuleType {
    Exploit,
    Auxiliary,
    Post,
    Payload,
    Encoder,
    Nop,
    Evasion,
}

impl std::fmt::Display for MetasploitModuleType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Exploit => write!(f, "exploit"),
            Self::Auxiliary => write!(f, "auxiliary"),
            Self::Post => write!(f, "post"),
            Self::Payload => write!(f, "payload"),
            Self::Encoder => write!(f, "encoder"),
            Self::Nop => write!(f, "nop"),
            Self::Evasion => write!(f, "evasion"),
        }
    }
}

/// Module ranking
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, PartialOrd, Ord)]
#[serde(rename_all = "snake_case")]
pub enum MetasploitRank {
    Manual,
    Low,
    Average,
    Normal,
    Good,
    Great,
    Excellent,
}

impl From<&str> for MetasploitRank {
    fn from(s: &str) -> Self {
        match s.to_lowercase().as_str() {
            "manual" | "manualranking" => Self::Manual,
            "low" | "lowranking" => Self::Low,
            "average" | "averageranking" => Self::Average,
            "normal" | "normalranking" => Self::Normal,
            "good" | "goodranking" => Self::Good,
            "great" | "greatranking" => Self::Great,
            "excellent" | "excellentranking" => Self::Excellent,
            _ => Self::Normal,
        }
    }
}

impl MetasploitRank {
    pub fn to_reliability(&self) -> ExploitReliability {
        match self {
            Self::Excellent | Self::Great => ExploitReliability::Excellent,
            Self::Good => ExploitReliability::Good,
            Self::Normal | Self::Average => ExploitReliability::Average,
            Self::Low | Self::Manual => ExploitReliability::Low,
        }
    }
}

/// Module reference (CVE, EDB, URL, etc.)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ModuleReference {
    pub ref_type: String,
    pub value: String,
}

/// Module target
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ModuleTarget {
    pub id: u32,
    pub name: String,
    pub platform: Option<String>,
    pub arch: Option<String>,
}

/// Module option
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ModuleOption {
    pub name: String,
    pub option_type: String,
    pub required: bool,
    pub default: Option<String>,
    pub description: String,
}

/// Module notes (stability, reliability, side effects)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ModuleNotes {
    pub stability: Vec<String>,
    pub reliability: Vec<String>,
    pub side_effects: Vec<String>,
}

/// Search query for Metasploit modules
#[derive(Debug, Clone, Default)]
pub struct MetasploitSearchQuery {
    pub query: Option<String>,
    pub cve_id: Option<String>,
    pub module_type: Option<MetasploitModuleType>,
    pub platform: Option<String>,
    pub min_rank: Option<MetasploitRank>,
    pub author: Option<String>,
}

impl MetasploitClient {
    /// Create a new Metasploit client
    pub fn new() -> Result<Self> {
        let client = Client::builder()
            .timeout(Duration::from_secs(30))
            .user_agent("Genial Architect Scanner/1.0")
            .build()?;

        Ok(Self {
            client,
            module_cache: HashMap::new(),
            rpc_url: None,
            rpc_token: None,
        })
    }

    /// Create client with RPC connection
    pub fn with_rpc(rpc_url: String, rpc_token: String) -> Result<Self> {
        let mut client = Self::new()?;
        client.rpc_url = Some(rpc_url);
        client.rpc_token = Some(rpc_token);
        Ok(client)
    }

    /// Search for Metasploit modules by CVE
    pub async fn search_by_cve(&self, cve_id: &str) -> Result<Vec<MetasploitModuleInfo>> {
        debug!("Searching Metasploit modules for CVE: {}", cve_id);

        // If RPC is available, use it
        if let (Some(ref rpc_url), Some(ref token)) = (&self.rpc_url, &self.rpc_token) {
            return self.rpc_search_by_cve(rpc_url, token, cve_id).await;
        }

        // Otherwise search cache
        let modules: Vec<MetasploitModuleInfo> = self
            .module_cache
            .values()
            .filter(|m| m.cve_ids.iter().any(|c| c.eq_ignore_ascii_case(cve_id)))
            .cloned()
            .collect();

        Ok(modules)
    }

    /// Search modules with query
    pub async fn search(&self, query: &MetasploitSearchQuery) -> Result<Vec<MetasploitModuleInfo>> {
        let mut results: Vec<MetasploitModuleInfo> = self.module_cache.values().cloned().collect();

        // Filter by query text
        if let Some(ref q) = query.query {
            let q_lower = q.to_lowercase();
            results.retain(|m| {
                m.name.to_lowercase().contains(&q_lower)
                    || m.description.to_lowercase().contains(&q_lower)
                    || m.fullname.to_lowercase().contains(&q_lower)
            });
        }

        // Filter by CVE
        if let Some(ref cve) = query.cve_id {
            results.retain(|m| m.cve_ids.iter().any(|c| c.eq_ignore_ascii_case(cve)));
        }

        // Filter by module type
        if let Some(ref mt) = query.module_type {
            results.retain(|m| &m.module_type == mt);
        }

        // Filter by platform
        if let Some(ref platform) = query.platform {
            let p_lower = platform.to_lowercase();
            results.retain(|m| m.platform.iter().any(|p| p.to_lowercase().contains(&p_lower)));
        }

        // Filter by minimum rank
        if let Some(ref min_rank) = query.min_rank {
            results.retain(|m| m.rank >= *min_rank);
        }

        // Filter by author
        if let Some(ref author) = query.author {
            let a_lower = author.to_lowercase();
            results.retain(|m| m.author.iter().any(|a| a.to_lowercase().contains(&a_lower)));
        }

        Ok(results)
    }

    /// Get module details by path
    pub async fn get_module(&self, module_path: &str) -> Result<MetasploitModuleInfo> {
        // Check cache
        if let Some(module) = self.module_cache.get(module_path) {
            return Ok(module.clone());
        }

        // Try to fetch from GitHub
        self.fetch_module_from_github(module_path).await
    }

    /// Get module source code
    pub async fn get_module_source(&self, module_path: &str) -> Result<String> {
        let url = format!("{}/modules/{}.rb", MSF_MODULES_RAW, module_path);
        debug!("Fetching module source from: {}", url);

        let response = self.client.get(&url).send().await?;

        if response.status().is_success() {
            Ok(response.text().await?)
        } else {
            Err(anyhow!("Failed to fetch module source: {}", response.status()))
        }
    }

    /// Convert Metasploit module to generic Exploit
    pub fn to_exploit(&self, module: &MetasploitModuleInfo) -> Exploit {
        let now = Utc::now();

        // Extract CVEs from references
        let cve_ids: Vec<String> = module
            .references
            .iter()
            .filter(|r| r.ref_type.to_uppercase() == "CVE")
            .map(|r| format!("CVE-{}", r.value))
            .collect();

        // Map platforms
        let platform = if module.platform.is_empty() {
            ExploitPlatform::Multiple
        } else if module.platform.iter().any(|p| p.to_lowercase().contains("win")) {
            ExploitPlatform::Windows
        } else if module.platform.iter().any(|p| p.to_lowercase().contains("linux")) {
            ExploitPlatform::Linux
        } else if module.platform.iter().any(|p| p.to_lowercase().contains("unix")) {
            ExploitPlatform::Unix
        } else {
            ExploitPlatform::Multiple
        };

        // Map architecture
        let architecture = if module.arch.is_empty() {
            ExploitArchitecture::Unknown
        } else if module.arch.iter().any(|a| a.contains("x64") || a.contains("64")) {
            ExploitArchitecture::X64
        } else if module.arch.iter().any(|a| a.contains("x86") || a.contains("32")) {
            ExploitArchitecture::X86
        } else if module.arch.iter().any(|a| a.to_lowercase().contains("arm")) {
            ExploitArchitecture::Arm
        } else {
            ExploitArchitecture::Multiple
        };

        // Map type
        let exploit_type = match module.module_type {
            MetasploitModuleType::Exploit => {
                if module.fullname.contains("local/") {
                    ExploitType::Local
                } else if module.fullname.contains("dos/") {
                    ExploitType::Dos
                } else {
                    ExploitType::Remote
                }
            }
            MetasploitModuleType::Auxiliary => {
                if module.fullname.contains("dos/") {
                    ExploitType::Dos
                } else {
                    ExploitType::Other("auxiliary".to_string())
                }
            }
            MetasploitModuleType::Post => ExploitType::PrivilegeEscalation,
            _ => ExploitType::Other(module.module_type.to_string()),
        };

        Exploit {
            id: uuid::Uuid::new_v4().to_string(),
            exploit_db_id: module
                .references
                .iter()
                .find(|r| r.ref_type.to_uppercase() == "EDB")
                .map(|r| r.value.clone()),
            metasploit_module: Some(module.fullname.clone()),
            cve_ids,
            title: module.name.clone(),
            description: Some(module.description.clone()),
            platform,
            architecture,
            exploit_type,
            author: module.author.first().cloned(),
            source_url: Some(format!(
                "https://github.com/rapid7/metasploit-framework/blob/master/modules/{}.rb",
                module.path
            )),
            source: ExploitSource::Metasploit,
            code: None,
            language: Some(ExploitLanguage::Ruby),
            verified: true, // Metasploit modules are vetted
            reliability: module.rank.to_reliability(),
            tags: vec!["metasploit".to_string()],
            published_date: module.disclosure_date,
            created_at: now,
            updated_at: now,
        }
    }

    /// Load modules from local module index
    pub async fn load_module_index(&mut self) -> Result<usize> {
        info!("Loading Metasploit module index...");

        // This would typically load from a pre-built index file
        // For now, we'll return the cache size
        Ok(self.module_cache.len())
    }

    /// Sync modules from a specific category
    pub async fn sync_category(&mut self, category: &str) -> Result<usize> {
        info!("Syncing Metasploit {} modules...", category);

        // In a full implementation, this would:
        // 1. Clone/pull the metasploit-framework repo
        // 2. Parse all .rb files in modules/{category}/
        // 3. Extract metadata using regex or a Ruby parser
        // 4. Cache the results

        Ok(0)
    }

    /// RPC search implementation
    async fn rpc_search_by_cve(
        &self,
        rpc_url: &str,
        token: &str,
        cve_id: &str,
    ) -> Result<Vec<MetasploitModuleInfo>> {
        let url = format!("{}/api/v1/modules/search", rpc_url);

        #[derive(Serialize)]
        struct SearchRequest {
            cve: String,
        }

        let response = self
            .client
            .post(&url)
            .header("Authorization", format!("Bearer {}", token))
            .json(&SearchRequest {
                cve: cve_id.to_string(),
            })
            .send()
            .await?;

        if response.status().is_success() {
            let modules: Vec<MetasploitModuleInfo> = response.json().await?;
            Ok(modules)
        } else {
            Err(anyhow!("RPC search failed: {}", response.status()))
        }
    }

    /// Fetch module from GitHub
    async fn fetch_module_from_github(&self, module_path: &str) -> Result<MetasploitModuleInfo> {
        let source = self.get_module_source(module_path).await?;
        self.parse_module_source(module_path, &source)
    }

    /// Parse module source code to extract metadata
    fn parse_module_source(&self, path: &str, source: &str) -> Result<MetasploitModuleInfo> {
        // Extract metadata using regex
        let name = self
            .extract_field(source, r#"'Name'\s*=>\s*['"](.*?)['"]"#)
            .unwrap_or_else(|| path.split('/').last().unwrap_or("Unknown").to_string());

        let description = self
            .extract_field(source, r#"'Description'\s*=>\s*%q\{([\s\S]*?)\}"#)
            .or_else(|| self.extract_field(source, r#"'Description'\s*=>\s*['"](.*?)['"]"#))
            .unwrap_or_default();

        let author = self.extract_array(source, r#"'Author'\s*=>\s*\[([\s\S]*?)\]"#);

        let references = self.extract_references(source);

        let cve_ids: Vec<String> = references
            .iter()
            .filter(|r| r.ref_type == "CVE")
            .map(|r| format!("CVE-{}", r.value))
            .collect();

        let platform = self.extract_array(source, r#"'Platform'\s*=>\s*\[(.*?)\]"#);
        let arch = self.extract_array(source, r#"'Arch'\s*=>\s*\[(.*?)\]"#);

        let rank_str = self
            .extract_field(source, r#"Rank\s*=\s*(\w+)"#)
            .unwrap_or_else(|| "NormalRanking".to_string());

        let disclosure = self
            .extract_field(source, r#"'DisclosureDate'\s*=>\s*['"](.*?)['"]"#)
            .and_then(|d| NaiveDate::parse_from_str(&d, "%Y-%m-%d").ok());

        // Determine module type from path
        let module_type = if path.starts_with("exploits/") || path.starts_with("exploit/") {
            MetasploitModuleType::Exploit
        } else if path.starts_with("auxiliary/") {
            MetasploitModuleType::Auxiliary
        } else if path.starts_with("post/") {
            MetasploitModuleType::Post
        } else if path.starts_with("payloads/") || path.starts_with("payload/") {
            MetasploitModuleType::Payload
        } else if path.starts_with("encoders/") || path.starts_with("encoder/") {
            MetasploitModuleType::Encoder
        } else if path.starts_with("nops/") || path.starts_with("nop/") {
            MetasploitModuleType::Nop
        } else if path.starts_with("evasion/") {
            MetasploitModuleType::Evasion
        } else {
            MetasploitModuleType::Exploit
        };

        Ok(MetasploitModuleInfo {
            name,
            fullname: path.to_string(),
            module_type,
            rank: MetasploitRank::from(rank_str.as_str()),
            description,
            author,
            license: Some("BSD-3-Clause".to_string()),
            references,
            platform,
            arch,
            targets: Vec::new(),
            options: Vec::new(),
            privileged: source.contains("'Privileged'") && source.contains("true"),
            disclosure_date: disclosure,
            notes: None,
            path: path.to_string(),
            cve_ids,
        })
    }

    fn extract_field(&self, source: &str, pattern: &str) -> Option<String> {
        let re = regex::Regex::new(pattern).ok()?;
        re.captures(source)
            .and_then(|c| c.get(1))
            .map(|m| m.as_str().trim().to_string())
    }

    fn extract_array(&self, source: &str, pattern: &str) -> Vec<String> {
        let re = match regex::Regex::new(pattern) {
            Ok(r) => r,
            Err(_) => return Vec::new(),
        };

        re.captures(source)
            .and_then(|c| c.get(1))
            .map(|m| {
                m.as_str()
                    .split(',')
                    .map(|s| s.trim().trim_matches(|c| c == '\'' || c == '"').to_string())
                    .filter(|s| !s.is_empty())
                    .collect()
            })
            .unwrap_or_default()
    }

    fn extract_references(&self, source: &str) -> Vec<ModuleReference> {
        let mut refs = Vec::new();

        // Match [ 'TYPE', 'VALUE' ] patterns
        let re = regex::Regex::new(r#"\[\s*'(\w+)'\s*,\s*'([^']+)'\s*\]"#).unwrap();

        for cap in re.captures_iter(source) {
            if let (Some(ref_type), Some(value)) = (cap.get(1), cap.get(2)) {
                refs.push(ModuleReference {
                    ref_type: ref_type.as_str().to_string(),
                    value: value.as_str().to_string(),
                });
            }
        }

        refs
    }

    /// Get sync status
    pub fn get_sync_status(&self) -> ExploitSyncStatus {
        ExploitSyncStatus {
            source: ExploitSource::Metasploit,
            last_sync_at: None,
            total_exploits: self.module_cache.len() as u64,
            new_since_last_sync: 0,
            sync_in_progress: false,
            last_error: None,
        }
    }
}

impl Default for MetasploitClient {
    fn default() -> Self {
        Self::new().expect("Failed to create MetasploitClient")
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_rank_conversion() {
        assert_eq!(MetasploitRank::from("excellent"), MetasploitRank::Excellent);
        assert_eq!(MetasploitRank::from("ExcellentRanking"), MetasploitRank::Excellent);
        assert_eq!(MetasploitRank::from("normal"), MetasploitRank::Normal);
    }

    #[test]
    fn test_rank_to_reliability() {
        assert_eq!(
            MetasploitRank::Excellent.to_reliability(),
            ExploitReliability::Excellent
        );
        assert_eq!(
            MetasploitRank::Good.to_reliability(),
            ExploitReliability::Good
        );
        assert_eq!(
            MetasploitRank::Low.to_reliability(),
            ExploitReliability::Low
        );
    }

    #[tokio::test]
    async fn test_client_creation() {
        let client = MetasploitClient::new();
        assert!(client.is_ok());
    }
}
