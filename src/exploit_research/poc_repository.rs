//! PoC Repository Module
//!
//! Manages Proof-of-Concept code storage, versioning, and testing.

use anyhow::{anyhow, Result};
use chrono::Utc;
use std::collections::HashMap;
use std::fs;
use std::path::{Path, PathBuf};
use log::{debug, info, warn};

use super::types::*;

/// Default PoC storage directory
const DEFAULT_POC_DIR: &str = "./poc_repository";

/// PoC Repository for managing exploit proof-of-concept code
pub struct PocRepository {
    storage_path: PathBuf,
    index: HashMap<String, PocEntry>,
}

impl PocRepository {
    /// Create a new PoC repository
    pub fn new(storage_path: Option<&str>) -> Result<Self> {
        let path = PathBuf::from(storage_path.unwrap_or(DEFAULT_POC_DIR));

        // Create directory if it doesn't exist
        if !path.exists() {
            fs::create_dir_all(&path)?;
        }

        let mut repo = Self {
            storage_path: path,
            index: HashMap::new(),
        };

        // Load existing index
        repo.load_index()?;

        Ok(repo)
    }

    /// Load the PoC index from disk
    fn load_index(&mut self) -> Result<()> {
        let index_path = self.storage_path.join("index.json");

        if index_path.exists() {
            let content = fs::read_to_string(&index_path)?;
            self.index = serde_json::from_str(&content)?;
            debug!("Loaded {} PoCs from index", self.index.len());
        }

        Ok(())
    }

    /// Save the PoC index to disk
    fn save_index(&self) -> Result<()> {
        let index_path = self.storage_path.join("index.json");
        let content = serde_json::to_string_pretty(&self.index)?;
        fs::write(&index_path, content)?;
        Ok(())
    }

    /// Create a new PoC entry
    pub fn create(&mut self, request: CreatePocRequest) -> Result<PocEntry> {
        let now = Utc::now();
        let id = uuid::Uuid::new_v4().to_string();

        // Determine language from code if not specified
        let language = request.language.unwrap_or_else(|| {
            detect_language(&request.code)
        });

        // Create PoC directory
        let poc_dir = self.storage_path.join(&id);
        fs::create_dir_all(&poc_dir)?;

        // Save initial code version
        let version_id = uuid::Uuid::new_v4().to_string();
        let code_file = poc_dir.join(format!("v1_{}.txt", version_id));
        fs::write(&code_file, &request.code)?;

        let initial_version = PocVersion {
            version: "1.0.0".to_string(),
            code: request.code,
            changelog: Some("Initial version".to_string()),
            created_at: now,
            created_by: request.author.clone(),
        };

        let entry = PocEntry {
            id: id.clone(),
            cve_id: request.cve_id,
            exploit_id: request.exploit_id,
            title: request.title,
            description: request.description,
            language,
            code_path: code_file.to_string_lossy().to_string(),
            author: request.author,
            status: PocStatus::Development,
            tags: request.tags,
            target_info: request.target_info,
            requirements: request.requirements,
            versions: vec![initial_version],
            test_results: Vec::new(),
            created_at: now,
            updated_at: now,
        };

        self.index.insert(id.clone(), entry.clone());
        self.save_index()?;

        info!("Created PoC: {} - {}", id, entry.title);
        Ok(entry)
    }

    /// Get a PoC by ID
    pub fn get(&self, id: &str) -> Option<&PocEntry> {
        self.index.get(id)
    }

    /// Get a PoC by CVE ID
    pub fn get_by_cve(&self, cve_id: &str) -> Vec<&PocEntry> {
        self.index
            .values()
            .filter(|p| p.cve_id.as_deref() == Some(cve_id))
            .collect()
    }

    /// Get a PoC by exploit ID
    pub fn get_by_exploit(&self, exploit_id: &str) -> Vec<&PocEntry> {
        self.index
            .values()
            .filter(|p| p.exploit_id.as_deref() == Some(exploit_id))
            .collect()
    }

    /// Update a PoC entry
    pub fn update(&mut self, id: &str, request: UpdatePocRequest) -> Result<PocEntry> {
        let entry = self.index.get_mut(id)
            .ok_or_else(|| anyhow!("PoC not found: {}", id))?;

        let now = Utc::now();

        if let Some(title) = request.title {
            entry.title = title;
        }
        if let Some(description) = request.description {
            entry.description = Some(description);
        }
        if let Some(status) = request.status {
            entry.status = status;
        }
        if let Some(tags) = request.tags {
            entry.tags = tags;
        }
        if let Some(target_info) = request.target_info {
            entry.target_info = Some(target_info);
        }
        if let Some(requirements) = request.requirements {
            entry.requirements = Some(requirements);
        }

        // Handle code update with versioning
        if let Some(new_code) = request.code {
            let version_num = entry.versions.len() + 1;
            let version_id = uuid::Uuid::new_v4().to_string();

            // Save new code version
            let poc_dir = self.storage_path.join(id);
            let code_file = poc_dir.join(format!("v{}_{}.txt", version_num, version_id));
            fs::write(&code_file, &new_code)?;

            let new_version = PocVersion {
                version: format!("{}.0.0", version_num),
                code: new_code,
                changelog: request.changelog,
                created_at: now,
                created_by: request.updated_by.clone(),
            };

            entry.versions.push(new_version);
            entry.code_path = code_file.to_string_lossy().to_string();
        }

        entry.updated_at = now;
        let updated = entry.clone();

        self.save_index()?;
        info!("Updated PoC: {}", id);

        Ok(updated)
    }

    /// Delete a PoC
    pub fn delete(&mut self, id: &str) -> Result<()> {
        if self.index.remove(id).is_some() {
            // Remove PoC directory
            let poc_dir = self.storage_path.join(id);
            if poc_dir.exists() {
                fs::remove_dir_all(&poc_dir)?;
            }

            self.save_index()?;
            info!("Deleted PoC: {}", id);
            Ok(())
        } else {
            Err(anyhow!("PoC not found: {}", id))
        }
    }

    /// List all PoCs with optional filters
    pub fn list(&self, filter: Option<PocFilter>) -> Vec<&PocEntry> {
        let mut results: Vec<&PocEntry> = self.index.values().collect();

        if let Some(f) = filter {
            if let Some(status) = f.status {
                results.retain(|p| p.status == status);
            }
            if let Some(language) = f.language {
                results.retain(|p| p.language == language);
            }
            if let Some(ref cve_id) = f.cve_id {
                results.retain(|p| p.cve_id.as_deref() == Some(cve_id.as_str()));
            }
            if let Some(ref author) = f.author {
                results.retain(|p| p.author.as_deref() == Some(author.as_str()));
            }
            if let Some(ref query) = f.query {
                let q_lower = query.to_lowercase();
                results.retain(|p| {
                    p.title.to_lowercase().contains(&q_lower) ||
                    p.description.as_ref().map(|d| d.to_lowercase().contains(&q_lower)).unwrap_or(false) ||
                    p.tags.iter().any(|t| t.to_lowercase().contains(&q_lower))
                });
            }
        }

        // Sort by updated_at descending
        results.sort_by(|a, b| b.updated_at.cmp(&a.updated_at));

        results
    }

    /// Get the current code for a PoC
    pub fn get_code(&self, id: &str) -> Result<String> {
        let entry = self.get(id)
            .ok_or_else(|| anyhow!("PoC not found: {}", id))?;

        // Get latest version
        entry.versions.last()
            .map(|v| v.code.clone())
            .ok_or_else(|| anyhow!("No code versions found"))
    }

    /// Get a specific version of PoC code
    pub fn get_code_version(&self, id: &str, version: &str) -> Result<String> {
        let entry = self.get(id)
            .ok_or_else(|| anyhow!("PoC not found: {}", id))?;

        entry.versions.iter()
            .find(|v| v.version == version)
            .map(|v| v.code.clone())
            .ok_or_else(|| anyhow!("Version {} not found", version))
    }

    /// Add test results for a PoC
    pub fn add_test_result(&mut self, id: &str, result: PocTestResults) -> Result<()> {
        let entry = self.index.get_mut(id)
            .ok_or_else(|| anyhow!("PoC not found: {}", id))?;

        entry.test_results.push(result);
        entry.updated_at = Utc::now();

        // Update status based on test results
        if entry.test_results.last().map(|r| r.success).unwrap_or(false) {
            if entry.status == PocStatus::Development {
                entry.status = PocStatus::Testing;
            }
        }

        self.save_index()?;
        Ok(())
    }

    /// Import PoC from external source
    pub fn import_from_url(&mut self, url: &str, cve_id: Option<String>) -> Result<PocEntry> {
        // For now, just create a placeholder
        // In a full implementation, this would fetch and parse the code
        warn!("URL import not fully implemented: {}", url);

        let request = CreatePocRequest {
            cve_id,
            exploit_id: None,
            title: format!("Imported from {}", url),
            description: Some(format!("Imported from: {}", url)),
            language: None,
            code: format!("// Imported from: {}\n// TODO: Fetch and validate code", url),
            author: None,
            tags: vec!["imported".to_string()],
            target_info: None,
            requirements: None,
        };

        self.create(request)
    }

    /// Export PoC to a file
    pub fn export(&self, id: &str, output_path: &Path) -> Result<()> {
        let entry = self.get(id)
            .ok_or_else(|| anyhow!("PoC not found: {}", id))?;

        let code = self.get_code(id)?;

        // Create export with metadata header
        let export_content = format!(
            r#"#!/usr/bin/env {}
# PoC: {}
# CVE: {}
# Author: {}
# Status: {:?}
# Description: {}
# Tags: {}
# Created: {}
# Updated: {}
#
# Requirements: {}
#

{}
"#,
            get_interpreter(&entry.language),
            entry.title,
            entry.cve_id.as_deref().unwrap_or("N/A"),
            entry.author.as_deref().unwrap_or("Unknown"),
            entry.status,
            entry.description.as_deref().unwrap_or("No description"),
            entry.tags.join(", "),
            entry.created_at.format("%Y-%m-%d %H:%M:%S UTC"),
            entry.updated_at.format("%Y-%m-%d %H:%M:%S UTC"),
            entry.requirements.as_ref().map(|r| r.join(", ")).unwrap_or_else(|| "None".to_string()),
            code
        );

        fs::write(output_path, export_content)?;
        info!("Exported PoC {} to {:?}", id, output_path);

        Ok(())
    }

    /// Get statistics about the repository
    pub fn stats(&self) -> PocRepositoryStats {
        let total = self.index.len();
        let by_status: HashMap<PocStatus, usize> = self.index.values()
            .fold(HashMap::new(), |mut acc, p| {
                *acc.entry(p.status.clone()).or_insert(0) += 1;
                acc
            });

        let by_language: HashMap<ExploitLanguage, usize> = self.index.values()
            .fold(HashMap::new(), |mut acc, p| {
                *acc.entry(p.language.clone()).or_insert(0) += 1;
                acc
            });

        let with_cve = self.index.values()
            .filter(|p| p.cve_id.is_some())
            .count();

        let tested = self.index.values()
            .filter(|p| !p.test_results.is_empty())
            .count();

        PocRepositoryStats {
            total_pocs: total,
            by_status,
            by_language,
            with_cve,
            tested,
        }
    }
}

/// Filter options for listing PoCs
#[derive(Debug, Clone, Default)]
pub struct PocFilter {
    pub status: Option<PocStatus>,
    pub language: Option<ExploitLanguage>,
    pub cve_id: Option<String>,
    pub author: Option<String>,
    pub query: Option<String>,
}

/// Repository statistics
#[derive(Debug, Clone)]
pub struct PocRepositoryStats {
    pub total_pocs: usize,
    pub by_status: HashMap<PocStatus, usize>,
    pub by_language: HashMap<ExploitLanguage, usize>,
    pub with_cve: usize,
    pub tested: usize,
}

/// Detect programming language from code
fn detect_language(code: &str) -> ExploitLanguage {
    let code_lower = code.to_lowercase();

    if code_lower.contains("#!/usr/bin/python") ||
       code_lower.contains("import ") && (code_lower.contains("socket") || code_lower.contains("requests")) {
        ExploitLanguage::Python
    } else if code_lower.contains("#!/bin/bash") || code_lower.contains("#!/bin/sh") {
        ExploitLanguage::Bash
    } else if code_lower.contains("require ") && code_lower.contains("msf") {
        ExploitLanguage::Ruby
    } else if code_lower.contains("#include") && (code_lower.contains("stdio.h") || code_lower.contains("stdlib.h")) {
        ExploitLanguage::C
    } else if code_lower.contains("func ") && code_lower.contains("package ") {
        ExploitLanguage::Go
    } else if code_lower.contains("use strict") || code_lower.contains("const ") && code_lower.contains("require(") {
        ExploitLanguage::Javascript
    } else if code_lower.contains("<?php") {
        ExploitLanguage::Php
    } else if code_lower.contains("import java.") || code_lower.contains("public class ") {
        ExploitLanguage::Java
    } else if code_lower.contains("#!/usr/bin/perl") || code_lower.contains("use strict;") {
        ExploitLanguage::Perl
    } else if code_lower.contains("fn ") && code_lower.contains("let ") {
        ExploitLanguage::Rust
    } else if code_lower.contains("param(") || code_lower.contains("$psversiontable") {
        ExploitLanguage::Powershell
    } else {
        ExploitLanguage::Other("unknown".to_string())
    }
}

/// Get interpreter for language
fn get_interpreter(language: &ExploitLanguage) -> &'static str {
    match language {
        ExploitLanguage::Python => "python3",
        ExploitLanguage::Ruby => "ruby",
        ExploitLanguage::Perl => "perl",
        ExploitLanguage::Bash => "bash",
        ExploitLanguage::Powershell => "pwsh",
        ExploitLanguage::Javascript => "node",
        ExploitLanguage::Go => "go run",
        _ => "sh",
    }
}

impl Default for PocRepository {
    fn default() -> Self {
        Self::new(None).expect("Failed to create PocRepository")
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::tempdir;

    #[test]
    fn test_detect_language() {
        assert!(matches!(
            detect_language("#!/usr/bin/python\nimport socket"),
            ExploitLanguage::Python
        ));

        assert!(matches!(
            detect_language("#!/bin/bash\necho hello"),
            ExploitLanguage::Bash
        ));
    }

    #[test]
    fn test_poc_repository_create() {
        let temp = tempdir().unwrap();
        let mut repo = PocRepository::new(Some(temp.path().to_str().unwrap())).unwrap();

        let request = CreatePocRequest {
            cve_id: Some("CVE-2024-1234".to_string()),
            exploit_id: None,
            title: "Test PoC".to_string(),
            description: Some("Test description".to_string()),
            language: Some(ExploitLanguage::Python),
            code: "#!/usr/bin/python\nprint('test')".to_string(),
            author: Some("tester".to_string()),
            tags: vec!["test".to_string()],
            target_info: None,
            requirements: None,
        };

        let poc = repo.create(request).unwrap();
        assert_eq!(poc.title, "Test PoC");
        assert!(matches!(poc.status, PocStatus::Development));

        // Verify retrieval
        let retrieved = repo.get(&poc.id).unwrap();
        assert_eq!(retrieved.cve_id, Some("CVE-2024-1234".to_string()));
    }

    #[test]
    fn test_poc_versioning() {
        let temp = tempdir().unwrap();
        let mut repo = PocRepository::new(Some(temp.path().to_str().unwrap())).unwrap();

        let create_req = CreatePocRequest {
            cve_id: None,
            exploit_id: None,
            title: "Version Test".to_string(),
            description: None,
            language: Some(ExploitLanguage::Python),
            code: "print('v1')".to_string(),
            author: None,
            tags: Vec::new(),
            target_info: None,
            requirements: None,
        };

        let poc = repo.create(create_req).unwrap();
        assert_eq!(poc.versions.len(), 1);

        // Update with new code
        let update_req = UpdatePocRequest {
            code: Some("print('v2')".to_string()),
            changelog: Some("Updated to v2".to_string()),
            ..Default::default()
        };

        let updated = repo.update(&poc.id, update_req).unwrap();
        assert_eq!(updated.versions.len(), 2);

        // Get specific version
        let v1_code = repo.get_code_version(&poc.id, "1.0.0").unwrap();
        assert!(v1_code.contains("v1"));

        let v2_code = repo.get_code_version(&poc.id, "2.0.0").unwrap();
        assert!(v2_code.contains("v2"));
    }
}
