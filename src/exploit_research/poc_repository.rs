//! PoC Repository Module
//!
//! Manages Proof-of-Concept code storage, versioning, and testing.

use anyhow::{anyhow, Result};
use chrono::Utc;
use std::collections::HashMap;
use std::fs;
use std::path::{Path, PathBuf};
use log::{debug, info, warn};

use super::types::*;

/// Default PoC storage directory
const DEFAULT_POC_DIR: &str = "./poc_repository";

/// PoC Repository for managing exploit proof-of-concept code
pub struct PocRepository {
    storage_path: PathBuf,
    index: HashMap<String, PocEntry>,
}

impl PocRepository {
    /// Create a new PoC repository
    pub fn new(storage_path: Option<&str>) -> Result<Self> {
        let path = PathBuf::from(storage_path.unwrap_or(DEFAULT_POC_DIR));

        // Create directory if it doesn't exist
        if !path.exists() {
            fs::create_dir_all(&path)?;
        }

        let mut repo = Self {
            storage_path: path,
            index: HashMap::new(),
        };

        // Load existing index
        repo.load_index()?;

        Ok(repo)
    }

    /// Load the PoC index from disk
    fn load_index(&mut self) -> Result<()> {
        let index_path = self.storage_path.join("index.json");

        if index_path.exists() {
            let content = fs::read_to_string(&index_path)?;
            self.index = serde_json::from_str(&content)?;
            debug!("Loaded {} PoCs from index", self.index.len());
        }

        Ok(())
    }

    /// Save the PoC index to disk
    fn save_index(&self) -> Result<()> {
        let index_path = self.storage_path.join("index.json");
        let content = serde_json::to_string_pretty(&self.index)?;
        fs::write(&index_path, content)?;
        Ok(())
    }

    /// Create a new PoC entry
    pub fn create(&mut self, request: CreatePocRequest) -> Result<PocEntry> {
        let now = Utc::now();
        let id = uuid::Uuid::new_v4().to_string();

        // Determine language from code if not specified
        let language = request.language.unwrap_or_else(|| {
            detect_language(&request.code)
        });

        // Create PoC directory
        let poc_dir = self.storage_path.join(&id);
        fs::create_dir_all(&poc_dir)?;

        // Save initial code version
        let version_id = uuid::Uuid::new_v4().to_string();
        let code_file = poc_dir.join(format!("v1_{}.txt", version_id));
        fs::write(&code_file, &request.code)?;

        let initial_version = PocVersion {
            version: "1.0.0".to_string(),
            code: request.code,
            changelog: Some("Initial version".to_string()),
            created_at: now,
            created_by: request.author.clone(),
        };

        let entry = PocEntry {
            id: id.clone(),
            cve_id: request.cve_id,
            exploit_id: request.exploit_id,
            title: request.title,
            description: request.description,
            language,
            code_path: code_file.to_string_lossy().to_string(),
            author: request.author,
            status: PocStatus::Development,
            tags: request.tags,
            target_info: request.target_info,
            requirements: request.requirements,
            versions: vec![initial_version],
            test_results: Vec::new(),
            created_at: now,
            updated_at: now,
        };

        self.index.insert(id.clone(), entry.clone());
        self.save_index()?;

        info!("Created PoC: {} - {}", id, entry.title);
        Ok(entry)
    }

    /// Get a PoC by ID
    pub fn get(&self, id: &str) -> Option<&PocEntry> {
        self.index.get(id)
    }

    /// Get a PoC by CVE ID
    pub fn get_by_cve(&self, cve_id: &str) -> Vec<&PocEntry> {
        self.index
            .values()
            .filter(|p| p.cve_id.as_deref() == Some(cve_id))
            .collect()
    }

    /// Get a PoC by exploit ID
    pub fn get_by_exploit(&self, exploit_id: &str) -> Vec<&PocEntry> {
        self.index
            .values()
            .filter(|p| p.exploit_id.as_deref() == Some(exploit_id))
            .collect()
    }

    /// Update a PoC entry
    pub fn update(&mut self, id: &str, request: UpdatePocRequest) -> Result<PocEntry> {
        let entry = self.index.get_mut(id)
            .ok_or_else(|| anyhow!("PoC not found: {}", id))?;

        let now = Utc::now();

        if let Some(title) = request.title {
            entry.title = title;
        }
        if let Some(description) = request.description {
            entry.description = Some(description);
        }
        if let Some(status) = request.status {
            entry.status = status;
        }
        if let Some(tags) = request.tags {
            entry.tags = tags;
        }
        if let Some(target_info) = request.target_info {
            entry.target_info = Some(target_info);
        }
        if let Some(requirements) = request.requirements {
            entry.requirements = Some(requirements);
        }

        // Handle code update with versioning
        if let Some(new_code) = request.code {
            let version_num = entry.versions.len() + 1;
            let version_id = uuid::Uuid::new_v4().to_string();

            // Save new code version
            let poc_dir = self.storage_path.join(id);
            let code_file = poc_dir.join(format!("v{}_{}.txt", version_num, version_id));
            fs::write(&code_file, &new_code)?;

            let new_version = PocVersion {
                version: format!("{}.0.0", version_num),
                code: new_code,
                changelog: request.changelog,
                created_at: now,
                created_by: request.updated_by.clone(),
            };

            entry.versions.push(new_version);
            entry.code_path = code_file.to_string_lossy().to_string();
        }

        entry.updated_at = now;
        let updated = entry.clone();

        self.save_index()?;
        info!("Updated PoC: {}", id);

        Ok(updated)
    }

    /// Delete a PoC
    pub fn delete(&mut self, id: &str) -> Result<()> {
        if self.index.remove(id).is_some() {
            // Remove PoC directory
            let poc_dir = self.storage_path.join(id);
            if poc_dir.exists() {
                fs::remove_dir_all(&poc_dir)?;
            }

            self.save_index()?;
            info!("Deleted PoC: {}", id);
            Ok(())
        } else {
            Err(anyhow!("PoC not found: {}", id))
        }
    }

    /// List all PoCs with optional filters
    pub fn list(&self, filter: Option<PocFilter>) -> Vec<&PocEntry> {
        let mut results: Vec<&PocEntry> = self.index.values().collect();

        if let Some(f) = filter {
            if let Some(status) = f.status {
                results.retain(|p| p.status == status);
            }
            if let Some(language) = f.language {
                results.retain(|p| p.language == language);
            }
            if let Some(ref cve_id) = f.cve_id {
                results.retain(|p| p.cve_id.as_deref() == Some(cve_id.as_str()));
            }
            if let Some(ref author) = f.author {
                results.retain(|p| p.author.as_deref() == Some(author.as_str()));
            }
            if let Some(ref query) = f.query {
                let q_lower = query.to_lowercase();
                results.retain(|p| {
                    p.title.to_lowercase().contains(&q_lower) ||
                    p.description.as_ref().map(|d| d.to_lowercase().contains(&q_lower)).unwrap_or(false) ||
                    p.tags.iter().any(|t| t.to_lowercase().contains(&q_lower))
                });
            }
        }

        // Sort by updated_at descending
        results.sort_by(|a, b| b.updated_at.cmp(&a.updated_at));

        results
    }

    /// Get the current code for a PoC
    pub fn get_code(&self, id: &str) -> Result<String> {
        let entry = self.get(id)
            .ok_or_else(|| anyhow!("PoC not found: {}", id))?;

        // Get latest version
        entry.versions.last()
            .map(|v| v.code.clone())
            .ok_or_else(|| anyhow!("No code versions found"))
    }

    /// Get a specific version of PoC code
    pub fn get_code_version(&self, id: &str, version: &str) -> Result<String> {
        let entry = self.get(id)
            .ok_or_else(|| anyhow!("PoC not found: {}", id))?;

        entry.versions.iter()
            .find(|v| v.version == version)
            .map(|v| v.code.clone())
            .ok_or_else(|| anyhow!("Version {} not found", version))
    }

    /// Add test results for a PoC
    pub fn add_test_result(&mut self, id: &str, result: PocTestResults) -> Result<()> {
        let entry = self.index.get_mut(id)
            .ok_or_else(|| anyhow!("PoC not found: {}", id))?;

        entry.test_results.push(result);
        entry.updated_at = Utc::now();

        // Update status based on test results
        if entry.test_results.last().map(|r| r.success).unwrap_or(false) {
            if entry.status == PocStatus::Development {
                entry.status = PocStatus::Testing;
            }
        }

        self.save_index()?;
        Ok(())
    }

    /// Import PoC from external source URL
    ///
    /// Fetches code from the provided URL and creates a new PoC entry.
    /// Supports GitHub raw URLs, GitLab raw URLs, Pastebin, and other plain text sources.
    pub fn import_from_url(&mut self, url: &str, cve_id: Option<String>) -> Result<PocEntry> {
        // Use tokio runtime to fetch the URL synchronously
        let rt = tokio::runtime::Builder::new_current_thread()
            .enable_all()
            .build()
            .map_err(|e| anyhow!("Failed to create runtime: {}", e))?;

        let fetch_result = rt.block_on(async {
            Self::fetch_code_from_url(url).await
        });

        match fetch_result {
            Ok((code, detected_language, source_info)) => {
                info!("Successfully fetched {} bytes from {}", code.len(), url);

                // Try to extract CVE from URL if not provided
                let final_cve_id = cve_id.or_else(|| Self::extract_cve_from_text(&code));

                // Try to extract title from source
                let title = source_info.get("title")
                    .cloned()
                    .unwrap_or_else(|| format!("Imported from {}", Self::extract_domain(url)));

                // Build tags
                let mut tags = vec!["imported".to_string()];
                if let Some(source) = source_info.get("source") {
                    tags.push(source.clone());
                }
                if final_cve_id.is_some() {
                    tags.push("cve".to_string());
                }

                let request = CreatePocRequest {
                    cve_id: final_cve_id,
                    exploit_id: source_info.get("exploit_id").cloned(),
                    title,
                    description: Some(format!(
                        "Imported from: {}\nFetched on: {}",
                        url,
                        chrono::Utc::now().format("%Y-%m-%d %H:%M:%S UTC")
                    )),
                    language: Some(detected_language),
                    code,
                    author: source_info.get("author").cloned(),
                    tags,
                    target_info: None,
                    requirements: None,
                };

                self.create(request)
            }
            Err(e) => {
                warn!("Failed to fetch from URL {}: {}", url, e);
                Err(anyhow!("Failed to import from URL: {}", e))
            }
        }
    }

    /// Fetch code from a URL
    async fn fetch_code_from_url(url: &str) -> Result<(String, ExploitLanguage, std::collections::HashMap<String, String>)> {
        let client = reqwest::Client::builder()
            .timeout(std::time::Duration::from_secs(30))
            .user_agent("HeroForge Security Platform")
            .build()
            .map_err(|e| anyhow!("Failed to create HTTP client: {}", e))?;

        let mut source_info = std::collections::HashMap::new();

        // Transform URLs to raw content URLs if needed
        let raw_url = Self::transform_to_raw_url(url, &mut source_info);

        let response = client
            .get(&raw_url)
            .header("Accept", "text/plain, application/octet-stream, */*")
            .send()
            .await
            .map_err(|e| anyhow!("Failed to fetch URL: {}", e))?;

        if !response.status().is_success() {
            return Err(anyhow!(
                "HTTP error {}: {}",
                response.status(),
                response.status().canonical_reason().unwrap_or("Unknown")
            ));
        }

        let content_type = response.headers()
            .get("content-type")
            .and_then(|v| v.to_str().ok())
            .unwrap_or("text/plain")
            .to_string();

        let code = response.text().await
            .map_err(|e| anyhow!("Failed to read response body: {}", e))?;

        // Validate that this looks like code
        if code.is_empty() {
            return Err(anyhow!("Empty response from URL"));
        }

        // Detect language from content and URL
        let language = Self::detect_language_from_content(&code, url);

        // Try to extract metadata from the code
        Self::extract_metadata_from_code(&code, &mut source_info);

        source_info.insert("content_type".to_string(), content_type);

        Ok((code, language, source_info))
    }

    /// Transform URLs to their raw content equivalents
    fn transform_to_raw_url(url: &str, source_info: &mut std::collections::HashMap<String, String>) -> String {
        // GitHub: github.com/user/repo/blob/branch/file -> raw.githubusercontent.com/user/repo/branch/file
        if url.contains("github.com") && url.contains("/blob/") {
            source_info.insert("source".to_string(), "github".to_string());
            return url
                .replace("github.com", "raw.githubusercontent.com")
                .replace("/blob/", "/");
        }

        // GitHub raw already
        if url.contains("raw.githubusercontent.com") {
            source_info.insert("source".to_string(), "github".to_string());
            return url.to_string();
        }

        // GitLab: gitlab.com/user/repo/-/blob/branch/file -> gitlab.com/user/repo/-/raw/branch/file
        if url.contains("gitlab.com") && url.contains("/-/blob/") {
            source_info.insert("source".to_string(), "gitlab".to_string());
            return url.replace("/-/blob/", "/-/raw/");
        }

        // GitLab raw already
        if url.contains("gitlab.com") && url.contains("/-/raw/") {
            source_info.insert("source".to_string(), "gitlab".to_string());
            return url.to_string();
        }

        // Pastebin: pastebin.com/XXXXX -> pastebin.com/raw/XXXXX
        if url.contains("pastebin.com") && !url.contains("/raw/") {
            source_info.insert("source".to_string(), "pastebin".to_string());
            let parts: Vec<&str> = url.split("pastebin.com/").collect();
            if parts.len() == 2 {
                return format!("https://pastebin.com/raw/{}", parts[1]);
            }
        }

        // Exploit-DB
        if url.contains("exploit-db.com") {
            source_info.insert("source".to_string(), "exploit-db".to_string());
            // Try to extract exploit ID
            if let Some(id) = url.split('/').last() {
                if let Ok(_) = id.parse::<u64>() {
                    source_info.insert("exploit_id".to_string(), format!("EDB-{}", id));
                }
            }
        }

        // GitHub Gist
        if url.contains("gist.github.com") || url.contains("gist.githubusercontent.com") {
            source_info.insert("source".to_string(), "github-gist".to_string());
        }

        // Return original URL if no transformation needed
        url.to_string()
    }

    /// Detect language from code content and URL
    fn detect_language_from_content(code: &str, url: &str) -> ExploitLanguage {
        // First try to detect from file extension in URL
        let url_lower = url.to_lowercase();
        if url_lower.ends_with(".py") { return ExploitLanguage::Python; }
        if url_lower.ends_with(".rb") { return ExploitLanguage::Ruby; }
        if url_lower.ends_with(".sh") || url_lower.ends_with(".bash") { return ExploitLanguage::Bash; }
        if url_lower.ends_with(".ps1") { return ExploitLanguage::Powershell; }
        if url_lower.ends_with(".pl") { return ExploitLanguage::Perl; }
        if url_lower.ends_with(".js") { return ExploitLanguage::Javascript; }
        if url_lower.ends_with(".go") { return ExploitLanguage::Go; }
        if url_lower.ends_with(".c") { return ExploitLanguage::C; }
        if url_lower.ends_with(".cpp") || url_lower.ends_with(".cc") { return ExploitLanguage::Cpp; }
        if url_lower.ends_with(".rs") { return ExploitLanguage::Rust; }
        if url_lower.ends_with(".java") { return ExploitLanguage::Java; }
        if url_lower.ends_with(".php") { return ExploitLanguage::Php; }

        // Fall back to content-based detection
        detect_language(code)
    }

    /// Extract metadata from code (author, title, etc.)
    fn extract_metadata_from_code(code: &str, source_info: &mut std::collections::HashMap<String, String>) {
        // Check first few lines for common patterns
        for line in code.lines().take(30) {
            let line = line.trim();

            // Author patterns
            if line.to_lowercase().contains("author:") || line.to_lowercase().contains("@author") {
                if let Some(author) = line.split(':').nth(1) {
                    source_info.insert("author".to_string(), author.trim().to_string());
                }
            }

            // Title patterns
            if line.to_lowercase().contains("title:") || line.to_lowercase().contains("exploit title:") {
                if let Some(title) = line.split(':').nth(1) {
                    source_info.insert("title".to_string(), title.trim().to_string());
                }
            }
        }
    }

    /// Extract CVE ID from text
    fn extract_cve_from_text(text: &str) -> Option<String> {
        // Look for CVE pattern: CVE-YYYY-NNNNN
        let cve_pattern = regex::Regex::new(r"CVE-\d{4}-\d{4,7}").ok()?;
        cve_pattern.find(text).map(|m| m.as_str().to_string())
    }

    /// Extract domain from URL
    fn extract_domain(url: &str) -> String {
        url.split("://")
            .nth(1)
            .and_then(|s| s.split('/').next())
            .unwrap_or("unknown")
            .to_string()
    }

    /// Export PoC to a file
    pub fn export(&self, id: &str, output_path: &Path) -> Result<()> {
        let entry = self.get(id)
            .ok_or_else(|| anyhow!("PoC not found: {}", id))?;

        let code = self.get_code(id)?;

        // Create export with metadata header
        let export_content = format!(
            r#"#!/usr/bin/env {}
# PoC: {}
# CVE: {}
# Author: {}
# Status: {:?}
# Description: {}
# Tags: {}
# Created: {}
# Updated: {}
#
# Requirements: {}
#

{}
"#,
            get_interpreter(&entry.language),
            entry.title,
            entry.cve_id.as_deref().unwrap_or("N/A"),
            entry.author.as_deref().unwrap_or("Unknown"),
            entry.status,
            entry.description.as_deref().unwrap_or("No description"),
            entry.tags.join(", "),
            entry.created_at.format("%Y-%m-%d %H:%M:%S UTC"),
            entry.updated_at.format("%Y-%m-%d %H:%M:%S UTC"),
            entry.requirements.as_ref().map(|r| r.join(", ")).unwrap_or_else(|| "None".to_string()),
            code
        );

        fs::write(output_path, export_content)?;
        info!("Exported PoC {} to {:?}", id, output_path);

        Ok(())
    }

    /// Get statistics about the repository
    pub fn stats(&self) -> PocRepositoryStats {
        let total = self.index.len();
        let by_status: HashMap<PocStatus, usize> = self.index.values()
            .fold(HashMap::new(), |mut acc, p| {
                *acc.entry(p.status.clone()).or_insert(0) += 1;
                acc
            });

        let by_language: HashMap<ExploitLanguage, usize> = self.index.values()
            .fold(HashMap::new(), |mut acc, p| {
                *acc.entry(p.language.clone()).or_insert(0) += 1;
                acc
            });

        let with_cve = self.index.values()
            .filter(|p| p.cve_id.is_some())
            .count();

        let tested = self.index.values()
            .filter(|p| !p.test_results.is_empty())
            .count();

        PocRepositoryStats {
            total_pocs: total,
            by_status,
            by_language,
            with_cve,
            tested,
        }
    }
}

/// Filter options for listing PoCs
#[derive(Debug, Clone, Default)]
pub struct PocFilter {
    pub status: Option<PocStatus>,
    pub language: Option<ExploitLanguage>,
    pub cve_id: Option<String>,
    pub author: Option<String>,
    pub query: Option<String>,
}

/// Repository statistics
#[derive(Debug, Clone)]
pub struct PocRepositoryStats {
    pub total_pocs: usize,
    pub by_status: HashMap<PocStatus, usize>,
    pub by_language: HashMap<ExploitLanguage, usize>,
    pub with_cve: usize,
    pub tested: usize,
}

/// Detect programming language from code
fn detect_language(code: &str) -> ExploitLanguage {
    let code_lower = code.to_lowercase();

    if code_lower.contains("#!/usr/bin/python") ||
       code_lower.contains("import ") && (code_lower.contains("socket") || code_lower.contains("requests")) {
        ExploitLanguage::Python
    } else if code_lower.contains("#!/bin/bash") || code_lower.contains("#!/bin/sh") {
        ExploitLanguage::Bash
    } else if code_lower.contains("require ") && code_lower.contains("msf") {
        ExploitLanguage::Ruby
    } else if code_lower.contains("#include") && (code_lower.contains("stdio.h") || code_lower.contains("stdlib.h")) {
        ExploitLanguage::C
    } else if code_lower.contains("func ") && code_lower.contains("package ") {
        ExploitLanguage::Go
    } else if code_lower.contains("use strict") || code_lower.contains("const ") && code_lower.contains("require(") {
        ExploitLanguage::Javascript
    } else if code_lower.contains("<?php") {
        ExploitLanguage::Php
    } else if code_lower.contains("import java.") || code_lower.contains("public class ") {
        ExploitLanguage::Java
    } else if code_lower.contains("#!/usr/bin/perl") || code_lower.contains("use strict;") {
        ExploitLanguage::Perl
    } else if code_lower.contains("fn ") && code_lower.contains("let ") {
        ExploitLanguage::Rust
    } else if code_lower.contains("param(") || code_lower.contains("$psversiontable") {
        ExploitLanguage::Powershell
    } else {
        ExploitLanguage::Other("unknown".to_string())
    }
}

/// Get interpreter for language
fn get_interpreter(language: &ExploitLanguage) -> &'static str {
    match language {
        ExploitLanguage::Python => "python3",
        ExploitLanguage::Ruby => "ruby",
        ExploitLanguage::Perl => "perl",
        ExploitLanguage::Bash => "bash",
        ExploitLanguage::Powershell => "pwsh",
        ExploitLanguage::Javascript => "node",
        ExploitLanguage::Go => "go run",
        _ => "sh",
    }
}

impl Default for PocRepository {
    fn default() -> Self {
        Self::new(None).expect("Failed to create PocRepository")
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::tempdir;

    #[test]
    fn test_detect_language() {
        assert!(matches!(
            detect_language("#!/usr/bin/python\nimport socket"),
            ExploitLanguage::Python
        ));

        assert!(matches!(
            detect_language("#!/bin/bash\necho hello"),
            ExploitLanguage::Bash
        ));
    }

    #[test]
    fn test_poc_repository_create() {
        let temp = tempdir().unwrap();
        let mut repo = PocRepository::new(Some(temp.path().to_str().unwrap())).unwrap();

        let request = CreatePocRequest {
            cve_id: Some("CVE-2024-1234".to_string()),
            exploit_id: None,
            title: "Test PoC".to_string(),
            description: Some("Test description".to_string()),
            language: Some(ExploitLanguage::Python),
            code: "#!/usr/bin/python\nprint('test')".to_string(),
            author: Some("tester".to_string()),
            tags: vec!["test".to_string()],
            target_info: None,
            requirements: None,
        };

        let poc = repo.create(request).unwrap();
        assert_eq!(poc.title, "Test PoC");
        assert!(matches!(poc.status, PocStatus::Development));

        // Verify retrieval
        let retrieved = repo.get(&poc.id).unwrap();
        assert_eq!(retrieved.cve_id, Some("CVE-2024-1234".to_string()));
    }

    #[test]
    fn test_poc_versioning() {
        let temp = tempdir().unwrap();
        let mut repo = PocRepository::new(Some(temp.path().to_str().unwrap())).unwrap();

        let create_req = CreatePocRequest {
            cve_id: None,
            exploit_id: None,
            title: "Version Test".to_string(),
            description: None,
            language: Some(ExploitLanguage::Python),
            code: "print('v1')".to_string(),
            author: None,
            tags: Vec::new(),
            target_info: None,
            requirements: None,
        };

        let poc = repo.create(create_req).unwrap();
        assert_eq!(poc.versions.len(), 1);

        // Update with new code
        let update_req = UpdatePocRequest {
            code: Some("print('v2')".to_string()),
            changelog: Some("Updated to v2".to_string()),
            ..Default::default()
        };

        let updated = repo.update(&poc.id, update_req).unwrap();
        assert_eq!(updated.versions.len(), 2);

        // Get specific version
        let v1_code = repo.get_code_version(&poc.id, "1.0.0").unwrap();
        assert!(v1_code.contains("v1"));

        let v2_code = repo.get_code_version(&poc.id, "2.0.0").unwrap();
        assert!(v2_code.contains("v2"));
    }
}
