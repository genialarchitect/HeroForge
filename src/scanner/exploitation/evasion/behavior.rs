// Behavioral Evasion Techniques
// Provides analysis and documentation of behavioral evasion methods
// For educational and authorized penetration testing purposes only

use super::{
    DetectionRisk, EvasionArtifact, EvasionResult, EvasionTechnique,
    SandboxCheckResult, SandboxIndicator,
};
use chrono::Utc;
use std::collections::HashMap;
use uuid::Uuid;

// ============================================================================
// Sandbox Detection Indicators
// ============================================================================

/// Categories of sandbox detection methods
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize, PartialEq, Eq)]
pub enum SandboxIndicatorCategory {
    VirtualMachine,
    AnalysisTool,
    Timing,
    Hardware,
    UserInteraction,
    Network,
    Process,
    Registry,
    FileSystem,
}

impl std::fmt::Display for SandboxIndicatorCategory {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            SandboxIndicatorCategory::VirtualMachine => write!(f, "Virtual Machine"),
            SandboxIndicatorCategory::AnalysisTool => write!(f, "Analysis Tool"),
            SandboxIndicatorCategory::Timing => write!(f, "Timing"),
            SandboxIndicatorCategory::Hardware => write!(f, "Hardware"),
            SandboxIndicatorCategory::UserInteraction => write!(f, "User Interaction"),
            SandboxIndicatorCategory::Network => write!(f, "Network"),
            SandboxIndicatorCategory::Process => write!(f, "Process"),
            SandboxIndicatorCategory::Registry => write!(f, "Registry"),
            SandboxIndicatorCategory::FileSystem => write!(f, "File System"),
        }
    }
}

/// Detailed sandbox indicator information
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct SandboxIndicatorInfo {
    pub name: String,
    pub category: SandboxIndicatorCategory,
    pub description: String,
    pub check_method: String,
    pub windows_specific: bool,
    pub linux_specific: bool,
    pub detection_confidence: u8,
    pub mitre_id: Option<String>,
    pub code_example: Option<String>,
}

/// Get all known sandbox indicators
pub fn get_sandbox_indicators() -> Vec<SandboxIndicatorInfo> {
    vec![
        // Virtual Machine Detection
        SandboxIndicatorInfo {
            name: "VMware Registry Keys".to_string(),
            category: SandboxIndicatorCategory::VirtualMachine,
            description: "Check for VMware-specific registry keys".to_string(),
            check_method: r#"HKLM\SOFTWARE\VMware, Inc.\VMware Tools"#.to_string(),
            windows_specific: true,
            linux_specific: false,
            detection_confidence: 90,
            mitre_id: Some("T1497.001".to_string()),
            code_example: Some(r#"RegOpenKeyEx(HKEY_LOCAL_MACHINE, "SOFTWARE\\VMware, Inc.\\VMware Tools", ...)"#.to_string()),
        },
        SandboxIndicatorInfo {
            name: "VirtualBox Guest Additions".to_string(),
            category: SandboxIndicatorCategory::VirtualMachine,
            description: "Check for VirtualBox guest additions".to_string(),
            check_method: r#"HKLM\SOFTWARE\Oracle\VirtualBox Guest Additions"#.to_string(),
            windows_specific: true,
            linux_specific: false,
            detection_confidence: 90,
            mitre_id: Some("T1497.001".to_string()),
            code_example: None,
        },
        SandboxIndicatorInfo {
            name: "Hyper-V CPUID".to_string(),
            category: SandboxIndicatorCategory::VirtualMachine,
            description: "CPUID hypervisor present bit check".to_string(),
            check_method: "CPUID with EAX=1, check ECX bit 31".to_string(),
            windows_specific: false,
            linux_specific: false,
            detection_confidence: 85,
            mitre_id: Some("T1497.001".to_string()),
            code_example: Some(r#"__cpuid(cpuInfo, 1); if (cpuInfo[2] & (1 << 31)) { /* VM */ }"#.to_string()),
        },
        SandboxIndicatorInfo {
            name: "MAC Address OUI Check".to_string(),
            category: SandboxIndicatorCategory::VirtualMachine,
            description: "Check MAC address vendor prefix for VM vendors".to_string(),
            check_method: "GetAdaptersAddresses and check first 3 bytes".to_string(),
            windows_specific: false,
            linux_specific: false,
            detection_confidence: 75,
            mitre_id: Some("T1497.001".to_string()),
            code_example: Some(r#"// VMware: 00:0C:29, 00:50:56
// VirtualBox: 08:00:27
// Hyper-V: 00:15:5D"#.to_string()),
        },
        SandboxIndicatorInfo {
            name: "DMI/BIOS Strings".to_string(),
            category: SandboxIndicatorCategory::VirtualMachine,
            description: "Check BIOS and system manufacturer strings".to_string(),
            check_method: "WMI Win32_BIOS, Win32_ComputerSystem".to_string(),
            windows_specific: true,
            linux_specific: false,
            detection_confidence: 80,
            mitre_id: Some("T1497.001".to_string()),
            code_example: Some(r#"SELECT * FROM Win32_BIOS WHERE Manufacturer LIKE '%VMware%'"#.to_string()),
        },

        // Analysis Tool Detection
        SandboxIndicatorInfo {
            name: "Debugger Present".to_string(),
            category: SandboxIndicatorCategory::AnalysisTool,
            description: "Check if debugger is attached".to_string(),
            check_method: "IsDebuggerPresent() API".to_string(),
            windows_specific: true,
            linux_specific: false,
            detection_confidence: 95,
            mitre_id: Some("T1497.001".to_string()),
            code_example: Some(r#"if (IsDebuggerPresent()) { exit(0); }"#.to_string()),
        },
        SandboxIndicatorInfo {
            name: "PEB BeingDebugged".to_string(),
            category: SandboxIndicatorCategory::AnalysisTool,
            description: "Check PEB BeingDebugged flag directly".to_string(),
            check_method: "Read PEB structure at fs:[0x30] (x86) or gs:[0x60] (x64)".to_string(),
            windows_specific: true,
            linux_specific: false,
            detection_confidence: 90,
            mitre_id: Some("T1497.001".to_string()),
            code_example: Some(r#"mov eax, fs:[0x30]  ; Get PEB
movzx eax, byte ptr [eax+2]  ; BeingDebugged flag"#.to_string()),
        },
        SandboxIndicatorInfo {
            name: "NtGlobalFlag".to_string(),
            category: SandboxIndicatorCategory::AnalysisTool,
            description: "Check NtGlobalFlag in PEB for debug heap flags".to_string(),
            check_method: "PEB->NtGlobalFlag at offset 0x68 (x86) or 0xBC (x64)".to_string(),
            windows_specific: true,
            linux_specific: false,
            detection_confidence: 85,
            mitre_id: Some("T1497.001".to_string()),
            code_example: Some(r#"// FLG_HEAP_ENABLE_TAIL_CHECK | FLG_HEAP_ENABLE_FREE_CHECK | FLG_HEAP_VALIDATE_PARAMETERS
// Value 0x70 indicates debugger"#.to_string()),
        },
        SandboxIndicatorInfo {
            name: "Process Names".to_string(),
            category: SandboxIndicatorCategory::AnalysisTool,
            description: "Check for analysis tool processes".to_string(),
            check_method: "EnumProcesses and check names".to_string(),
            windows_specific: false,
            linux_specific: false,
            detection_confidence: 80,
            mitre_id: Some("T1057".to_string()),
            code_example: Some(r#"// Check for: ollydbg.exe, x64dbg.exe, processhacker.exe, procmon.exe,
// wireshark.exe, fiddler.exe, ida.exe, ida64.exe, windbg.exe"#.to_string()),
        },
        SandboxIndicatorInfo {
            name: "Window Names".to_string(),
            category: SandboxIndicatorCategory::AnalysisTool,
            description: "Check for analysis tool window titles".to_string(),
            check_method: "EnumWindows and GetWindowText".to_string(),
            windows_specific: true,
            linux_specific: false,
            detection_confidence: 70,
            mitre_id: Some("T1497.001".to_string()),
            code_example: None,
        },

        // Timing-based Detection
        SandboxIndicatorInfo {
            name: "RDTSC Timing".to_string(),
            category: SandboxIndicatorCategory::Timing,
            description: "Use RDTSC to detect single-stepping or VM overhead".to_string(),
            check_method: "Measure time between two RDTSC instructions".to_string(),
            windows_specific: false,
            linux_specific: false,
            detection_confidence: 75,
            mitre_id: Some("T1497.003".to_string()),
            code_example: Some(r#"__rdtsc(); // first
// some operations
__rdtsc(); // second
// If delta > threshold, sandbox/debugger"#.to_string()),
        },
        SandboxIndicatorInfo {
            name: "Sleep Acceleration".to_string(),
            category: SandboxIndicatorCategory::Timing,
            description: "Detect if Sleep() is being accelerated".to_string(),
            check_method: "Sleep for extended period, measure actual time".to_string(),
            windows_specific: false,
            linux_specific: false,
            detection_confidence: 85,
            mitre_id: Some("T1497.003".to_string()),
            code_example: Some(r#"GetTickCount64();
Sleep(60000);  // 60 seconds
GetTickCount64();
// If elapsed < 55 seconds, sandbox is accelerating"#.to_string()),
        },
        SandboxIndicatorInfo {
            name: "Long Delay".to_string(),
            category: SandboxIndicatorCategory::Timing,
            description: "Use long delays to exceed sandbox timeout".to_string(),
            check_method: "Sleep beyond typical sandbox analysis time (2-5 min)".to_string(),
            windows_specific: false,
            linux_specific: false,
            detection_confidence: 60,
            mitre_id: Some("T1497.003".to_string()),
            code_example: Some(r#"// Many sandboxes timeout after 2-5 minutes
Sleep(300000);  // 5 minutes"#.to_string()),
        },

        // Hardware Checks
        SandboxIndicatorInfo {
            name: "CPU Core Count".to_string(),
            category: SandboxIndicatorCategory::Hardware,
            description: "Check for low CPU core count (common in VMs)".to_string(),
            check_method: "GetSystemInfo or /proc/cpuinfo".to_string(),
            windows_specific: false,
            linux_specific: false,
            detection_confidence: 50,
            mitre_id: Some("T1497.001".to_string()),
            code_example: Some(r#"SYSTEM_INFO si;
GetSystemInfo(&si);
if (si.dwNumberOfProcessors < 2) { /* likely VM */ }"#.to_string()),
        },
        SandboxIndicatorInfo {
            name: "RAM Size".to_string(),
            category: SandboxIndicatorCategory::Hardware,
            description: "Check for low RAM (common in sandboxes)".to_string(),
            check_method: "GlobalMemoryStatusEx".to_string(),
            windows_specific: false,
            linux_specific: false,
            detection_confidence: 50,
            mitre_id: Some("T1497.001".to_string()),
            code_example: Some(r#"MEMORYSTATUSEX ms;
ms.dwLength = sizeof(ms);
GlobalMemoryStatusEx(&ms);
if (ms.ullTotalPhys < 2ULL * 1024 * 1024 * 1024) { /* < 2GB */ }"#.to_string()),
        },
        SandboxIndicatorInfo {
            name: "Disk Size".to_string(),
            category: SandboxIndicatorCategory::Hardware,
            description: "Check for small disk size".to_string(),
            check_method: "GetDiskFreeSpaceEx".to_string(),
            windows_specific: false,
            linux_specific: false,
            detection_confidence: 45,
            mitre_id: Some("T1497.001".to_string()),
            code_example: None,
        },
        SandboxIndicatorInfo {
            name: "Screen Resolution".to_string(),
            category: SandboxIndicatorCategory::Hardware,
            description: "Check for unusual screen resolution".to_string(),
            check_method: "GetSystemMetrics(SM_CXSCREEN/SM_CYSCREEN)".to_string(),
            windows_specific: true,
            linux_specific: false,
            detection_confidence: 40,
            mitre_id: Some("T1497.001".to_string()),
            code_example: None,
        },

        // User Interaction
        SandboxIndicatorInfo {
            name: "Mouse Movement".to_string(),
            category: SandboxIndicatorCategory::UserInteraction,
            description: "Check for mouse movement/clicks".to_string(),
            check_method: "GetCursorPos over time, GetAsyncKeyState".to_string(),
            windows_specific: true,
            linux_specific: false,
            detection_confidence: 80,
            mitre_id: Some("T1497.002".to_string()),
            code_example: Some(r#"POINT p1, p2;
GetCursorPos(&p1);
Sleep(30000);  // Wait 30 seconds
GetCursorPos(&p2);
if (p1.x == p2.x && p1.y == p2.y) { /* no mouse movement */ }"#.to_string()),
        },
        SandboxIndicatorInfo {
            name: "Recent User Files".to_string(),
            category: SandboxIndicatorCategory::UserInteraction,
            description: "Check for recently modified user files".to_string(),
            check_method: "Enumerate Documents, Desktop, etc.".to_string(),
            windows_specific: false,
            linux_specific: false,
            detection_confidence: 60,
            mitre_id: Some("T1497.002".to_string()),
            code_example: None,
        },
        SandboxIndicatorInfo {
            name: "Browser History".to_string(),
            category: SandboxIndicatorCategory::UserInteraction,
            description: "Check for browser history presence".to_string(),
            check_method: "Check browser profile directories".to_string(),
            windows_specific: false,
            linux_specific: false,
            detection_confidence: 55,
            mitre_id: Some("T1497.002".to_string()),
            code_example: None,
        },

        // Process-based
        SandboxIndicatorInfo {
            name: "Parent Process".to_string(),
            category: SandboxIndicatorCategory::Process,
            description: "Check parent process for sandbox indicators".to_string(),
            check_method: "NtQueryInformationProcess, check parent PID".to_string(),
            windows_specific: true,
            linux_specific: false,
            detection_confidence: 65,
            mitre_id: Some("T1057".to_string()),
            code_example: None,
        },
        SandboxIndicatorInfo {
            name: "Username Check".to_string(),
            category: SandboxIndicatorCategory::Process,
            description: "Check for sandbox-typical usernames".to_string(),
            check_method: "GetUserName, environment variables".to_string(),
            windows_specific: false,
            linux_specific: false,
            detection_confidence: 70,
            mitre_id: Some("T1497.001".to_string()),
            code_example: Some(r#"// Common sandbox usernames: sandbox, malware, virus, admin, test,
// user, john, joe, emily, sample, maltest, CurrentUser"#.to_string()),
        },
        SandboxIndicatorInfo {
            name: "Hostname Check".to_string(),
            category: SandboxIndicatorCategory::Process,
            description: "Check for sandbox-typical hostnames".to_string(),
            check_method: "GetComputerName".to_string(),
            windows_specific: false,
            linux_specific: false,
            detection_confidence: 65,
            mitre_id: Some("T1497.001".to_string()),
            code_example: Some(r#"// Common: SANDBOX, VIRUS, MALWARE, TEST, SAMPLE, WIN7-PC"#.to_string()),
        },
    ]
}

// ============================================================================
// Sleep Obfuscation Techniques
// ============================================================================

/// Information about sleep obfuscation techniques
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct SleepObfuscationInfo {
    pub name: String,
    pub description: String,
    pub implementation_notes: String,
    pub pros: Vec<String>,
    pub cons: Vec<String>,
    pub detection_difficulty: u8,
    pub code_concept: String,
}

/// Get sleep obfuscation techniques
pub fn get_sleep_obfuscation_techniques() -> Vec<SleepObfuscationInfo> {
    vec![
        SleepObfuscationInfo {
            name: "API Sleep".to_string(),
            description: "Standard Sleep() API call".to_string(),
            implementation_notes: "Simple but easily hooked by EDR".to_string(),
            pros: vec!["Simple".to_string(), "Reliable".to_string()],
            cons: vec!["Easily hooked".to_string(), "Easily accelerated by sandboxes".to_string()],
            detection_difficulty: 1,
            code_concept: "Sleep(milliseconds);".to_string(),
        },
        SleepObfuscationInfo {
            name: "WaitForSingleObject".to_string(),
            description: "Use WaitForSingleObject with timeout".to_string(),
            implementation_notes: "Create a never-signaled event and wait on it".to_string(),
            pros: vec!["Less commonly hooked".to_string()],
            cons: vec!["Still uses kernel wait".to_string()],
            detection_difficulty: 3,
            code_concept: r#"HANDLE h = CreateEvent(NULL, TRUE, FALSE, NULL);
WaitForSingleObject(h, timeout);"#.to_string(),
        },
        SleepObfuscationInfo {
            name: "NtDelayExecution".to_string(),
            description: "Direct syscall to NtDelayExecution".to_string(),
            implementation_notes: "Bypasses user-mode hooks on Sleep".to_string(),
            pros: vec!["Bypasses Sleep hooks".to_string()],
            cons: vec!["Requires syscall number".to_string(), "Syscall monitoring can detect".to_string()],
            detection_difficulty: 6,
            code_concept: r#"LARGE_INTEGER li;
li.QuadPart = -(delay * 10000);  // 100ns units
NtDelayExecution(FALSE, &li);"#.to_string(),
        },
        SleepObfuscationInfo {
            name: "CPU Burn Loop".to_string(),
            description: "Busy loop consuming CPU cycles".to_string(),
            implementation_notes: "Use RDTSC to measure elapsed time".to_string(),
            pros: vec!["No API calls".to_string(), "Hard to accelerate".to_string()],
            cons: vec!["High CPU usage".to_string(), "Suspicious behavior".to_string()],
            detection_difficulty: 5,
            code_concept: r#"uint64_t start = __rdtsc();
while (__rdtsc() - start < cycles_to_wait) { };"#.to_string(),
        },
        SleepObfuscationInfo {
            name: "Memory Encryption Sleep".to_string(),
            description: "Encrypt memory during sleep, decrypt on wake".to_string(),
            implementation_notes: "Protects payload in memory during delay".to_string(),
            pros: vec!["Hides payload during sleep".to_string(), "Evades memory scanning".to_string()],
            cons: vec!["Complex implementation".to_string()],
            detection_difficulty: 8,
            code_concept: r#"// 1. Encrypt heap/stack with key
// 2. Store key in register or volatile memory
// 3. Sleep using any method
// 4. Decrypt on resume"#.to_string(),
        },
        SleepObfuscationInfo {
            name: "Callback-based Delay".to_string(),
            description: "Use timer callbacks for delayed execution".to_string(),
            implementation_notes: "CreateTimerQueueTimer, SetTimer, etc.".to_string(),
            pros: vec!["Async execution".to_string(), "Less suspicious".to_string()],
            cons: vec!["More complex logic".to_string()],
            detection_difficulty: 5,
            code_concept: r#"CreateTimerQueueTimer(&hTimer, NULL,
    TimerRoutine, param, delayMs, 0, 0);"#.to_string(),
        },
        SleepObfuscationInfo {
            name: "Thread Pool Wait".to_string(),
            description: "Use thread pool wait objects".to_string(),
            implementation_notes: "SetThreadpoolWait with timeout".to_string(),
            pros: vec!["Legitimate API usage".to_string()],
            cons: vec!["Windows thread pool knowledge needed".to_string()],
            detection_difficulty: 6,
            code_concept: r#"PTP_WAIT wait = CreateThreadpoolWait(callback, ctx, NULL);
SetThreadpoolWait(wait, event, &timeout);"#.to_string(),
        },
    ]
}

// ============================================================================
// Unhooking Techniques Documentation
// ============================================================================

/// Information about unhooking techniques (documentation only)
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct UnhookingTechniqueInfo {
    pub name: String,
    pub description: String,
    pub target: String,
    pub method: String,
    pub detection_risk: DetectionRisk,
    pub mitre_id: Option<String>,
    pub notes: Vec<String>,
}

/// Get unhooking technique documentation
pub fn get_unhooking_techniques() -> Vec<UnhookingTechniqueInfo> {
    vec![
        UnhookingTechniqueInfo {
            name: "NTDLL Unhooking (Disk)".to_string(),
            description: "Restore ntdll.dll .text section from disk copy".to_string(),
            target: "ntdll.dll".to_string(),
            method: "Read clean ntdll from disk, copy .text section over hooked version".to_string(),
            detection_risk: DetectionRisk::Medium,
            mitre_id: Some("T1562.001".to_string()),
            notes: vec![
                "Read ntdll.dll from C:\\Windows\\System32\\".to_string(),
                "Parse PE headers to find .text section".to_string(),
                "Use VirtualProtect to make section writable".to_string(),
                "Copy clean bytes over hooked region".to_string(),
                "Restore original protection".to_string(),
            ],
        },
        UnhookingTechniqueInfo {
            name: "NTDLL Unhooking (KnownDlls)".to_string(),
            description: "Map clean ntdll from \\KnownDlls\\".to_string(),
            target: "ntdll.dll".to_string(),
            method: "Open section from KnownDlls, map view, copy .text".to_string(),
            detection_risk: DetectionRisk::Low,
            mitre_id: Some("T1562.001".to_string()),
            notes: vec![
                "Open \\KnownDlls\\ntdll.dll section object".to_string(),
                "Map view of section".to_string(),
                "Copy .text section to loaded ntdll".to_string(),
            ],
        },
        UnhookingTechniqueInfo {
            name: "Suspended Process Unhooking".to_string(),
            description: "Create suspended process, read its clean ntdll".to_string(),
            target: "ntdll.dll".to_string(),
            method: "Spawn suspended process, read ntdll before EDR hooks".to_string(),
            detection_risk: DetectionRisk::Medium,
            mitre_id: Some("T1562.001".to_string()),
            notes: vec![
                "CreateProcess with CREATE_SUSPENDED".to_string(),
                "Read ntdll.dll from new process memory".to_string(),
                "Copy to current process".to_string(),
                "Terminate suspended process".to_string(),
            ],
        },
        UnhookingTechniqueInfo {
            name: "Direct Syscalls".to_string(),
            description: "Bypass hooks entirely via direct syscall invocation".to_string(),
            target: "All hooked functions".to_string(),
            method: "Manually invoke syscalls without going through ntdll".to_string(),
            detection_risk: DetectionRisk::Low,
            mitre_id: Some("T1106".to_string()),
            notes: vec![
                "Extract syscall numbers dynamically".to_string(),
                "Craft syscall stub in executable memory".to_string(),
                "Invoke syscall directly (syscall/int 2e)".to_string(),
                "Avoid all user-mode hooks".to_string(),
            ],
        },
        UnhookingTechniqueInfo {
            name: "Syscall Number Extraction".to_string(),
            description: "Extract syscall numbers from ntdll exports".to_string(),
            target: "Nt* functions".to_string(),
            method: "Parse function prologues to find syscall numbers".to_string(),
            detection_risk: DetectionRisk::Low,
            mitre_id: Some("T1106".to_string()),
            notes: vec![
                "Locate Nt* function in ntdll".to_string(),
                "Read first bytes: mov eax, <syscall number>".to_string(),
                "Handle hooked case: jmp <hook> - look at stored original".to_string(),
                "x64: mov r10, rcx; mov eax, <num>; syscall".to_string(),
            ],
        },
        UnhookingTechniqueInfo {
            name: "Hell's Gate".to_string(),
            description: "Dynamic syscall number resolution technique".to_string(),
            target: "All Nt* functions".to_string(),
            method: "Parse function prologue even if hooked, find syscall number nearby".to_string(),
            detection_risk: DetectionRisk::Low,
            mitre_id: Some("T1106".to_string()),
            notes: vec![
                "If function is hooked (starts with jmp), search nearby functions".to_string(),
                "Calculate syscall number offset from nearby unhooked function".to_string(),
                "Syscall numbers are sequential for most Nt functions".to_string(),
            ],
        },
        UnhookingTechniqueInfo {
            name: "Halo's Gate".to_string(),
            description: "Improved Hell's Gate with neighbor function search".to_string(),
            target: "All Nt* functions".to_string(),
            method: "Search neighbor functions up/down for unhooked function".to_string(),
            detection_risk: DetectionRisk::Low,
            mitre_id: Some("T1106".to_string()),
            notes: vec![
                "If target function is hooked, search neighbors".to_string(),
                "Find nearest unhooked function".to_string(),
                "Calculate target syscall number from offset".to_string(),
            ],
        },
    ]
}

// ============================================================================
// Process Hollowing & Injection Documentation
// ============================================================================

/// Information about process injection techniques (documentation only)
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct ProcessInjectionInfo {
    pub name: String,
    pub technique_id: String,
    pub description: String,
    pub steps: Vec<String>,
    pub detection_methods: Vec<String>,
    pub mitre_id: String,
    pub detection_risk: DetectionRisk,
}

/// Get process injection technique documentation
pub fn get_process_injection_techniques() -> Vec<ProcessInjectionInfo> {
    vec![
        ProcessInjectionInfo {
            name: "Process Hollowing".to_string(),
            technique_id: "T1055.012".to_string(),
            description: "Replace legitimate process memory with malicious code".to_string(),
            steps: vec![
                "Create target process in suspended state".to_string(),
                "Unmap (NtUnmapViewOfSection) original executable image".to_string(),
                "Allocate memory in target at image base".to_string(),
                "Write malicious PE into allocated memory".to_string(),
                "Set thread context to point to new entry point".to_string(),
                "Resume suspended thread".to_string(),
            ],
            detection_methods: vec![
                "Memory region comparison with on-disk image".to_string(),
                "Detecting NtUnmapViewOfSection calls".to_string(),
                "Thread context modification monitoring".to_string(),
                "Image load callback monitoring".to_string(),
            ],
            mitre_id: "T1055.012".to_string(),
            detection_risk: DetectionRisk::High,
        },
        ProcessInjectionInfo {
            name: "Classic DLL Injection".to_string(),
            technique_id: "T1055.001".to_string(),
            description: "Inject DLL into remote process via CreateRemoteThread".to_string(),
            steps: vec![
                "Open target process with PROCESS_ALL_ACCESS".to_string(),
                "Allocate memory in target for DLL path".to_string(),
                "Write DLL path to allocated memory".to_string(),
                "Get address of LoadLibraryA in kernel32".to_string(),
                "CreateRemoteThread with LoadLibraryA and DLL path".to_string(),
            ],
            detection_methods: vec![
                "CreateRemoteThread detection".to_string(),
                "VirtualAllocEx/WriteProcessMemory monitoring".to_string(),
                "DLL load from unusual paths".to_string(),
            ],
            mitre_id: "T1055.001".to_string(),
            detection_risk: DetectionRisk::Critical,
        },
        ProcessInjectionInfo {
            name: "Thread Execution Hijacking".to_string(),
            technique_id: "T1055.003".to_string(),
            description: "Hijack existing thread to execute shellcode".to_string(),
            steps: vec![
                "Open target process and enumerate threads".to_string(),
                "Suspend target thread".to_string(),
                "Allocate memory for shellcode".to_string(),
                "Write shellcode to allocated memory".to_string(),
                "Get and modify thread context (RIP/EIP)".to_string(),
                "Resume thread to execute shellcode".to_string(),
            ],
            detection_methods: vec![
                "SuspendThread/SetThreadContext monitoring".to_string(),
                "Unexpected thread context changes".to_string(),
            ],
            mitre_id: "T1055.003".to_string(),
            detection_risk: DetectionRisk::High,
        },
        ProcessInjectionInfo {
            name: "APC Injection".to_string(),
            technique_id: "T1055.004".to_string(),
            description: "Queue APC to target thread for code execution".to_string(),
            steps: vec![
                "Open target process and thread".to_string(),
                "Allocate memory in target process".to_string(),
                "Write shellcode to allocated memory".to_string(),
                "QueueUserAPC with shellcode address".to_string(),
                "APC executes when thread enters alertable wait".to_string(),
            ],
            detection_methods: vec![
                "QueueUserAPC/NtQueueApcThread monitoring".to_string(),
                "Cross-process APC queueing detection".to_string(),
            ],
            mitre_id: "T1055.004".to_string(),
            detection_risk: DetectionRisk::High,
        },
        ProcessInjectionInfo {
            name: "Early Bird Injection".to_string(),
            technique_id: "T1055".to_string(),
            description: "APC injection to main thread before entry point".to_string(),
            steps: vec![
                "Create process in suspended state".to_string(),
                "Allocate and write shellcode".to_string(),
                "Queue APC to main thread".to_string(),
                "Resume process - APC runs before main()".to_string(),
            ],
            detection_methods: vec![
                "Suspended process creation followed by APC".to_string(),
                "Early execution before CRT initialization".to_string(),
            ],
            mitre_id: "T1055".to_string(),
            detection_risk: DetectionRisk::Medium,
        },
        ProcessInjectionInfo {
            name: "Module Stomping".to_string(),
            technique_id: "T1055".to_string(),
            description: "Overwrite loaded DLL with shellcode".to_string(),
            steps: vec![
                "Find loaded but unused DLL in target".to_string(),
                "Change memory protection to RWX".to_string(),
                "Overwrite .text section with shellcode".to_string(),
                "Create thread or hijack to execute".to_string(),
            ],
            detection_methods: vec![
                "Module integrity verification".to_string(),
                "Memory protection changes on loaded modules".to_string(),
            ],
            mitre_id: "T1055".to_string(),
            detection_risk: DetectionRisk::Medium,
        },
    ]
}

// ============================================================================
// Sandbox Check Implementation
// ============================================================================

/// Analyze system for sandbox indicators (documentation of what to check)
pub fn analyze_sandbox_indicators() -> SandboxCheckResult {
    let indicators = get_sandbox_indicators();

    // This is analysis/documentation only - not actual checks
    let sandbox_indicators: Vec<SandboxIndicator> = indicators
        .iter()
        .map(|info| SandboxIndicator {
            name: info.name.clone(),
            category: info.category.to_string(),
            description: info.description.clone(),
            confidence: info.detection_confidence,
            details: Some(info.check_method.clone()),
        })
        .collect();

    SandboxCheckResult {
        is_sandbox: false, // This is documentation, not actual detection
        confidence: 0,
        indicators: sandbox_indicators,
        environment: {
            let mut env = HashMap::new();
            env.insert("analysis_mode".to_string(), "documentation".to_string());
            env.insert("indicators_documented".to_string(), indicators.len().to_string());
            env
        },
        timestamp: Utc::now(),
    }
}

/// Apply behavioral evasion analysis
pub fn apply_behavioral_evasion_analysis(
    techniques: &[EvasionTechnique],
) -> EvasionResult {
    let mut artifacts = Vec::new();
    let mut confidence: u8 = 50;

    for technique in techniques {
        match technique {
            EvasionTechnique::SandboxDetection => {
                let indicators = get_sandbox_indicators();
                artifacts.push(EvasionArtifact {
                    technique: technique.clone(),
                    artifact_type: "sandbox_detection".to_string(),
                    description: format!("Documented {} sandbox detection methods", indicators.len()),
                    details: {
                        let mut map = HashMap::new();
                        map.insert("indicator_count".to_string(), serde_json::json!(indicators.len()));
                        let categories: Vec<_> = indicators.iter().map(|i| i.category.to_string()).collect();
                        map.insert("categories".to_string(), serde_json::json!(categories));
                        map
                    },
                });
                confidence = confidence.saturating_add(15);
            }
            EvasionTechnique::TimingEvasion => {
                let sleep_techniques = get_sleep_obfuscation_techniques();
                artifacts.push(EvasionArtifact {
                    technique: technique.clone(),
                    artifact_type: "timing_evasion".to_string(),
                    description: format!("Documented {} sleep obfuscation techniques", sleep_techniques.len()),
                    details: {
                        let mut map = HashMap::new();
                        map.insert("technique_count".to_string(), serde_json::json!(sleep_techniques.len()));
                        map
                    },
                });
                confidence = confidence.saturating_add(10);
            }
            EvasionTechnique::NtdllUnhooking | EvasionTechnique::DirectSyscalls => {
                let unhook_techniques = get_unhooking_techniques();
                artifacts.push(EvasionArtifact {
                    technique: technique.clone(),
                    artifact_type: "unhooking".to_string(),
                    description: format!("Documented {} unhooking techniques", unhook_techniques.len()),
                    details: {
                        let mut map = HashMap::new();
                        map.insert("technique_count".to_string(), serde_json::json!(unhook_techniques.len()));
                        map
                    },
                });
                confidence = confidence.saturating_add(20);
            }
            EvasionTechnique::ProcessHollowing | EvasionTechnique::DllInjection | EvasionTechnique::ThreadHijacking => {
                let injection_techniques = get_process_injection_techniques();
                artifacts.push(EvasionArtifact {
                    technique: technique.clone(),
                    artifact_type: "process_injection".to_string(),
                    description: format!("Documented {} injection techniques", injection_techniques.len()),
                    details: {
                        let mut map = HashMap::new();
                        map.insert("technique_count".to_string(), serde_json::json!(injection_techniques.len()));
                        map
                    },
                });
                confidence = confidence.saturating_add(15);
            }
            _ => {
                artifacts.push(EvasionArtifact {
                    technique: technique.clone(),
                    artifact_type: "documentation".to_string(),
                    description: technique.description().to_string(),
                    details: HashMap::new(),
                });
                confidence = confidence.saturating_add(5);
            }
        }
    }

    confidence = std::cmp::min(confidence, 95);

    let detection_risk = if techniques.iter().any(|t| matches!(t,
        EvasionTechnique::DirectSyscalls | EvasionTechnique::NtdllUnhooking
    )) {
        DetectionRisk::Low
    } else if techniques.iter().any(|t| matches!(t,
        EvasionTechnique::SandboxDetection | EvasionTechnique::TimingEvasion
    )) {
        DetectionRisk::Medium
    } else {
        DetectionRisk::High
    };

    EvasionResult {
        id: Uuid::new_v4().to_string(),
        techniques_applied: techniques.to_vec(),
        original_hash: "N/A".to_string(),
        modified_hash: None,
        confidence,
        detection_risk,
        artifacts,
        recommendations: vec![
            "Combine sandbox detection with timing evasion".to_string(),
            "Use direct syscalls to bypass user-mode hooks".to_string(),
            "Test against target EDR before deployment".to_string(),
            "Consider memory encryption during sleep".to_string(),
        ],
        timestamp: Utc::now(),
    }
}
