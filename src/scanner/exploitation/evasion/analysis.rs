// Payload Analysis Module
// Provides analysis of payloads for detection risk assessment
// For educational and authorized penetration testing purposes only

#![allow(dead_code)]

use super::{
    signature::calculate_entropy,
    ApiAnalysis, ApiCombination, DetectionRisk, EntropyAnalysis, EntropySection,
    PayloadAnalysisResult, SuspiciousPattern, SuspiciousString,
};
use chrono::Utc;
use std::collections::HashMap;
use uuid::Uuid;

// ============================================================================
// Suspicious String Patterns
// ============================================================================

/// Categories of suspicious strings
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize, PartialEq, Eq)]
pub enum StringCategory {
    ApiCall,
    Command,
    Url,
    Registry,
    FilePath,
    CryptoConstant,
    DebugString,
    Credential,
    NetworkIndicator,
}

impl std::fmt::Display for StringCategory {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            StringCategory::ApiCall => write!(f, "API Call"),
            StringCategory::Command => write!(f, "Command"),
            StringCategory::Url => write!(f, "URL"),
            StringCategory::Registry => write!(f, "Registry"),
            StringCategory::FilePath => write!(f, "File Path"),
            StringCategory::CryptoConstant => write!(f, "Crypto Constant"),
            StringCategory::DebugString => write!(f, "Debug String"),
            StringCategory::Credential => write!(f, "Credential"),
            StringCategory::NetworkIndicator => write!(f, "Network Indicator"),
        }
    }
}

/// Known suspicious string patterns
const SUSPICIOUS_STRINGS: &[(&str, &str, &str, u8)] = &[
    // API Calls (name, reason, category, risk_score)
    ("VirtualAlloc", "Memory allocation API often used for shellcode", "api_call", 7),
    ("VirtualAllocEx", "Remote memory allocation (injection)", "api_call", 9),
    ("VirtualProtect", "Memory protection change (make executable)", "api_call", 8),
    ("WriteProcessMemory", "Write to remote process (injection)", "api_call", 9),
    ("CreateRemoteThread", "Remote thread creation (injection)", "api_call", 10),
    ("NtCreateThreadEx", "Native thread creation", "api_call", 9),
    ("LoadLibrary", "DLL loading", "api_call", 6),
    ("GetProcAddress", "API resolution", "api_call", 5),
    ("ShellExecute", "Command execution", "api_call", 7),
    ("WinExec", "Command execution", "api_call", 7),
    ("CreateProcess", "Process creation", "api_call", 6),
    ("OpenProcess", "Process handle acquisition", "api_call", 7),
    ("NtUnmapViewOfSection", "Process hollowing indicator", "api_call", 10),
    ("SetThreadContext", "Thread context modification", "api_call", 9),
    ("QueueUserAPC", "APC injection", "api_call", 9),
    ("RegSetValueEx", "Registry modification", "api_call", 6),
    ("CryptEncrypt", "Encryption API", "api_call", 5),
    ("CryptDecrypt", "Decryption API", "api_call", 5),
    ("InternetOpen", "Network initialization", "api_call", 6),
    ("HttpOpenRequest", "HTTP communication", "api_call", 6),
    ("WSAStartup", "Socket initialization", "api_call", 5),

    // Command Strings
    ("cmd.exe", "Command shell reference", "command", 6),
    ("powershell", "PowerShell reference", "command", 7),
    ("cmd /c", "Command execution", "command", 7),
    ("powershell -enc", "Encoded PowerShell", "command", 9),
    ("powershell -e", "Encoded PowerShell", "command", 9),
    ("-ExecutionPolicy Bypass", "Policy bypass", "command", 8),
    ("Invoke-Expression", "PowerShell execution", "command", 8),
    ("IEX", "PowerShell IEX alias", "command", 7),
    ("Invoke-WebRequest", "Download indicator", "command", 7),
    ("wget", "Download utility", "command", 5),
    ("curl", "Download utility", "command", 5),
    ("certutil", "LOLBin download", "command", 8),
    ("bitsadmin", "LOLBin download", "command", 8),
    ("mshta", "LOLBin execution", "command", 8),
    ("wscript", "Script host", "command", 6),
    ("cscript", "Script host", "command", 6),
    ("regsvr32", "LOLBin execution", "command", 7),
    ("rundll32", "LOLBin execution", "command", 7),

    // Registry Paths
    ("HKEY_LOCAL_MACHINE", "Registry access", "registry", 4),
    ("HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run", "Persistence location", "registry", 8),
    ("HKCU\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run", "Persistence location", "registry", 8),
    ("CurrentVersion\\RunOnce", "Persistence location", "registry", 8),

    // File Paths
    ("\\Windows\\Temp", "Temp directory", "file_path", 5),
    ("\\AppData\\Local\\Temp", "User temp directory", "file_path", 4),
    ("\\System32\\", "System directory", "file_path", 4),
    (".exe", "Executable extension", "file_path", 3),
    (".dll", "DLL extension", "file_path", 3),
    (".bat", "Batch file", "file_path", 5),
    (".ps1", "PowerShell script", "file_path", 6),
    (".vbs", "VBScript file", "file_path", 6),

    // Network Indicators
    ("http://", "HTTP URL", "network", 4),
    ("https://", "HTTPS URL", "network", 3),
    ("/c2/", "C2 path indicator", "network", 8),
    ("/beacon/", "Beacon path indicator", "network", 8),
    (":4444", "Common Metasploit port", "network", 7),
    (":8080", "Common proxy/C2 port", "network", 5),
    (":443", "HTTPS port", "network", 3),

    // Debug/Development Strings
    ("DEBUG", "Debug string", "debug", 3),
    ("TODO", "Development artifact", "debug", 2),
    ("FIXME", "Development artifact", "debug", 2),
    ("password", "Credential keyword", "credential", 6),
    ("username", "Credential keyword", "credential", 5),
    ("login", "Authentication keyword", "credential", 4),
    ("secret", "Sensitive keyword", "credential", 6),
    ("token", "Authentication token", "credential", 5),
];

/// Known suspicious API combinations
const SUSPICIOUS_API_COMBOS: &[(&[&str], &str, Option<&str>)] = &[
    // (APIs, what it suggests, MITRE ID)
    (
        &["VirtualAlloc", "VirtualProtect", "CreateThread"],
        "Shellcode execution pattern",
        Some("T1055"),
    ),
    (
        &["OpenProcess", "VirtualAllocEx", "WriteProcessMemory", "CreateRemoteThread"],
        "Classic DLL/shellcode injection",
        Some("T1055.001"),
    ),
    (
        &["CreateProcess", "NtUnmapViewOfSection", "VirtualAllocEx", "WriteProcessMemory"],
        "Process hollowing pattern",
        Some("T1055.012"),
    ),
    (
        &["OpenProcess", "VirtualAllocEx", "WriteProcessMemory", "QueueUserAPC"],
        "APC injection pattern",
        Some("T1055.004"),
    ),
    (
        &["NtCreateThreadEx", "RtlCreateUserThread"],
        "Alternative thread creation (evasion)",
        Some("T1055"),
    ),
    (
        &["VirtualAlloc", "memcpy", "VirtualProtect"],
        "Shellcode copy and execute",
        Some("T1055"),
    ),
    (
        &["GetProcAddress", "LoadLibrary"],
        "Dynamic API resolution",
        Some("T1106"),
    ),
    (
        &["CryptAcquireContext", "CryptEncrypt"],
        "Encryption capability (potential ransomware)",
        Some("T1486"),
    ),
    (
        &["FindFirstFile", "FindNextFile", "MoveFile"],
        "File enumeration and manipulation",
        None,
    ),
    (
        &["RegOpenKeyEx", "RegSetValueEx"],
        "Registry modification",
        Some("T1112"),
    ),
    (
        &["socket", "connect", "send", "recv"],
        "Network communication",
        Some("T1095"),
    ),
    (
        &["CreateMutex", "OpenMutex"],
        "Mutex creation (single instance check)",
        None,
    ),
    (
        &["GetAsyncKeyState", "SetWindowsHookEx"],
        "Keylogging capability",
        Some("T1056.001"),
    ),
    (
        &["OpenClipboard", "GetClipboardData"],
        "Clipboard access",
        Some("T1115"),
    ),
    (
        &["BitBlt", "GetDC", "CreateCompatibleDC"],
        "Screen capture capability",
        Some("T1113"),
    ),
];

/// Known suspicious byte patterns
const SUSPICIOUS_PATTERNS: &[(&str, &str, &[u8], Option<&str>)] = &[
    // (name, description, pattern, MITRE ID)
    (
        "MZ Header",
        "DOS executable header",
        b"MZ",
        None,
    ),
    (
        "PE Signature",
        "PE executable signature",
        b"PE\x00\x00",
        None,
    ),
    (
        "Metasploit NOP Sled",
        "Common Metasploit NOP sled pattern",
        &[0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90],
        Some("T1055"),
    ),
    (
        "x64 Shellcode Prologue",
        "Common x64 shellcode start",
        &[0x48, 0x31, 0xC0],  // xor rax, rax
        Some("T1055"),
    ),
    (
        "x86 Shellcode Prologue",
        "Common x86 shellcode start",
        &[0x31, 0xC0],  // xor eax, eax
        Some("T1055"),
    ),
    (
        "GetPC Technique",
        "Position-independent code pattern",
        &[0xE8, 0x00, 0x00, 0x00, 0x00, 0x58],  // call $+5; pop eax
        Some("T1055"),
    ),
    (
        "Cobalt Strike Sleep Mask",
        "Known CS artifact",
        &[0x4C, 0x8B, 0xD1, 0xB8],
        Some("T1055"),
    ),
];

// ============================================================================
// Payload Analysis Functions
// ============================================================================

/// Perform comprehensive payload analysis
pub fn analyze_payload(payload: &[u8]) -> PayloadAnalysisResult {
    use sha2::{Sha256, Digest};
    let mut hasher = Sha256::new();
    hasher.update(payload);
    let payload_hash = format!("{:x}", hasher.finalize());

    // Entropy analysis
    let entropy = analyze_entropy(payload);

    // String extraction and analysis
    let suspicious_strings = extract_suspicious_strings(payload);

    // Pattern detection
    let suspicious_patterns = detect_suspicious_patterns(payload);

    // API analysis (from extracted strings)
    let api_analysis = analyze_api_usage(&suspicious_strings);

    // Calculate overall risk score
    let risk_score = calculate_risk_score(&entropy, &suspicious_strings, &suspicious_patterns, &api_analysis);

    // Determine detection risk level
    let detection_risk = if risk_score >= 80 {
        DetectionRisk::Critical
    } else if risk_score >= 60 {
        DetectionRisk::High
    } else if risk_score >= 40 {
        DetectionRisk::Medium
    } else {
        DetectionRisk::Low
    };

    // Generate recommendations
    let recommendations = generate_recommendations(&entropy, &suspicious_strings, &suspicious_patterns, risk_score);

    PayloadAnalysisResult {
        id: Uuid::new_v4().to_string(),
        payload_hash,
        detection_risk,
        risk_score,
        entropy,
        suspicious_strings,
        suspicious_patterns,
        api_analysis: Some(api_analysis),
        recommendations,
        timestamp: Utc::now(),
    }
}

/// Analyze payload entropy
pub fn analyze_entropy(data: &[u8]) -> EntropyAnalysis {
    let overall_entropy = calculate_entropy(data);

    // Analyze entropy in chunks to find high-entropy sections
    let chunk_size = 256;
    let mut high_entropy_sections = Vec::new();

    for (i, chunk) in data.chunks(chunk_size).enumerate() {
        let chunk_entropy = calculate_entropy(chunk);

        // Entropy > 7.0 is suspicious (random/encrypted data)
        if chunk_entropy > 7.0 && chunk.len() >= 64 {
            let interpretation = if chunk_entropy > 7.9 {
                "Likely encrypted or compressed data".to_string()
            } else if chunk_entropy > 7.5 {
                "Possibly packed or encrypted".to_string()
            } else {
                "High entropy section (encoded data?)".to_string()
            };

            high_entropy_sections.push(EntropySection {
                offset: i * chunk_size,
                length: chunk.len(),
                entropy: chunk_entropy,
                interpretation,
            });
        }
    }

    let has_high_entropy_sections = !high_entropy_sections.is_empty();

    let assessment = if overall_entropy > 7.5 {
        "Very high entropy indicates encryption, packing, or compression. This is suspicious for executable code."
    } else if overall_entropy > 7.0 {
        "High entropy suggests some sections may be encrypted or compressed."
    } else if overall_entropy > 6.0 {
        "Moderate entropy - typical of compiled code with some data sections."
    } else if overall_entropy > 4.0 {
        "Normal entropy for executable code."
    } else {
        "Low entropy - possibly contains large amounts of null bytes or repeated data."
    };

    EntropyAnalysis {
        overall_entropy,
        has_high_entropy_sections,
        high_entropy_sections,
        assessment: assessment.to_string(),
    }
}

/// Extract and analyze suspicious strings from payload
pub fn extract_suspicious_strings(data: &[u8]) -> Vec<SuspiciousString> {
    let mut suspicious = Vec::new();

    // Extract ASCII strings (minimum 4 characters)
    let ascii_strings = extract_ascii_strings(data, 4);

    // Extract Unicode strings (minimum 4 characters)
    let unicode_strings = extract_unicode_strings(data, 4);

    let all_strings: Vec<(String, Option<usize>)> = ascii_strings
        .into_iter()
        .chain(unicode_strings.into_iter())
        .collect();

    for (string, offset) in all_strings {
        // Check against known suspicious patterns
        for (pattern, reason, category, risk) in SUSPICIOUS_STRINGS {
            if string.to_lowercase().contains(&pattern.to_lowercase()) {
                suspicious.push(SuspiciousString {
                    value: string.clone(),
                    reason: reason.to_string(),
                    category: category.to_string(),
                    risk_score: *risk,
                    offset,
                });
                break; // Only match once per string
            }
        }
    }

    // Sort by risk score (highest first)
    suspicious.sort_by(|a, b| b.risk_score.cmp(&a.risk_score));

    // Deduplicate
    suspicious.dedup_by(|a, b| a.value == b.value);

    suspicious
}

/// Extract ASCII strings from binary data
fn extract_ascii_strings(data: &[u8], min_length: usize) -> Vec<(String, Option<usize>)> {
    let mut strings = Vec::new();
    let mut current_string = String::new();
    let mut start_offset = 0;

    for (i, &byte) in data.iter().enumerate() {
        if byte.is_ascii_graphic() || byte == b' ' {
            if current_string.is_empty() {
                start_offset = i;
            }
            current_string.push(byte as char);
        } else {
            if current_string.len() >= min_length {
                strings.push((current_string.clone(), Some(start_offset)));
            }
            current_string.clear();
        }
    }

    // Don't forget the last string
    if current_string.len() >= min_length {
        strings.push((current_string, Some(start_offset)));
    }

    strings
}

/// Extract Unicode (UTF-16LE) strings from binary data
fn extract_unicode_strings(data: &[u8], min_length: usize) -> Vec<(String, Option<usize>)> {
    let mut strings = Vec::new();
    let mut current_chars = Vec::new();
    let mut start_offset = 0;

    let mut i = 0;
    while i + 1 < data.len() {
        let char_code = u16::from_le_bytes([data[i], data[i + 1]]);

        if (0x20..=0x7E).contains(&char_code) || char_code == 0x0020 {
            if current_chars.is_empty() {
                start_offset = i;
            }
            current_chars.push(char_code as u8 as char);
        } else {
            if current_chars.len() >= min_length {
                strings.push((current_chars.iter().collect(), Some(start_offset)));
            }
            current_chars.clear();
        }

        i += 2;
    }

    if current_chars.len() >= min_length {
        strings.push((current_chars.iter().collect(), Some(start_offset)));
    }

    strings
}

/// Detect suspicious byte patterns in payload
pub fn detect_suspicious_patterns(data: &[u8]) -> Vec<SuspiciousPattern> {
    let mut patterns = Vec::new();

    for (name, description, pattern, mitre_id) in SUSPICIOUS_PATTERNS {
        if let Some(offset) = find_pattern(data, pattern) {
            patterns.push(SuspiciousPattern {
                name: name.to_string(),
                description: description.to_string(),
                category: "byte_pattern".to_string(),
                risk_score: 7,
                mitre_id: mitre_id.map(|s| s.to_string()),
                matched_signature: Some(hex_encode(&data[offset..std::cmp::min(offset + 16, data.len())])),
            });
        }
    }

    // Check for long NOP sleds (more than 16 NOPs)
    if let Some(offset) = find_nop_sled(data, 16) {
        patterns.push(SuspiciousPattern {
            name: "Long NOP Sled".to_string(),
            description: "Extended NOP sled often precedes shellcode".to_string(),
            category: "shellcode_indicator".to_string(),
            risk_score: 8,
            mitre_id: Some("T1055".to_string()),
            matched_signature: Some(format!("NOP sled at offset 0x{:X}", offset)),
        });
    }

    // Check for XOR loops (common decryption stub)
    if has_xor_loop_pattern(data) {
        patterns.push(SuspiciousPattern {
            name: "XOR Decryption Loop".to_string(),
            description: "Pattern suggesting XOR decryption stub".to_string(),
            category: "decryption_stub".to_string(),
            risk_score: 7,
            mitre_id: Some("T1140".to_string()),
            matched_signature: None,
        });
    }

    patterns
}

/// Find a byte pattern in data
fn find_pattern(data: &[u8], pattern: &[u8]) -> Option<usize> {
    data.windows(pattern.len())
        .position(|window| window == pattern)
}

/// Find a NOP sled of minimum length
fn find_nop_sled(data: &[u8], min_length: usize) -> Option<usize> {
    let mut count = 0;
    let mut start = 0;

    for (i, &byte) in data.iter().enumerate() {
        if byte == 0x90 {
            if count == 0 {
                start = i;
            }
            count += 1;
            if count >= min_length {
                return Some(start);
            }
        } else {
            count = 0;
        }
    }

    None
}

/// Check for XOR loop pattern
fn has_xor_loop_pattern(data: &[u8]) -> bool {
    // Look for common XOR loop patterns:
    // xor [reg], byte  followed by inc/add and loop/jmp
    let xor_patterns: &[[u8; 2]] = &[
        [0x30, 0x00], // xor [rax], al (placeholder)
        [0x31, 0x00], // xor [rax], eax (placeholder)
        [0x32, 0x00], // xor al, [rax] (placeholder)
        [0x33, 0x00], // xor eax, [rax] (placeholder)
        [0x80, 0x30], // xor byte [rax], imm8
        [0x80, 0x31], // xor byte [rcx], imm8
    ];

    for window in data.windows(10) {
        // Check if window contains XOR followed by loop control
        for pattern in xor_patterns {
            if window[0] == pattern[0] && (pattern[1] == 0x00 || window[1] == pattern[1]) {
                // Look for loop control nearby
                for &byte in &window[2..] {
                    if byte == 0xE2  // loop
                        || byte == 0xE0  // loopne
                        || byte == 0xE1  // loope
                        || byte == 0xEB  // jmp short
                        || byte == 0x75  // jnz
                        || byte == 0x74  // jz
                    {
                        return true;
                    }
                }
            }
        }
    }

    false
}

/// Hex encode bytes
fn hex_encode(data: &[u8]) -> String {
    data.iter().map(|b| format!("{:02X}", b)).collect::<Vec<_>>().join(" ")
}

/// Analyze API usage patterns
pub fn analyze_api_usage(suspicious_strings: &[SuspiciousString]) -> ApiAnalysis {
    // Extract API names from suspicious strings
    let api_strings: Vec<&str> = suspicious_strings
        .iter()
        .filter(|s| s.category == "api_call")
        .map(|s| s.value.as_str())
        .collect();

    // Check for suspicious API combinations
    let mut api_combinations = Vec::new();

    for (combo_apis, suggests, mitre_id) in SUSPICIOUS_API_COMBOS {
        let matching_count = combo_apis
            .iter()
            .filter(|api| api_strings.iter().any(|s| s.contains(*api)))
            .count();

        // If we have at least half of the combo APIs, flag it
        if matching_count >= (combo_apis.len() + 1) / 2 && matching_count >= 2 {
            api_combinations.push(ApiCombination {
                apis: combo_apis.iter().map(|s| s.to_string()).collect(),
                suggests: suggests.to_string(),
                mitre_id: mitre_id.map(|s| s.to_string()),
            });
        }
    }

    let assessment = if api_combinations.is_empty() && api_strings.is_empty() {
        "No suspicious API patterns detected".to_string()
    } else if api_combinations.len() >= 2 {
        "Multiple suspicious API combinations detected - high likelihood of malicious activity".to_string()
    } else if !api_combinations.is_empty() {
        format!("Suspicious API pattern detected: {}", api_combinations[0].suggests)
    } else {
        format!("{} suspicious API calls detected", api_strings.len())
    };

    ApiAnalysis {
        suspicious_apis: api_strings.iter().map(|s| s.to_string()).collect(),
        api_combinations,
        assessment,
    }
}

/// Calculate overall risk score
fn calculate_risk_score(
    entropy: &EntropyAnalysis,
    strings: &[SuspiciousString],
    patterns: &[SuspiciousPattern],
    api_analysis: &ApiAnalysis,
) -> u8 {
    let mut score: f64 = 0.0;

    // Entropy contribution (0-20 points)
    if entropy.overall_entropy > 7.5 {
        score += 20.0;
    } else if entropy.overall_entropy > 7.0 {
        score += 15.0;
    } else if entropy.has_high_entropy_sections {
        score += 10.0;
    }

    // Suspicious strings contribution (0-40 points)
    let string_score: u32 = strings.iter().map(|s| s.risk_score as u32).sum();
    score += (string_score as f64).min(40.0);

    // Pattern contribution (0-25 points)
    let pattern_score: u32 = patterns.iter().map(|p| p.risk_score as u32).sum();
    score += (pattern_score as f64).min(25.0);

    // API combination contribution (0-15 points)
    score += (api_analysis.api_combinations.len() as f64 * 5.0).min(15.0);

    std::cmp::min(score as u8, 100)
}

/// Generate recommendations based on analysis
fn generate_recommendations(
    entropy: &EntropyAnalysis,
    strings: &[SuspiciousString],
    patterns: &[SuspiciousPattern],
    risk_score: u8,
) -> Vec<String> {
    let mut recommendations = Vec::new();

    if entropy.overall_entropy < 6.0 {
        recommendations.push("Consider encrypting payload sections to increase entropy and avoid signature detection".to_string());
    }

    if strings.iter().any(|s| s.category == "api_call" && s.risk_score >= 8) {
        recommendations.push("Use dynamic API resolution (GetProcAddress with obfuscated names) to hide API calls".to_string());
    }

    if strings.iter().any(|s| s.category == "command") {
        recommendations.push("Obfuscate command strings using encoding or string concatenation".to_string());
    }

    if patterns.iter().any(|p| p.name.contains("NOP")) {
        recommendations.push("Replace NOP sleds with random junk instructions or dead code".to_string());
    }

    if patterns.iter().any(|p| p.name.contains("Shellcode")) {
        recommendations.push("Use shellcode encoder or polymorphic engine to modify shellcode signature".to_string());
    }

    if entropy.has_high_entropy_sections {
        recommendations.push("Consider using staged payload to avoid having encrypted blob detected".to_string());
    }

    if risk_score >= 60 {
        recommendations.push("Test payload against target AV/EDR before deployment".to_string());
        recommendations.push("Consider using fileless techniques to avoid disk-based detection".to_string());
    }

    if risk_score >= 80 {
        recommendations.push("Payload has high detection risk - significant modifications recommended".to_string());
        recommendations.push("Consider process hollowing or other memory-only execution techniques".to_string());
    }

    if recommendations.is_empty() {
        recommendations.push("Payload has relatively low detection indicators".to_string());
    }

    recommendations
}

// ============================================================================
// VirusTotal-Style Local Heuristic Scoring
// ============================================================================

/// Heuristic detection result (similar to AV verdict)
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct HeuristicResult {
    pub engine_name: String,
    pub verdict: String,
    pub confidence: u8,
    pub details: Option<String>,
}

/// Run local heuristic analysis (simulating multiple AV engines)
pub fn run_heuristic_analysis(data: &[u8]) -> Vec<HeuristicResult> {
    let mut results = Vec::new();
    let analysis = analyze_payload(data);

    // Entropy-based heuristic
    results.push(HeuristicResult {
        engine_name: "EntropyAnalyzer".to_string(),
        verdict: if analysis.entropy.overall_entropy > 7.5 {
            "Suspicious.Packed".to_string()
        } else if analysis.entropy.overall_entropy > 7.0 {
            "Heuristic.HighEntropy".to_string()
        } else {
            "Clean".to_string()
        },
        confidence: if analysis.entropy.overall_entropy > 7.5 { 85 } else if analysis.entropy.overall_entropy > 7.0 { 60 } else { 10 },
        details: Some(format!("Entropy: {:.2}", analysis.entropy.overall_entropy)),
    });

    // String-based heuristic
    let high_risk_strings = analysis.suspicious_strings.iter().filter(|s| s.risk_score >= 8).count();
    results.push(HeuristicResult {
        engine_name: "StringAnalyzer".to_string(),
        verdict: if high_risk_strings >= 5 {
            "Trojan.Generic".to_string()
        } else if high_risk_strings >= 2 {
            "Suspicious.Strings".to_string()
        } else {
            "Clean".to_string()
        },
        confidence: std::cmp::min(high_risk_strings as u8 * 15, 90),
        details: Some(format!("{} high-risk strings detected", high_risk_strings)),
    });

    // Pattern-based heuristic
    let shellcode_patterns = analysis.suspicious_patterns.iter()
        .filter(|p| p.category == "shellcode_indicator" || p.name.contains("Shellcode"))
        .count();
    results.push(HeuristicResult {
        engine_name: "ShellcodeDetector".to_string(),
        verdict: if shellcode_patterns >= 2 {
            "Shellcode.Generic".to_string()
        } else if shellcode_patterns == 1 {
            "Heuristic.Shellcode".to_string()
        } else {
            "Clean".to_string()
        },
        confidence: std::cmp::min(shellcode_patterns as u8 * 40, 95),
        details: Some(format!("{} shellcode indicators", shellcode_patterns)),
    });

    // API-based heuristic
    if let Some(ref api) = analysis.api_analysis {
        let injection_combos = api.api_combinations.iter()
            .filter(|c| c.suggests.contains("injection") || c.suggests.contains("hollowing"))
            .count();
        results.push(HeuristicResult {
            engine_name: "BehaviorAnalyzer".to_string(),
            verdict: if injection_combos >= 2 {
                "Trojan.Injector".to_string()
            } else if injection_combos == 1 {
                "Heuristic.ProcessInjection".to_string()
            } else if !api.suspicious_apis.is_empty() {
                "Suspicious.APIs".to_string()
            } else {
                "Clean".to_string()
            },
            confidence: std::cmp::min(injection_combos as u8 * 35 + api.suspicious_apis.len() as u8 * 3, 95),
            details: Some(format!("{} suspicious API combinations", injection_combos)),
        });
    }

    // Overall heuristic
    results.push(HeuristicResult {
        engine_name: "HeroForge.Heuristic".to_string(),
        verdict: match analysis.risk_score {
            80..=100 => "Malware.Generic".to_string(),
            60..=79 => "Suspicious.High".to_string(),
            40..=59 => "Suspicious.Medium".to_string(),
            20..=39 => "PUP.Possible".to_string(),
            _ => "Clean".to_string(),
        },
        confidence: analysis.risk_score,
        details: Some(format!("Overall risk score: {}/100", analysis.risk_score)),
    });

    results
}

/// Get summary of heuristic analysis
pub fn get_heuristic_summary(results: &[HeuristicResult]) -> HashMap<String, serde_json::Value> {
    let mut summary = HashMap::new();

    let detections = results.iter().filter(|r| r.verdict != "Clean").count();
    let total = results.len();
    let detection_rate = (detections as f64 / total as f64 * 100.0) as u8;

    summary.insert("total_engines".to_string(), serde_json::json!(total));
    summary.insert("detections".to_string(), serde_json::json!(detections));
    summary.insert("detection_rate".to_string(), serde_json::json!(format!("{}%", detection_rate)));
    summary.insert("risk_level".to_string(), serde_json::json!(
        if detection_rate >= 80 { "Critical" }
        else if detection_rate >= 50 { "High" }
        else if detection_rate >= 20 { "Medium" }
        else { "Low" }
    ));

    let verdicts: Vec<_> = results.iter()
        .filter(|r| r.verdict != "Clean")
        .map(|r| format!("{}: {}", r.engine_name, r.verdict))
        .collect();
    summary.insert("verdicts".to_string(), serde_json::json!(verdicts));

    summary
}
