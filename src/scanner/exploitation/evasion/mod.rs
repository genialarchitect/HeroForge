// AV/EDR Evasion Analysis Framework
// Provides techniques for understanding and analyzing evasion methods
// For educational and authorized penetration testing purposes only

#![allow(dead_code)]

pub mod signature;
pub mod behavior;
pub mod analysis;

use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

// ============================================================================
// Core Evasion Enums and Types
// ============================================================================

/// Detection risk level for analyzed payloads
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, PartialOrd, Ord)]
#[serde(rename_all = "snake_case")]
pub enum DetectionRisk {
    /// Low risk - unlikely to trigger AV/EDR
    Low,
    /// Medium risk - may trigger some AV products
    Medium,
    /// High risk - likely to trigger most AV products
    High,
    /// Critical risk - will almost certainly be detected
    Critical,
}

impl std::fmt::Display for DetectionRisk {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            DetectionRisk::Low => write!(f, "Low"),
            DetectionRisk::Medium => write!(f, "Medium"),
            DetectionRisk::High => write!(f, "High"),
            DetectionRisk::Critical => write!(f, "Critical"),
        }
    }
}

/// Categories of evasion techniques
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]
#[serde(rename_all = "snake_case")]
pub enum EvasionCategory {
    /// Signature-based evasion (string obfuscation, encoding)
    Signature,
    /// Behavioral evasion (sandbox detection, timing)
    Behavioral,
    /// Memory-based evasion (process hollowing, injection)
    Memory,
    /// Network-based evasion (encrypted channels, domain fronting)
    Network,
    /// File-based evasion (alternate data streams, file metadata)
    FileBased,
}

impl std::fmt::Display for EvasionCategory {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            EvasionCategory::Signature => write!(f, "Signature"),
            EvasionCategory::Behavioral => write!(f, "Behavioral"),
            EvasionCategory::Memory => write!(f, "Memory"),
            EvasionCategory::Network => write!(f, "Network"),
            EvasionCategory::FileBased => write!(f, "File-Based"),
        }
    }
}

/// Individual evasion techniques
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]
#[serde(rename_all = "snake_case")]
pub enum EvasionTechnique {
    // Signature Evasion
    /// XOR encoding of strings and data
    XorEncoding,
    /// Base64 encoding with custom alphabets
    Base64Obfuscation,
    /// String concatenation to avoid static signatures
    StringConcatenation,
    /// Dead code insertion to change binary hash
    DeadCodeInsertion,
    /// API name obfuscation (GetProcAddress patterns)
    ApiObfuscation,
    /// Import Address Table manipulation
    IatManipulation,
    /// Custom encryption of payload sections
    PayloadEncryption,
    /// Code morphing/polymorphism
    Polymorphism,

    // Behavioral Evasion
    /// Check for sandbox indicators (VM detection)
    SandboxDetection,
    /// Time-based evasion (sleep, time delays)
    TimingEvasion,
    /// User interaction detection (mouse movement, keystrokes)
    UserInteractionCheck,
    /// Check for analysis tools (debuggers, monitors)
    AnalysisToolDetection,
    /// Check for insufficient system resources (CPU, RAM)
    ResourceCheck,
    /// Domain/hostname validation
    EnvironmentValidation,

    // Memory Evasion
    /// Process hollowing technique documentation
    ProcessHollowing,
    /// DLL injection technique documentation
    DllInjection,
    /// Thread execution hijacking documentation
    ThreadHijacking,
    /// Direct syscall invocation documentation
    DirectSyscalls,
    /// NTDLL unhooking technique documentation
    NtdllUnhooking,
    /// Memory-only execution (fileless)
    FilelessExecution,

    // Network Evasion
    /// Encrypted C2 channels
    EncryptedC2,
    /// Domain fronting technique
    DomainFronting,
    /// DNS tunneling
    DnsTunneling,
    /// Traffic mimicry (HTTPS as normal traffic)
    TrafficMimicry,

    // File-Based Evasion
    /// Alternate Data Streams (Windows)
    AlternateDataStreams,
    /// File metadata manipulation
    MetadataManipulation,
    /// File extension spoofing
    ExtensionSpoofing,
    /// Timestomping
    Timestomping,
}

impl EvasionTechnique {
    /// Get the category for this technique
    pub fn category(&self) -> EvasionCategory {
        match self {
            EvasionTechnique::XorEncoding
            | EvasionTechnique::Base64Obfuscation
            | EvasionTechnique::StringConcatenation
            | EvasionTechnique::DeadCodeInsertion
            | EvasionTechnique::ApiObfuscation
            | EvasionTechnique::IatManipulation
            | EvasionTechnique::PayloadEncryption
            | EvasionTechnique::Polymorphism => EvasionCategory::Signature,

            EvasionTechnique::SandboxDetection
            | EvasionTechnique::TimingEvasion
            | EvasionTechnique::UserInteractionCheck
            | EvasionTechnique::AnalysisToolDetection
            | EvasionTechnique::ResourceCheck
            | EvasionTechnique::EnvironmentValidation => EvasionCategory::Behavioral,

            EvasionTechnique::ProcessHollowing
            | EvasionTechnique::DllInjection
            | EvasionTechnique::ThreadHijacking
            | EvasionTechnique::DirectSyscalls
            | EvasionTechnique::NtdllUnhooking
            | EvasionTechnique::FilelessExecution => EvasionCategory::Memory,

            EvasionTechnique::EncryptedC2
            | EvasionTechnique::DomainFronting
            | EvasionTechnique::DnsTunneling
            | EvasionTechnique::TrafficMimicry => EvasionCategory::Network,

            EvasionTechnique::AlternateDataStreams
            | EvasionTechnique::MetadataManipulation
            | EvasionTechnique::ExtensionSpoofing
            | EvasionTechnique::Timestomping => EvasionCategory::FileBased,
        }
    }

    /// Get description of the technique
    pub fn description(&self) -> &'static str {
        match self {
            EvasionTechnique::XorEncoding => "XOR encoding of strings and data to avoid signature detection",
            EvasionTechnique::Base64Obfuscation => "Base64 encoding with optional custom alphabets",
            EvasionTechnique::StringConcatenation => "Break strings into concatenated parts to avoid static signatures",
            EvasionTechnique::DeadCodeInsertion => "Insert non-functional code to change binary hash",
            EvasionTechnique::ApiObfuscation => "Obfuscate API calls using GetProcAddress or dynamic resolution",
            EvasionTechnique::IatManipulation => "Manipulate Import Address Table to hide API usage",
            EvasionTechnique::PayloadEncryption => "Encrypt payload sections with runtime decryption",
            EvasionTechnique::Polymorphism => "Generate varying code that performs the same function",

            EvasionTechnique::SandboxDetection => "Detect sandbox/VM environment indicators",
            EvasionTechnique::TimingEvasion => "Use time delays to evade sandbox time limits",
            EvasionTechnique::UserInteractionCheck => "Verify real user presence (mouse, keyboard)",
            EvasionTechnique::AnalysisToolDetection => "Detect debuggers and analysis tools",
            EvasionTechnique::ResourceCheck => "Verify sufficient system resources (sandbox detection)",
            EvasionTechnique::EnvironmentValidation => "Validate domain, hostname, or other environment factors",

            EvasionTechnique::ProcessHollowing => "Documentation: Replace legitimate process memory with malicious code",
            EvasionTechnique::DllInjection => "Documentation: Inject DLL into another process address space",
            EvasionTechnique::ThreadHijacking => "Documentation: Hijack thread execution in another process",
            EvasionTechnique::DirectSyscalls => "Documentation: Bypass user-mode hooks via direct syscalls",
            EvasionTechnique::NtdllUnhooking => "Documentation: Remove EDR hooks from ntdll.dll",
            EvasionTechnique::FilelessExecution => "Documentation: Execute payload entirely in memory",

            EvasionTechnique::EncryptedC2 => "Use encrypted channels for command and control",
            EvasionTechnique::DomainFronting => "Hide C2 traffic behind legitimate CDN domains",
            EvasionTechnique::DnsTunneling => "Exfiltrate data via DNS queries",
            EvasionTechnique::TrafficMimicry => "Mimic legitimate HTTPS traffic patterns",

            EvasionTechnique::AlternateDataStreams => "Hide data in Windows Alternate Data Streams",
            EvasionTechnique::MetadataManipulation => "Modify file metadata to appear legitimate",
            EvasionTechnique::ExtensionSpoofing => "Use misleading file extensions",
            EvasionTechnique::Timestomping => "Modify file timestamps to avoid detection",
        }
    }

    /// Get MITRE ATT&CK technique ID if applicable
    pub fn mitre_id(&self) -> Option<&'static str> {
        match self {
            EvasionTechnique::XorEncoding | EvasionTechnique::Base64Obfuscation => Some("T1027"),
            EvasionTechnique::DeadCodeInsertion | EvasionTechnique::Polymorphism => Some("T1027.005"),
            EvasionTechnique::SandboxDetection => Some("T1497"),
            EvasionTechnique::TimingEvasion => Some("T1497.003"),
            EvasionTechnique::ProcessHollowing => Some("T1055.012"),
            EvasionTechnique::DllInjection => Some("T1055.001"),
            EvasionTechnique::DirectSyscalls => Some("T1106"),
            EvasionTechnique::DomainFronting => Some("T1090.004"),
            EvasionTechnique::DnsTunneling => Some("T1048.003"),
            EvasionTechnique::AlternateDataStreams => Some("T1564.004"),
            EvasionTechnique::Timestomping => Some("T1070.006"),
            _ => None,
        }
    }

    /// Get detection difficulty (higher = harder to detect)
    pub fn detection_difficulty(&self) -> u8 {
        match self {
            EvasionTechnique::Base64Obfuscation => 2,
            EvasionTechnique::XorEncoding => 3,
            EvasionTechnique::StringConcatenation => 4,
            EvasionTechnique::DeadCodeInsertion => 5,
            EvasionTechnique::ApiObfuscation => 6,
            EvasionTechnique::PayloadEncryption => 7,
            EvasionTechnique::Polymorphism => 8,
            EvasionTechnique::SandboxDetection => 5,
            EvasionTechnique::TimingEvasion => 4,
            EvasionTechnique::DirectSyscalls => 9,
            EvasionTechnique::NtdllUnhooking => 9,
            EvasionTechnique::FilelessExecution => 8,
            EvasionTechnique::DomainFronting => 7,
            _ => 5,
        }
    }
}

// ============================================================================
// Evasion Profile - Collection of Techniques
// ============================================================================

/// A profile containing a set of evasion techniques
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EvasionProfile {
    /// Profile name
    pub name: String,
    /// Description of the profile
    pub description: String,
    /// Techniques included in this profile
    pub techniques: Vec<EvasionTechnique>,
    /// Target platform (Windows, Linux, etc.)
    pub target_platform: String,
    /// Estimated detection risk when using this profile
    pub estimated_risk: DetectionRisk,
    /// MITRE ATT&CK technique IDs covered
    pub mitre_techniques: Vec<String>,
}

impl EvasionProfile {
    /// Create a new evasion profile
    pub fn new(name: &str, description: &str, techniques: Vec<EvasionTechnique>, platform: &str) -> Self {
        let mitre_techniques: Vec<String> = techniques
            .iter()
            .filter_map(|t| t.mitre_id().map(|s| s.to_string()))
            .collect();

        let avg_difficulty: f64 = if techniques.is_empty() {
            0.0
        } else {
            techniques.iter().map(|t| t.detection_difficulty() as f64).sum::<f64>() / techniques.len() as f64
        };

        let estimated_risk = if avg_difficulty >= 7.0 {
            DetectionRisk::Low
        } else if avg_difficulty >= 5.0 {
            DetectionRisk::Medium
        } else if avg_difficulty >= 3.0 {
            DetectionRisk::High
        } else {
            DetectionRisk::Critical
        };

        Self {
            name: name.to_string(),
            description: description.to_string(),
            techniques,
            target_platform: platform.to_string(),
            estimated_risk,
            mitre_techniques,
        }
    }

    /// Get predefined profiles
    pub fn predefined_profiles() -> Vec<EvasionProfile> {
        vec![
            EvasionProfile::new(
                "Basic",
                "Basic evasion techniques suitable for testing AV coverage",
                vec![
                    EvasionTechnique::XorEncoding,
                    EvasionTechnique::Base64Obfuscation,
                ],
                "Windows",
            ),
            EvasionProfile::new(
                "Intermediate",
                "Intermediate evasion with sandbox detection",
                vec![
                    EvasionTechnique::XorEncoding,
                    EvasionTechnique::StringConcatenation,
                    EvasionTechnique::SandboxDetection,
                    EvasionTechnique::TimingEvasion,
                    EvasionTechnique::ApiObfuscation,
                ],
                "Windows",
            ),
            EvasionProfile::new(
                "Advanced",
                "Advanced evasion techniques for EDR bypass testing",
                vec![
                    EvasionTechnique::PayloadEncryption,
                    EvasionTechnique::Polymorphism,
                    EvasionTechnique::SandboxDetection,
                    EvasionTechnique::AnalysisToolDetection,
                    EvasionTechnique::DirectSyscalls,
                    EvasionTechnique::FilelessExecution,
                ],
                "Windows",
            ),
            EvasionProfile::new(
                "Stealth",
                "Maximum stealth with multiple evasion layers",
                vec![
                    EvasionTechnique::PayloadEncryption,
                    EvasionTechnique::Polymorphism,
                    EvasionTechnique::SandboxDetection,
                    EvasionTechnique::TimingEvasion,
                    EvasionTechnique::UserInteractionCheck,
                    EvasionTechnique::AnalysisToolDetection,
                    EvasionTechnique::DirectSyscalls,
                    EvasionTechnique::NtdllUnhooking,
                    EvasionTechnique::EncryptedC2,
                ],
                "Windows",
            ),
        ]
    }
}

// ============================================================================
// Evasion Result Types
// ============================================================================

/// Result of applying evasion techniques
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EvasionResult {
    /// Unique identifier
    pub id: String,
    /// Techniques that were applied
    pub techniques_applied: Vec<EvasionTechnique>,
    /// Original payload hash (for comparison)
    pub original_hash: String,
    /// Modified payload hash (if payload was modified)
    pub modified_hash: Option<String>,
    /// Confidence level that evasion was successful (0-100)
    pub confidence: u8,
    /// Detection risk assessment
    pub detection_risk: DetectionRisk,
    /// Detailed artifacts and modifications made
    pub artifacts: Vec<EvasionArtifact>,
    /// Recommendations for improvement
    pub recommendations: Vec<String>,
    /// Timestamp
    pub timestamp: DateTime<Utc>,
}

/// Artifact from evasion technique application
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EvasionArtifact {
    /// Technique that produced this artifact
    pub technique: EvasionTechnique,
    /// Type of artifact (e.g., "encoded_string", "sandbox_check")
    pub artifact_type: String,
    /// Description of what was done
    pub description: String,
    /// Additional details
    pub details: HashMap<String, serde_json::Value>,
}

// ============================================================================
// Payload Analysis Types
// ============================================================================

/// Result of analyzing a payload for detection risk
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PayloadAnalysisResult {
    /// Unique identifier
    pub id: String,
    /// Hash of analyzed payload
    pub payload_hash: String,
    /// Overall detection risk
    pub detection_risk: DetectionRisk,
    /// Numeric risk score (0-100, higher = more likely to be detected)
    pub risk_score: u8,
    /// Entropy analysis result
    pub entropy: EntropyAnalysis,
    /// Suspicious strings found
    pub suspicious_strings: Vec<SuspiciousString>,
    /// Suspicious patterns found
    pub suspicious_patterns: Vec<SuspiciousPattern>,
    /// API/import analysis
    pub api_analysis: Option<ApiAnalysis>,
    /// Recommendations to reduce detection risk
    pub recommendations: Vec<String>,
    /// Timestamp
    pub timestamp: DateTime<Utc>,
}

/// Entropy analysis result
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EntropyAnalysis {
    /// Overall entropy (0.0-8.0, higher = more random)
    pub overall_entropy: f64,
    /// Whether high entropy sections were found (potential encryption/packing)
    pub has_high_entropy_sections: bool,
    /// Sections with notably high entropy
    pub high_entropy_sections: Vec<EntropySection>,
    /// Assessment of entropy findings
    pub assessment: String,
}

/// High entropy section in payload
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EntropySection {
    /// Offset in payload
    pub offset: usize,
    /// Length of section
    pub length: usize,
    /// Entropy value
    pub entropy: f64,
    /// Possible interpretation
    pub interpretation: String,
}

/// Suspicious string found in payload
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SuspiciousString {
    /// The string value
    pub value: String,
    /// Why it's suspicious
    pub reason: String,
    /// Category (api_call, command, url, etc.)
    pub category: String,
    /// Risk contribution (0-10)
    pub risk_score: u8,
    /// Offset in payload (if applicable)
    pub offset: Option<usize>,
}

/// Suspicious pattern found in payload
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SuspiciousPattern {
    /// Pattern name
    pub name: String,
    /// Description
    pub description: String,
    /// Category
    pub category: String,
    /// Risk contribution (0-10)
    pub risk_score: u8,
    /// MITRE ATT&CK ID if applicable
    pub mitre_id: Option<String>,
    /// Matched bytes/signature (hex)
    pub matched_signature: Option<String>,
}

/// API/Import analysis
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ApiAnalysis {
    /// Suspicious API calls found
    pub suspicious_apis: Vec<String>,
    /// Known malware-associated API combinations
    pub api_combinations: Vec<ApiCombination>,
    /// Assessment
    pub assessment: String,
}

/// Combination of APIs that suggest malicious intent
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ApiCombination {
    /// APIs in the combination
    pub apis: Vec<String>,
    /// What this combination suggests
    pub suggests: String,
    /// MITRE ATT&CK technique if applicable
    pub mitre_id: Option<String>,
}

// ============================================================================
// Sandbox Detection Types
// ============================================================================

/// Result of sandbox environment check
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SandboxCheckResult {
    /// Whether sandbox indicators were detected
    pub is_sandbox: bool,
    /// Confidence level (0-100)
    pub confidence: u8,
    /// Indicators found
    pub indicators: Vec<SandboxIndicator>,
    /// Environment details
    pub environment: HashMap<String, String>,
    /// Timestamp
    pub timestamp: DateTime<Utc>,
}

/// Individual sandbox indicator
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SandboxIndicator {
    /// Indicator name
    pub name: String,
    /// Category (vm, analysis_tool, network, timing, etc.)
    pub category: String,
    /// Description
    pub description: String,
    /// Confidence this indicator suggests sandbox
    pub confidence: u8,
    /// Details
    pub details: Option<String>,
}

// ============================================================================
// Evasion Job Types (for database/API)
// ============================================================================

/// Status of an evasion job
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum EvasionJobStatus {
    Pending,
    Running,
    Completed,
    Failed,
}

/// Evasion job for async processing
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EvasionJob {
    /// Unique identifier
    pub id: String,
    /// User who created the job
    pub user_id: String,
    /// Job type (analyze, apply_evasion, sandbox_check)
    pub job_type: String,
    /// Job status
    pub status: EvasionJobStatus,
    /// Input parameters (serialized JSON)
    pub input: serde_json::Value,
    /// Result (serialized JSON)
    pub result: Option<serde_json::Value>,
    /// Error message if failed
    pub error: Option<String>,
    /// Created timestamp
    pub created_at: DateTime<Utc>,
    /// Completed timestamp
    pub completed_at: Option<DateTime<Utc>>,
}

// ============================================================================
// Helper Functions
// ============================================================================

/// Get all available evasion techniques
pub fn get_all_techniques() -> Vec<EvasionTechniqueInfo> {
    vec![
        // Signature Evasion
        EvasionTechniqueInfo::new(EvasionTechnique::XorEncoding),
        EvasionTechniqueInfo::new(EvasionTechnique::Base64Obfuscation),
        EvasionTechniqueInfo::new(EvasionTechnique::StringConcatenation),
        EvasionTechniqueInfo::new(EvasionTechnique::DeadCodeInsertion),
        EvasionTechniqueInfo::new(EvasionTechnique::ApiObfuscation),
        EvasionTechniqueInfo::new(EvasionTechnique::IatManipulation),
        EvasionTechniqueInfo::new(EvasionTechnique::PayloadEncryption),
        EvasionTechniqueInfo::new(EvasionTechnique::Polymorphism),
        // Behavioral
        EvasionTechniqueInfo::new(EvasionTechnique::SandboxDetection),
        EvasionTechniqueInfo::new(EvasionTechnique::TimingEvasion),
        EvasionTechniqueInfo::new(EvasionTechnique::UserInteractionCheck),
        EvasionTechniqueInfo::new(EvasionTechnique::AnalysisToolDetection),
        EvasionTechniqueInfo::new(EvasionTechnique::ResourceCheck),
        EvasionTechniqueInfo::new(EvasionTechnique::EnvironmentValidation),
        // Memory (documentation only)
        EvasionTechniqueInfo::new(EvasionTechnique::ProcessHollowing),
        EvasionTechniqueInfo::new(EvasionTechnique::DllInjection),
        EvasionTechniqueInfo::new(EvasionTechnique::ThreadHijacking),
        EvasionTechniqueInfo::new(EvasionTechnique::DirectSyscalls),
        EvasionTechniqueInfo::new(EvasionTechnique::NtdllUnhooking),
        EvasionTechniqueInfo::new(EvasionTechnique::FilelessExecution),
        // Network
        EvasionTechniqueInfo::new(EvasionTechnique::EncryptedC2),
        EvasionTechniqueInfo::new(EvasionTechnique::DomainFronting),
        EvasionTechniqueInfo::new(EvasionTechnique::DnsTunneling),
        EvasionTechniqueInfo::new(EvasionTechnique::TrafficMimicry),
        // File-Based
        EvasionTechniqueInfo::new(EvasionTechnique::AlternateDataStreams),
        EvasionTechniqueInfo::new(EvasionTechnique::MetadataManipulation),
        EvasionTechniqueInfo::new(EvasionTechnique::ExtensionSpoofing),
        EvasionTechniqueInfo::new(EvasionTechnique::Timestomping),
    ]
}

/// Info wrapper for API responses
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EvasionTechniqueInfo {
    pub technique: EvasionTechnique,
    pub category: EvasionCategory,
    pub description: String,
    pub mitre_id: Option<String>,
    pub detection_difficulty: u8,
}

impl EvasionTechniqueInfo {
    pub fn new(technique: EvasionTechnique) -> Self {
        Self {
            category: technique.category(),
            description: technique.description().to_string(),
            mitre_id: technique.mitre_id().map(|s| s.to_string()),
            detection_difficulty: technique.detection_difficulty(),
            technique,
        }
    }
}

#[allow(unused_imports)]
pub use signature::*;
#[allow(unused_imports)]
pub use behavior::*;
#[allow(unused_imports)]
pub use analysis::*;
