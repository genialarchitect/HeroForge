// Signature-Based Evasion Techniques
// Provides analysis and documentation of signature evasion methods
// For educational and authorized penetration testing purposes only

use super::{
    DetectionRisk, EvasionArtifact, EvasionResult, EvasionTechnique,
};
use chrono::Utc;
use std::collections::HashMap;
use uuid::Uuid;

// ============================================================================
// String Obfuscation Techniques
// ============================================================================

/// Analyzes and demonstrates XOR encoding of strings
/// This is for understanding how malware obfuscates strings
pub fn analyze_xor_encoding(data: &[u8], key: u8) -> XorAnalysis {
    let encoded: Vec<u8> = data.iter().map(|b| b ^ key).collect();
    let decoded: Vec<u8> = encoded.iter().map(|b| b ^ key).collect();

    // Calculate entropy change
    let original_entropy = calculate_entropy(data);
    let encoded_entropy = calculate_entropy(&encoded);

    XorAnalysis {
        original_size: data.len(),
        encoded_size: encoded.len(),
        key_used: key,
        original_entropy,
        encoded_entropy,
        entropy_change: encoded_entropy - original_entropy,
        is_reversible: decoded == data,
        detection_notes: if key == 0x00 {
            "XOR with 0x00 provides no obfuscation".to_string()
        } else if key == 0xFF {
            "XOR with 0xFF is easily detectable (simple NOT operation)".to_string()
        } else {
            format!("XOR with 0x{:02X} provides basic obfuscation", key)
        },
    }
}

/// Result of XOR encoding analysis
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct XorAnalysis {
    pub original_size: usize,
    pub encoded_size: usize,
    pub key_used: u8,
    pub original_entropy: f64,
    pub encoded_entropy: f64,
    pub entropy_change: f64,
    pub is_reversible: bool,
    pub detection_notes: String,
}

/// Analyzes string concatenation obfuscation
/// Shows how malware breaks strings to avoid static signatures
pub fn analyze_string_concatenation(input: &str) -> StringConcatAnalysis {
    // Demonstrate how strings can be broken up
    let char_array: Vec<char> = input.chars().collect();
    let split_points = generate_split_points(input.len());

    let mut chunks: Vec<String> = Vec::new();
    let mut start = 0;
    for point in &split_points {
        if *point > start && *point < char_array.len() {
            chunks.push(char_array[start..*point].iter().collect());
            start = *point;
        }
    }
    if start < char_array.len() {
        chunks.push(char_array[start..].iter().collect());
    }

    StringConcatAnalysis {
        original_string: input.to_string(),
        chunk_count: chunks.len(),
        chunks,
        detection_notes: "String concatenation breaks static signatures but is detectable through dynamic analysis".to_string(),
        recommended_chunk_size: if input.len() > 20 { 4 } else { 2 },
    }
}

/// Result of string concatenation analysis
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct StringConcatAnalysis {
    pub original_string: String,
    pub chunk_count: usize,
    pub chunks: Vec<String>,
    pub detection_notes: String,
    pub recommended_chunk_size: usize,
}

/// Generate pseudo-random split points for string chunking
fn generate_split_points(length: usize) -> Vec<usize> {
    let chunk_size = std::cmp::max(2, length / 4);
    (chunk_size..length).step_by(chunk_size).collect()
}

// ============================================================================
// API Call Obfuscation Analysis
// ============================================================================

/// Common Windows APIs that are often obfuscated by malware
pub const SUSPICIOUS_APIS: &[(&str, &str, &str)] = &[
    ("VirtualAlloc", "Memory Allocation", "T1055"),
    ("VirtualAllocEx", "Remote Memory Allocation", "T1055"),
    ("VirtualProtect", "Memory Protection Change", "T1055"),
    ("VirtualProtectEx", "Remote Memory Protection", "T1055"),
    ("WriteProcessMemory", "Process Memory Write", "T1055"),
    ("ReadProcessMemory", "Process Memory Read", "T1055"),
    ("CreateRemoteThread", "Remote Thread Creation", "T1055"),
    ("NtCreateThreadEx", "Native Thread Creation", "T1055"),
    ("LoadLibrary", "DLL Loading", "T1055.001"),
    ("LoadLibraryA", "DLL Loading (ANSI)", "T1055.001"),
    ("LoadLibraryW", "DLL Loading (Wide)", "T1055.001"),
    ("GetProcAddress", "API Resolution", "T1106"),
    ("OpenProcess", "Process Handle", "T1055"),
    ("CreateProcess", "Process Creation", "T1106"),
    ("ShellExecute", "Command Execution", "T1059"),
    ("WinExec", "Command Execution", "T1059"),
    ("NtUnmapViewOfSection", "Process Hollowing", "T1055.012"),
    ("SetThreadContext", "Thread Context Modification", "T1055"),
    ("ResumeThread", "Thread Resumption", "T1055"),
    ("SuspendThread", "Thread Suspension", "T1055"),
    ("QueueUserAPC", "APC Injection", "T1055.004"),
    ("NtQueueApcThread", "Native APC Injection", "T1055.004"),
    ("RegSetValueEx", "Registry Modification", "T1112"),
    ("CryptEncrypt", "Encryption", "T1027"),
    ("CryptDecrypt", "Decryption", "T1140"),
    ("InternetOpen", "Network Initialization", "T1071"),
    ("HttpOpenRequest", "HTTP Request", "T1071.001"),
    ("WSAStartup", "Socket Initialization", "T1095"),
    ("connect", "Network Connection", "T1095"),
    ("send", "Network Send", "T1041"),
    ("recv", "Network Receive", "T1095"),
];

/// Analyze API call patterns for obfuscation potential
pub fn analyze_api_obfuscation(api_name: &str) -> ApiObfuscationAnalysis {
    // Check if this is a known suspicious API
    let api_info = SUSPICIOUS_APIS
        .iter()
        .find(|(name, _, _)| *name == api_name);

    let (is_suspicious, category, mitre_id) = match api_info {
        Some((_, cat, mitre)) => (true, cat.to_string(), Some(mitre.to_string())),
        None => (false, "Unknown".to_string(), None),
    };

    // Generate obfuscation examples
    let obfuscation_methods = generate_api_obfuscation_examples(api_name);

    ApiObfuscationAnalysis {
        api_name: api_name.to_string(),
        is_suspicious,
        category,
        mitre_id,
        obfuscation_methods,
        detection_notes: if is_suspicious {
            format!("'{}' is commonly monitored by EDR solutions. Consider using dynamic resolution or direct syscalls.", api_name)
        } else {
            "API not in common malware signature lists".to_string()
        },
    }
}

/// Generate examples of API obfuscation techniques
fn generate_api_obfuscation_examples(api_name: &str) -> Vec<ObfuscationMethod> {
    vec![
        ObfuscationMethod {
            name: "GetProcAddress Resolution".to_string(),
            description: "Dynamically resolve API at runtime".to_string(),
            example: format!(
                r#"// Instead of direct import:
// typedef LPVOID (WINAPI *{0}Func)(...);
// {0}Func p{0} = ({0}Func)GetProcAddress(GetModuleHandle("kernel32"), "{0}");"#,
                api_name
            ),
            difficulty: 3,
        },
        ObfuscationMethod {
            name: "Hash-based Resolution".to_string(),
            description: "Use API name hash instead of string".to_string(),
            example: format!(
                r#"// Pre-compute hash of "{}"
// DWORD hash = 0x{:08X};  // Example hash
// void* func = ResolveApiByHash(hash);"#,
                api_name,
                simple_hash(api_name)
            ),
            difficulty: 5,
        },
        ObfuscationMethod {
            name: "XOR Encoded Name".to_string(),
            description: "XOR encode the API name string".to_string(),
            example: format!(
                r#"// XOR key: 0x42
// Encoded: "{}"
// Decode at runtime before GetProcAddress"#,
                xor_encode_string(api_name, 0x42)
            ),
            difficulty: 4,
        },
        ObfuscationMethod {
            name: "Stack-based String".to_string(),
            description: "Build string on stack instead of .data section".to_string(),
            example: format!(
                r#"char api[] = {{ {} }};
// Build "{}" character by character on stack"#,
                api_name.chars().map(|c| format!("0x{:02X}", c as u8)).collect::<Vec<_>>().join(", "),
                api_name
            ),
            difficulty: 3,
        },
    ]
}

/// Simple hash function for API name (for demonstration)
fn simple_hash(s: &str) -> u32 {
    let mut hash: u32 = 0;
    for c in s.bytes() {
        hash = hash.wrapping_add(c as u32);
        hash = hash.wrapping_add(hash << 10);
        hash ^= hash >> 6;
    }
    hash = hash.wrapping_add(hash << 3);
    hash ^= hash >> 11;
    hash = hash.wrapping_add(hash << 15);
    hash
}

/// XOR encode a string (for demonstration)
fn xor_encode_string(s: &str, key: u8) -> String {
    s.bytes()
        .map(|b| format!("\\x{:02X}", b ^ key))
        .collect()
}

/// Result of API obfuscation analysis
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct ApiObfuscationAnalysis {
    pub api_name: String,
    pub is_suspicious: bool,
    pub category: String,
    pub mitre_id: Option<String>,
    pub obfuscation_methods: Vec<ObfuscationMethod>,
    pub detection_notes: String,
}

/// Obfuscation method example
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct ObfuscationMethod {
    pub name: String,
    pub description: String,
    pub example: String,
    pub difficulty: u8,
}

// ============================================================================
// Import Address Table (IAT) Analysis
// ============================================================================

/// Analyze IAT manipulation potential
pub fn analyze_iat_manipulation() -> IatAnalysisResult {
    IatAnalysisResult {
        techniques: vec![
            IatTechnique {
                name: "IAT Hooking".to_string(),
                description: "Replace IAT entries to intercept API calls".to_string(),
                use_case: "Interception".to_string(),
                detection_method: "IAT integrity checking, memory scanning".to_string(),
                mitre_id: Some("T1574.001".to_string()),
            },
            IatTechnique {
                name: "Delayed Import Loading".to_string(),
                description: "Use delay-load imports to defer API resolution".to_string(),
                use_case: "Evasion".to_string(),
                detection_method: "Static analysis of delay-load descriptor".to_string(),
                mitre_id: None,
            },
            IatTechnique {
                name: "Manual IAT Resolution".to_string(),
                description: "Manually walk PEB to resolve imports without standard IAT".to_string(),
                use_case: "Evasion".to_string(),
                detection_method: "Behavioral analysis, PEB access monitoring".to_string(),
                mitre_id: Some("T1106".to_string()),
            },
            IatTechnique {
                name: "API Set Redirection".to_string(),
                description: "Use Windows API sets for indirect resolution".to_string(),
                use_case: "Evasion".to_string(),
                detection_method: "API set schema analysis".to_string(),
                mitre_id: None,
            },
        ],
        recommendations: vec![
            "Manual import resolution using PEB walking reduces static analysis visibility".to_string(),
            "Combine with string obfuscation for API names".to_string(),
            "Consider direct syscalls to bypass user-mode hooks entirely".to_string(),
        ],
    }
}

/// IAT analysis result
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct IatAnalysisResult {
    pub techniques: Vec<IatTechnique>,
    pub recommendations: Vec<String>,
}

/// IAT manipulation technique
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct IatTechnique {
    pub name: String,
    pub description: String,
    pub use_case: String,
    pub detection_method: String,
    pub mitre_id: Option<String>,
}

// ============================================================================
// Dead Code Insertion Analysis
// ============================================================================

/// Analyze dead code insertion for hash modification
pub fn analyze_dead_code_insertion(payload_hash: &str) -> DeadCodeAnalysis {
    DeadCodeAnalysis {
        original_hash: payload_hash.to_string(),
        techniques: vec![
            DeadCodeTechnique {
                name: "NOP Sleds".to_string(),
                description: "Insert NOP (0x90) instructions between functional code".to_string(),
                impact_on_hash: "High - Changes byte sequence significantly".to_string(),
                detection_risk: DetectionRisk::Low,
            },
            DeadCodeTechnique {
                name: "Junk Computations".to_string(),
                description: "Add mathematical operations that don't affect program state".to_string(),
                impact_on_hash: "High - Adds unique byte patterns".to_string(),
                detection_risk: DetectionRisk::Low,
            },
            DeadCodeTechnique {
                name: "Unreachable Branches".to_string(),
                description: "Add conditional jumps that never execute".to_string(),
                impact_on_hash: "Medium - Adds control flow complexity".to_string(),
                detection_risk: DetectionRisk::Medium,
            },
            DeadCodeTechnique {
                name: "Garbage Data Sections".to_string(),
                description: "Add random data sections to PE file".to_string(),
                impact_on_hash: "High - Dramatically changes file hash".to_string(),
                detection_risk: DetectionRisk::Low,
            },
            DeadCodeTechnique {
                name: "Polymorphic Wrappers".to_string(),
                description: "Wrap payload in dynamically generated code".to_string(),
                impact_on_hash: "Very High - Creates unique variants".to_string(),
                detection_risk: DetectionRisk::Low,
            },
        ],
        recommendations: vec![
            "Combine multiple techniques for maximum effectiveness".to_string(),
            "Ensure dead code doesn't introduce suspicious patterns".to_string(),
            "Balance file size increase with evasion benefit".to_string(),
        ],
    }
}

/// Dead code insertion analysis
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct DeadCodeAnalysis {
    pub original_hash: String,
    pub techniques: Vec<DeadCodeTechnique>,
    pub recommendations: Vec<String>,
}

/// Dead code insertion technique
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct DeadCodeTechnique {
    pub name: String,
    pub description: String,
    pub impact_on_hash: String,
    pub detection_risk: DetectionRisk,
}

// ============================================================================
// Payload Encryption Analysis
// ============================================================================

/// Analyze payload encryption options
pub fn analyze_encryption_options() -> EncryptionAnalysis {
    EncryptionAnalysis {
        algorithms: vec![
            EncryptionAlgorithmInfo {
                name: "XOR (Single Byte)".to_string(),
                strength: "Weak".to_string(),
                key_size: "8 bits".to_string(),
                pros: vec!["Simple to implement".to_string(), "Fast".to_string(), "No dependencies".to_string()],
                cons: vec!["Easily broken".to_string(), "Detectable patterns".to_string()],
                detection_risk: DetectionRisk::High,
            },
            EncryptionAlgorithmInfo {
                name: "XOR (Multi-Byte Key)".to_string(),
                strength: "Medium".to_string(),
                key_size: "Variable".to_string(),
                pros: vec!["Better than single-byte".to_string(), "Still simple".to_string()],
                cons: vec!["Key length patterns detectable".to_string()],
                detection_risk: DetectionRisk::Medium,
            },
            EncryptionAlgorithmInfo {
                name: "RC4".to_string(),
                strength: "Medium".to_string(),
                key_size: "40-2048 bits".to_string(),
                pros: vec!["Fast stream cipher".to_string(), "Simple implementation".to_string()],
                cons: vec!["Known weaknesses".to_string(), "Some AV detect RC4 patterns".to_string()],
                detection_risk: DetectionRisk::Medium,
            },
            EncryptionAlgorithmInfo {
                name: "AES-256".to_string(),
                strength: "Strong".to_string(),
                key_size: "256 bits".to_string(),
                pros: vec!["Industry standard".to_string(), "Very secure".to_string()],
                cons: vec!["Larger stub needed".to_string(), "May need crypto library".to_string()],
                detection_risk: DetectionRisk::Low,
            },
            EncryptionAlgorithmInfo {
                name: "ChaCha20".to_string(),
                strength: "Strong".to_string(),
                key_size: "256 bits".to_string(),
                pros: vec!["Fast in software".to_string(), "Modern design".to_string()],
                cons: vec!["Less common, may stand out".to_string()],
                detection_risk: DetectionRisk::Low,
            },
        ],
        key_derivation_notes: vec![
            "Derive key from environment variables to avoid static key".to_string(),
            "Use time-based key derivation for uniqueness".to_string(),
            "Consider domain/hostname-based key for targeted execution".to_string(),
        ],
        recommendations: vec![
            "AES-256 with environmental key derivation recommended".to_string(),
            "Implement decryption stub with obfuscation".to_string(),
            "Consider multiple encryption layers".to_string(),
        ],
    }
}

/// Encryption options analysis
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct EncryptionAnalysis {
    pub algorithms: Vec<EncryptionAlgorithmInfo>,
    pub key_derivation_notes: Vec<String>,
    pub recommendations: Vec<String>,
}

/// Encryption algorithm info
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct EncryptionAlgorithmInfo {
    pub name: String,
    pub strength: String,
    pub key_size: String,
    pub pros: Vec<String>,
    pub cons: Vec<String>,
    pub detection_risk: DetectionRisk,
}

// ============================================================================
// Utility Functions
// ============================================================================

/// Calculate Shannon entropy of data
pub fn calculate_entropy(data: &[u8]) -> f64 {
    if data.is_empty() {
        return 0.0;
    }

    let mut frequency = [0u64; 256];
    for byte in data {
        frequency[*byte as usize] += 1;
    }

    let len = data.len() as f64;
    let mut entropy = 0.0;

    for count in &frequency {
        if *count > 0 {
            let p = *count as f64 / len;
            entropy -= p * p.log2();
        }
    }

    entropy
}

/// Apply signature evasion techniques to analyze a payload
pub fn apply_signature_evasion_analysis(
    payload: &[u8],
    techniques: &[EvasionTechnique],
) -> EvasionResult {
    use sha2::{Sha256, Digest};
    let mut artifacts = Vec::new();
    let mut hasher = Sha256::new();
    hasher.update(payload);
    let original_hash = format!("{:x}", hasher.finalize());
    let mut confidence: u8 = 50;

    for technique in techniques {
        match technique {
            EvasionTechnique::XorEncoding => {
                let analysis = analyze_xor_encoding(payload, 0x42);
                artifacts.push(EvasionArtifact {
                    technique: technique.clone(),
                    artifact_type: "xor_analysis".to_string(),
                    description: format!("XOR encoding analysis with key 0x42"),
                    details: {
                        let mut map = HashMap::new();
                        map.insert("original_entropy".to_string(), serde_json::json!(analysis.original_entropy));
                        map.insert("encoded_entropy".to_string(), serde_json::json!(analysis.encoded_entropy));
                        map.insert("key".to_string(), serde_json::json!(analysis.key_used));
                        map
                    },
                });
                confidence = confidence.saturating_add(10);
            }
            EvasionTechnique::DeadCodeInsertion => {
                let analysis = analyze_dead_code_insertion(&original_hash);
                artifacts.push(EvasionArtifact {
                    technique: technique.clone(),
                    artifact_type: "dead_code_analysis".to_string(),
                    description: "Dead code insertion options analyzed".to_string(),
                    details: {
                        let mut map = HashMap::new();
                        map.insert("techniques_available".to_string(), serde_json::json!(analysis.techniques.len()));
                        map
                    },
                });
                confidence = confidence.saturating_add(15);
            }
            EvasionTechnique::PayloadEncryption => {
                let analysis = analyze_encryption_options();
                artifacts.push(EvasionArtifact {
                    technique: technique.clone(),
                    artifact_type: "encryption_analysis".to_string(),
                    description: "Encryption options analyzed".to_string(),
                    details: {
                        let mut map = HashMap::new();
                        map.insert("algorithms_available".to_string(), serde_json::json!(analysis.algorithms.len()));
                        map
                    },
                });
                confidence = confidence.saturating_add(20);
            }
            _ => {
                artifacts.push(EvasionArtifact {
                    technique: technique.clone(),
                    artifact_type: "documentation".to_string(),
                    description: technique.description().to_string(),
                    details: HashMap::new(),
                });
                confidence = confidence.saturating_add(5);
            }
        }
    }

    // Cap confidence at 95
    confidence = std::cmp::min(confidence, 95);

    // Determine detection risk based on techniques used
    let detection_risk = if techniques.iter().any(|t| t.detection_difficulty() >= 8) {
        DetectionRisk::Low
    } else if techniques.iter().any(|t| t.detection_difficulty() >= 5) {
        DetectionRisk::Medium
    } else {
        DetectionRisk::High
    };

    EvasionResult {
        id: Uuid::new_v4().to_string(),
        techniques_applied: techniques.to_vec(),
        original_hash,
        modified_hash: None, // Analysis only, no actual modification
        confidence,
        detection_risk,
        artifacts,
        recommendations: vec![
            "Combine multiple signature evasion techniques".to_string(),
            "Test against target AV/EDR before deployment".to_string(),
            "Consider behavioral evasion in addition to signature evasion".to_string(),
        ],
        timestamp: Utc::now(),
    }
}
