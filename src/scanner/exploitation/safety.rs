// Exploitation Safety Controller
// Validates and enforces safety constraints for exploitation campaigns

#![allow(dead_code)]

use crate::scanner::exploitation::types::*;
use chrono::{DateTime, Duration, Utc};
use log::info;
use serde::{Deserialize, Serialize};
use std::collections::HashSet;
use std::net::IpAddr;
use std::str::FromStr;

// ============================================================================
// Safety Configuration
// ============================================================================

/// Safety configuration for exploitation campaigns
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExploitSafetyConfig {
    /// Require explicit user authorization before execution
    pub require_authorization: bool,
    /// Allowed target CIDRs or hostnames (whitelist)
    pub allowed_targets: Vec<String>,
    /// Blocked target CIDRs or hostnames (blacklist)
    pub blocked_targets: Vec<String>,
    /// Maximum concurrent attacks/threads
    pub max_concurrent_attacks: u32,
    /// Enforce delays for password attacks (lockout protection)
    pub lockout_protection: bool,
    /// Minimum delay between password attempts (ms)
    pub min_spray_delay_ms: u64,
    /// Enable comprehensive audit logging
    pub audit_logging: bool,
    /// Cleanup artifacts after completion
    pub cleanup_on_complete: bool,
    /// Credential expiry time in hours
    pub credential_expiry_hours: u32,
    /// Block attacks against localhost/loopback
    pub block_localhost: bool,
    /// Block attacks against private RFC1918 ranges (unless explicitly allowed)
    pub require_explicit_private_range: bool,
}

impl Default for ExploitSafetyConfig {
    fn default() -> Self {
        Self {
            require_authorization: true,
            allowed_targets: Vec::new(),
            blocked_targets: vec![
                // Common production/critical infrastructure patterns
                "prod.*".to_string(),
                "production.*".to_string(),
                "*.prod.*".to_string(),
                "dc*".to_string(), // Domain controllers
                "pdc*".to_string(),
            ],
            max_concurrent_attacks: 10,
            lockout_protection: true,
            min_spray_delay_ms: 1000,
            audit_logging: true,
            cleanup_on_complete: true,
            credential_expiry_hours: 72, // 3 days
            block_localhost: true,
            require_explicit_private_range: false,
        }
    }
}

// ============================================================================
// Safety Violation Types
// ============================================================================

/// Types of safety violations
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum SafetyViolationType {
    UnauthorizedExecution,
    BlockedTarget,
    TargetNotAllowed,
    LocalhostBlocked,
    ExcessiveConcurrency,
    InsufficientDelay,
    InvalidConfiguration,
    CredentialExpired,
    MsfvenomNotAvailable,
}

/// Safety violation with details
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SafetyViolation {
    pub violation_type: SafetyViolationType,
    pub message: String,
    pub target: Option<String>,
    pub severity: Severity,
}

impl SafetyViolation {
    pub fn new(
        violation_type: SafetyViolationType,
        message: impl Into<String>,
        target: Option<String>,
    ) -> Self {
        let severity = match violation_type {
            SafetyViolationType::UnauthorizedExecution => Severity::Critical,
            SafetyViolationType::BlockedTarget => Severity::High,
            SafetyViolationType::LocalhostBlocked => Severity::High,
            SafetyViolationType::TargetNotAllowed => Severity::Medium,
            SafetyViolationType::ExcessiveConcurrency => Severity::Medium,
            SafetyViolationType::InsufficientDelay => Severity::Medium,
            SafetyViolationType::InvalidConfiguration => Severity::Low,
            SafetyViolationType::CredentialExpired => Severity::Info,
            SafetyViolationType::MsfvenomNotAvailable => Severity::Low,
        };

        Self {
            violation_type,
            message: message.into(),
            target,
            severity,
        }
    }
}

// ============================================================================
// Safety Controller
// ============================================================================

/// Safety controller for validating exploitation campaigns
pub struct SafetyController {
    config: ExploitSafetyConfig,
    authorized_campaigns: HashSet<String>,
}

impl SafetyController {
    pub fn new(config: ExploitSafetyConfig) -> Self {
        Self {
            config,
            authorized_campaigns: HashSet::new(),
        }
    }

    pub fn with_default_config() -> Self {
        Self::new(ExploitSafetyConfig::default())
    }

    /// Authorize a campaign for execution
    pub fn authorize_campaign(&mut self, campaign_id: &str) {
        info!("Campaign {} authorized for execution", campaign_id);
        self.authorized_campaigns.insert(campaign_id.to_string());
    }

    /// Check if a campaign is authorized
    pub fn is_authorized(&self, campaign_id: &str) -> bool {
        !self.config.require_authorization || self.authorized_campaigns.contains(campaign_id)
    }

    /// Validate a password spray configuration
    pub fn validate_password_spray(
        &self,
        config: &PasswordSprayConfig,
        campaign_id: &str,
    ) -> Vec<SafetyViolation> {
        let mut violations = Vec::new();

        // Check authorization
        if self.config.require_authorization && !self.is_authorized(campaign_id) {
            violations.push(SafetyViolation::new(
                SafetyViolationType::UnauthorizedExecution,
                "Campaign not authorized. User must explicitly authorize execution.",
                None,
            ));
        }

        // Validate targets
        for target in &config.targets {
            if let Some(violation) = self.validate_target(target) {
                violations.push(violation);
            }
        }

        // Check concurrency limits
        if config.threads > self.config.max_concurrent_attacks {
            violations.push(SafetyViolation::new(
                SafetyViolationType::ExcessiveConcurrency,
                format!(
                    "Thread count {} exceeds maximum allowed {}",
                    config.threads, self.config.max_concurrent_attacks
                ),
                None,
            ));
        }

        // Check delay requirements (lockout protection)
        if self.config.lockout_protection
            && config.delay_between_attempts_ms < self.config.min_spray_delay_ms
        {
            violations.push(SafetyViolation::new(
                SafetyViolationType::InsufficientDelay,
                format!(
                    "Delay {}ms is below minimum {}ms (lockout protection)",
                    config.delay_between_attempts_ms, self.config.min_spray_delay_ms
                ),
                None,
            ));
        }

        // Validate configuration
        if config.usernames.is_empty() {
            violations.push(SafetyViolation::new(
                SafetyViolationType::InvalidConfiguration,
                "No usernames provided",
                None,
            ));
        }

        if config.passwords.is_empty() {
            violations.push(SafetyViolation::new(
                SafetyViolationType::InvalidConfiguration,
                "No passwords provided",
                None,
            ));
        }

        violations
    }

    /// Validate a Kerberos attack configuration
    pub fn validate_kerberos(
        &self,
        config: &KerberoastConfig,
        campaign_id: &str,
    ) -> Vec<SafetyViolation> {
        let mut violations = Vec::new();

        if self.config.require_authorization && !self.is_authorized(campaign_id) {
            violations.push(SafetyViolation::new(
                SafetyViolationType::UnauthorizedExecution,
                "Campaign not authorized",
                None,
            ));
        }

        // Validate domain controller target
        if let Some(violation) = self.validate_target(&config.domain_controller) {
            violations.push(violation);
        }

        // Validate credentials provided
        if config.password.is_none() && config.ntlm_hash.is_none() {
            violations.push(SafetyViolation::new(
                SafetyViolationType::InvalidConfiguration,
                "Either password or NTLM hash must be provided",
                None,
            ));
        }

        if config.domain.is_empty() {
            violations.push(SafetyViolation::new(
                SafetyViolationType::InvalidConfiguration,
                "Domain is required",
                None,
            ));
        }

        violations
    }

    /// Validate AS-REP roast configuration
    pub fn validate_asrep_roast(
        &self,
        config: &AsrepRoastConfig,
        campaign_id: &str,
    ) -> Vec<SafetyViolation> {
        let mut violations = Vec::new();

        if self.config.require_authorization && !self.is_authorized(campaign_id) {
            violations.push(SafetyViolation::new(
                SafetyViolationType::UnauthorizedExecution,
                "Campaign not authorized",
                None,
            ));
        }

        if let Some(violation) = self.validate_target(&config.domain_controller) {
            violations.push(violation);
        }

        if config.usernames.is_empty() && !config.enumerate_users {
            violations.push(SafetyViolation::new(
                SafetyViolationType::InvalidConfiguration,
                "Either provide usernames or enable user enumeration",
                None,
            ));
        }

        violations
    }

    /// Validate shell generation configuration
    pub fn validate_shell_config(&self, config: &ShellConfig) -> Vec<SafetyViolation> {
        let mut violations = Vec::new();

        // Check if msfvenom is needed and available
        if config.format.is_meterpreter() {
            if !Self::check_msfvenom_available() {
                violations.push(SafetyViolation::new(
                    SafetyViolationType::MsfvenomNotAvailable,
                    "Meterpreter payloads require msfvenom which is not installed or not in PATH",
                    None,
                ));
            }
        }

        // Validate LHOST
        if config.lhost.is_empty() {
            violations.push(SafetyViolation::new(
                SafetyViolationType::InvalidConfiguration,
                "LHOST (listener IP) is required",
                None,
            ));
        }

        // Validate LPORT
        if config.lport == 0 {
            violations.push(SafetyViolation::new(
                SafetyViolationType::InvalidConfiguration,
                "LPORT must be greater than 0",
                None,
            ));
        }

        // Validate platform/format compatibility
        let compatible = match config.format {
            ShellFormat::PowerShell | ShellFormat::MeterpreterPowerShell => {
                config.platform == Platform::Windows
            }
            ShellFormat::Bash => {
                config.platform == Platform::Linux || config.platform == Platform::MacOS
            }
            ShellFormat::MeterpreterExe | ShellFormat::MeterpreterDll => {
                config.platform == Platform::Windows
            }
            ShellFormat::MeterpreterElf => config.platform == Platform::Linux,
            _ => true,
        };

        if !compatible {
            violations.push(SafetyViolation::new(
                SafetyViolationType::InvalidConfiguration,
                format!(
                    "Format {:?} is not compatible with platform {:?}",
                    config.format, config.platform
                ),
                None,
            ));
        }

        violations
    }

    /// Validate post-exploitation configuration
    pub fn validate_post_exploit(
        &self,
        config: &PostExploitConfig,
        campaign_id: &str,
    ) -> Vec<SafetyViolation> {
        let mut violations = Vec::new();

        if self.config.require_authorization && !self.is_authorized(campaign_id) {
            violations.push(SafetyViolation::new(
                SafetyViolationType::UnauthorizedExecution,
                "Campaign not authorized",
                None,
            ));
        }

        if let Some(violation) = self.validate_target(&config.target) {
            violations.push(violation);
        }

        // Check if module requires credentials
        let requires_creds = matches!(
            config.module,
            PostExploitModule::PassTheHash
                | PostExploitModule::PassTheTicket
                | PostExploitModule::PsExec
                | PostExploitModule::WmiExec
                | PostExploitModule::SshPivot
        );

        if requires_creds && config.credentials.is_none() {
            violations.push(SafetyViolation::new(
                SafetyViolationType::InvalidConfiguration,
                format!(
                    "Module {:?} requires credentials",
                    config.module
                ),
                None,
            ));
        }

        violations
    }

    /// Validate a single target
    fn validate_target(&self, target: &str) -> Option<SafetyViolation> {
        // Check localhost blocking
        if self.config.block_localhost {
            let is_localhost = target == "localhost"
                || target == "127.0.0.1"
                || target == "::1"
                || target.starts_with("127.");

            if is_localhost {
                return Some(SafetyViolation::new(
                    SafetyViolationType::LocalhostBlocked,
                    "Attacks against localhost are blocked",
                    Some(target.to_string()),
                ));
            }
        }

        // Check blocked targets (blacklist)
        for pattern in &self.config.blocked_targets {
            if Self::matches_pattern(target, pattern) {
                return Some(SafetyViolation::new(
                    SafetyViolationType::BlockedTarget,
                    format!("Target matches blocked pattern: {}", pattern),
                    Some(target.to_string()),
                ));
            }
        }

        // Check allowed targets (whitelist - if specified)
        if !self.config.allowed_targets.is_empty() {
            let is_allowed = self
                .config
                .allowed_targets
                .iter()
                .any(|pattern| Self::matches_pattern(target, pattern));

            if !is_allowed {
                return Some(SafetyViolation::new(
                    SafetyViolationType::TargetNotAllowed,
                    "Target not in allowed list",
                    Some(target.to_string()),
                ));
            }
        }

        None
    }

    /// Check if a target matches a pattern (supports wildcards)
    fn matches_pattern(target: &str, pattern: &str) -> bool {
        if pattern.contains('*') {
            // Glob-style wildcard matching
            let parts: Vec<&str> = pattern.split('*').collect();

            // Single wildcard case
            if parts.len() == 2 {
                let prefix = parts[0];
                let suffix = parts[1];

                if prefix.is_empty() && suffix.is_empty() {
                    return true;
                } else if prefix.is_empty() {
                    return target.ends_with(suffix);
                } else if suffix.is_empty() {
                    return target.starts_with(prefix);
                } else {
                    return target.starts_with(prefix) && target.ends_with(suffix);
                }
            }

            // Multiple wildcards - use sequential matching
            if parts.len() > 2 {
                let mut remaining = target;

                // Check prefix (first part)
                if !parts[0].is_empty() {
                    if !remaining.starts_with(parts[0]) {
                        return false;
                    }
                    remaining = &remaining[parts[0].len()..];
                }

                // Check middle parts
                for i in 1..parts.len() - 1 {
                    if let Some(pos) = remaining.find(parts[i]) {
                        remaining = &remaining[pos + parts[i].len()..];
                    } else {
                        return false;
                    }
                }

                // Check suffix (last part)
                let last = parts[parts.len() - 1];
                if !last.is_empty() && !remaining.ends_with(last) {
                    return false;
                }

                return true;
            }
        }

        // Exact match or CIDR check
        target == pattern || Self::ip_in_cidr(target, pattern)
    }

    /// Check if an IP is in a CIDR range
    fn ip_in_cidr(ip_str: &str, cidr: &str) -> bool {
        if !cidr.contains('/') {
            return false;
        }

        let parts: Vec<&str> = cidr.split('/').collect();
        if parts.len() != 2 {
            return false;
        }

        let Ok(target_ip) = IpAddr::from_str(ip_str) else {
            return false;
        };

        let Ok(network_ip) = IpAddr::from_str(parts[0]) else {
            return false;
        };

        let Ok(prefix_len) = parts[1].parse::<u8>() else {
            return false;
        };

        match (target_ip, network_ip) {
            (IpAddr::V4(t), IpAddr::V4(n)) => {
                if prefix_len > 32 {
                    return false;
                }
                let mask = if prefix_len == 0 {
                    0
                } else {
                    !0u32 << (32 - prefix_len)
                };
                (u32::from(t) & mask) == (u32::from(n) & mask)
            }
            (IpAddr::V6(t), IpAddr::V6(n)) => {
                if prefix_len > 128 {
                    return false;
                }
                let t_bytes = t.octets();
                let n_bytes = n.octets();
                let full_bytes = (prefix_len / 8) as usize;
                let remaining_bits = prefix_len % 8;

                if t_bytes[..full_bytes] != n_bytes[..full_bytes] {
                    return false;
                }

                if remaining_bits > 0 && full_bytes < 16 {
                    let mask = !0u8 << (8 - remaining_bits);
                    (t_bytes[full_bytes] & mask) == (n_bytes[full_bytes] & mask)
                } else {
                    true
                }
            }
            _ => false,
        }
    }

    /// Check if msfvenom is available
    pub fn check_msfvenom_available() -> bool {
        std::process::Command::new("msfvenom")
            .arg("--version")
            .output()
            .is_ok()
    }

    /// Check if credentials have expired
    pub fn check_credential_expiry(&self, created_at: DateTime<Utc>) -> bool {
        let expiry = created_at + Duration::hours(self.config.credential_expiry_hours as i64);
        Utc::now() > expiry
    }

    /// Get the configuration
    pub fn config(&self) -> &ExploitSafetyConfig {
        &self.config
    }

    /// Update configuration
    pub fn update_config(&mut self, config: ExploitSafetyConfig) {
        self.config = config;
    }
}

// ============================================================================
// Audit Logging
// ============================================================================

/// Audit log entry for exploitation actions
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExploitAuditLog {
    pub id: String,
    pub user_id: String,
    pub campaign_id: Option<String>,
    pub action: ExploitAuditAction,
    pub target: Option<String>,
    pub details: serde_json::Value,
    pub timestamp: DateTime<Utc>,
    pub ip_address: Option<String>,
}

/// Exploitation audit actions
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum ExploitAuditAction {
    CampaignCreated,
    CampaignAuthorized,
    CampaignStarted,
    CampaignCompleted,
    CampaignCancelled,
    CampaignFailed,
    CredentialFound,
    HashExtracted,
    ShellGenerated,
    ModuleExecuted,
    SafetyViolation,
    ResultExported,
}

impl ExploitAuditLog {
    pub fn new(
        user_id: &str,
        action: ExploitAuditAction,
        campaign_id: Option<&str>,
        target: Option<&str>,
        details: serde_json::Value,
    ) -> Self {
        Self {
            id: uuid::Uuid::new_v4().to_string(),
            user_id: user_id.to_string(),
            campaign_id: campaign_id.map(String::from),
            action,
            target: target.map(String::from),
            details,
            timestamp: Utc::now(),
            ip_address: None,
        }
    }

    pub fn with_ip(mut self, ip: &str) -> Self {
        self.ip_address = Some(ip.to_string());
        self
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_pattern_matching() {
        assert!(SafetyController::matches_pattern("prod.example.com", "prod.*"));
        assert!(SafetyController::matches_pattern("app.prod.local", "*.prod.*"));
        assert!(SafetyController::matches_pattern("dc01.domain.local", "dc*"));
        assert!(!SafetyController::matches_pattern("web.example.com", "prod.*"));
    }

    #[test]
    fn test_cidr_matching() {
        assert!(SafetyController::ip_in_cidr("192.168.1.100", "192.168.1.0/24"));
        assert!(SafetyController::ip_in_cidr("10.0.0.1", "10.0.0.0/8"));
        assert!(!SafetyController::ip_in_cidr("192.168.2.1", "192.168.1.0/24"));
    }

    #[test]
    fn test_localhost_blocking() {
        let controller = SafetyController::with_default_config();

        assert!(controller.validate_target("localhost").is_some());
        assert!(controller.validate_target("127.0.0.1").is_some());
        assert!(controller.validate_target("::1").is_some());
    }

    #[test]
    fn test_password_spray_validation() {
        let mut controller = SafetyController::with_default_config();

        let config = PasswordSprayConfig {
            targets: vec!["192.168.1.1".to_string()],
            usernames: vec!["admin".to_string()],
            passwords: vec!["password".to_string()],
            delay_between_attempts_ms: 100, // Too low
            ..Default::default()
        };

        let violations = controller.validate_password_spray(&config, "test-campaign");

        // Should have violations for: unauthorized + insufficient delay
        assert!(violations.iter().any(|v| v.violation_type == SafetyViolationType::UnauthorizedExecution));
        assert!(violations.iter().any(|v| v.violation_type == SafetyViolationType::InsufficientDelay));

        // Authorize and try again
        controller.authorize_campaign("test-campaign");
        let violations = controller.validate_password_spray(&config, "test-campaign");

        // Should only have delay violation now
        assert!(!violations.iter().any(|v| v.violation_type == SafetyViolationType::UnauthorizedExecution));
    }
}
