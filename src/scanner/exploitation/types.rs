// Exploitation Framework Types
// Core types for the HeroForge exploitation module

#![allow(dead_code)]

use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

// ============================================================================
// Core Enums
// ============================================================================

/// Attack type categories
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]
#[serde(rename_all = "snake_case")]
pub enum AttackType {
    PasswordSpray,
    Kerberoast,
    AsrepRoast,
    SmbRelay,
    ShellGeneration,
    PostExploitation,
    CredentialDump,
    PrivilegeEscalation,
    Persistence,
    LateralMovement,
}

impl std::fmt::Display for AttackType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AttackType::PasswordSpray => write!(f, "Password Spray"),
            AttackType::Kerberoast => write!(f, "Kerberoasting"),
            AttackType::AsrepRoast => write!(f, "AS-REP Roasting"),
            AttackType::SmbRelay => write!(f, "SMB Relay"),
            AttackType::ShellGeneration => write!(f, "Shell Generation"),
            AttackType::PostExploitation => write!(f, "Post-Exploitation"),
            AttackType::CredentialDump => write!(f, "Credential Dump"),
            AttackType::PrivilegeEscalation => write!(f, "Privilege Escalation"),
            AttackType::Persistence => write!(f, "Persistence"),
            AttackType::LateralMovement => write!(f, "Lateral Movement"),
        }
    }
}

/// Campaign status
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum CampaignStatus {
    Pending,
    Running,
    Completed,
    Failed,
    Cancelled,
}

impl std::fmt::Display for CampaignStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            CampaignStatus::Pending => write!(f, "pending"),
            CampaignStatus::Running => write!(f, "running"),
            CampaignStatus::Completed => write!(f, "completed"),
            CampaignStatus::Failed => write!(f, "failed"),
            CampaignStatus::Cancelled => write!(f, "cancelled"),
        }
    }
}

/// Result types for exploitation findings
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum ResultType {
    CredentialFound,
    HashExtracted,
    ShellGenerated,
    PrivEscFound,
    PersistenceCreated,
    LateralMovement,
    CredentialDumped,
    Error,
}

/// Severity levels
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, PartialOrd, Ord)]
#[serde(rename_all = "snake_case")]
pub enum Severity {
    Info,
    Low,
    Medium,
    High,
    Critical,
}

// ============================================================================
// Password Spray Types
// ============================================================================

/// Protocol for password spraying
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum SprayProtocol {
    Smb,
    Ldap,
    Rdp,
    Ssh,
    HttpBasic,
    HttpNtlm,
    Kerberos,
    WinRm,
}

impl std::fmt::Display for SprayProtocol {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            SprayProtocol::Smb => write!(f, "SMB"),
            SprayProtocol::Ldap => write!(f, "LDAP"),
            SprayProtocol::Rdp => write!(f, "RDP"),
            SprayProtocol::Ssh => write!(f, "SSH"),
            SprayProtocol::HttpBasic => write!(f, "HTTP Basic"),
            SprayProtocol::HttpNtlm => write!(f, "HTTP NTLM"),
            SprayProtocol::Kerberos => write!(f, "Kerberos"),
            SprayProtocol::WinRm => write!(f, "WinRM"),
        }
    }
}

impl SprayProtocol {
    pub fn default_port(&self) -> u16 {
        match self {
            SprayProtocol::Smb => 445,
            SprayProtocol::Ldap => 389,
            SprayProtocol::Rdp => 3389,
            SprayProtocol::Ssh => 22,
            SprayProtocol::HttpBasic | SprayProtocol::HttpNtlm => 80,
            SprayProtocol::Kerberos => 88,
            SprayProtocol::WinRm => 5985,
        }
    }
}

/// Password spray configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PasswordSprayConfig {
    pub targets: Vec<String>,
    pub usernames: Vec<String>,
    pub passwords: Vec<String>,
    pub protocol: SprayProtocol,
    pub domain: Option<String>,
    pub port: Option<u16>,
    pub delay_between_attempts_ms: u64,
    pub delay_between_users_ms: u64,
    pub max_attempts_per_user: u32,
    pub stop_on_success: bool,
    pub threads: u32,
    pub use_ssl: bool,
}

impl Default for PasswordSprayConfig {
    fn default() -> Self {
        Self {
            targets: Vec::new(),
            usernames: Vec::new(),
            passwords: Vec::new(),
            protocol: SprayProtocol::Ldap,
            domain: None,
            port: None,
            delay_between_attempts_ms: 1000,
            delay_between_users_ms: 500,
            max_attempts_per_user: 3,
            stop_on_success: false,
            threads: 5,
            use_ssl: false,
        }
    }
}

/// Result of a password spray attempt
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SprayResult {
    pub target: String,
    pub username: String,
    pub password: String,
    pub protocol: SprayProtocol,
    pub success: bool,
    pub error: Option<String>,
    pub timestamp: DateTime<Utc>,
}

// ============================================================================
// Kerberos Attack Types
// ============================================================================

/// Hash output format
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum HashFormat {
    Hashcat,
    John,
}

/// Kerberoasting configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct KerberoastConfig {
    pub domain_controller: String,
    pub domain: String,
    pub username: String,
    pub password: Option<String>,
    pub ntlm_hash: Option<String>,
    pub target_spns: Option<Vec<String>>,
    pub output_format: HashFormat,
    pub request_rc4: bool,
}

impl Default for KerberoastConfig {
    fn default() -> Self {
        Self {
            domain_controller: String::new(),
            domain: String::new(),
            username: String::new(),
            password: None,
            ntlm_hash: None,
            target_spns: None,
            output_format: HashFormat::Hashcat,
            request_rc4: true,
        }
    }
}

/// Kerberoasting result
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct KerberoastResult {
    pub spn: String,
    pub username: String,
    pub hash: String,
    pub hash_format: HashFormat,
    pub encryption_type: String,
    pub crackable: bool,
    pub timestamp: DateTime<Utc>,
}

/// AS-REP Roasting configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AsrepRoastConfig {
    pub domain_controller: String,
    pub domain: String,
    pub usernames: Vec<String>,
    pub enumerate_users: bool,
    pub output_format: HashFormat,
}

impl Default for AsrepRoastConfig {
    fn default() -> Self {
        Self {
            domain_controller: String::new(),
            domain: String::new(),
            usernames: Vec::new(),
            enumerate_users: false,
            output_format: HashFormat::Hashcat,
        }
    }
}

/// AS-REP Roasting result
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AsrepRoastResult {
    pub username: String,
    pub hash: String,
    pub hash_format: HashFormat,
    pub timestamp: DateTime<Utc>,
}

// ============================================================================
// Shell Generator Types
// ============================================================================

/// Shell type
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum ShellType {
    ReverseShell,
    BindShell,
    WebShell,
}

impl std::fmt::Display for ShellType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ShellType::ReverseShell => write!(f, "Reverse Shell"),
            ShellType::BindShell => write!(f, "Bind Shell"),
            ShellType::WebShell => write!(f, "Web Shell"),
        }
    }
}

/// Target platform
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum Platform {
    Windows,
    Linux,
    MacOS,
    Universal,
}

impl std::fmt::Display for Platform {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Platform::Windows => write!(f, "Windows"),
            Platform::Linux => write!(f, "Linux"),
            Platform::MacOS => write!(f, "macOS"),
            Platform::Universal => write!(f, "Universal"),
        }
    }
}

/// Architecture for binary payloads
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Default)]
#[serde(rename_all = "snake_case")]
pub enum Architecture {
    #[default]
    X64,
    X86,
}

impl std::fmt::Display for Architecture {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Architecture::X64 => write!(f, "x64"),
            Architecture::X86 => write!(f, "x86"),
        }
    }
}

/// MSF encoder type for payload encoding
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Default)]
#[serde(rename_all = "snake_case")]
pub enum MsfEncoder {
    #[default]
    None,
    ShikataGaNai,
    Xor,
    XorDynamic,
    AlphanumMixed,
    AlphanumUpper,
    CountDown,
    Jmp,
}

impl MsfEncoder {
    pub fn as_str(&self) -> Option<&'static str> {
        match self {
            MsfEncoder::None => None,
            MsfEncoder::ShikataGaNai => Some("x86/shikata_ga_nai"),
            MsfEncoder::Xor => Some("x86/xor"),
            MsfEncoder::XorDynamic => Some("x86/xor_dynamic"),
            MsfEncoder::AlphanumMixed => Some("x86/alpha_mixed"),
            MsfEncoder::AlphanumUpper => Some("x86/alpha_upper"),
            MsfEncoder::CountDown => Some("x86/countdown"),
            MsfEncoder::Jmp => Some("x86/jmp_call_additive"),
        }
    }
}

/// Shell output format
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum ShellFormat {
    // Script-based
    PowerShell,
    Bash,
    Python,
    Perl,
    Php,
    Aspx,
    Jsp,
    // Meterpreter TCP (requires msfvenom)
    MeterpreterExe,
    MeterpreterElf,
    MeterpreterDll,
    MeterpreterPowerShell,
    MeterpreterPython,
    // Meterpreter HTTPS (requires msfvenom)
    MeterpreterHttpsExe,
    MeterpreterHttpsElf,
    MeterpreterHttpsPowerShell,
    // Shell (non-Meterpreter, simpler)
    ShellReverseExe,
    ShellReverseElf,
}

impl ShellFormat {
    pub fn is_meterpreter(&self) -> bool {
        matches!(
            self,
            ShellFormat::MeterpreterExe
                | ShellFormat::MeterpreterElf
                | ShellFormat::MeterpreterDll
                | ShellFormat::MeterpreterPowerShell
                | ShellFormat::MeterpreterPython
                | ShellFormat::MeterpreterHttpsExe
                | ShellFormat::MeterpreterHttpsElf
                | ShellFormat::MeterpreterHttpsPowerShell
                | ShellFormat::ShellReverseExe
                | ShellFormat::ShellReverseElf
        )
    }

    pub fn is_binary(&self) -> bool {
        matches!(
            self,
            ShellFormat::MeterpreterExe
                | ShellFormat::MeterpreterElf
                | ShellFormat::MeterpreterDll
                | ShellFormat::MeterpreterHttpsExe
                | ShellFormat::MeterpreterHttpsElf
                | ShellFormat::ShellReverseExe
                | ShellFormat::ShellReverseElf
        )
    }

    pub fn file_extension(&self) -> &'static str {
        match self {
            ShellFormat::PowerShell | ShellFormat::MeterpreterPowerShell | ShellFormat::MeterpreterHttpsPowerShell => "ps1",
            ShellFormat::Bash => "sh",
            ShellFormat::Python | ShellFormat::MeterpreterPython => "py",
            ShellFormat::Perl => "pl",
            ShellFormat::Php => "php",
            ShellFormat::Aspx => "aspx",
            ShellFormat::Jsp => "jsp",
            ShellFormat::MeterpreterExe | ShellFormat::MeterpreterHttpsExe | ShellFormat::ShellReverseExe => "exe",
            ShellFormat::MeterpreterElf | ShellFormat::MeterpreterHttpsElf | ShellFormat::ShellReverseElf => "elf",
            ShellFormat::MeterpreterDll => "dll",
        }
    }
}

/// Encoding type for payloads
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Default)]
#[serde(rename_all = "snake_case")]
pub enum EncodingType {
    #[default]
    None,
    Base64,
    Hex,
    Xor,
}

/// Shell generation configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ShellConfig {
    pub shell_type: ShellType,
    pub platform: Platform,
    pub format: ShellFormat,
    pub lhost: String,
    pub lport: u16,
    pub encoding: EncodingType,
    pub obfuscation_level: u8,
    pub staged: bool,
    pub xor_key: Option<String>,
    /// Architecture for binary payloads (x86 or x64)
    #[serde(default)]
    pub architecture: Architecture,
    /// MSF encoder for msfvenom payloads
    #[serde(default)]
    pub msf_encoder: MsfEncoder,
    /// Number of encoder iterations
    #[serde(default = "default_encoder_iterations")]
    pub encoder_iterations: u8,
    /// Custom bad characters to avoid (e.g., "\x00\x0a")
    #[serde(default)]
    pub bad_chars: Option<String>,
    /// EXITFUNC option for msfvenom (thread, process, seh, none)
    #[serde(default)]
    pub exit_func: Option<String>,
}

fn default_encoder_iterations() -> u8 { 1 }

impl Default for ShellConfig {
    fn default() -> Self {
        Self {
            shell_type: ShellType::ReverseShell,
            platform: Platform::Linux,
            format: ShellFormat::Bash,
            lhost: String::new(),
            lport: 4444,
            encoding: EncodingType::None,
            obfuscation_level: 0,
            staged: false,
            xor_key: None,
            architecture: Architecture::X64,
            msf_encoder: MsfEncoder::None,
            encoder_iterations: 1,
            bad_chars: None,
            exit_func: None,
        }
    }
}

/// Generated shell result
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ShellResult {
    pub id: String,
    pub payload: String,
    pub payload_hash: String,
    pub format: ShellFormat,
    pub platform: Platform,
    pub listener_command: String,
    pub one_liner: Option<String>,
    pub created_at: DateTime<Utc>,
}

// ============================================================================
// Post-Exploitation Types
// ============================================================================

/// Post-exploitation module categories
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum PostExploitCategory {
    CredentialHarvesting,
    PrivilegeEscalation,
    Persistence,
    LateralMovement,
    Discovery,
}

/// Post-exploitation modules
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum PostExploitModule {
    // Credential Harvesting
    DumpSam,
    DumpLsass,
    ExtractBrowserCreds,
    ExtractWifiPasswords,
    DumpKeePass,
    ExtractSshKeys,
    DumpCredMan,

    // Privilege Escalation Checks
    CheckAlwaysInstallElevated,
    CheckUnquotedPaths,
    CheckWeakServicePerms,
    CheckSeImpersonate,
    CheckSudoers,
    CheckSuid,
    CheckCapabilities,

    // Persistence
    CreateScheduledTask,
    AddRegistryRunKey,
    CreateService,
    AddCronJob,
    AddSshKey,
    WmiEventSub,

    // Lateral Movement
    PassTheHash,
    PassTheTicket,
    PsExec,
    WmiExec,
    SshPivot,
    RdpHijack,

    // Discovery
    NetworkShares,
    DomainUsers,
    LocalUsers,
    InstalledSoftware,
    RunningProcesses,
}

impl PostExploitModule {
    pub fn category(&self) -> PostExploitCategory {
        match self {
            PostExploitModule::DumpSam
            | PostExploitModule::DumpLsass
            | PostExploitModule::ExtractBrowserCreds
            | PostExploitModule::ExtractWifiPasswords
            | PostExploitModule::DumpKeePass
            | PostExploitModule::ExtractSshKeys
            | PostExploitModule::DumpCredMan => PostExploitCategory::CredentialHarvesting,

            PostExploitModule::CheckAlwaysInstallElevated
            | PostExploitModule::CheckUnquotedPaths
            | PostExploitModule::CheckWeakServicePerms
            | PostExploitModule::CheckSeImpersonate
            | PostExploitModule::CheckSudoers
            | PostExploitModule::CheckSuid
            | PostExploitModule::CheckCapabilities => PostExploitCategory::PrivilegeEscalation,

            PostExploitModule::CreateScheduledTask
            | PostExploitModule::AddRegistryRunKey
            | PostExploitModule::CreateService
            | PostExploitModule::AddCronJob
            | PostExploitModule::AddSshKey
            | PostExploitModule::WmiEventSub => PostExploitCategory::Persistence,

            PostExploitModule::PassTheHash
            | PostExploitModule::PassTheTicket
            | PostExploitModule::PsExec
            | PostExploitModule::WmiExec
            | PostExploitModule::SshPivot
            | PostExploitModule::RdpHijack => PostExploitCategory::LateralMovement,

            PostExploitModule::NetworkShares
            | PostExploitModule::DomainUsers
            | PostExploitModule::LocalUsers
            | PostExploitModule::InstalledSoftware
            | PostExploitModule::RunningProcesses => PostExploitCategory::Discovery,
        }
    }

    pub fn supported_platforms(&self) -> Vec<Platform> {
        match self {
            // Windows-only
            PostExploitModule::DumpSam
            | PostExploitModule::DumpLsass
            | PostExploitModule::DumpCredMan
            | PostExploitModule::CheckAlwaysInstallElevated
            | PostExploitModule::CheckUnquotedPaths
            | PostExploitModule::CheckWeakServicePerms
            | PostExploitModule::CheckSeImpersonate
            | PostExploitModule::CreateScheduledTask
            | PostExploitModule::AddRegistryRunKey
            | PostExploitModule::CreateService
            | PostExploitModule::WmiEventSub
            | PostExploitModule::PassTheHash
            | PostExploitModule::PassTheTicket
            | PostExploitModule::PsExec
            | PostExploitModule::WmiExec
            | PostExploitModule::RdpHijack => vec![Platform::Windows],

            // Linux/macOS
            PostExploitModule::CheckSudoers
            | PostExploitModule::CheckSuid
            | PostExploitModule::CheckCapabilities
            | PostExploitModule::AddCronJob => vec![Platform::Linux, Platform::MacOS],

            // Cross-platform
            PostExploitModule::ExtractBrowserCreds
            | PostExploitModule::ExtractWifiPasswords
            | PostExploitModule::DumpKeePass
            | PostExploitModule::ExtractSshKeys
            | PostExploitModule::AddSshKey
            | PostExploitModule::SshPivot
            | PostExploitModule::NetworkShares
            | PostExploitModule::DomainUsers
            | PostExploitModule::LocalUsers
            | PostExploitModule::InstalledSoftware
            | PostExploitModule::RunningProcesses => {
                vec![Platform::Windows, Platform::Linux, Platform::MacOS]
            }
        }
    }

    pub fn description(&self) -> &'static str {
        match self {
            PostExploitModule::DumpSam => "Extract password hashes from SAM database",
            PostExploitModule::DumpLsass => "Extract credentials from LSASS process memory",
            PostExploitModule::ExtractBrowserCreds => "Extract saved passwords from browsers",
            PostExploitModule::ExtractWifiPasswords => "Extract stored WiFi passwords",
            PostExploitModule::DumpKeePass => "Extract KeePass database master key",
            PostExploitModule::ExtractSshKeys => "Find and extract SSH private keys",
            PostExploitModule::DumpCredMan => "Dump Windows Credential Manager",
            PostExploitModule::CheckAlwaysInstallElevated => {
                "Check for AlwaysInstallElevated registry key"
            }
            PostExploitModule::CheckUnquotedPaths => {
                "Find services with unquoted executable paths"
            }
            PostExploitModule::CheckWeakServicePerms => "Check for weak service permissions",
            PostExploitModule::CheckSeImpersonate => "Check for SeImpersonate privilege",
            PostExploitModule::CheckSudoers => "Check sudo configuration for privilege escalation",
            PostExploitModule::CheckSuid => "Find SUID binaries for privilege escalation",
            PostExploitModule::CheckCapabilities => "Check for Linux capabilities abuse",
            PostExploitModule::CreateScheduledTask => "Create scheduled task for persistence",
            PostExploitModule::AddRegistryRunKey => "Add registry run key for persistence",
            PostExploitModule::CreateService => "Create Windows service for persistence",
            PostExploitModule::AddCronJob => "Add cron job for persistence",
            PostExploitModule::AddSshKey => "Add SSH authorized key for persistence",
            PostExploitModule::WmiEventSub => "Create WMI event subscription for persistence",
            PostExploitModule::PassTheHash => "Authenticate using NTLM hash",
            PostExploitModule::PassTheTicket => "Authenticate using Kerberos ticket",
            PostExploitModule::PsExec => "Remote execution via PsExec",
            PostExploitModule::WmiExec => "Remote execution via WMI",
            PostExploitModule::SshPivot => "SSH tunnel for pivoting",
            PostExploitModule::RdpHijack => "Hijack RDP session",
            PostExploitModule::NetworkShares => "Enumerate network shares",
            PostExploitModule::DomainUsers => "Enumerate domain users",
            PostExploitModule::LocalUsers => "Enumerate local users",
            PostExploitModule::InstalledSoftware => "List installed software",
            PostExploitModule::RunningProcesses => "List running processes",
        }
    }
}

/// Post-exploitation module configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PostExploitConfig {
    pub module: PostExploitModule,
    pub target: String,
    pub credentials: Option<Credentials>,
    pub options: HashMap<String, serde_json::Value>,
}

/// Credentials for authentication
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Credentials {
    pub username: String,
    pub password: Option<String>,
    pub ntlm_hash: Option<String>,
    pub domain: Option<String>,
    pub ssh_key: Option<String>,
}

/// Post-exploitation result
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PostExploitResult {
    pub module: PostExploitModule,
    pub target: String,
    pub success: bool,
    pub findings: Vec<PostExploitFinding>,
    pub error: Option<String>,
    pub timestamp: DateTime<Utc>,
}

/// Individual finding from post-exploitation
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PostExploitFinding {
    pub finding_type: String,
    pub value: String,
    pub details: Option<HashMap<String, serde_json::Value>>,
    pub severity: Severity,
}

// ============================================================================
// Campaign Types
// ============================================================================

/// Exploitation campaign
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExploitationCampaign {
    pub id: String,
    pub user_id: String,
    pub name: String,
    pub attack_type: AttackType,
    pub status: CampaignStatus,
    pub config: serde_json::Value,
    pub targets: Vec<String>,
    pub created_at: DateTime<Utc>,
    pub started_at: Option<DateTime<Utc>>,
    pub completed_at: Option<DateTime<Utc>>,
}

/// Exploitation result stored in database
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExploitationResult {
    pub id: String,
    pub campaign_id: String,
    pub target: String,
    pub result_type: ResultType,
    pub data: serde_json::Value,
    pub severity: Option<Severity>,
    pub created_at: DateTime<Utc>,
}

/// Generated payload record
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GeneratedPayload {
    pub id: String,
    pub user_id: String,
    pub payload_type: ShellType,
    pub platform: Platform,
    pub format: ShellFormat,
    pub config: serde_json::Value,
    pub payload_hash: String,
    pub created_at: DateTime<Utc>,
}

// ============================================================================
// Progress Messages (for WebSocket)
// ============================================================================

/// Progress messages sent via WebSocket during exploitation
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum ExploitationProgress {
    CampaignStarted {
        campaign_id: String,
        attack_type: AttackType,
        total_targets: usize,
    },
    TargetStarted {
        target: String,
        index: usize,
        total: usize,
    },
    AttemptMade {
        target: String,
        username: String,
        success: bool,
    },
    CredentialFound {
        target: String,
        username: String,
        credential_type: String,
    },
    HashExtracted {
        target: String,
        username: String,
        hash_type: String,
    },
    ShellGenerated {
        payload_id: String,
        format: ShellFormat,
    },
    ModuleCompleted {
        module: PostExploitModule,
        success: bool,
        findings_count: usize,
    },
    CampaignProgress {
        progress_percent: u8,
        message: String,
    },
    CampaignCompleted {
        campaign_id: String,
        total_results: usize,
        successful: usize,
        duration_ms: u64,
    },
    CampaignCancelled {
        campaign_id: String,
    },
    Error {
        message: String,
    },
}
