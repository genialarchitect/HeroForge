// Exploitation Engine
// Main orchestrator for exploitation campaigns

use crate::scanner::exploitation::types::*;
use crate::scanner::exploitation::safety::*;
use anyhow::{anyhow, Result};
use chrono::Utc;
use log::{error, info, warn};
use std::sync::Arc;
use tokio::sync::{broadcast, RwLock, Semaphore};

/// Main exploitation engine
pub struct ExploitationEngine {
    safety: Arc<RwLock<SafetyController>>,
    max_concurrent: usize,
    progress_tx: Option<broadcast::Sender<ExploitationProgress>>,
}

impl ExploitationEngine {
    pub fn new(safety_config: ExploitSafetyConfig) -> Self {
        let max_concurrent = safety_config.max_concurrent_attacks as usize;
        Self {
            safety: Arc::new(RwLock::new(SafetyController::new(safety_config))),
            max_concurrent,
            progress_tx: None,
        }
    }

    pub fn with_default_safety() -> Self {
        Self::new(ExploitSafetyConfig::default())
    }

    /// Set progress broadcast channel
    pub fn set_progress_channel(&mut self, tx: broadcast::Sender<ExploitationProgress>) {
        self.progress_tx = Some(tx);
    }

    /// Create a new progress broadcast channel
    pub fn create_progress_channel(&mut self) -> broadcast::Receiver<ExploitationProgress> {
        let (tx, rx) = broadcast::channel(100);
        self.progress_tx = Some(tx);
        rx
    }

    /// Send progress update
    fn send_progress(&self, progress: ExploitationProgress) {
        if let Some(tx) = &self.progress_tx {
            let _ = tx.send(progress);
        }
    }

    /// Authorize a campaign for execution
    pub async fn authorize_campaign(&self, campaign_id: &str) {
        let mut safety = self.safety.write().await;
        safety.authorize_campaign(campaign_id);
    }

    /// Run a password spray campaign
    pub async fn run_password_spray(
        &self,
        campaign_id: &str,
        config: PasswordSprayConfig,
    ) -> Result<Vec<SprayResult>> {
        // Validate configuration
        let safety = self.safety.read().await;
        let violations = safety.validate_password_spray(&config, campaign_id);
        drop(safety);

        if !violations.is_empty() {
            let error_msgs: Vec<String> = violations.iter().map(|v| v.message.clone()).collect();
            return Err(anyhow!("Safety violations: {}", error_msgs.join("; ")));
        }

        info!(
            "Starting password spray campaign {} with {} targets, {} users, {} passwords",
            campaign_id,
            config.targets.len(),
            config.usernames.len(),
            config.passwords.len()
        );

        self.send_progress(ExploitationProgress::CampaignStarted {
            campaign_id: campaign_id.to_string(),
            attack_type: AttackType::PasswordSpray,
            total_targets: config.targets.len(),
        });

        let mut results = Vec::new();
        let semaphore = Arc::new(Semaphore::new(config.threads as usize));
        let total_attempts = config.targets.len() * config.usernames.len() * config.passwords.len();
        let mut completed = 0;

        for (target_idx, target) in config.targets.iter().enumerate() {
            self.send_progress(ExploitationProgress::TargetStarted {
                target: target.clone(),
                index: target_idx + 1,
                total: config.targets.len(),
            });

            for username in &config.usernames {
                for password in &config.passwords {
                    let _permit = semaphore.clone().acquire_owned().await?;

                    // Attempt authentication based on protocol
                    let result = self
                        .attempt_spray(
                            target,
                            username,
                            password,
                            &config.protocol,
                            config.domain.as_deref(),
                            config.port,
                            config.use_ssl,
                        )
                        .await;

                    let success = result.success;

                    self.send_progress(ExploitationProgress::AttemptMade {
                        target: target.clone(),
                        username: username.clone(),
                        success,
                    });

                    if success {
                        self.send_progress(ExploitationProgress::CredentialFound {
                            target: target.clone(),
                            username: username.clone(),
                            credential_type: "password".to_string(),
                        });

                        if config.stop_on_success {
                            results.push(result);
                            return Ok(results);
                        }
                    }

                    results.push(result);
                    completed += 1;

                    // Progress update every 10%
                    if completed % (total_attempts / 10).max(1) == 0 {
                        let progress = ((completed as f64 / total_attempts as f64) * 100.0) as u8;
                        self.send_progress(ExploitationProgress::CampaignProgress {
                            progress_percent: progress,
                            message: format!("Completed {}/{} attempts", completed, total_attempts),
                        });
                    }

                    // Delay between attempts
                    if config.delay_between_attempts_ms > 0 {
                        tokio::time::sleep(tokio::time::Duration::from_millis(
                            config.delay_between_attempts_ms,
                        ))
                        .await;
                    }
                }

                // Delay between users
                if config.delay_between_users_ms > 0 {
                    tokio::time::sleep(tokio::time::Duration::from_millis(
                        config.delay_between_users_ms,
                    ))
                    .await;
                }
            }
        }

        let successful = results.iter().filter(|r| r.success).count();
        self.send_progress(ExploitationProgress::CampaignCompleted {
            campaign_id: campaign_id.to_string(),
            total_results: results.len(),
            successful,
            duration_ms: 0, // TODO: Track actual duration
        });

        Ok(results)
    }

    /// Attempt a single spray authentication
    async fn attempt_spray(
        &self,
        target: &str,
        username: &str,
        password: &str,
        protocol: &SprayProtocol,
        domain: Option<&str>,
        port: Option<u16>,
        use_ssl: bool,
    ) -> SprayResult {
        let port = port.unwrap_or_else(|| protocol.default_port());
        let full_username = match domain {
            Some(d) => format!("{}\\{}", d, username),
            None => username.to_string(),
        };

        // TODO: Implement actual protocol handlers
        // For now, return a placeholder result
        let (success, error) = match protocol {
            SprayProtocol::Ssh => {
                crate::scanner::exploitation::password_spray::try_ssh(target, port, &full_username, password).await
            }
            SprayProtocol::Ldap => {
                crate::scanner::exploitation::password_spray::try_ldap(target, port, &full_username, password, use_ssl).await
            }
            SprayProtocol::Smb => {
                crate::scanner::exploitation::password_spray::try_smb(target, port, &full_username, password).await
            }
            _ => {
                // Placeholder for other protocols
                (false, Some("Protocol not yet implemented".to_string()))
            }
        };

        SprayResult {
            target: target.to_string(),
            username: full_username,
            password: password.to_string(),
            protocol: protocol.clone(),
            success,
            error,
            timestamp: Utc::now(),
        }
    }

    /// Run Kerberoasting attack
    pub async fn run_kerberoast(
        &self,
        campaign_id: &str,
        config: KerberoastConfig,
    ) -> Result<Vec<KerberoastResult>> {
        let safety = self.safety.read().await;
        let violations = safety.validate_kerberos(&config, campaign_id);
        drop(safety);

        if !violations.is_empty() {
            let error_msgs: Vec<String> = violations.iter().map(|v| v.message.clone()).collect();
            return Err(anyhow!("Safety violations: {}", error_msgs.join("; ")));
        }

        info!(
            "Starting Kerberoast attack against {} in domain {}",
            config.domain_controller, config.domain
        );

        self.send_progress(ExploitationProgress::CampaignStarted {
            campaign_id: campaign_id.to_string(),
            attack_type: AttackType::Kerberoast,
            total_targets: 1,
        });

        let results = crate::scanner::exploitation::kerberos::run_kerberoast(&config).await?;

        for result in &results {
            self.send_progress(ExploitationProgress::HashExtracted {
                target: config.domain_controller.clone(),
                username: result.username.clone(),
                hash_type: result.encryption_type.clone(),
            });
        }

        self.send_progress(ExploitationProgress::CampaignCompleted {
            campaign_id: campaign_id.to_string(),
            total_results: results.len(),
            successful: results.len(),
            duration_ms: 0,
        });

        Ok(results)
    }

    /// Run AS-REP Roasting attack
    pub async fn run_asrep_roast(
        &self,
        campaign_id: &str,
        config: AsrepRoastConfig,
    ) -> Result<Vec<AsrepRoastResult>> {
        let safety = self.safety.read().await;
        let violations = safety.validate_asrep_roast(&config, campaign_id);
        drop(safety);

        if !violations.is_empty() {
            let error_msgs: Vec<String> = violations.iter().map(|v| v.message.clone()).collect();
            return Err(anyhow!("Safety violations: {}", error_msgs.join("; ")));
        }

        info!(
            "Starting AS-REP Roast attack against {} in domain {}",
            config.domain_controller, config.domain
        );

        self.send_progress(ExploitationProgress::CampaignStarted {
            campaign_id: campaign_id.to_string(),
            attack_type: AttackType::AsrepRoast,
            total_targets: config.usernames.len(),
        });

        let results = crate::scanner::exploitation::kerberos::run_asrep_roast(&config).await?;

        for result in &results {
            self.send_progress(ExploitationProgress::HashExtracted {
                target: config.domain_controller.clone(),
                username: result.username.clone(),
                hash_type: "AS-REP".to_string(),
            });
        }

        self.send_progress(ExploitationProgress::CampaignCompleted {
            campaign_id: campaign_id.to_string(),
            total_results: results.len(),
            successful: results.len(),
            duration_ms: 0,
        });

        Ok(results)
    }

    /// Generate a shell payload
    pub async fn generate_shell(&self, config: ShellConfig) -> Result<ShellResult> {
        let safety = self.safety.read().await;
        let violations = safety.validate_shell_config(&config);
        drop(safety);

        if !violations.is_empty() {
            let error_msgs: Vec<String> = violations.iter().map(|v| v.message.clone()).collect();
            return Err(anyhow!("Safety violations: {}", error_msgs.join("; ")));
        }

        info!(
            "Generating {:?} shell for {:?} ({:?})",
            config.shell_type, config.platform, config.format
        );

        let result = crate::scanner::exploitation::shells::generate_shell(&config).await?;

        self.send_progress(ExploitationProgress::ShellGenerated {
            payload_id: result.id.clone(),
            format: result.format.clone(),
        });

        Ok(result)
    }

    /// Run a post-exploitation module
    pub async fn run_post_exploit(
        &self,
        campaign_id: &str,
        config: PostExploitConfig,
    ) -> Result<PostExploitResult> {
        let safety = self.safety.read().await;
        let violations = safety.validate_post_exploit(&config, campaign_id);
        drop(safety);

        if !violations.is_empty() {
            let error_msgs: Vec<String> = violations.iter().map(|v| v.message.clone()).collect();
            return Err(anyhow!("Safety violations: {}", error_msgs.join("; ")));
        }

        info!(
            "Running post-exploitation module {:?} against {}",
            config.module, config.target
        );

        let result = crate::scanner::exploitation::post_exploit::run_module(&config).await?;

        self.send_progress(ExploitationProgress::ModuleCompleted {
            module: config.module,
            success: result.success,
            findings_count: result.findings.len(),
        });

        Ok(result)
    }

    /// Get safety configuration
    pub async fn get_safety_config(&self) -> ExploitSafetyConfig {
        let safety = self.safety.read().await;
        safety.config().clone()
    }

    /// Update safety configuration
    pub async fn update_safety_config(&self, config: ExploitSafetyConfig) {
        let mut safety = self.safety.write().await;
        safety.update_config(config);
    }

    /// Check if msfvenom is available
    pub fn check_msfvenom() -> bool {
        SafetyController::check_msfvenom_available()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_engine_creation() {
        let engine = ExploitationEngine::with_default_safety();
        assert!(!engine.check_msfvenom()); // Likely not installed in test env
    }

    #[tokio::test]
    async fn test_unauthorized_campaign_fails() {
        let engine = ExploitationEngine::with_default_safety();

        let config = PasswordSprayConfig {
            targets: vec!["192.168.1.1".to_string()],
            usernames: vec!["admin".to_string()],
            passwords: vec!["password".to_string()],
            ..Default::default()
        };

        let result = engine.run_password_spray("unauthorized-campaign", config).await;
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("unauthorized"));
    }
}
