// Password Spray Module
// Implements password spraying attacks with lockout evasion

mod protocols;
mod wordlists;

pub use protocols::*;
pub use wordlists::*;

use crate::scanner::exploitation::types::*;
use anyhow::Result;
use log::{debug, info, warn};

/// Common password lists for spraying
pub fn get_common_passwords() -> Vec<String> {
    wordlists::COMMON_PASSWORDS
        .iter()
        .map(|s| s.to_string())
        .collect()
}

/// Season-based passwords (Spring2024!, Winter2024!, etc.)
pub fn get_seasonal_passwords(year: u16) -> Vec<String> {
    let seasons = ["Spring", "Summer", "Fall", "Winter"];
    let suffixes = ["!", "@", "#", "1", "123"];

    let mut passwords = Vec::new();
    for season in &seasons {
        for suffix in &suffixes {
            passwords.push(format!("{}{}{}", season, year, suffix));
            passwords.push(format!("{}{}{}", season, year - 1, suffix));
        }
    }
    passwords
}

/// Company-based password variants
pub fn get_company_passwords(company_name: &str) -> Vec<String> {
    let base = company_name.to_lowercase();
    let capitalized = capitalize_first(&base);
    let upper = company_name.to_uppercase();

    let suffixes = [
        "!", "@", "#", "1", "123", "2024", "2024!", "2023", "2023!",
        "@123", "!123", "#1", "1!", "12!", "123!",
    ];

    let mut passwords = Vec::new();
    for suffix in &suffixes {
        passwords.push(format!("{}{}", base, suffix));
        passwords.push(format!("{}{}", capitalized, suffix));
        passwords.push(format!("{}{}", upper, suffix));
    }
    passwords
}

fn capitalize_first(s: &str) -> String {
    let mut chars = s.chars();
    match chars.next() {
        None => String::new(),
        Some(c) => c.to_uppercase().collect::<String>() + chars.as_str(),
    }
}

/// Try SSH authentication
pub async fn try_ssh(
    host: &str,
    port: u16,
    username: &str,
    password: &str,
) -> (bool, Option<String>) {
    protocols::ssh::try_auth(host, port, username, password).await
}

/// Try LDAP authentication
pub async fn try_ldap(
    host: &str,
    port: u16,
    username: &str,
    password: &str,
    use_ssl: bool,
) -> (bool, Option<String>) {
    protocols::ldap::try_auth(host, port, username, password, use_ssl).await
}

/// Try SMB authentication
pub async fn try_smb(
    host: &str,
    port: u16,
    username: &str,
    password: &str,
) -> (bool, Option<String>) {
    protocols::smb::try_auth(host, port, username, password).await
}

/// Try RDP authentication
pub async fn try_rdp(
    host: &str,
    port: u16,
    username: &str,
    password: &str,
) -> (bool, Option<String>) {
    protocols::rdp::try_auth(host, port, username, password).await
}

/// Try WinRM authentication
pub async fn try_winrm(
    host: &str,
    port: u16,
    username: &str,
    password: &str,
    use_ssl: bool,
) -> (bool, Option<String>) {
    protocols::winrm::try_auth(host, port, username, password, use_ssl).await
}

/// Try HTTP Basic authentication
pub async fn try_http_basic(
    host: &str,
    port: u16,
    path: &str,
    username: &str,
    password: &str,
    use_ssl: bool,
) -> (bool, Option<String>) {
    protocols::http::try_basic_auth(host, port, path, username, password, use_ssl).await
}

/// Try HTTP NTLM authentication
pub async fn try_http_ntlm(
    host: &str,
    port: u16,
    path: &str,
    username: &str,
    password: &str,
    domain: Option<&str>,
    use_ssl: bool,
) -> (bool, Option<String>) {
    protocols::http::try_ntlm_auth(host, port, path, username, password, domain, use_ssl).await
}

/// Try Kerberos authentication
pub async fn try_kerberos(
    kdc: &str,
    realm: &str,
    username: &str,
    password: &str,
) -> (bool, Option<String>) {
    protocols::kerberos::try_auth(kdc, realm, username, password).await
}
