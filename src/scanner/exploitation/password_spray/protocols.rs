// Protocol-specific authentication implementations
// Each protocol module implements try_auth() for password spraying

pub mod ssh {
    use log::{debug, warn, info};
    use std::net::TcpStream;
    use ssh2::Session;
    use std::time::Duration;

    pub async fn try_auth(
        host: &str,
        port: u16,
        username: &str,
        password: &str,
    ) -> (bool, Option<String>) {
        let addr = format!("{}:{}", host, port);
        let username = username.to_string();
        let password = password.to_string();
        let addr_clone = addr.clone();

        // Run SSH connection in blocking thread since ssh2 is synchronous
        let result = tokio::task::spawn_blocking(move || {
            // Connect with timeout
            let tcp = match TcpStream::connect_timeout(
                &addr_clone.parse().unwrap_or_else(|_| {
                    format!("{}:{}", "0.0.0.0", port).parse().unwrap()
                }),
                Duration::from_secs(10),
            ) {
                Ok(stream) => stream,
                Err(e) => {
                    warn!("SSH connection to {} failed: {}", addr_clone, e);
                    return (false, Some(format!("Connection failed: {}", e)));
                }
            };

            // Set read/write timeouts
            let _ = tcp.set_read_timeout(Some(Duration::from_secs(15)));
            let _ = tcp.set_write_timeout(Some(Duration::from_secs(15)));

            // Create SSH session
            let mut session = match Session::new() {
                Ok(s) => s,
                Err(e) => {
                    return (false, Some(format!("Failed to create SSH session: {}", e)));
                }
            };

            session.set_tcp_stream(tcp);

            // Perform SSH handshake
            if let Err(e) = session.handshake() {
                debug!("SSH handshake failed for {}: {}", addr_clone, e);
                return (false, Some(format!("SSH handshake failed: {}", e)));
            }

            // Try password authentication
            match session.userauth_password(&username, &password) {
                Ok(_) => {
                    if session.authenticated() {
                        info!("SSH authentication successful: {}@{}", username, addr_clone);
                        (true, None)
                    } else {
                        debug!("SSH auth returned OK but not authenticated for {}@{}", username, addr_clone);
                        (false, Some("Authentication status unclear".to_string()))
                    }
                }
                Err(e) => {
                    // Check for common auth failure patterns
                    let error_msg = e.to_string();
                    if error_msg.contains("USERAUTH_DENIED") ||
                       error_msg.contains("authentication failed") ||
                       error_msg.contains("Permission denied") {
                        debug!("SSH auth failed for {}@{}: {}", username, addr_clone, e);
                        (false, Some("Invalid credentials".to_string()))
                    } else {
                        warn!("SSH auth error for {}@{}: {}", username, addr_clone, e);
                        (false, Some(format!("Auth error: {}", e)))
                    }
                }
            }
        }).await;

        match result {
            Ok(r) => r,
            Err(e) => {
                warn!("SSH task panicked for {}: {}", addr, e);
                (false, Some(format!("Task error: {}", e)))
            }
        }
    }
}

pub mod ldap {
    use log::{debug, warn, info};
    use ldap3::{LdapConnAsync, LdapConnSettings};
    use std::time::Duration;

    pub async fn try_auth(
        host: &str,
        port: u16,
        username: &str,
        password: &str,
        use_ssl: bool,
    ) -> (bool, Option<String>) {
        // Build LDAP URL
        let scheme = if use_ssl { "ldaps" } else { "ldap" };
        let url = format!("{}://{}:{}", scheme, host, port);

        // Configure connection settings with timeout
        let settings = LdapConnSettings::new()
            .set_conn_timeout(Duration::from_secs(10));

        // Connect to LDAP server
        let (conn, mut ldap) = match LdapConnAsync::with_settings(settings, &url).await {
            Ok(result) => result,
            Err(e) => {
                warn!("LDAP connection to {} failed: {}", url, e);
                return (false, Some(format!("Connection failed: {}", e)));
            }
        };

        // Drive the connection in background
        ldap3::drive!(conn);

        // Attempt simple bind (authentication)
        // Username format can be:
        // - DN format: cn=username,dc=domain,dc=com
        // - UPN format: username@domain.com
        // - SAM format: DOMAIN\username
        let bind_result = ldap.simple_bind(username, password).await;

        match bind_result {
            Ok(result) => {
                // Check bind result
                match result.success() {
                    Ok(_) => {
                        info!("LDAP authentication successful: {} @ {}", username, url);
                        // Unbind cleanly
                        let _ = ldap.unbind().await;
                        (true, None)
                    }
                    Err(e) => {
                        // LDAP error codes for auth failure:
                        // 49 = Invalid credentials
                        // 52e = LDAP_INVALID_CREDENTIALS
                        // 775 = Account locked out
                        let error_str = format!("{:?}", e);
                        if error_str.contains("49") || error_str.contains("INVALID_CREDENTIALS") {
                            debug!("LDAP auth failed for {} @ {}: invalid credentials", username, url);
                            (false, Some("Invalid credentials".to_string()))
                        } else if error_str.contains("775") || error_str.contains("ACCOUNT_LOCKED") {
                            warn!("LDAP account locked: {} @ {}", username, url);
                            (false, Some("Account locked".to_string()))
                        } else {
                            debug!("LDAP bind error for {} @ {}: {:?}", username, url, e);
                            (false, Some(format!("Bind failed: {:?}", e)))
                        }
                    }
                }
            }
            Err(e) => {
                warn!("LDAP bind failed for {} @ {}: {}", username, url, e);
                (false, Some(format!("Bind error: {}", e)))
            }
        }
    }
}

pub mod smb {
    use log::{debug, warn, info};
    use tokio::process::Command;
    use std::time::Duration;

    /// Try SMB authentication using smbclient
    /// Falls back to connection test if smbclient is not available
    pub async fn try_auth(
        host: &str,
        port: u16,
        username: &str,
        password: &str,
    ) -> (bool, Option<String>) {
        try_auth_with_domain(host, port, username, password, None).await
    }

    /// Try SMB authentication with optional domain
    pub async fn try_auth_with_domain(
        host: &str,
        port: u16,
        username: &str,
        password: &str,
        domain: Option<&str>,
    ) -> (bool, Option<String>) {
        // Check if smbclient is available
        let smbclient_check = Command::new("which")
            .arg("smbclient")
            .output()
            .await;

        if smbclient_check.is_ok() && smbclient_check.as_ref().unwrap().status.success() {
            // Use smbclient for authentication test
            return try_smbclient_auth(host, port, username, password, domain).await;
        }

        // Fallback: check if rpcclient is available
        let rpcclient_check = Command::new("which")
            .arg("rpcclient")
            .output()
            .await;

        if rpcclient_check.is_ok() && rpcclient_check.as_ref().unwrap().status.success() {
            return try_rpcclient_auth(host, username, password, domain).await;
        }

        // No SMB tools available - attempt raw connection test
        warn!("No SMB tools (smbclient/rpcclient) available, using connection test only");
        try_connection_test(host, port).await
    }

    async fn try_smbclient_auth(
        host: &str,
        port: u16,
        username: &str,
        password: &str,
        domain: Option<&str>,
    ) -> (bool, Option<String>) {
        // Build smbclient command to list shares (lightweight auth test)
        // smbclient -L \\\\host -U 'username%password' -p port
        let user_arg = if let Some(dom) = domain {
            format!("{}\\{}%{}", dom, username, password)
        } else {
            format!("{}%{}", username, password)
        };

        let result = tokio::time::timeout(
            Duration::from_secs(15),
            Command::new("smbclient")
                .args([
                    "-L",
                    &format!("//{}", host),
                    "-U",
                    &user_arg,
                    "-p",
                    &port.to_string(),
                    "-g", // Guest fallback disabled
                    "-N", // No password prompt
                ])
                .output()
        ).await;

        match result {
            Ok(Ok(output)) => {
                let stdout = String::from_utf8_lossy(&output.stdout);
                let stderr = String::from_utf8_lossy(&output.stderr);
                let combined = format!("{}{}", stdout, stderr);

                // Check for successful authentication indicators
                if output.status.success() || combined.contains("Sharename") {
                    info!("SMB authentication successful: {}@{}", username, host);
                    (true, None)
                } else if combined.contains("NT_STATUS_LOGON_FAILURE") ||
                          combined.contains("LOGON_FAILURE") ||
                          combined.contains("NT_STATUS_WRONG_PASSWORD") {
                    debug!("SMB auth failed for {}@{}: invalid credentials", username, host);
                    (false, Some("Invalid credentials".to_string()))
                } else if combined.contains("NT_STATUS_ACCOUNT_LOCKED_OUT") {
                    warn!("SMB account locked: {}@{}", username, host);
                    (false, Some("Account locked".to_string()))
                } else if combined.contains("NT_STATUS_ACCOUNT_DISABLED") {
                    debug!("SMB account disabled: {}@{}", username, host);
                    (false, Some("Account disabled".to_string()))
                } else if combined.contains("NT_STATUS_PASSWORD_EXPIRED") {
                    info!("SMB password expired (auth may have succeeded): {}@{}", username, host);
                    (true, Some("Password expired".to_string()))
                } else if combined.contains("NT_STATUS_PASSWORD_MUST_CHANGE") {
                    info!("SMB password must change (auth succeeded): {}@{}", username, host);
                    (true, Some("Password must be changed".to_string()))
                } else if combined.contains("NT_STATUS_HOST_UNREACHABLE") ||
                          combined.contains("NT_STATUS_CONNECTION_REFUSED") {
                    warn!("SMB connection failed to {}", host);
                    (false, Some("Connection refused".to_string()))
                } else {
                    debug!("SMB unknown result for {}@{}: {}", username, host, combined);
                    (false, Some(format!("Unknown result: {}", combined.chars().take(100).collect::<String>())))
                }
            }
            Ok(Err(e)) => {
                warn!("Failed to execute smbclient for {}: {}", host, e);
                (false, Some(format!("Execution error: {}", e)))
            }
            Err(_) => {
                warn!("SMB authentication timeout for {}@{}", username, host);
                (false, Some("Connection timeout".to_string()))
            }
        }
    }

    async fn try_rpcclient_auth(
        host: &str,
        username: &str,
        password: &str,
        domain: Option<&str>,
    ) -> (bool, Option<String>) {
        let user_arg = if let Some(dom) = domain {
            format!("{}\\{}", dom, username)
        } else {
            username.to_string()
        };

        let result = tokio::time::timeout(
            Duration::from_secs(15),
            Command::new("rpcclient")
                .args([
                    "-U",
                    &format!("{}%{}", user_arg, password),
                    host,
                    "-c",
                    "getusername",
                ])
                .output()
        ).await;

        match result {
            Ok(Ok(output)) => {
                let stdout = String::from_utf8_lossy(&output.stdout);
                let stderr = String::from_utf8_lossy(&output.stderr);
                let combined = format!("{}{}", stdout, stderr);

                if output.status.success() || combined.contains("Account Name") {
                    info!("SMB (rpcclient) auth successful: {}@{}", username, host);
                    (true, None)
                } else if combined.contains("NT_STATUS_LOGON_FAILURE") {
                    (false, Some("Invalid credentials".to_string()))
                } else {
                    (false, Some(format!("Auth failed: {}", combined.chars().take(100).collect::<String>())))
                }
            }
            Ok(Err(e)) => {
                (false, Some(format!("Execution error: {}", e)))
            }
            Err(_) => {
                (false, Some("Connection timeout".to_string()))
            }
        }
    }

    async fn try_connection_test(
        host: &str,
        port: u16,
    ) -> (bool, Option<String>) {
        use tokio::net::TcpStream;
        use tokio::time::timeout;

        let addr = format!("{}:{}", host, port);

        match timeout(Duration::from_secs(10), TcpStream::connect(&addr)).await {
            Ok(Ok(_)) => {
                debug!("SMB port {} open on {}, but no auth tools available", port, host);
                (false, Some("SMB port open - install smbclient for auth testing".to_string()))
            }
            Ok(Err(e)) => {
                warn!("SMB connection to {} failed: {}", addr, e);
                (false, Some(format!("Connection failed: {}", e)))
            }
            Err(_) => {
                (false, Some("Connection timeout".to_string()))
            }
        }
    }
}

pub mod rdp {
    use log::debug;
    use tokio::net::TcpStream;
    use tokio::time::{timeout, Duration};

    pub async fn try_auth(
        host: &str,
        port: u16,
        username: &str,
        password: &str,
    ) -> (bool, Option<String>) {
        let addr = format!("{}:{}", host, port);

        let connect_result = timeout(Duration::from_secs(10), TcpStream::connect(&addr)).await;

        match connect_result {
            Ok(Ok(_stream)) => {
                debug!("RDP connection to {} successful", addr);
                (false, Some("RDP auth not yet implemented - connection successful".to_string()))
            }
            Ok(Err(e)) => {
                (false, Some(format!("Connection failed: {}", e)))
            }
            Err(_) => {
                (false, Some("Connection timeout".to_string()))
            }
        }
    }
}

pub mod winrm {
    use log::debug;

    pub async fn try_auth(
        host: &str,
        port: u16,
        username: &str,
        password: &str,
        use_ssl: bool,
    ) -> (bool, Option<String>) {
        let scheme = if use_ssl { "https" } else { "http" };
        let url = format!("{}://{}:{}/wsman", scheme, host, port);

        // WinRM uses HTTP-based authentication
        // For now, return placeholder
        debug!("WinRM endpoint: {}", url);
        (false, Some("WinRM auth not yet implemented".to_string()))
    }
}

pub mod http {
    use log::{debug, warn};
    use reqwest::Client;
    use tokio::time::Duration;

    pub async fn try_basic_auth(
        host: &str,
        port: u16,
        path: &str,
        username: &str,
        password: &str,
        use_ssl: bool,
    ) -> (bool, Option<String>) {
        let scheme = if use_ssl { "https" } else { "http" };
        let url = format!("{}://{}:{}{}", scheme, host, port, path);

        let client = Client::builder()
            .timeout(Duration::from_secs(10))
            .danger_accept_invalid_certs(true)
            .build();

        match client {
            Ok(client) => {
                let result = client
                    .get(&url)
                    .basic_auth(username, Some(password))
                    .send()
                    .await;

                match result {
                    Ok(response) => {
                        let status = response.status();
                        if status.is_success() || status == reqwest::StatusCode::FORBIDDEN {
                            // 200 OK or 403 Forbidden (authenticated but not authorized)
                            debug!("HTTP Basic auth successful for {} at {}", username, url);
                            (true, None)
                        } else if status == reqwest::StatusCode::UNAUTHORIZED {
                            debug!("HTTP Basic auth failed for {} at {}", username, url);
                            (false, Some("Invalid credentials".to_string()))
                        } else {
                            (false, Some(format!("Unexpected status: {}", status)))
                        }
                    }
                    Err(e) => {
                        warn!("HTTP request failed: {}", e);
                        (false, Some(format!("Request failed: {}", e)))
                    }
                }
            }
            Err(e) => {
                (false, Some(format!("Failed to create HTTP client: {}", e)))
            }
        }
    }

    pub async fn try_ntlm_auth(
        host: &str,
        port: u16,
        path: &str,
        username: &str,
        password: &str,
        domain: Option<&str>,
        use_ssl: bool,
    ) -> (bool, Option<String>) {
        // NTLM over HTTP requires a more complex handshake
        // For now, return placeholder
        let scheme = if use_ssl { "https" } else { "http" };
        let url = format!("{}://{}:{}{}", scheme, host, port, path);
        debug!("NTLM auth attempt at {}", url);
        (false, Some("NTLM auth not yet implemented".to_string()))
    }
}

pub mod kerberos {
    use log::debug;

    pub async fn try_auth(
        kdc: &str,
        realm: &str,
        username: &str,
        password: &str,
    ) -> (bool, Option<String>) {
        // Kerberos auth requires AS-REQ/AS-REP exchange
        // This would use a Kerberos library like krb5
        debug!("Kerberos auth attempt for {}@{} via KDC {}", username, realm, kdc);
        (false, Some("Kerberos auth not yet implemented".to_string()))
    }
}
