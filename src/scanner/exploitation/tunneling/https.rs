//! HTTPS Tunneling Module
//!
//! Provides encoding and decoding of data through HTTPS requests for
//! testing data exfiltration defenses during authorized penetration testing.
//!
//! Supports multiple tunneling methods including headers, body, URL parameters,
//! and cookies.

use crate::scanner::exploitation::tunneling::{
    chunk_data, DecodeRequest, DecodeResponse, EncodeRequest, EncodeResponse,
    EncodedTunnelData, TunnelEncoding,
};
use anyhow::{anyhow, Result};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

// ============================================================================
// HTTPS Tunnel Methods
// ============================================================================

/// HTTPS tunneling methods
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Default)]
#[serde(rename_all = "snake_case")]
pub enum HttpsTunnelMethod {
    /// Encode data in HTTP headers
    Headers,
    /// Encode data in POST/PUT body
    #[default]
    Body,
    /// Encode data in URL parameters
    UrlParams,
    /// Encode data in cookies
    Cookies,
    /// Encode data in custom header
    CustomHeader,
    /// Encode data mixed across multiple channels
    Mixed,
}

impl std::fmt::Display for HttpsTunnelMethod {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            HttpsTunnelMethod::Headers => write!(f, "Headers"),
            HttpsTunnelMethod::Body => write!(f, "Body"),
            HttpsTunnelMethod::UrlParams => write!(f, "URL Parameters"),
            HttpsTunnelMethod::Cookies => write!(f, "Cookies"),
            HttpsTunnelMethod::CustomHeader => write!(f, "Custom Header"),
            HttpsTunnelMethod::Mixed => write!(f, "Mixed"),
        }
    }
}

impl HttpsTunnelMethod {
    /// Get the maximum data capacity for this method
    pub fn max_capacity(&self) -> usize {
        match self {
            HttpsTunnelMethod::Headers => 8192,      // Typical header limit
            HttpsTunnelMethod::Body => 10485760,     // 10MB typical limit
            HttpsTunnelMethod::UrlParams => 2048,    // URL length limit
            HttpsTunnelMethod::Cookies => 4096,      // Cookie size limit
            HttpsTunnelMethod::CustomHeader => 8192, // Same as headers
            HttpsTunnelMethod::Mixed => 10485760,    // Combined limit
        }
    }

    /// Get the recommended chunk size for this method
    pub fn recommended_chunk_size(&self) -> usize {
        match self {
            HttpsTunnelMethod::Headers => 1024,
            HttpsTunnelMethod::Body => 8192,
            HttpsTunnelMethod::UrlParams => 512,
            HttpsTunnelMethod::Cookies => 1024,
            HttpsTunnelMethod::CustomHeader => 1024,
            HttpsTunnelMethod::Mixed => 4096,
        }
    }
}

/// HTTP methods for tunnel requests
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Default)]
#[serde(rename_all = "UPPERCASE")]
pub enum HttpMethod {
    Get,
    #[default]
    Post,
    Put,
    Patch,
    Delete,
    Options,
}

impl std::fmt::Display for HttpMethod {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            HttpMethod::Get => write!(f, "GET"),
            HttpMethod::Post => write!(f, "POST"),
            HttpMethod::Put => write!(f, "PUT"),
            HttpMethod::Patch => write!(f, "PATCH"),
            HttpMethod::Delete => write!(f, "DELETE"),
            HttpMethod::Options => write!(f, "OPTIONS"),
        }
    }
}

// ============================================================================
// HTTPS-specific Configuration
// ============================================================================

/// HTTPS tunneling configuration options
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct HttpsTunnelOptions {
    /// Target endpoint URL
    pub endpoint: String,
    /// HTTP method to use
    pub http_method: HttpMethod,
    /// Tunneling method
    pub tunnel_method: HttpsTunnelMethod,
    /// Custom header name (for CustomHeader method)
    pub custom_header_name: Option<String>,
    /// Custom parameter name (for UrlParams method)
    pub param_name: Option<String>,
    /// Cookie name (for Cookies method)
    pub cookie_name: Option<String>,
    /// Additional headers to include
    pub extra_headers: HashMap<String, String>,
    /// Content-Type for body encoding
    pub content_type: Option<String>,
    /// Use JSON wrapper for body
    pub json_wrapper: bool,
    /// JSON key for data
    pub json_key: Option<String>,
    /// Mimic legitimate traffic patterns
    pub mimic_traffic: bool,
    /// User-Agent string
    pub user_agent: Option<String>,
}

impl Default for HttpsTunnelOptions {
    fn default() -> Self {
        Self {
            endpoint: String::new(),
            http_method: HttpMethod::Post,
            tunnel_method: HttpsTunnelMethod::Body,
            custom_header_name: None,
            param_name: Some("data".to_string()),
            cookie_name: Some("session".to_string()),
            extra_headers: HashMap::new(),
            content_type: Some("application/json".to_string()),
            json_wrapper: true,
            json_key: Some("payload".to_string()),
            mimic_traffic: true,
            user_agent: Some("Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36".to_string()),
        }
    }
}

// ============================================================================
// Encoding Functions
// ============================================================================

/// Encode data for HTTPS tunneling
pub fn encode_https_data(request: &EncodeRequest, options: &HttpsTunnelOptions) -> Result<EncodeResponse> {
    // Decode input data if base64 encoded
    let data = if request.data_is_base64 {
        use base64::{Engine as _, engine::general_purpose::STANDARD};
        STANDARD.decode(&request.data)
            .map_err(|e| anyhow!("Failed to decode base64 input: {}", e))?
    } else {
        request.data.as_bytes().to_vec()
    };

    let original_size = data.len();

    // Determine chunk size
    let chunk_size = request.chunk_size
        .unwrap_or_else(|| options.tunnel_method.recommended_chunk_size());

    // Split data into chunks
    let raw_chunks = chunk_data(&data, chunk_size);

    // Encode each chunk
    let mut encoded_chunks = Vec::new();
    let mut total_encoded_size = 0;

    for (i, chunk) in raw_chunks.iter().enumerate() {
        let encoded = encode_https_chunk(chunk, &request.encoding, options, i, raw_chunks.len())?;
        total_encoded_size += encoded.encoded_size;
        encoded_chunks.push(encoded);
    }

    Ok(EncodeResponse {
        chunks: encoded_chunks,
        total_chunks: raw_chunks.len(),
        original_size,
        total_encoded_size,
        encoding: request.encoding.clone(),
    })
}

/// Encode a single chunk for HTTPS request
fn encode_https_chunk(
    data: &[u8],
    encoding: &TunnelEncoding,
    options: &HttpsTunnelOptions,
    sequence: usize,
    total: usize,
) -> Result<EncodedTunnelData> {
    // Encode the data
    let encoded_data = encode_data_for_http(data, encoding)?;

    // Build the HTTP payload based on tunnel method
    let (payload, protocol_data) = match &options.tunnel_method {
        HttpsTunnelMethod::Headers => {
            build_header_payload(&encoded_data, options, sequence, total)?
        }
        HttpsTunnelMethod::Body => {
            build_body_payload(&encoded_data, options, sequence, total)?
        }
        HttpsTunnelMethod::UrlParams => {
            build_url_params_payload(&encoded_data, options, sequence, total)?
        }
        HttpsTunnelMethod::Cookies => {
            build_cookie_payload(&encoded_data, options, sequence, total)?
        }
        HttpsTunnelMethod::CustomHeader => {
            build_custom_header_payload(&encoded_data, options, sequence, total)?
        }
        HttpsTunnelMethod::Mixed => {
            build_mixed_payload(&encoded_data, options, sequence, total)?
        }
    };

    let encoded_size = payload.len();

    Ok(EncodedTunnelData {
        payload,
        original_size: data.len(),
        encoded_size,
        encoding: encoding.clone(),
        protocol_data,
    })
}

/// Encode data for HTTP transport
fn encode_data_for_http(data: &[u8], encoding: &TunnelEncoding) -> Result<String> {
    match encoding {
        TunnelEncoding::Base64 => {
            use base64::{Engine as _, engine::general_purpose::STANDARD};
            Ok(STANDARD.encode(data))
        }
        TunnelEncoding::Base64Url => {
            use base64::{Engine as _, engine::general_purpose::URL_SAFE_NO_PAD};
            Ok(URL_SAFE_NO_PAD.encode(data))
        }
        TunnelEncoding::Hex => {
            Ok(hex::encode(data))
        }
        TunnelEncoding::None => {
            // Try to interpret as UTF-8, fallback to lossy conversion
            Ok(String::from_utf8_lossy(data).to_string())
        }
        _ => Err(anyhow!("Unsupported encoding for HTTPS: {:?}", encoding)),
    }
}

/// Build header-based payload
fn build_header_payload(
    encoded_data: &str,
    options: &HttpsTunnelOptions,
    sequence: usize,
    total: usize,
) -> Result<(String, serde_json::Value)> {
    // Split data across multiple headers if needed
    let headers = split_across_headers(encoded_data, sequence, total);

    let mut all_headers = headers.clone();
    all_headers.extend(options.extra_headers.clone());

    if let Some(ua) = &options.user_agent {
        all_headers.insert("User-Agent".to_string(), ua.clone());
    }

    let protocol_data = serde_json::json!({
        "method": options.http_method.to_string(),
        "endpoint": options.endpoint,
        "headers": all_headers,
        "sequence": sequence,
        "total": total,
        "tunnel_method": "headers"
    });

    // Format as HTTP request fragment
    let payload = format_http_request(&options.http_method, &options.endpoint, &all_headers, None);

    Ok((payload, protocol_data))
}

/// Build body-based payload
fn build_body_payload(
    encoded_data: &str,
    options: &HttpsTunnelOptions,
    sequence: usize,
    total: usize,
) -> Result<(String, serde_json::Value)> {
    let body = if options.json_wrapper {
        let key = options.json_key.as_deref().unwrap_or("data");
        serde_json::json!({
            key: encoded_data,
            "seq": sequence,
            "total": total
        }).to_string()
    } else {
        encoded_data.to_string()
    };

    let mut headers = options.extra_headers.clone();
    if let Some(content_type) = &options.content_type {
        headers.insert("Content-Type".to_string(), content_type.clone());
    }
    headers.insert("Content-Length".to_string(), body.len().to_string());

    if let Some(ua) = &options.user_agent {
        headers.insert("User-Agent".to_string(), ua.clone());
    }

    let protocol_data = serde_json::json!({
        "method": options.http_method.to_string(),
        "endpoint": options.endpoint,
        "headers": headers,
        "body": body,
        "sequence": sequence,
        "total": total,
        "tunnel_method": "body"
    });

    let payload = format_http_request(&options.http_method, &options.endpoint, &headers, Some(&body));

    Ok((payload, protocol_data))
}

/// Build URL parameters payload
fn build_url_params_payload(
    encoded_data: &str,
    options: &HttpsTunnelOptions,
    sequence: usize,
    total: usize,
) -> Result<(String, serde_json::Value)> {
    let param_name = options.param_name.as_deref().unwrap_or("d");

    // URL encode the data
    let url_encoded = urlencoding::encode(encoded_data);

    let query_string = format!(
        "{}={}&seq={}&total={}",
        param_name, url_encoded, sequence, total
    );

    let full_url = if options.endpoint.contains('?') {
        format!("{}&{}", options.endpoint, query_string)
    } else {
        format!("{}?{}", options.endpoint, query_string)
    };

    let mut headers = options.extra_headers.clone();
    if let Some(ua) = &options.user_agent {
        headers.insert("User-Agent".to_string(), ua.clone());
    }

    let protocol_data = serde_json::json!({
        "method": "GET",
        "endpoint": full_url,
        "headers": headers,
        "query_string": query_string,
        "sequence": sequence,
        "total": total,
        "tunnel_method": "url_params"
    });

    let payload = format_http_request(&HttpMethod::Get, &full_url, &headers, None);

    Ok((payload, protocol_data))
}

/// Build cookie-based payload
fn build_cookie_payload(
    encoded_data: &str,
    options: &HttpsTunnelOptions,
    sequence: usize,
    total: usize,
) -> Result<(String, serde_json::Value)> {
    let cookie_name = options.cookie_name.as_deref().unwrap_or("session");

    // URL encode for cookie safety
    let url_encoded = urlencoding::encode(encoded_data);

    let cookie_value = format!(
        "{}={}; seq={}; total={}",
        cookie_name, url_encoded, sequence, total
    );

    let mut headers = options.extra_headers.clone();
    headers.insert("Cookie".to_string(), cookie_value.clone());

    if let Some(ua) = &options.user_agent {
        headers.insert("User-Agent".to_string(), ua.clone());
    }

    let protocol_data = serde_json::json!({
        "method": options.http_method.to_string(),
        "endpoint": options.endpoint,
        "headers": headers,
        "cookie": cookie_value,
        "sequence": sequence,
        "total": total,
        "tunnel_method": "cookies"
    });

    let payload = format_http_request(&options.http_method, &options.endpoint, &headers, None);

    Ok((payload, protocol_data))
}

/// Build custom header payload
fn build_custom_header_payload(
    encoded_data: &str,
    options: &HttpsTunnelOptions,
    sequence: usize,
    total: usize,
) -> Result<(String, serde_json::Value)> {
    let header_name = options.custom_header_name.as_deref()
        .unwrap_or("X-Custom-Data");

    let mut headers = options.extra_headers.clone();
    headers.insert(header_name.to_string(), encoded_data.to_string());
    headers.insert("X-Sequence".to_string(), sequence.to_string());
    headers.insert("X-Total".to_string(), total.to_string());

    if let Some(ua) = &options.user_agent {
        headers.insert("User-Agent".to_string(), ua.clone());
    }

    let protocol_data = serde_json::json!({
        "method": options.http_method.to_string(),
        "endpoint": options.endpoint,
        "headers": headers,
        "custom_header": header_name,
        "sequence": sequence,
        "total": total,
        "tunnel_method": "custom_header"
    });

    let payload = format_http_request(&options.http_method, &options.endpoint, &headers, None);

    Ok((payload, protocol_data))
}

/// Build mixed payload (data spread across multiple channels)
fn build_mixed_payload(
    encoded_data: &str,
    options: &HttpsTunnelOptions,
    sequence: usize,
    total: usize,
) -> Result<(String, serde_json::Value)> {
    // Split data into thirds: headers, body, and url params
    let third = encoded_data.len() / 3;
    let part1 = &encoded_data[..third];
    let part2 = &encoded_data[third..2*third];
    let part3 = &encoded_data[2*third..];

    let mut headers = options.extra_headers.clone();
    headers.insert("X-Data-Part1".to_string(), part1.to_string());
    headers.insert("X-Sequence".to_string(), sequence.to_string());

    if let Some(ua) = &options.user_agent {
        headers.insert("User-Agent".to_string(), ua.clone());
    }

    let body = serde_json::json!({
        "data": part2,
        "checksum": simple_checksum(encoded_data.as_bytes())
    }).to_string();

    let query = format!("p3={}&t={}", urlencoding::encode(part3), total);
    let full_url = if options.endpoint.contains('?') {
        format!("{}&{}", options.endpoint, query)
    } else {
        format!("{}?{}", options.endpoint, query)
    };

    headers.insert("Content-Type".to_string(), "application/json".to_string());
    headers.insert("Content-Length".to_string(), body.len().to_string());

    let protocol_data = serde_json::json!({
        "method": "POST",
        "endpoint": full_url,
        "headers": headers,
        "body": body,
        "parts": {
            "header": part1,
            "body": part2,
            "url": part3
        },
        "sequence": sequence,
        "total": total,
        "tunnel_method": "mixed"
    });

    let payload = format_http_request(&HttpMethod::Post, &full_url, &headers, Some(&body));

    Ok((payload, protocol_data))
}

/// Split data across multiple HTTP headers
fn split_across_headers(data: &str, sequence: usize, total: usize) -> HashMap<String, String> {
    let mut headers = HashMap::new();

    // Use common header names that might evade detection
    let header_names = [
        "X-Request-ID",
        "X-Correlation-ID",
        "X-Transaction-ID",
        "X-Session-Token",
        "X-API-Key",
        "X-Client-Version",
    ];

    let chunk_size = (data.len() / header_names.len()).max(1);
    let chunks: Vec<&str> = data
        .as_bytes()
        .chunks(chunk_size)
        .map(|c| std::str::from_utf8(c).unwrap_or(""))
        .collect();

    for (i, chunk) in chunks.iter().enumerate() {
        if i < header_names.len() {
            headers.insert(header_names[i].to_string(), chunk.to_string());
        }
    }

    headers.insert("X-Sequence".to_string(), sequence.to_string());
    headers.insert("X-Total".to_string(), total.to_string());

    headers
}

/// Format an HTTP request as a string
fn format_http_request(
    method: &HttpMethod,
    url: &str,
    headers: &HashMap<String, String>,
    body: Option<&str>,
) -> String {
    let mut request = format!("{} {} HTTP/1.1\r\n", method, url);

    for (key, value) in headers {
        request.push_str(&format!("{}: {}\r\n", key, value));
    }

    request.push_str("\r\n");

    if let Some(b) = body {
        request.push_str(b);
    }

    request
}

/// Simple checksum for verification
fn simple_checksum(data: &[u8]) -> u32 {
    data.iter().fold(0u32, |acc, &b| acc.wrapping_add(b as u32))
}

// ============================================================================
// Decoding Functions
// ============================================================================

/// Decode data from HTTPS tunnel
pub fn decode_https_data(request: &DecodeRequest, options: &HttpsTunnelOptions) -> Result<DecodeResponse> {
    let mut decoded_chunks: Vec<(usize, Vec<u8>)> = Vec::new();

    for chunk_data in &request.chunks {
        match decode_https_chunk(chunk_data, &request.encoding, options) {
            Ok((sequence, data)) => {
                decoded_chunks.push((sequence, data));
            }
            Err(e) => {
                return Ok(DecodeResponse {
                    data: String::new(),
                    original_size: 0,
                    success: false,
                    error: Some(format!("Failed to decode chunk: {}", e)),
                });
            }
        }
    }

    // Sort by sequence number
    decoded_chunks.sort_by_key(|(seq, _)| *seq);

    // Reassemble
    let mut reassembled = Vec::new();
    for (_, data) in decoded_chunks {
        reassembled.extend(data);
    }

    // Return as base64 for binary safety
    use base64::{Engine as _, engine::general_purpose::STANDARD};
    let encoded_result = STANDARD.encode(&reassembled);

    Ok(DecodeResponse {
        data: encoded_result,
        original_size: reassembled.len(),
        success: true,
        error: None,
    })
}

/// Decode a single HTTPS chunk
fn decode_https_chunk(
    payload: &str,
    encoding: &TunnelEncoding,
    _options: &HttpsTunnelOptions,
) -> Result<(usize, Vec<u8>)> {
    // Try to parse as JSON first (body method)
    if let Ok(json) = serde_json::from_str::<serde_json::Value>(payload) {
        let data_str = json.get("data")
            .or_else(|| json.get("payload"))
            .and_then(|v| v.as_str())
            .unwrap_or(payload);

        let sequence = json.get("seq")
            .or_else(|| json.get("sequence"))
            .and_then(|v| v.as_u64())
            .unwrap_or(0) as usize;

        let decoded = decode_data_from_http(data_str, encoding)?;
        return Ok((sequence, decoded));
    }

    // If not JSON, try direct decoding
    let decoded = decode_data_from_http(payload, encoding)?;
    Ok((0, decoded))
}

/// Decode data from HTTP transport
fn decode_data_from_http(data: &str, encoding: &TunnelEncoding) -> Result<Vec<u8>> {
    match encoding {
        TunnelEncoding::Base64 => {
            use base64::{Engine as _, engine::general_purpose::STANDARD};
            STANDARD.decode(data)
                .map_err(|e| anyhow!("Failed to decode base64: {}", e))
        }
        TunnelEncoding::Base64Url => {
            use base64::{Engine as _, engine::general_purpose::URL_SAFE_NO_PAD};
            URL_SAFE_NO_PAD.decode(data)
                .map_err(|e| anyhow!("Failed to decode base64url: {}", e))
        }
        TunnelEncoding::Hex => {
            hex::decode(data)
                .map_err(|e| anyhow!("Failed to decode hex: {}", e))
        }
        TunnelEncoding::None => {
            Ok(data.as_bytes().to_vec())
        }
        _ => Err(anyhow!("Unsupported encoding for HTTPS: {:?}", encoding)),
    }
}

// ============================================================================
// Utility Functions
// ============================================================================

/// Parse HTTPS options from a HashMap
pub fn parse_https_options(options: &Option<HashMap<String, serde_json::Value>>) -> HttpsTunnelOptions {
    let mut https_options = HttpsTunnelOptions::default();

    if let Some(opts) = options {
        if let Some(endpoint) = opts.get("endpoint").and_then(|v| v.as_str()) {
            https_options.endpoint = endpoint.to_string();
        }
        if let Some(method) = opts.get("http_method").and_then(|v| v.as_str()) {
            https_options.http_method = match method.to_uppercase().as_str() {
                "GET" => HttpMethod::Get,
                "POST" => HttpMethod::Post,
                "PUT" => HttpMethod::Put,
                "PATCH" => HttpMethod::Patch,
                "DELETE" => HttpMethod::Delete,
                _ => HttpMethod::Post,
            };
        }
        if let Some(tunnel_method) = opts.get("tunnel_method").and_then(|v| v.as_str()) {
            https_options.tunnel_method = match tunnel_method.to_lowercase().as_str() {
                "headers" => HttpsTunnelMethod::Headers,
                "body" => HttpsTunnelMethod::Body,
                "url_params" => HttpsTunnelMethod::UrlParams,
                "cookies" => HttpsTunnelMethod::Cookies,
                "custom_header" => HttpsTunnelMethod::CustomHeader,
                "mixed" => HttpsTunnelMethod::Mixed,
                _ => HttpsTunnelMethod::Body,
            };
        }
        if let Some(header_name) = opts.get("custom_header_name").and_then(|v| v.as_str()) {
            https_options.custom_header_name = Some(header_name.to_string());
        }
        if let Some(param_name) = opts.get("param_name").and_then(|v| v.as_str()) {
            https_options.param_name = Some(param_name.to_string());
        }
        if let Some(cookie_name) = opts.get("cookie_name").and_then(|v| v.as_str()) {
            https_options.cookie_name = Some(cookie_name.to_string());
        }
        if let Some(json_wrapper) = opts.get("json_wrapper").and_then(|v| v.as_bool()) {
            https_options.json_wrapper = json_wrapper;
        }
        if let Some(user_agent) = opts.get("user_agent").and_then(|v| v.as_str()) {
            https_options.user_agent = Some(user_agent.to_string());
        }
    }

    https_options
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_encode_https_body() {
        let request = EncodeRequest {
            data: "Hello, World!".to_string(),
            data_is_base64: false,
            encoding: TunnelEncoding::Base64,
            chunk_size: None,
            options: None,
        };

        let options = HttpsTunnelOptions {
            endpoint: "https://example.com/api/data".to_string(),
            tunnel_method: HttpsTunnelMethod::Body,
            ..Default::default()
        };

        let response = encode_https_data(&request, &options).unwrap();

        assert!(!response.chunks.is_empty());
        assert_eq!(response.original_size, 13);

        // Verify the payload contains JSON
        let payload = &response.chunks[0].payload;
        assert!(payload.contains("POST"));
        assert!(payload.contains("application/json"));
    }

    #[test]
    fn test_encode_https_url_params() {
        let request = EncodeRequest {
            data: "Test data".to_string(),
            data_is_base64: false,
            encoding: TunnelEncoding::Base64Url,
            chunk_size: None,
            options: None,
        };

        let options = HttpsTunnelOptions {
            endpoint: "https://example.com/search".to_string(),
            tunnel_method: HttpsTunnelMethod::UrlParams,
            param_name: Some("q".to_string()),
            ..Default::default()
        };

        let response = encode_https_data(&request, &options).unwrap();

        let payload = &response.chunks[0].payload;
        assert!(payload.contains("GET"));
        assert!(payload.contains("?q="));
    }

    #[test]
    fn test_encode_https_cookies() {
        let request = EncodeRequest {
            data: "Cookie data".to_string(),
            data_is_base64: false,
            encoding: TunnelEncoding::Base64,
            chunk_size: None,
            options: None,
        };

        let options = HttpsTunnelOptions {
            endpoint: "https://example.com/".to_string(),
            tunnel_method: HttpsTunnelMethod::Cookies,
            cookie_name: Some("auth_token".to_string()),
            ..Default::default()
        };

        let response = encode_https_data(&request, &options).unwrap();

        let payload = &response.chunks[0].payload;
        assert!(payload.contains("Cookie:"));
        assert!(payload.contains("auth_token="));
    }

    #[test]
    fn test_roundtrip_body_encoding() {
        let original = b"Test data for HTTPS tunneling roundtrip";

        let encode_request = EncodeRequest {
            data: String::from_utf8_lossy(original).to_string(),
            data_is_base64: false,
            encoding: TunnelEncoding::Base64,
            chunk_size: Some(20),
            options: None,
        };

        let options = HttpsTunnelOptions {
            endpoint: "https://example.com/api".to_string(),
            tunnel_method: HttpsTunnelMethod::Body,
            json_wrapper: true,
            json_key: Some("data".to_string()),
            ..Default::default()
        };

        let encoded = encode_https_data(&encode_request, &options).unwrap();

        // Extract body from each chunk for decoding
        let bodies: Vec<String> = encoded.chunks.iter()
            .map(|c| {
                // Extract the JSON body from protocol_data
                c.protocol_data.get("body")
                    .and_then(|v| v.as_str())
                    .unwrap_or("")
                    .to_string()
            })
            .collect();

        let decode_request = DecodeRequest {
            chunks: bodies,
            encoding: TunnelEncoding::Base64,
            options: None,
        };

        let decoded = decode_https_data(&decode_request, &options).unwrap();

        assert!(decoded.success);

        use base64::{Engine as _, engine::general_purpose::STANDARD};
        let decoded_bytes = STANDARD.decode(&decoded.data).unwrap();
        assert_eq!(decoded_bytes, original);
    }

    #[test]
    fn test_tunnel_method_capacity() {
        assert_eq!(HttpsTunnelMethod::Body.max_capacity(), 10485760);
        assert_eq!(HttpsTunnelMethod::UrlParams.max_capacity(), 2048);
        assert_eq!(HttpsTunnelMethod::Cookies.max_capacity(), 4096);
    }
}
