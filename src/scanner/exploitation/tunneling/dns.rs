//! DNS Tunneling Module
//!
//! Provides encoding and decoding of data through DNS queries for
//! testing data exfiltration defenses during authorized penetration testing.
//!
//! Supports multiple DNS record types (TXT, A, AAAA, CNAME) and various
//! encoding schemes (Base32, Hex, Base64URL).

#![allow(dead_code)]

use crate::scanner::exploitation::tunneling::{
    chunk_data, DecodeRequest, DecodeResponse, EncodeRequest, EncodeResponse,
    EncodedTunnelData, TunnelEncoding,
};
use anyhow::{anyhow, Result};
use base32::Alphabet;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

// ============================================================================
// DNS Record Types
// ============================================================================

/// DNS record types supported for tunneling
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Default)]
#[serde(rename_all = "snake_case")]
pub enum DnsRecordType {
    /// TXT records (largest capacity, most common for tunneling)
    #[default]
    Txt,
    /// A records (IPv4, encode in subdomain)
    A,
    /// AAAA records (IPv6, encode in subdomain)
    Aaaa,
    /// CNAME records (alias, encode in subdomain)
    Cname,
    /// MX records (mail exchange)
    Mx,
    /// NULL records (for raw data)
    Null,
}

impl std::fmt::Display for DnsRecordType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            DnsRecordType::Txt => write!(f, "TXT"),
            DnsRecordType::A => write!(f, "A"),
            DnsRecordType::Aaaa => write!(f, "AAAA"),
            DnsRecordType::Cname => write!(f, "CNAME"),
            DnsRecordType::Mx => write!(f, "MX"),
            DnsRecordType::Null => write!(f, "NULL"),
        }
    }
}

impl DnsRecordType {
    /// Get the maximum data capacity for this record type (per query)
    pub fn max_capacity(&self) -> usize {
        match self {
            // TXT can hold up to 255 bytes per string, multiple strings allowed
            DnsRecordType::Txt => 255,
            // A/AAAA/CNAME use subdomain encoding, limited by label length
            DnsRecordType::A | DnsRecordType::Aaaa | DnsRecordType::Cname => 253,
            DnsRecordType::Mx => 253,
            DnsRecordType::Null => 65535,
        }
    }

    /// Get the recommended label size for this record type
    pub fn recommended_label_size(&self) -> usize {
        match self {
            DnsRecordType::Txt => 63, // Max label length
            DnsRecordType::A | DnsRecordType::Aaaa | DnsRecordType::Cname => 63,
            DnsRecordType::Mx => 63,
            DnsRecordType::Null => 63,
        }
    }
}

// ============================================================================
// DNS-specific Configuration
// ============================================================================

/// DNS tunneling configuration options
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DnsTunnelOptions {
    /// Base domain for queries (e.g., "tunnel.example.com")
    pub domain: String,
    /// DNS record type to use
    pub record_type: DnsRecordType,
    /// Maximum label length (default: 63)
    pub max_label_length: usize,
    /// Maximum total query length (default: 253)
    pub max_query_length: usize,
    /// Use random subdomain prefixes for obfuscation
    pub use_random_prefix: bool,
    /// Prefix length for random prefixes
    pub random_prefix_length: usize,
    /// Split data across multiple labels
    pub multi_label: bool,
    /// Label separator (usually ".")
    pub label_separator: char,
}

impl Default for DnsTunnelOptions {
    fn default() -> Self {
        Self {
            domain: String::new(),
            record_type: DnsRecordType::Txt,
            max_label_length: 63,
            max_query_length: 253,
            use_random_prefix: false,
            random_prefix_length: 4,
            multi_label: true,
            label_separator: '.',
        }
    }
}

// ============================================================================
// Encoding Functions
// ============================================================================

/// Encode data for DNS tunneling
///
/// Returns a list of DNS queries that can be used to exfiltrate the data.
pub fn encode_dns_data(request: &EncodeRequest, options: &DnsTunnelOptions) -> Result<EncodeResponse> {
    // Decode input data if base64 encoded
    let data = if request.data_is_base64 {
        use base64::{Engine as _, engine::general_purpose::STANDARD};
        STANDARD.decode(&request.data)
            .map_err(|e| anyhow!("Failed to decode base64 input: {}", e))?
    } else {
        request.data.as_bytes().to_vec()
    };

    let original_size = data.len();

    // Determine chunk size based on encoding and DNS constraints
    let effective_chunk_size = calculate_chunk_size(&request.encoding, options);
    let chunk_size = request.chunk_size.unwrap_or(effective_chunk_size);

    // Split data into chunks
    let raw_chunks = chunk_data(&data, chunk_size);

    // Encode each chunk
    let mut encoded_chunks = Vec::new();
    let mut total_encoded_size = 0;

    for (i, chunk) in raw_chunks.iter().enumerate() {
        let encoded = encode_chunk(chunk, &request.encoding, options, i, raw_chunks.len())?;
        total_encoded_size += encoded.encoded_size;
        encoded_chunks.push(encoded);
    }

    Ok(EncodeResponse {
        chunks: encoded_chunks,
        total_chunks: raw_chunks.len(),
        original_size,
        total_encoded_size,
        encoding: request.encoding.clone(),
    })
}

/// Encode a single chunk for DNS query
fn encode_chunk(
    data: &[u8],
    encoding: &TunnelEncoding,
    options: &DnsTunnelOptions,
    sequence: usize,
    total: usize,
) -> Result<EncodedTunnelData> {
    // Encode the data
    let encoded_data = match encoding {
        TunnelEncoding::Base32 => {
            base32::encode(Alphabet::Rfc4648Lower { padding: false }, data)
        }
        TunnelEncoding::Hex => {
            hex::encode(data)
        }
        TunnelEncoding::Base64Url => {
            use base64::{Engine as _, engine::general_purpose::URL_SAFE_NO_PAD};
            URL_SAFE_NO_PAD.encode(data)
        }
        TunnelEncoding::Base64 => {
            use base64::{Engine as _, engine::general_purpose::STANDARD_NO_PAD};
            // Replace + with - and / with _ for DNS safety
            STANDARD_NO_PAD.encode(data)
                .replace('+', "-")
                .replace('/', "_")
        }
        _ => {
            return Err(anyhow!("Unsupported encoding for DNS: {:?}", encoding));
        }
    };

    // Build DNS query from encoded data
    let dns_query = build_dns_query(&encoded_data, options, sequence, total)?;
    let encoded_size = dns_query.len();

    // Build protocol data
    let protocol_data = serde_json::json!({
        "query": dns_query,
        "record_type": options.record_type.to_string(),
        "domain": options.domain,
        "sequence": sequence,
        "total": total,
        "labels": split_into_labels(&encoded_data, options.max_label_length),
    });

    Ok(EncodedTunnelData {
        payload: dns_query,
        original_size: data.len(),
        encoded_size,
        encoding: encoding.clone(),
        protocol_data,
    })
}

/// Build a DNS query from encoded data
fn build_dns_query(
    encoded_data: &str,
    options: &DnsTunnelOptions,
    sequence: usize,
    total: usize,
) -> Result<String> {
    let mut query_parts = Vec::new();

    // Add random prefix if enabled
    if options.use_random_prefix {
        let prefix = generate_random_prefix(options.random_prefix_length);
        query_parts.push(prefix);
    }

    // Add sequence information (for reassembly)
    let seq_label = format!("{:04x}{:04x}", sequence, total);
    query_parts.push(seq_label);

    // Split encoded data into DNS-safe labels
    let labels = split_into_labels(encoded_data, options.max_label_length);
    query_parts.extend(labels);

    // Add the base domain
    if !options.domain.is_empty() {
        query_parts.push(options.domain.clone());
    }

    let query = query_parts.join(&options.label_separator.to_string());

    // Validate total length
    if query.len() > options.max_query_length {
        return Err(anyhow!(
            "DNS query too long: {} bytes (max: {})",
            query.len(),
            options.max_query_length
        ));
    }

    Ok(query)
}

/// Split encoded data into DNS labels of specified length
fn split_into_labels(data: &str, max_length: usize) -> Vec<String> {
    data.chars()
        .collect::<Vec<char>>()
        .chunks(max_length)
        .map(|chunk| chunk.iter().collect())
        .collect()
}

/// Generate a random prefix for obfuscation
fn generate_random_prefix(length: usize) -> String {
    use rand::Rng;
    let mut rng = rand::thread_rng();
    let chars: Vec<char> = (0..length)
        .map(|_| {
            let idx = rng.gen_range(0..36);
            if idx < 10 {
                (b'0' + idx as u8) as char
            } else {
                (b'a' + (idx - 10) as u8) as char
            }
        })
        .collect();
    chars.iter().collect()
}

/// Calculate optimal chunk size based on encoding and DNS constraints
fn calculate_chunk_size(encoding: &TunnelEncoding, options: &DnsTunnelOptions) -> usize {
    // Account for encoding expansion
    let encoding_ratio = match encoding {
        TunnelEncoding::Base32 => 1.6, // 5 bits per char
        TunnelEncoding::Hex => 2.0,     // 4 bits per char
        TunnelEncoding::Base64Url | TunnelEncoding::Base64 => 1.34, // 6 bits per char
        _ => 2.0,
    };

    // Calculate available space for data
    // Reserve space for: prefix (8 chars), sequence (8 chars), separators, domain
    let reserved = 8 + 8 + 10 + options.domain.len();
    let available = options.max_query_length.saturating_sub(reserved);

    // Calculate max raw bytes that fit
    ((available as f64) / encoding_ratio) as usize
}

// ============================================================================
// Decoding Functions
// ============================================================================

/// Decode data from DNS tunnel queries
pub fn decode_dns_data(request: &DecodeRequest, options: &DnsTunnelOptions) -> Result<DecodeResponse> {
    let mut decoded_chunks: Vec<(usize, Vec<u8>)> = Vec::new();

    for chunk_data in &request.chunks {
        match decode_chunk(chunk_data, &request.encoding, options) {
            Ok((sequence, data)) => {
                decoded_chunks.push((sequence, data));
            }
            Err(e) => {
                return Ok(DecodeResponse {
                    data: String::new(),
                    original_size: 0,
                    success: false,
                    error: Some(format!("Failed to decode chunk: {}", e)),
                });
            }
        }
    }

    // Sort by sequence number
    decoded_chunks.sort_by_key(|(seq, _)| *seq);

    // Reassemble
    let mut reassembled = Vec::new();
    for (_, data) in decoded_chunks {
        reassembled.extend(data);
    }

    // Return as base64 for binary safety
    use base64::{Engine as _, engine::general_purpose::STANDARD};
    let encoded_result = STANDARD.encode(&reassembled);

    Ok(DecodeResponse {
        data: encoded_result,
        original_size: reassembled.len(),
        success: true,
        error: None,
    })
}

/// Decode a single DNS query chunk
fn decode_chunk(
    query: &str,
    encoding: &TunnelEncoding,
    options: &DnsTunnelOptions,
) -> Result<(usize, Vec<u8>)> {
    // Remove domain suffix
    let query_without_domain = if !options.domain.is_empty() {
        query
            .strip_suffix(&format!(".{}", options.domain))
            .or_else(|| query.strip_suffix(&options.domain))
            .unwrap_or(query)
    } else {
        query
    };

    // Split into labels
    let labels: Vec<&str> = query_without_domain.split('.').collect();

    if labels.is_empty() {
        return Err(anyhow!("Empty DNS query"));
    }

    // Extract sequence info (first or second label depending on prefix)
    let (seq_label_idx, data_start_idx) = if options.use_random_prefix {
        (1, 2)
    } else {
        (0, 1)
    };

    if labels.len() <= seq_label_idx {
        return Err(anyhow!("DNS query too short"));
    }

    // Parse sequence
    let seq_label = labels[seq_label_idx];
    if seq_label.len() != 8 {
        return Err(anyhow!("Invalid sequence label: {}", seq_label));
    }
    let sequence = usize::from_str_radix(&seq_label[..4], 16)
        .map_err(|e| anyhow!("Failed to parse sequence: {}", e))?;

    // Reconstruct encoded data from remaining labels
    let encoded_data: String = labels[data_start_idx..].join("");

    // Decode based on encoding type
    let decoded = match encoding {
        TunnelEncoding::Base32 => {
            base32::decode(Alphabet::Rfc4648Lower { padding: false }, &encoded_data)
                .ok_or_else(|| anyhow!("Failed to decode base32"))?
        }
        TunnelEncoding::Hex => {
            hex::decode(&encoded_data)
                .map_err(|e| anyhow!("Failed to decode hex: {}", e))?
        }
        TunnelEncoding::Base64Url => {
            use base64::{Engine as _, engine::general_purpose::URL_SAFE_NO_PAD};
            URL_SAFE_NO_PAD.decode(&encoded_data)
                .map_err(|e| anyhow!("Failed to decode base64url: {}", e))?
        }
        TunnelEncoding::Base64 => {
            use base64::{Engine as _, engine::general_purpose::STANDARD_NO_PAD};
            // Convert back from DNS-safe characters
            let restored = encoded_data.replace('-', "+").replace('_', "/");
            STANDARD_NO_PAD.decode(&restored)
                .map_err(|e| anyhow!("Failed to decode base64: {}", e))?
        }
        _ => {
            return Err(anyhow!("Unsupported encoding for DNS: {:?}", encoding));
        }
    };

    Ok((sequence, decoded))
}

// ============================================================================
// Domain Generation for Exfiltration
// ============================================================================

/// DNS Domain Generation Algorithm (DGA) for creating query domains
pub struct DomainGenerator {
    /// Base domain suffix
    pub base_domain: String,
    /// Seed for generation
    pub seed: u64,
    /// Current counter
    counter: u64,
}

impl DomainGenerator {
    /// Create a new domain generator
    pub fn new(base_domain: &str, seed: u64) -> Self {
        Self {
            base_domain: base_domain.to_string(),
            seed,
            counter: 0,
        }
    }

    /// Generate the next domain
    pub fn next_domain(&mut self) -> String {
        let hash = simple_hash(self.seed, self.counter);
        self.counter += 1;

        let subdomain = format!("{:016x}", hash);
        format!("{}.{}", subdomain, self.base_domain)
    }

    /// Generate a batch of domains
    pub fn generate_batch(&mut self, count: usize) -> Vec<String> {
        (0..count).map(|_| self.next_domain()).collect()
    }

    /// Reset the generator
    pub fn reset(&mut self) {
        self.counter = 0;
    }
}

/// Simple hash function for domain generation
fn simple_hash(seed: u64, counter: u64) -> u64 {
    let mut h = seed.wrapping_add(counter);
    h = h.wrapping_mul(0x517cc1b727220a95);
    h ^= h >> 32;
    h = h.wrapping_mul(0x517cc1b727220a95);
    h ^= h >> 32;
    h
}

// ============================================================================
// DNS Query Builder for Various Record Types
// ============================================================================

/// Build DNS queries for specific record types
#[derive(Debug, Clone)]
pub struct DnsQueryBuilder {
    options: DnsTunnelOptions,
}

impl DnsQueryBuilder {
    /// Create a new query builder
    pub fn new(options: DnsTunnelOptions) -> Self {
        Self { options }
    }

    /// Build a TXT record query
    pub fn build_txt_query(&self, data: &[u8]) -> Result<String> {
        let mut encode_request = EncodeRequest {
            data: String::new(),
            data_is_base64: true,
            encoding: TunnelEncoding::Base32,
            chunk_size: Some(self.options.max_label_length),
            options: None,
        };

        use base64::{Engine as _, engine::general_purpose::STANDARD};
        encode_request.data = STANDARD.encode(data);

        let response = encode_dns_data(&encode_request, &self.options)?;

        if response.chunks.is_empty() {
            return Err(anyhow!("No chunks generated"));
        }

        Ok(response.chunks[0].payload.clone())
    }

    /// Build an A record query (data encoded in subdomain)
    pub fn build_a_query(&self, data: &[u8]) -> Result<String> {
        // A records return IPv4 addresses, so data must be in the query subdomain
        self.build_txt_query(data)
    }

    /// Build an AAAA record query (data encoded in subdomain)
    pub fn build_aaaa_query(&self, data: &[u8]) -> Result<String> {
        // AAAA records return IPv6 addresses, data in subdomain
        self.build_txt_query(data)
    }

    /// Build a CNAME record query
    pub fn build_cname_query(&self, data: &[u8]) -> Result<String> {
        self.build_txt_query(data)
    }
}

// ============================================================================
// Utility Functions
// ============================================================================

/// Parse DNS options from a HashMap
pub fn parse_dns_options(options: &Option<HashMap<String, serde_json::Value>>) -> DnsTunnelOptions {
    let mut dns_options = DnsTunnelOptions::default();

    if let Some(opts) = options {
        if let Some(domain) = opts.get("domain").and_then(|v| v.as_str()) {
            dns_options.domain = domain.to_string();
        }
        if let Some(record_type) = opts.get("record_type").and_then(|v| v.as_str()) {
            dns_options.record_type = match record_type.to_uppercase().as_str() {
                "TXT" => DnsRecordType::Txt,
                "A" => DnsRecordType::A,
                "AAAA" => DnsRecordType::Aaaa,
                "CNAME" => DnsRecordType::Cname,
                "MX" => DnsRecordType::Mx,
                "NULL" => DnsRecordType::Null,
                _ => DnsRecordType::Txt,
            };
        }
        if let Some(max_label) = opts.get("max_label_length").and_then(|v| v.as_u64()) {
            dns_options.max_label_length = max_label as usize;
        }
        if let Some(use_prefix) = opts.get("use_random_prefix").and_then(|v| v.as_bool()) {
            dns_options.use_random_prefix = use_prefix;
        }
        if let Some(multi_label) = opts.get("multi_label").and_then(|v| v.as_bool()) {
            dns_options.multi_label = multi_label;
        }
    }

    dns_options
}

/// Validate a DNS query for proper format
pub fn validate_dns_query(query: &str) -> Result<()> {
    // Check total length
    if query.len() > 253 {
        return Err(anyhow!("DNS query too long: {} bytes (max: 253)", query.len()));
    }

    // Check each label
    for label in query.split('.') {
        if label.len() > 63 {
            return Err(anyhow!("DNS label too long: {} bytes (max: 63)", label.len()));
        }
        if label.is_empty() {
            return Err(anyhow!("Empty DNS label"));
        }
        // Check for valid characters (alphanumeric and hyphen, not starting/ending with hyphen)
        if !label.chars().all(|c| c.is_ascii_alphanumeric() || c == '-') {
            return Err(anyhow!("Invalid characters in DNS label: {}", label));
        }
        if label.starts_with('-') || label.ends_with('-') {
            return Err(anyhow!("DNS label cannot start or end with hyphen: {}", label));
        }
    }

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_encode_dns_data() {
        let request = EncodeRequest {
            data: "Hello, World!".to_string(),
            data_is_base64: false,
            encoding: TunnelEncoding::Base32,
            chunk_size: None,
            options: None,
        };

        let options = DnsTunnelOptions {
            domain: "tunnel.example.com".to_string(),
            ..Default::default()
        };

        let response = encode_dns_data(&request, &options).unwrap();

        assert!(!response.chunks.is_empty());
        assert_eq!(response.original_size, 13);
        assert!(response.chunks[0].payload.contains("tunnel.example.com"));
    }

    #[test]
    fn test_roundtrip_encoding() {
        let original = b"Test data for DNS tunneling roundtrip";

        let encode_request = EncodeRequest {
            data: String::from_utf8_lossy(original).to_string(),
            data_is_base64: false,
            encoding: TunnelEncoding::Base32,
            chunk_size: Some(20),
            options: None,
        };

        let options = DnsTunnelOptions {
            domain: "test.example.com".to_string(),
            ..Default::default()
        };

        let encoded = encode_dns_data(&encode_request, &options).unwrap();

        // Decode
        let decode_request = DecodeRequest {
            chunks: encoded.chunks.iter().map(|c| c.payload.clone()).collect(),
            encoding: TunnelEncoding::Base32,
            options: None,
        };

        let decoded = decode_dns_data(&decode_request, &options).unwrap();

        assert!(decoded.success);

        // Verify data matches
        use base64::{Engine as _, engine::general_purpose::STANDARD};
        let decoded_bytes = STANDARD.decode(&decoded.data).unwrap();
        assert_eq!(decoded_bytes, original);
    }

    #[test]
    fn test_domain_generator() {
        let mut gen = DomainGenerator::new("example.com", 12345);

        let domain1 = gen.next_domain();
        let domain2 = gen.next_domain();

        assert!(domain1.ends_with(".example.com"));
        assert!(domain2.ends_with(".example.com"));
        assert_ne!(domain1, domain2);

        // Reset and verify deterministic
        gen.reset();
        let domain1_again = gen.next_domain();
        assert_eq!(domain1, domain1_again);
    }

    #[test]
    fn test_split_into_labels() {
        let data = "abcdefghijklmnopqrstuvwxyz";
        let labels = split_into_labels(data, 10);

        assert_eq!(labels.len(), 3);
        assert_eq!(labels[0], "abcdefghij");
        assert_eq!(labels[1], "klmnopqrst");
        assert_eq!(labels[2], "uvwxyz");
    }

    #[test]
    fn test_validate_dns_query() {
        // Valid query
        assert!(validate_dns_query("abc.def.example.com").is_ok());

        // Too long label
        let long_label = "a".repeat(64);
        assert!(validate_dns_query(&format!("{}.example.com", long_label)).is_err());

        // Invalid characters
        assert!(validate_dns_query("abc_def.example.com").is_err());

        // Hyphen at start
        assert!(validate_dns_query("-abc.example.com").is_err());
    }
}
