//! Tunneling Framework Module for Data Exfiltration Defense Testing
//!
//! This module provides tools for testing data exfiltration defenses during authorized
//! penetration testing engagements. It supports encoding/decoding data through various
//! covert channels including DNS, HTTPS, and ICMP tunneling.
//!
//! **WARNING**: This module is intended solely for authorized security testing.
//! Unauthorized use of these techniques may be illegal.

pub mod dns;
pub mod https;
pub mod icmp;

use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

// ============================================================================
// Core Types
// ============================================================================

/// Supported tunneling protocols
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]
#[serde(rename_all = "snake_case")]
pub enum TunnelProtocol {
    /// DNS tunneling using TXT, A, AAAA, or CNAME records
    Dns,
    /// HTTPS tunneling using headers, body, or cookies
    Https,
    /// ICMP tunneling using echo request/reply payloads
    Icmp,
    /// WebSocket tunneling
    WebSocket,
}

impl std::fmt::Display for TunnelProtocol {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            TunnelProtocol::Dns => write!(f, "DNS"),
            TunnelProtocol::Https => write!(f, "HTTPS"),
            TunnelProtocol::Icmp => write!(f, "ICMP"),
            TunnelProtocol::WebSocket => write!(f, "WebSocket"),
        }
    }
}

/// Data encoding methods for tunnel payloads
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Default)]
#[serde(rename_all = "snake_case")]
pub enum TunnelEncoding {
    /// Base64 encoding (standard)
    #[default]
    Base64,
    /// Base64 URL-safe encoding
    Base64Url,
    /// Hexadecimal encoding
    Hex,
    /// Base32 encoding (DNS-safe)
    Base32,
    /// Custom alphabet encoding
    Custom,
    /// No encoding (raw bytes)
    None,
}

impl std::fmt::Display for TunnelEncoding {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            TunnelEncoding::Base64 => write!(f, "Base64"),
            TunnelEncoding::Base64Url => write!(f, "Base64 URL-safe"),
            TunnelEncoding::Hex => write!(f, "Hexadecimal"),
            TunnelEncoding::Base32 => write!(f, "Base32"),
            TunnelEncoding::Custom => write!(f, "Custom"),
            TunnelEncoding::None => write!(f, "None"),
        }
    }
}

/// Session status for tunnel connections
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum TunnelSessionStatus {
    /// Session is active
    Active,
    /// Session is paused
    Paused,
    /// Session completed successfully
    Completed,
    /// Session failed
    Failed,
    /// Session was terminated
    Terminated,
}

impl std::fmt::Display for TunnelSessionStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            TunnelSessionStatus::Active => write!(f, "Active"),
            TunnelSessionStatus::Paused => write!(f, "Paused"),
            TunnelSessionStatus::Completed => write!(f, "Completed"),
            TunnelSessionStatus::Failed => write!(f, "Failed"),
            TunnelSessionStatus::Terminated => write!(f, "Terminated"),
        }
    }
}

/// Exfiltration job status
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum ExfiltrationJobStatus {
    /// Job is pending
    Pending,
    /// Job is in progress
    InProgress,
    /// Job completed successfully
    Completed,
    /// Job failed
    Failed,
    /// Job was cancelled
    Cancelled,
}

impl std::fmt::Display for ExfiltrationJobStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ExfiltrationJobStatus::Pending => write!(f, "Pending"),
            ExfiltrationJobStatus::InProgress => write!(f, "In Progress"),
            ExfiltrationJobStatus::Completed => write!(f, "Completed"),
            ExfiltrationJobStatus::Failed => write!(f, "Failed"),
            ExfiltrationJobStatus::Cancelled => write!(f, "Cancelled"),
        }
    }
}

// ============================================================================
// Configuration Types
// ============================================================================

/// Configuration for a tunnel connection
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TunnelConfig {
    /// Tunneling protocol to use
    pub protocol: TunnelProtocol,
    /// Target server address (e.g., DNS server, HTTPS endpoint)
    pub server: String,
    /// Server port (protocol-specific default if not specified)
    pub port: Option<u16>,
    /// Data encoding method
    pub encoding: TunnelEncoding,
    /// Maximum chunk size for data fragmentation (bytes)
    pub chunk_size: usize,
    /// Delay between chunks (milliseconds) to evade detection
    pub chunk_delay_ms: u64,
    /// Enable encryption (AES-256)
    pub encryption_enabled: bool,
    /// Encryption key (hex-encoded, 32 bytes for AES-256)
    pub encryption_key: Option<String>,
    /// Custom domain for DNS tunneling
    pub dns_domain: Option<String>,
    /// DNS record type for DNS tunneling
    pub dns_record_type: Option<dns::DnsRecordType>,
    /// HTTP method for HTTPS tunneling
    pub https_method: Option<https::HttpsTunnelMethod>,
    /// Custom headers for HTTPS tunneling
    pub https_headers: Option<HashMap<String, String>>,
    /// Additional protocol-specific options
    pub options: HashMap<String, serde_json::Value>,
}

impl Default for TunnelConfig {
    fn default() -> Self {
        Self {
            protocol: TunnelProtocol::Dns,
            server: String::new(),
            port: None,
            encoding: TunnelEncoding::Base64,
            chunk_size: 63, // DNS label limit
            chunk_delay_ms: 100,
            encryption_enabled: false,
            encryption_key: None,
            dns_domain: None,
            dns_record_type: None,
            https_method: None,
            https_headers: None,
            options: HashMap::new(),
        }
    }
}

impl TunnelConfig {
    /// Create a new DNS tunnel configuration
    pub fn dns(domain: &str, record_type: dns::DnsRecordType) -> Self {
        Self {
            protocol: TunnelProtocol::Dns,
            server: String::new(),
            port: Some(53),
            encoding: TunnelEncoding::Base32, // DNS-safe
            chunk_size: 63, // DNS label limit
            chunk_delay_ms: 100,
            dns_domain: Some(domain.to_string()),
            dns_record_type: Some(record_type),
            ..Default::default()
        }
    }

    /// Create a new HTTPS tunnel configuration
    pub fn https(server: &str, method: https::HttpsTunnelMethod) -> Self {
        Self {
            protocol: TunnelProtocol::Https,
            server: server.to_string(),
            port: Some(443),
            encoding: TunnelEncoding::Base64,
            chunk_size: 8192, // HTTP body limit
            chunk_delay_ms: 50,
            https_method: Some(method),
            ..Default::default()
        }
    }

    /// Create a new ICMP tunnel configuration
    pub fn icmp(target: &str) -> Self {
        Self {
            protocol: TunnelProtocol::Icmp,
            server: target.to_string(),
            port: None, // ICMP doesn't use ports
            encoding: TunnelEncoding::Base64,
            chunk_size: 1400, // MTU minus headers
            chunk_delay_ms: 200,
            ..Default::default()
        }
    }
}

// ============================================================================
// Message and Data Types
// ============================================================================

/// A message to be sent through a tunnel
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TunnelMessage {
    /// Unique message ID
    pub id: String,
    /// Raw data to tunnel
    pub data: Vec<u8>,
    /// Encoding used for the data
    pub encoding: TunnelEncoding,
    /// Message sequence number (for fragmented messages)
    pub sequence: u32,
    /// Total number of fragments
    pub total_fragments: u32,
    /// Is this the final fragment?
    pub is_final: bool,
    /// Timestamp
    pub timestamp: DateTime<Utc>,
    /// Additional metadata
    pub metadata: HashMap<String, String>,
}

impl TunnelMessage {
    /// Create a new tunnel message
    pub fn new(data: Vec<u8>, encoding: TunnelEncoding) -> Self {
        Self {
            id: uuid::Uuid::new_v4().to_string(),
            data,
            encoding,
            sequence: 0,
            total_fragments: 1,
            is_final: true,
            timestamp: Utc::now(),
            metadata: HashMap::new(),
        }
    }

    /// Create a fragment of a larger message
    pub fn fragment(
        id: &str,
        data: Vec<u8>,
        encoding: TunnelEncoding,
        sequence: u32,
        total: u32,
    ) -> Self {
        Self {
            id: id.to_string(),
            data,
            encoding,
            sequence,
            total_fragments: total,
            is_final: sequence == total - 1,
            timestamp: Utc::now(),
            metadata: HashMap::new(),
        }
    }
}

/// Encoded tunnel data ready for transmission
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EncodedTunnelData {
    /// Protocol-specific encoded payload
    pub payload: String,
    /// Original data size (before encoding)
    pub original_size: usize,
    /// Encoded data size
    pub encoded_size: usize,
    /// Encoding method used
    pub encoding: TunnelEncoding,
    /// Protocol-specific metadata
    pub protocol_data: serde_json::Value,
}

/// Statistics for a tunnel session or job
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct TunnelStats {
    /// Total bytes sent through the tunnel
    pub bytes_sent: u64,
    /// Total bytes received through the tunnel
    pub bytes_received: u64,
    /// Total packets/requests sent
    pub packets_sent: u64,
    /// Total packets/requests received
    pub packets_received: u64,
    /// Number of failed transmissions
    pub failed_transmissions: u64,
    /// Number of successful transmissions
    pub successful_transmissions: u64,
    /// Average transmission time (milliseconds)
    pub avg_transmission_time_ms: f64,
    /// Maximum transmission time (milliseconds)
    pub max_transmission_time_ms: f64,
    /// Session duration (seconds)
    pub duration_seconds: f64,
    /// Effective throughput (bytes per second)
    pub throughput_bps: f64,
}

impl TunnelStats {
    /// Create new empty stats
    pub fn new() -> Self {
        Self::default()
    }

    /// Record a successful transmission
    pub fn record_transmission(&mut self, bytes: u64, time_ms: f64) {
        self.bytes_sent += bytes;
        self.packets_sent += 1;
        self.successful_transmissions += 1;

        // Update average
        let n = self.successful_transmissions as f64;
        self.avg_transmission_time_ms =
            ((n - 1.0) * self.avg_transmission_time_ms + time_ms) / n;

        // Update max
        if time_ms > self.max_transmission_time_ms {
            self.max_transmission_time_ms = time_ms;
        }
    }

    /// Record a failed transmission
    pub fn record_failure(&mut self) {
        self.failed_transmissions += 1;
    }

    /// Calculate throughput based on current stats
    pub fn calculate_throughput(&mut self, duration_seconds: f64) {
        self.duration_seconds = duration_seconds;
        if duration_seconds > 0.0 {
            self.throughput_bps = self.bytes_sent as f64 / duration_seconds;
        }
    }
}

// ============================================================================
// Session and Job Types
// ============================================================================

/// An active tunnel session
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TunnelSession {
    /// Unique session ID
    pub id: String,
    /// User who created the session
    pub user_id: String,
    /// Session name/description
    pub name: String,
    /// Tunnel configuration
    pub config: TunnelConfig,
    /// Session status
    pub status: TunnelSessionStatus,
    /// Session statistics
    pub stats: TunnelStats,
    /// Session creation time
    pub created_at: DateTime<Utc>,
    /// Session start time (when first data was sent)
    pub started_at: Option<DateTime<Utc>>,
    /// Session end time
    pub ended_at: Option<DateTime<Utc>>,
    /// Last activity time
    pub last_activity: Option<DateTime<Utc>>,
    /// Error message if status is Failed
    pub error: Option<String>,
}

impl TunnelSession {
    /// Create a new tunnel session
    pub fn new(user_id: &str, name: &str, config: TunnelConfig) -> Self {
        Self {
            id: uuid::Uuid::new_v4().to_string(),
            user_id: user_id.to_string(),
            name: name.to_string(),
            config,
            status: TunnelSessionStatus::Active,
            stats: TunnelStats::new(),
            created_at: Utc::now(),
            started_at: None,
            ended_at: None,
            last_activity: None,
            error: None,
        }
    }

    /// Mark session as started
    pub fn start(&mut self) {
        self.started_at = Some(Utc::now());
        self.last_activity = Some(Utc::now());
    }

    /// Update last activity
    pub fn touch(&mut self) {
        self.last_activity = Some(Utc::now());
    }

    /// Mark session as completed
    pub fn complete(&mut self) {
        self.status = TunnelSessionStatus::Completed;
        self.ended_at = Some(Utc::now());
        self.calculate_final_stats();
    }

    /// Mark session as failed
    pub fn fail(&mut self, error: &str) {
        self.status = TunnelSessionStatus::Failed;
        self.error = Some(error.to_string());
        self.ended_at = Some(Utc::now());
        self.calculate_final_stats();
    }

    /// Calculate final statistics
    fn calculate_final_stats(&mut self) {
        if let (Some(start), Some(end)) = (self.started_at, self.ended_at) {
            let duration = (end - start).num_milliseconds() as f64 / 1000.0;
            self.stats.calculate_throughput(duration);
        }
    }
}

/// An exfiltration job for tracking data transfer operations
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExfiltrationJob {
    /// Unique job ID
    pub id: String,
    /// Associated session ID
    pub session_id: String,
    /// User who created the job
    pub user_id: String,
    /// Job name/description
    pub name: String,
    /// Source data identifier (e.g., file path, description)
    pub source: String,
    /// Total data size (bytes)
    pub total_size: u64,
    /// Transferred data size (bytes)
    pub transferred_size: u64,
    /// Number of chunks
    pub total_chunks: u32,
    /// Completed chunks
    pub completed_chunks: u32,
    /// Job status
    pub status: ExfiltrationJobStatus,
    /// Job statistics
    pub stats: TunnelStats,
    /// Job creation time
    pub created_at: DateTime<Utc>,
    /// Job start time
    pub started_at: Option<DateTime<Utc>>,
    /// Job completion time
    pub completed_at: Option<DateTime<Utc>>,
    /// Error message if failed
    pub error: Option<String>,
    /// Additional metadata
    pub metadata: HashMap<String, serde_json::Value>,
}

impl ExfiltrationJob {
    /// Create a new exfiltration job
    pub fn new(
        session_id: &str,
        user_id: &str,
        name: &str,
        source: &str,
        total_size: u64,
        chunk_size: usize,
    ) -> Self {
        let total_chunks = ((total_size as f64) / (chunk_size as f64)).ceil() as u32;
        Self {
            id: uuid::Uuid::new_v4().to_string(),
            session_id: session_id.to_string(),
            user_id: user_id.to_string(),
            name: name.to_string(),
            source: source.to_string(),
            total_size,
            transferred_size: 0,
            total_chunks,
            completed_chunks: 0,
            status: ExfiltrationJobStatus::Pending,
            stats: TunnelStats::new(),
            created_at: Utc::now(),
            started_at: None,
            completed_at: None,
            error: None,
            metadata: HashMap::new(),
        }
    }

    /// Start the job
    pub fn start(&mut self) {
        self.status = ExfiltrationJobStatus::InProgress;
        self.started_at = Some(Utc::now());
    }

    /// Record chunk completion
    pub fn complete_chunk(&mut self, chunk_size: u64, time_ms: f64) {
        self.completed_chunks += 1;
        self.transferred_size += chunk_size;
        self.stats.record_transmission(chunk_size, time_ms);

        if self.completed_chunks >= self.total_chunks {
            self.complete();
        }
    }

    /// Mark job as completed
    pub fn complete(&mut self) {
        self.status = ExfiltrationJobStatus::Completed;
        self.completed_at = Some(Utc::now());
        self.calculate_final_stats();
    }

    /// Mark job as failed
    pub fn fail(&mut self, error: &str) {
        self.status = ExfiltrationJobStatus::Failed;
        self.error = Some(error.to_string());
        self.completed_at = Some(Utc::now());
        self.calculate_final_stats();
    }

    /// Calculate final statistics
    fn calculate_final_stats(&mut self) {
        if let (Some(start), Some(end)) = (self.started_at, self.completed_at) {
            let duration = (end - start).num_milliseconds() as f64 / 1000.0;
            self.stats.calculate_throughput(duration);
        }
    }

    /// Get completion percentage
    pub fn progress_percent(&self) -> f32 {
        if self.total_chunks == 0 {
            return 0.0;
        }
        (self.completed_chunks as f32 / self.total_chunks as f32) * 100.0
    }
}

// ============================================================================
// API Request/Response Types
// ============================================================================

/// Request to encode data for tunneling
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EncodeRequest {
    /// Data to encode (base64 encoded for binary data)
    pub data: String,
    /// Whether data is base64 encoded
    pub data_is_base64: bool,
    /// Target encoding
    pub encoding: TunnelEncoding,
    /// Chunk size (optional, uses protocol default)
    pub chunk_size: Option<usize>,
    /// Protocol-specific options
    pub options: Option<HashMap<String, serde_json::Value>>,
}

/// Response containing encoded data
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EncodeResponse {
    /// Encoded chunks
    pub chunks: Vec<EncodedTunnelData>,
    /// Total number of chunks
    pub total_chunks: usize,
    /// Original data size
    pub original_size: usize,
    /// Total encoded size
    pub total_encoded_size: usize,
    /// Encoding used
    pub encoding: TunnelEncoding,
}

/// Request to decode tunneled data
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DecodeRequest {
    /// Encoded data chunks
    pub chunks: Vec<String>,
    /// Encoding used
    pub encoding: TunnelEncoding,
    /// Protocol-specific options
    pub options: Option<HashMap<String, serde_json::Value>>,
}

/// Response containing decoded data
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DecodeResponse {
    /// Decoded data (base64 encoded for binary safety)
    pub data: String,
    /// Original size before encoding
    pub original_size: usize,
    /// Whether reassembly was successful
    pub success: bool,
    /// Error message if not successful
    pub error: Option<String>,
}

/// Supported protocol information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProtocolInfo {
    /// Protocol identifier
    pub protocol: TunnelProtocol,
    /// Human-readable name
    pub name: String,
    /// Description
    pub description: String,
    /// Supported encodings
    pub supported_encodings: Vec<TunnelEncoding>,
    /// Default chunk size
    pub default_chunk_size: usize,
    /// Maximum chunk size
    pub max_chunk_size: usize,
    /// Whether encryption is supported
    pub supports_encryption: bool,
    /// Protocol-specific options
    pub options: Vec<ProtocolOption>,
}

/// Protocol-specific option definition
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProtocolOption {
    /// Option name
    pub name: String,
    /// Option description
    pub description: String,
    /// Option type
    pub option_type: String,
    /// Default value
    pub default_value: Option<serde_json::Value>,
    /// Whether the option is required
    pub required: bool,
}

// ============================================================================
// Utility Functions
// ============================================================================

/// Get information about all supported protocols
pub fn get_supported_protocols() -> Vec<ProtocolInfo> {
    vec![
        ProtocolInfo {
            protocol: TunnelProtocol::Dns,
            name: "DNS Tunneling".to_string(),
            description: "Encode data in DNS queries (TXT, A, AAAA, CNAME records)".to_string(),
            supported_encodings: vec![
                TunnelEncoding::Base32,
                TunnelEncoding::Hex,
                TunnelEncoding::Base64Url,
            ],
            default_chunk_size: 63,
            max_chunk_size: 253, // DNS label limit
            supports_encryption: true,
            options: vec![
                ProtocolOption {
                    name: "domain".to_string(),
                    description: "Base domain for DNS queries".to_string(),
                    option_type: "string".to_string(),
                    default_value: None,
                    required: true,
                },
                ProtocolOption {
                    name: "record_type".to_string(),
                    description: "DNS record type (TXT, A, AAAA, CNAME)".to_string(),
                    option_type: "string".to_string(),
                    default_value: Some(serde_json::json!("TXT")),
                    required: false,
                },
            ],
        },
        ProtocolInfo {
            protocol: TunnelProtocol::Https,
            name: "HTTPS Tunneling".to_string(),
            description: "Encode data in HTTP headers, body, URL parameters, or cookies".to_string(),
            supported_encodings: vec![
                TunnelEncoding::Base64,
                TunnelEncoding::Base64Url,
                TunnelEncoding::Hex,
            ],
            default_chunk_size: 8192,
            max_chunk_size: 1048576, // 1MB
            supports_encryption: true,
            options: vec![
                ProtocolOption {
                    name: "method".to_string(),
                    description: "Tunneling method (headers, body, url_params, cookies)".to_string(),
                    option_type: "string".to_string(),
                    default_value: Some(serde_json::json!("body")),
                    required: false,
                },
                ProtocolOption {
                    name: "http_method".to_string(),
                    description: "HTTP method (GET, POST, PUT)".to_string(),
                    option_type: "string".to_string(),
                    default_value: Some(serde_json::json!("POST")),
                    required: false,
                },
            ],
        },
        ProtocolInfo {
            protocol: TunnelProtocol::Icmp,
            name: "ICMP Tunneling".to_string(),
            description: "Encode data in ICMP echo request/reply payloads".to_string(),
            supported_encodings: vec![
                TunnelEncoding::Base64,
                TunnelEncoding::Hex,
                TunnelEncoding::None,
            ],
            default_chunk_size: 1400,
            max_chunk_size: 65507, // Max ICMP payload
            supports_encryption: true,
            options: vec![
                ProtocolOption {
                    name: "icmp_type".to_string(),
                    description: "ICMP message type (echo_request, echo_reply)".to_string(),
                    option_type: "string".to_string(),
                    default_value: Some(serde_json::json!("echo_request")),
                    required: false,
                },
                ProtocolOption {
                    name: "identifier".to_string(),
                    description: "ICMP identifier for session tracking".to_string(),
                    option_type: "integer".to_string(),
                    default_value: Some(serde_json::json!(0)),
                    required: false,
                },
            ],
        },
        ProtocolInfo {
            protocol: TunnelProtocol::WebSocket,
            name: "WebSocket Tunneling".to_string(),
            description: "Encode data in WebSocket frames".to_string(),
            supported_encodings: vec![
                TunnelEncoding::Base64,
                TunnelEncoding::None,
            ],
            default_chunk_size: 16384,
            max_chunk_size: 16777216, // 16MB
            supports_encryption: true,
            options: vec![
                ProtocolOption {
                    name: "mask".to_string(),
                    description: "Apply WebSocket masking".to_string(),
                    option_type: "boolean".to_string(),
                    default_value: Some(serde_json::json!(true)),
                    required: false,
                },
            ],
        },
    ]
}

/// Split data into chunks of the specified size
pub fn chunk_data(data: &[u8], chunk_size: usize) -> Vec<Vec<u8>> {
    data.chunks(chunk_size)
        .map(|chunk| chunk.to_vec())
        .collect()
}

/// Reassemble chunked data
pub fn reassemble_data(chunks: &[Vec<u8>]) -> Vec<u8> {
    chunks.iter().flatten().copied().collect()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_chunk_data() {
        let data = b"Hello, World! This is a test message.";
        let chunks = chunk_data(data, 10);

        assert_eq!(chunks.len(), 4);
        assert_eq!(chunks[0].len(), 10);
        assert_eq!(chunks[3].len(), 7); // Last chunk is smaller (37 total bytes)

        let reassembled = reassemble_data(&chunks);
        assert_eq!(reassembled, data.to_vec());
    }

    #[test]
    fn test_tunnel_config_dns() {
        let config = TunnelConfig::dns("example.com", dns::DnsRecordType::Txt);
        assert_eq!(config.protocol, TunnelProtocol::Dns);
        assert_eq!(config.encoding, TunnelEncoding::Base32);
        assert_eq!(config.dns_domain, Some("example.com".to_string()));
    }

    #[test]
    fn test_tunnel_session() {
        let config = TunnelConfig::default();
        let mut session = TunnelSession::new("user123", "Test Session", config);

        assert_eq!(session.status, TunnelSessionStatus::Active);
        assert!(session.started_at.is_none());

        session.start();
        assert!(session.started_at.is_some());

        session.complete();
        assert_eq!(session.status, TunnelSessionStatus::Completed);
        assert!(session.ended_at.is_some());
    }

    #[test]
    fn test_exfiltration_job_progress() {
        let mut job = ExfiltrationJob::new(
            "session123",
            "user123",
            "Test Job",
            "test_file.txt",
            1000,
            100,
        );

        assert_eq!(job.total_chunks, 10);
        assert_eq!(job.progress_percent(), 0.0);

        job.start();
        job.complete_chunk(100, 50.0);
        assert_eq!(job.progress_percent(), 10.0);

        for _ in 0..9 {
            job.complete_chunk(100, 50.0);
        }

        assert_eq!(job.status, ExfiltrationJobStatus::Completed);
        assert_eq!(job.progress_percent(), 100.0);
    }

    #[test]
    fn test_tunnel_stats() {
        let mut stats = TunnelStats::new();

        stats.record_transmission(100, 50.0);
        stats.record_transmission(200, 100.0);

        assert_eq!(stats.bytes_sent, 300);
        assert_eq!(stats.packets_sent, 2);
        assert_eq!(stats.successful_transmissions, 2);
        assert_eq!(stats.avg_transmission_time_ms, 75.0);
        assert_eq!(stats.max_transmission_time_ms, 100.0);

        stats.calculate_throughput(1.0);
        assert_eq!(stats.throughput_bps, 300.0);
    }
}
