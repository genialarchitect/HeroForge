//! ICMP Tunneling Module
//!
//! Provides encoding and decoding of data through ICMP echo request/reply payloads
//! for testing data exfiltration defenses during authorized penetration testing.
//!
//! **Requires root privileges or CAP_NET_RAW capability for actual ICMP transmission.**

use crate::scanner::exploitation::tunneling::{
    chunk_data, DecodeRequest, DecodeResponse, EncodeRequest, EncodeResponse,
    EncodedTunnelData, TunnelEncoding,
};
use anyhow::{anyhow, Result};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

// ============================================================================
// ICMP Types
// ============================================================================

/// ICMP message types for tunneling
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Default)]
#[serde(rename_all = "snake_case")]
pub enum IcmpMessageType {
    /// Echo Request (ping)
    #[default]
    EchoRequest,
    /// Echo Reply (pong)
    EchoReply,
    /// Destination Unreachable (can encode data in unused bytes)
    DestUnreachable,
    /// Timestamp Request
    TimestampRequest,
    /// Timestamp Reply
    TimestampReply,
}

impl IcmpMessageType {
    /// Get the ICMP type number
    pub fn type_number(&self) -> u8 {
        match self {
            IcmpMessageType::EchoRequest => 8,
            IcmpMessageType::EchoReply => 0,
            IcmpMessageType::DestUnreachable => 3,
            IcmpMessageType::TimestampRequest => 13,
            IcmpMessageType::TimestampReply => 14,
        }
    }

    /// Get the typical payload capacity
    pub fn payload_capacity(&self) -> usize {
        match self {
            IcmpMessageType::EchoRequest | IcmpMessageType::EchoReply => 65507, // Max IP payload
            IcmpMessageType::DestUnreachable => 576 - 28, // Min MTU minus headers
            IcmpMessageType::TimestampRequest | IcmpMessageType::TimestampReply => 12,
        }
    }
}

impl std::fmt::Display for IcmpMessageType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            IcmpMessageType::EchoRequest => write!(f, "Echo Request"),
            IcmpMessageType::EchoReply => write!(f, "Echo Reply"),
            IcmpMessageType::DestUnreachable => write!(f, "Destination Unreachable"),
            IcmpMessageType::TimestampRequest => write!(f, "Timestamp Request"),
            IcmpMessageType::TimestampReply => write!(f, "Timestamp Reply"),
        }
    }
}

// ============================================================================
// ICMP-specific Configuration
// ============================================================================

/// ICMP tunneling configuration options
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct IcmpTunnelOptions {
    /// Target IP address
    pub target: String,
    /// ICMP message type
    pub message_type: IcmpMessageType,
    /// ICMP identifier (for session tracking)
    pub identifier: u16,
    /// Starting sequence number
    pub start_sequence: u16,
    /// Maximum payload size per packet
    pub max_payload_size: usize,
    /// Add timestamp to payload
    pub include_timestamp: bool,
    /// Add checksum to payload
    pub include_checksum: bool,
    /// Pad payloads to fixed size (for traffic analysis evasion)
    pub pad_to_size: Option<usize>,
    /// Use fragmentation for large payloads
    pub allow_fragmentation: bool,
    /// TTL value
    pub ttl: u8,
}

impl Default for IcmpTunnelOptions {
    fn default() -> Self {
        Self {
            target: String::new(),
            message_type: IcmpMessageType::EchoRequest,
            identifier: rand::random(),
            start_sequence: 1,
            max_payload_size: 1400, // Safe MTU minus headers
            include_timestamp: true,
            include_checksum: true,
            pad_to_size: None,
            allow_fragmentation: false,
            ttl: 64,
        }
    }
}

/// ICMP packet structure for encoding
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct IcmpPacket {
    /// ICMP type
    pub icmp_type: u8,
    /// ICMP code
    pub code: u8,
    /// ICMP checksum (calculated)
    pub checksum: u16,
    /// Identifier
    pub identifier: u16,
    /// Sequence number
    pub sequence: u16,
    /// Payload data
    pub payload: Vec<u8>,
    /// Total packet size
    pub total_size: usize,
}

impl IcmpPacket {
    /// Create a new ICMP echo request packet
    pub fn echo_request(identifier: u16, sequence: u16, payload: Vec<u8>) -> Self {
        let mut packet = Self {
            icmp_type: 8, // Echo Request
            code: 0,
            checksum: 0,
            identifier,
            sequence,
            payload,
            total_size: 0,
        };
        packet.total_size = 8 + packet.payload.len(); // Header + payload
        packet.checksum = packet.calculate_checksum();
        packet
    }

    /// Create a new ICMP echo reply packet
    pub fn echo_reply(identifier: u16, sequence: u16, payload: Vec<u8>) -> Self {
        let mut packet = Self {
            icmp_type: 0, // Echo Reply
            code: 0,
            checksum: 0,
            identifier,
            sequence,
            payload,
            total_size: 0,
        };
        packet.total_size = 8 + packet.payload.len();
        packet.checksum = packet.calculate_checksum();
        packet
    }

    /// Calculate ICMP checksum
    pub fn calculate_checksum(&self) -> u16 {
        let mut bytes = self.to_bytes_without_checksum();

        // Pad to even length if necessary
        if bytes.len() % 2 != 0 {
            bytes.push(0);
        }

        let mut sum: u32 = 0;
        for chunk in bytes.chunks(2) {
            let word = ((chunk[0] as u32) << 8) | (chunk[1] as u32);
            sum = sum.wrapping_add(word);
        }

        // Fold 32-bit sum to 16 bits
        while (sum >> 16) != 0 {
            sum = (sum & 0xFFFF) + (sum >> 16);
        }

        !(sum as u16)
    }

    /// Convert to bytes without checksum
    fn to_bytes_without_checksum(&self) -> Vec<u8> {
        let mut bytes = Vec::with_capacity(8 + self.payload.len());
        bytes.push(self.icmp_type);
        bytes.push(self.code);
        bytes.push(0); // Checksum placeholder
        bytes.push(0);
        bytes.push((self.identifier >> 8) as u8);
        bytes.push((self.identifier & 0xFF) as u8);
        bytes.push((self.sequence >> 8) as u8);
        bytes.push((self.sequence & 0xFF) as u8);
        bytes.extend(&self.payload);
        bytes
    }

    /// Convert to raw bytes
    pub fn to_bytes(&self) -> Vec<u8> {
        let mut bytes = Vec::with_capacity(8 + self.payload.len());
        bytes.push(self.icmp_type);
        bytes.push(self.code);
        bytes.push((self.checksum >> 8) as u8);
        bytes.push((self.checksum & 0xFF) as u8);
        bytes.push((self.identifier >> 8) as u8);
        bytes.push((self.identifier & 0xFF) as u8);
        bytes.push((self.sequence >> 8) as u8);
        bytes.push((self.sequence & 0xFF) as u8);
        bytes.extend(&self.payload);
        bytes
    }

    /// Parse from raw bytes
    pub fn from_bytes(bytes: &[u8]) -> Result<Self> {
        if bytes.len() < 8 {
            return Err(anyhow!("ICMP packet too short: {} bytes", bytes.len()));
        }

        Ok(Self {
            icmp_type: bytes[0],
            code: bytes[1],
            checksum: ((bytes[2] as u16) << 8) | (bytes[3] as u16),
            identifier: ((bytes[4] as u16) << 8) | (bytes[5] as u16),
            sequence: ((bytes[6] as u16) << 8) | (bytes[7] as u16),
            payload: bytes[8..].to_vec(),
            total_size: bytes.len(),
        })
    }
}

// ============================================================================
// Encoding Functions
// ============================================================================

/// Encode data for ICMP tunneling
pub fn encode_icmp_data(request: &EncodeRequest, options: &IcmpTunnelOptions) -> Result<EncodeResponse> {
    // Decode input data if base64 encoded
    let data = if request.data_is_base64 {
        use base64::{Engine as _, engine::general_purpose::STANDARD};
        STANDARD.decode(&request.data)
            .map_err(|e| anyhow!("Failed to decode base64 input: {}", e))?
    } else {
        request.data.as_bytes().to_vec()
    };

    let original_size = data.len();

    // Determine chunk size (account for metadata in payload)
    let metadata_overhead = calculate_metadata_overhead(options);
    let effective_chunk_size = options.max_payload_size.saturating_sub(metadata_overhead);
    let chunk_size = request.chunk_size.unwrap_or(effective_chunk_size);

    // Split data into chunks
    let raw_chunks = chunk_data(&data, chunk_size);

    // Encode each chunk
    let mut encoded_chunks = Vec::new();
    let mut total_encoded_size = 0;

    for (i, chunk) in raw_chunks.iter().enumerate() {
        let sequence = options.start_sequence.wrapping_add(i as u16);
        let encoded = encode_icmp_chunk(chunk, &request.encoding, options, i, raw_chunks.len(), sequence)?;
        total_encoded_size += encoded.encoded_size;
        encoded_chunks.push(encoded);
    }

    Ok(EncodeResponse {
        chunks: encoded_chunks,
        total_chunks: raw_chunks.len(),
        original_size,
        total_encoded_size,
        encoding: request.encoding.clone(),
    })
}

/// Calculate metadata overhead in payload
fn calculate_metadata_overhead(options: &IcmpTunnelOptions) -> usize {
    let mut overhead = 8; // Base: 4 bytes sequence info + 4 bytes total/flags

    if options.include_timestamp {
        overhead += 8; // Unix timestamp
    }

    if options.include_checksum {
        overhead += 4; // CRC32
    }

    overhead
}

/// Encode a single chunk for ICMP packet
fn encode_icmp_chunk(
    data: &[u8],
    encoding: &TunnelEncoding,
    options: &IcmpTunnelOptions,
    index: usize,
    total: usize,
    sequence: u16,
) -> Result<EncodedTunnelData> {
    // Build the payload with metadata
    let mut payload = Vec::new();

    // Add sequence info (4 bytes)
    payload.extend(&(index as u32).to_be_bytes());

    // Add total chunks and flags (4 bytes)
    let flags: u32 = ((total as u32) << 8) | (if index == total - 1 { 1 } else { 0 });
    payload.extend(&flags.to_be_bytes());

    // Add timestamp if enabled
    if options.include_timestamp {
        let timestamp = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap_or_default()
            .as_secs();
        payload.extend(&timestamp.to_be_bytes());
    }

    // Encode the actual data
    let encoded_data = match encoding {
        TunnelEncoding::Base64 => {
            use base64::{Engine as _, engine::general_purpose::STANDARD};
            STANDARD.encode(data).into_bytes()
        }
        TunnelEncoding::Hex => {
            hex::encode(data).into_bytes()
        }
        TunnelEncoding::None => {
            data.to_vec()
        }
        _ => {
            return Err(anyhow!("Unsupported encoding for ICMP: {:?}", encoding));
        }
    };

    // Add data length (4 bytes) and data
    payload.extend(&(encoded_data.len() as u32).to_be_bytes());
    payload.extend(&encoded_data);

    // Add checksum if enabled
    if options.include_checksum {
        let crc = crc32(&payload);
        payload.extend(&crc.to_be_bytes());
    }

    // Pad to fixed size if configured
    if let Some(pad_size) = options.pad_to_size {
        if payload.len() < pad_size {
            payload.resize(pad_size, 0);
        }
    }

    // Create ICMP packet
    let packet = match options.message_type {
        IcmpMessageType::EchoRequest => {
            IcmpPacket::echo_request(options.identifier, sequence, payload.clone())
        }
        IcmpMessageType::EchoReply => {
            IcmpPacket::echo_reply(options.identifier, sequence, payload.clone())
        }
        _ => {
            // For other types, still use echo request format
            IcmpPacket::echo_request(options.identifier, sequence, payload.clone())
        }
    };

    // Convert to hex string for transport
    let packet_bytes = packet.to_bytes();
    let hex_payload = hex::encode(&packet_bytes);

    let protocol_data = serde_json::json!({
        "target": options.target,
        "icmp_type": options.message_type.type_number(),
        "identifier": options.identifier,
        "sequence": sequence,
        "index": index,
        "total": total,
        "payload_size": payload.len(),
        "packet_size": packet_bytes.len(),
        "raw_packet": hex_payload.clone(),
    });

    Ok(EncodedTunnelData {
        payload: hex_payload,
        original_size: data.len(),
        encoded_size: packet_bytes.len(),
        encoding: encoding.clone(),
        protocol_data,
    })
}

/// CRC32 checksum
fn crc32(data: &[u8]) -> u32 {
    let mut crc: u32 = 0xFFFFFFFF;
    for byte in data {
        crc ^= *byte as u32;
        for _ in 0..8 {
            if crc & 1 != 0 {
                crc = (crc >> 1) ^ 0xEDB88320;
            } else {
                crc >>= 1;
            }
        }
    }
    !crc
}

// ============================================================================
// Decoding Functions
// ============================================================================

/// Decode data from ICMP tunnel
pub fn decode_icmp_data(request: &DecodeRequest, options: &IcmpTunnelOptions) -> Result<DecodeResponse> {
    let mut decoded_chunks: Vec<(usize, Vec<u8>)> = Vec::new();

    for chunk_data in &request.chunks {
        match decode_icmp_chunk(chunk_data, &request.encoding, options) {
            Ok((sequence, data)) => {
                decoded_chunks.push((sequence, data));
            }
            Err(e) => {
                return Ok(DecodeResponse {
                    data: String::new(),
                    original_size: 0,
                    success: false,
                    error: Some(format!("Failed to decode chunk: {}", e)),
                });
            }
        }
    }

    // Sort by sequence number
    decoded_chunks.sort_by_key(|(seq, _)| *seq);

    // Reassemble
    let mut reassembled = Vec::new();
    for (_, data) in decoded_chunks {
        reassembled.extend(data);
    }

    // Return as base64 for binary safety
    use base64::{Engine as _, engine::general_purpose::STANDARD};
    let encoded_result = STANDARD.encode(&reassembled);

    Ok(DecodeResponse {
        data: encoded_result,
        original_size: reassembled.len(),
        success: true,
        error: None,
    })
}

/// Decode a single ICMP chunk
fn decode_icmp_chunk(
    hex_payload: &str,
    encoding: &TunnelEncoding,
    options: &IcmpTunnelOptions,
) -> Result<(usize, Vec<u8>)> {
    // Decode hex to bytes
    let packet_bytes = hex::decode(hex_payload)
        .map_err(|e| anyhow!("Failed to decode hex payload: {}", e))?;

    // Parse ICMP packet
    let packet = IcmpPacket::from_bytes(&packet_bytes)?;

    // Verify checksum
    let calculated_checksum = {
        let mut temp_packet = packet.clone();
        temp_packet.checksum = 0;
        temp_packet.checksum = temp_packet.calculate_checksum();
        temp_packet.checksum
    };

    if calculated_checksum != packet.checksum {
        return Err(anyhow!(
            "ICMP checksum mismatch: expected {:04x}, got {:04x}",
            calculated_checksum,
            packet.checksum
        ));
    }

    // Parse payload
    let payload = &packet.payload;
    let mut offset = 0;

    // Read sequence info
    if payload.len() < 8 {
        return Err(anyhow!("Payload too short for metadata"));
    }

    let index = u32::from_be_bytes([
        payload[offset],
        payload[offset + 1],
        payload[offset + 2],
        payload[offset + 3],
    ]) as usize;
    offset += 4;

    // Skip flags
    offset += 4;

    // Skip timestamp if present
    if options.include_timestamp {
        if payload.len() < offset + 8 {
            return Err(anyhow!("Payload too short for timestamp"));
        }
        offset += 8;
    }

    // Read data length
    if payload.len() < offset + 4 {
        return Err(anyhow!("Payload too short for data length"));
    }

    let data_len = u32::from_be_bytes([
        payload[offset],
        payload[offset + 1],
        payload[offset + 2],
        payload[offset + 3],
    ]) as usize;
    offset += 4;

    // Read encoded data
    if payload.len() < offset + data_len {
        return Err(anyhow!("Payload too short for data"));
    }

    let encoded_data = &payload[offset..offset + data_len];

    // Verify CRC if enabled
    if options.include_checksum {
        let crc_offset = offset + data_len;
        if payload.len() >= crc_offset + 4 {
            let stored_crc = u32::from_be_bytes([
                payload[crc_offset],
                payload[crc_offset + 1],
                payload[crc_offset + 2],
                payload[crc_offset + 3],
            ]);

            let calculated_crc = crc32(&payload[..crc_offset]);
            if stored_crc != calculated_crc {
                return Err(anyhow!(
                    "CRC mismatch: expected {:08x}, got {:08x}",
                    calculated_crc,
                    stored_crc
                ));
            }
        }
    }

    // Decode the data
    let decoded = match encoding {
        TunnelEncoding::Base64 => {
            use base64::{Engine as _, engine::general_purpose::STANDARD};
            STANDARD.decode(encoded_data)
                .map_err(|e| anyhow!("Failed to decode base64: {}", e))?
        }
        TunnelEncoding::Hex => {
            hex::decode(encoded_data)
                .map_err(|e| anyhow!("Failed to decode hex: {}", e))?
        }
        TunnelEncoding::None => {
            encoded_data.to_vec()
        }
        _ => {
            return Err(anyhow!("Unsupported encoding for ICMP: {:?}", encoding));
        }
    };

    Ok((index, decoded))
}

// ============================================================================
// Utility Functions
// ============================================================================

/// Parse ICMP options from a HashMap
pub fn parse_icmp_options(options: &Option<HashMap<String, serde_json::Value>>) -> IcmpTunnelOptions {
    let mut icmp_options = IcmpTunnelOptions::default();

    if let Some(opts) = options {
        if let Some(target) = opts.get("target").and_then(|v| v.as_str()) {
            icmp_options.target = target.to_string();
        }
        if let Some(msg_type) = opts.get("message_type").and_then(|v| v.as_str()) {
            icmp_options.message_type = match msg_type.to_lowercase().as_str() {
                "echo_request" | "ping" => IcmpMessageType::EchoRequest,
                "echo_reply" | "pong" => IcmpMessageType::EchoReply,
                "dest_unreachable" => IcmpMessageType::DestUnreachable,
                "timestamp_request" => IcmpMessageType::TimestampRequest,
                "timestamp_reply" => IcmpMessageType::TimestampReply,
                _ => IcmpMessageType::EchoRequest,
            };
        }
        if let Some(id) = opts.get("identifier").and_then(|v| v.as_u64()) {
            icmp_options.identifier = id as u16;
        }
        if let Some(seq) = opts.get("start_sequence").and_then(|v| v.as_u64()) {
            icmp_options.start_sequence = seq as u16;
        }
        if let Some(size) = opts.get("max_payload_size").and_then(|v| v.as_u64()) {
            icmp_options.max_payload_size = size as usize;
        }
        if let Some(ts) = opts.get("include_timestamp").and_then(|v| v.as_bool()) {
            icmp_options.include_timestamp = ts;
        }
        if let Some(crc) = opts.get("include_checksum").and_then(|v| v.as_bool()) {
            icmp_options.include_checksum = crc;
        }
        if let Some(pad) = opts.get("pad_to_size").and_then(|v| v.as_u64()) {
            icmp_options.pad_to_size = Some(pad as usize);
        }
        if let Some(ttl) = opts.get("ttl").and_then(|v| v.as_u64()) {
            icmp_options.ttl = ttl as u8;
        }
    }

    icmp_options
}

/// Check if ICMP tunneling is available (requires root/CAP_NET_RAW)
pub fn check_icmp_capability() -> bool {
    // On Linux, check if we can create a raw socket
    #[cfg(target_os = "linux")]
    {
        unsafe {
            let fd = libc::socket(libc::AF_INET, libc::SOCK_RAW, libc::IPPROTO_ICMP);
            if fd >= 0 {
                libc::close(fd);
                return true;
            }
        }
        false
    }

    #[cfg(not(target_os = "linux"))]
    {
        // On other platforms, assume available (would fail at runtime anyway)
        true
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_icmp_packet_creation() {
        let payload = b"Hello, ICMP!".to_vec();
        let packet = IcmpPacket::echo_request(1234, 1, payload.clone());

        assert_eq!(packet.icmp_type, 8);
        assert_eq!(packet.code, 0);
        assert_eq!(packet.identifier, 1234);
        assert_eq!(packet.sequence, 1);
        assert_eq!(packet.payload, payload);
        assert!(packet.checksum != 0);
    }

    #[test]
    fn test_icmp_packet_roundtrip() {
        let original = IcmpPacket::echo_request(5678, 42, b"Test data".to_vec());
        let bytes = original.to_bytes();
        let parsed = IcmpPacket::from_bytes(&bytes).unwrap();

        assert_eq!(original.icmp_type, parsed.icmp_type);
        assert_eq!(original.identifier, parsed.identifier);
        assert_eq!(original.sequence, parsed.sequence);
        assert_eq!(original.payload, parsed.payload);
        assert_eq!(original.checksum, parsed.checksum);
    }

    #[test]
    fn test_encode_icmp_data() {
        let request = EncodeRequest {
            data: "Hello, World!".to_string(),
            data_is_base64: false,
            encoding: TunnelEncoding::Base64,
            chunk_size: None,
            options: None,
        };

        let options = IcmpTunnelOptions {
            target: "192.168.1.1".to_string(),
            identifier: 12345,
            ..Default::default()
        };

        let response = encode_icmp_data(&request, &options).unwrap();

        assert!(!response.chunks.is_empty());
        assert_eq!(response.original_size, 13);

        // Verify the payload is valid hex
        let hex_payload = &response.chunks[0].payload;
        assert!(hex::decode(hex_payload).is_ok());
    }

    #[test]
    fn test_roundtrip_encoding() {
        let original = b"Test data for ICMP tunneling roundtrip";

        let encode_request = EncodeRequest {
            data: String::from_utf8_lossy(original).to_string(),
            data_is_base64: false,
            encoding: TunnelEncoding::Base64,
            chunk_size: Some(20),
            options: None,
        };

        let options = IcmpTunnelOptions {
            target: "10.0.0.1".to_string(),
            include_timestamp: true,
            include_checksum: true,
            ..Default::default()
        };

        let encoded = encode_icmp_data(&encode_request, &options).unwrap();

        // Decode
        let decode_request = DecodeRequest {
            chunks: encoded.chunks.iter().map(|c| c.payload.clone()).collect(),
            encoding: TunnelEncoding::Base64,
            options: None,
        };

        let decoded = decode_icmp_data(&decode_request, &options).unwrap();

        assert!(decoded.success);

        use base64::{Engine as _, engine::general_purpose::STANDARD};
        let decoded_bytes = STANDARD.decode(&decoded.data).unwrap();
        assert_eq!(decoded_bytes, original);
    }

    #[test]
    fn test_crc32() {
        let data = b"123456789";
        let crc = crc32(data);
        assert_eq!(crc, 0xCBF43926); // Known CRC32 value
    }

    #[test]
    fn test_icmp_checksum() {
        // Create a packet and verify checksum is valid
        let packet = IcmpPacket::echo_request(1, 1, vec![0x08, 0x09, 0x0a, 0x0b]);

        // Re-calculate and verify
        let mut verify_packet = packet.clone();
        verify_packet.checksum = 0;
        let calculated = verify_packet.calculate_checksum();

        assert_eq!(packet.checksum, calculated);
    }

    #[test]
    fn test_message_type_numbers() {
        assert_eq!(IcmpMessageType::EchoRequest.type_number(), 8);
        assert_eq!(IcmpMessageType::EchoReply.type_number(), 0);
        assert_eq!(IcmpMessageType::DestUnreachable.type_number(), 3);
    }
}
