// Payload Encoders Module
// Comprehensive encoding and obfuscation utilities for authorized penetration testing
//
// This module provides various encoding techniques to help red teams test security
// controls including EDR/AV evasion testing during authorized engagements.

pub mod xor;
pub mod base64_enc;
pub mod aes;
pub mod custom;

use anyhow::{anyhow, Result};
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

// Re-export encoder functions for convenience
#[allow(unused_imports)]
pub use xor::*;
#[allow(unused_imports)]
pub use base64_enc::*;
#[allow(unused_imports)]
pub use aes::*;
#[allow(unused_imports)]
pub use custom::*;

// ============================================================================
// Core Encoder Trait
// ============================================================================

/// Trait for payload encoders
pub trait Encoder: Send + Sync {
    /// Get the encoder type
    fn encoder_type(&self) -> EncoderType;

    /// Encode data
    fn encode(&self, data: &[u8], options: &EncodingOptions) -> Result<EncodingResult>;

    /// Decode data
    fn decode(&self, data: &[u8], options: &EncodingOptions) -> Result<Vec<u8>>;

    /// Get encoder description
    fn description(&self) -> &'static str;

    /// Check if encoder is reversible
    fn is_reversible(&self) -> bool {
        true
    }
}

// ============================================================================
// Encoder Types
// ============================================================================

/// Available encoder types
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]
#[serde(rename_all = "snake_case")]
pub enum EncoderType {
    // XOR variants
    XorSingleByte,
    XorMultiByte,
    XorRolling,
    XorAdditive,

    // Base64 variants
    Base64Standard,
    Base64UrlSafe,
    Base64Custom,
    Base64NoPadding,

    // AES variants
    Aes128Cbc,
    Aes256Cbc,
    Aes128Gcm,
    Aes256Gcm,

    // Custom encoders
    Hex,
    HexReverse,
    Rot13,
    Rot47,
    Unicode,
    UnicodeEscape,
    UrlEncode,
    HtmlEntities,
    StringReverse,
    CharSwap,
    ByteShuffle,

    // Composite
    Chain,
}

impl std::fmt::Display for EncoderType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            EncoderType::XorSingleByte => write!(f, "XOR Single-Byte"),
            EncoderType::XorMultiByte => write!(f, "XOR Multi-Byte"),
            EncoderType::XorRolling => write!(f, "XOR Rolling"),
            EncoderType::XorAdditive => write!(f, "XOR Additive"),
            EncoderType::Base64Standard => write!(f, "Base64 Standard"),
            EncoderType::Base64UrlSafe => write!(f, "Base64 URL-Safe"),
            EncoderType::Base64Custom => write!(f, "Base64 Custom Alphabet"),
            EncoderType::Base64NoPadding => write!(f, "Base64 No Padding"),
            EncoderType::Aes128Cbc => write!(f, "AES-128 CBC"),
            EncoderType::Aes256Cbc => write!(f, "AES-256 CBC"),
            EncoderType::Aes128Gcm => write!(f, "AES-128 GCM"),
            EncoderType::Aes256Gcm => write!(f, "AES-256 GCM"),
            EncoderType::Hex => write!(f, "Hex"),
            EncoderType::HexReverse => write!(f, "Hex Reverse"),
            EncoderType::Rot13 => write!(f, "ROT13"),
            EncoderType::Rot47 => write!(f, "ROT47"),
            EncoderType::Unicode => write!(f, "Unicode"),
            EncoderType::UnicodeEscape => write!(f, "Unicode Escape"),
            EncoderType::UrlEncode => write!(f, "URL Encode"),
            EncoderType::HtmlEntities => write!(f, "HTML Entities"),
            EncoderType::StringReverse => write!(f, "String Reverse"),
            EncoderType::CharSwap => write!(f, "Character Swap"),
            EncoderType::ByteShuffle => write!(f, "Byte Shuffle"),
            EncoderType::Chain => write!(f, "Encoder Chain"),
        }
    }
}

// ============================================================================
// Encoding Options
// ============================================================================

/// Options for encoding operations
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EncodingOptions {
    /// Encryption/encoding key
    pub key: Option<String>,

    /// Key as raw bytes (for binary keys)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub key_bytes: Option<Vec<u8>>,

    /// Initialization vector for block ciphers
    pub iv: Option<String>,

    /// Custom alphabet for custom Base64
    pub custom_alphabet: Option<String>,

    /// Number of encoding iterations
    #[serde(default = "default_iterations")]
    pub iterations: u32,

    /// Preserve null bytes
    #[serde(default)]
    pub preserve_nulls: bool,

    /// Add random padding
    #[serde(default)]
    pub random_padding: bool,

    /// Padding size
    #[serde(default)]
    pub padding_size: usize,

    /// Generate decoder stub
    #[serde(default = "default_true")]
    pub generate_decoder_stub: bool,

    /// Decoder stub language
    #[serde(default)]
    pub decoder_language: DecoderLanguage,

    /// Additional options as key-value pairs
    #[serde(default)]
    pub extra: HashMap<String, serde_json::Value>,
}

fn default_iterations() -> u32 {
    1
}

fn default_true() -> bool {
    true
}

impl Default for EncodingOptions {
    fn default() -> Self {
        Self {
            key: None,
            key_bytes: None,
            iv: None,
            custom_alphabet: None,
            iterations: 1,
            preserve_nulls: false,
            random_padding: false,
            padding_size: 0,
            generate_decoder_stub: true,
            decoder_language: DecoderLanguage::Python,
            extra: HashMap::new(),
        }
    }
}

/// Language for decoder stub generation
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Default)]
#[serde(rename_all = "snake_case")]
pub enum DecoderLanguage {
    #[default]
    Python,
    PowerShell,
    Bash,
    CSharp,
    JavaScript,
    Go,
    Rust,
}

// ============================================================================
// Encoding Result
// ============================================================================

/// Result of an encoding operation
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EncodingResult {
    /// Encoded payload as bytes
    pub encoded_data: Vec<u8>,

    /// Encoded payload as string (if applicable)
    pub encoded_string: Option<String>,

    /// Encoder used
    pub encoder_type: EncoderType,

    /// Decoder stub code
    pub decoder_stub: Option<String>,

    /// Key used for encoding (may be auto-generated)
    pub key_used: Option<String>,

    /// IV used for block ciphers
    pub iv_used: Option<String>,

    /// Metadata about the encoding
    pub metadata: EncodingMetadata,
}

/// Metadata about an encoding operation
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EncodingMetadata {
    /// Original size in bytes
    pub original_size: usize,

    /// Encoded size in bytes
    pub encoded_size: usize,

    /// Size ratio (encoded/original)
    pub size_ratio: f64,

    /// Number of iterations applied
    pub iterations: u32,

    /// Whether null bytes were preserved
    pub nulls_preserved: bool,

    /// Encoding timestamp
    pub timestamp: DateTime<Utc>,

    /// Hash of original data (SHA256)
    pub original_hash: String,

    /// Hash of encoded data (SHA256)
    pub encoded_hash: String,

    /// Bad characters avoided (if any)
    pub bad_chars_avoided: Vec<u8>,
}

// ============================================================================
// Encoder Chain
// ============================================================================

/// Chain multiple encoders together
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EncoderChain {
    /// Ordered list of encoders to apply
    pub encoders: Vec<EncoderChainItem>,
}

/// Single encoder in a chain
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EncoderChainItem {
    /// Encoder type
    pub encoder_type: EncoderType,

    /// Options for this encoder
    pub options: EncodingOptions,
}

impl EncoderChain {
    /// Create a new empty encoder chain
    pub fn new() -> Self {
        Self {
            encoders: Vec::new(),
        }
    }

    /// Add an encoder to the chain
    pub fn add(mut self, encoder_type: EncoderType, options: EncodingOptions) -> Self {
        self.encoders.push(EncoderChainItem {
            encoder_type,
            options,
        });
        self
    }

    /// Execute the encoder chain
    pub fn execute(&self, data: &[u8]) -> Result<ChainResult> {
        let mut current_data = data.to_vec();
        let mut steps: Vec<EncodingResult> = Vec::new();

        for item in &self.encoders {
            let encoder = get_encoder(&item.encoder_type)?;
            let result = encoder.encode(&current_data, &item.options)?;
            current_data = result.encoded_data.clone();
            steps.push(result);
        }

        Ok(ChainResult {
            final_data: current_data,
            steps,
            total_encoders: self.encoders.len(),
        })
    }

    /// Reverse the encoder chain (decode)
    pub fn reverse(&self, data: &[u8]) -> Result<Vec<u8>> {
        let mut current_data = data.to_vec();

        // Apply decoders in reverse order
        for item in self.encoders.iter().rev() {
            let encoder = get_encoder(&item.encoder_type)?;
            current_data = encoder.decode(&current_data, &item.options)?;
        }

        Ok(current_data)
    }
}

impl Default for EncoderChain {
    fn default() -> Self {
        Self::new()
    }
}

/// Result of a chained encoding operation
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChainResult {
    /// Final encoded data
    pub final_data: Vec<u8>,

    /// Results from each step
    pub steps: Vec<EncodingResult>,

    /// Total number of encoders applied
    pub total_encoders: usize,
}

// ============================================================================
// Encoded Payload (for storage)
// ============================================================================

/// Encoded payload with full metadata for storage
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EncodedPayload {
    /// Unique ID
    pub id: String,

    /// User ID who created this
    pub user_id: String,

    /// Original payload (encrypted for storage)
    pub original_payload: Vec<u8>,

    /// Encoded payload
    pub encoded_payload: Vec<u8>,

    /// Encoder chain used
    pub encoder_chain: EncoderChain,

    /// Decoder stub
    pub decoder_stub: Option<String>,

    /// Decoder stub language
    pub decoder_language: Option<DecoderLanguage>,

    /// Metadata
    pub metadata: EncodingMetadata,

    /// Created timestamp
    pub created_at: DateTime<Utc>,

    /// Associated customer (for authorization tracking)
    pub customer_id: Option<String>,

    /// Associated asset
    pub asset_id: Option<String>,
}

// ============================================================================
// Encoder Registry
// ============================================================================

/// Get an encoder instance by type
pub fn get_encoder(encoder_type: &EncoderType) -> Result<Box<dyn Encoder>> {
    match encoder_type {
        // XOR encoders
        EncoderType::XorSingleByte => Ok(Box::new(xor::XorEncoder::single_byte())),
        EncoderType::XorMultiByte => Ok(Box::new(xor::XorEncoder::multi_byte())),
        EncoderType::XorRolling => Ok(Box::new(xor::XorEncoder::rolling())),
        EncoderType::XorAdditive => Ok(Box::new(xor::XorEncoder::additive())),

        // Base64 encoders
        EncoderType::Base64Standard => Ok(Box::new(base64_enc::Base64Encoder::standard())),
        EncoderType::Base64UrlSafe => Ok(Box::new(base64_enc::Base64Encoder::url_safe())),
        EncoderType::Base64Custom => Ok(Box::new(base64_enc::Base64Encoder::custom())),
        EncoderType::Base64NoPadding => Ok(Box::new(base64_enc::Base64Encoder::no_padding())),

        // AES encoders
        EncoderType::Aes128Cbc => Ok(Box::new(aes::AesEncoder::aes128_cbc())),
        EncoderType::Aes256Cbc => Ok(Box::new(aes::AesEncoder::aes256_cbc())),
        EncoderType::Aes128Gcm => Ok(Box::new(aes::AesEncoder::aes128_gcm())),
        EncoderType::Aes256Gcm => Ok(Box::new(aes::AesEncoder::aes256_gcm())),

        // Custom encoders
        EncoderType::Hex => Ok(Box::new(custom::HexEncoder::new())),
        EncoderType::HexReverse => Ok(Box::new(custom::HexEncoder::reversed())),
        EncoderType::Rot13 => Ok(Box::new(custom::RotEncoder::rot13())),
        EncoderType::Rot47 => Ok(Box::new(custom::RotEncoder::rot47())),
        EncoderType::Unicode => Ok(Box::new(custom::UnicodeEncoder::new())),
        EncoderType::UnicodeEscape => Ok(Box::new(custom::UnicodeEncoder::escaped())),
        EncoderType::UrlEncode => Ok(Box::new(custom::UrlEncoder::new())),
        EncoderType::HtmlEntities => Ok(Box::new(custom::HtmlEncoder::new())),
        EncoderType::StringReverse => Ok(Box::new(custom::StringEncoder::reverse())),
        EncoderType::CharSwap => Ok(Box::new(custom::StringEncoder::char_swap())),
        EncoderType::ByteShuffle => Ok(Box::new(custom::ByteShuffleEncoder::new())),

        EncoderType::Chain => Err(anyhow!("Use EncoderChain for chained encoding")),
    }
}

/// List all available encoders with descriptions
pub fn list_encoders() -> Vec<EncoderInfo> {
    vec![
        // XOR encoders
        EncoderInfo {
            encoder_type: EncoderType::XorSingleByte,
            name: "XOR Single-Byte".to_string(),
            description: "XOR payload with a single byte key".to_string(),
            category: EncoderCategory::Xor,
            requires_key: true,
            key_length: Some(1),
        },
        EncoderInfo {
            encoder_type: EncoderType::XorMultiByte,
            name: "XOR Multi-Byte".to_string(),
            description: "XOR payload with a multi-byte key".to_string(),
            category: EncoderCategory::Xor,
            requires_key: true,
            key_length: None,
        },
        EncoderInfo {
            encoder_type: EncoderType::XorRolling,
            name: "XOR Rolling".to_string(),
            description: "XOR with rolling key derived from previous byte".to_string(),
            category: EncoderCategory::Xor,
            requires_key: true,
            key_length: Some(1),
        },
        EncoderInfo {
            encoder_type: EncoderType::XorAdditive,
            name: "XOR Additive".to_string(),
            description: "XOR with additive key feedback".to_string(),
            category: EncoderCategory::Xor,
            requires_key: true,
            key_length: None,
        },

        // Base64 encoders
        EncoderInfo {
            encoder_type: EncoderType::Base64Standard,
            name: "Base64 Standard".to_string(),
            description: "Standard Base64 encoding (RFC 4648)".to_string(),
            category: EncoderCategory::Base64,
            requires_key: false,
            key_length: None,
        },
        EncoderInfo {
            encoder_type: EncoderType::Base64UrlSafe,
            name: "Base64 URL-Safe".to_string(),
            description: "URL-safe Base64 encoding".to_string(),
            category: EncoderCategory::Base64,
            requires_key: false,
            key_length: None,
        },
        EncoderInfo {
            encoder_type: EncoderType::Base64Custom,
            name: "Base64 Custom".to_string(),
            description: "Base64 with custom alphabet".to_string(),
            category: EncoderCategory::Base64,
            requires_key: false,
            key_length: None,
        },
        EncoderInfo {
            encoder_type: EncoderType::Base64NoPadding,
            name: "Base64 No Padding".to_string(),
            description: "Base64 without padding characters".to_string(),
            category: EncoderCategory::Base64,
            requires_key: false,
            key_length: None,
        },

        // AES encoders
        EncoderInfo {
            encoder_type: EncoderType::Aes128Cbc,
            name: "AES-128 CBC".to_string(),
            description: "AES-128 encryption in CBC mode with PKCS7 padding".to_string(),
            category: EncoderCategory::Encryption,
            requires_key: true,
            key_length: Some(16),
        },
        EncoderInfo {
            encoder_type: EncoderType::Aes256Cbc,
            name: "AES-256 CBC".to_string(),
            description: "AES-256 encryption in CBC mode with PKCS7 padding".to_string(),
            category: EncoderCategory::Encryption,
            requires_key: true,
            key_length: Some(32),
        },
        EncoderInfo {
            encoder_type: EncoderType::Aes128Gcm,
            name: "AES-128 GCM".to_string(),
            description: "AES-128 authenticated encryption with GCM".to_string(),
            category: EncoderCategory::Encryption,
            requires_key: true,
            key_length: Some(16),
        },
        EncoderInfo {
            encoder_type: EncoderType::Aes256Gcm,
            name: "AES-256 GCM".to_string(),
            description: "AES-256 authenticated encryption with GCM".to_string(),
            category: EncoderCategory::Encryption,
            requires_key: true,
            key_length: Some(32),
        },

        // Custom encoders
        EncoderInfo {
            encoder_type: EncoderType::Hex,
            name: "Hex".to_string(),
            description: "Hexadecimal encoding".to_string(),
            category: EncoderCategory::Transform,
            requires_key: false,
            key_length: None,
        },
        EncoderInfo {
            encoder_type: EncoderType::HexReverse,
            name: "Hex Reverse".to_string(),
            description: "Reversed hexadecimal encoding".to_string(),
            category: EncoderCategory::Transform,
            requires_key: false,
            key_length: None,
        },
        EncoderInfo {
            encoder_type: EncoderType::Rot13,
            name: "ROT13".to_string(),
            description: "ROT13 letter substitution".to_string(),
            category: EncoderCategory::Transform,
            requires_key: false,
            key_length: None,
        },
        EncoderInfo {
            encoder_type: EncoderType::Rot47,
            name: "ROT47".to_string(),
            description: "ROT47 printable ASCII substitution".to_string(),
            category: EncoderCategory::Transform,
            requires_key: false,
            key_length: None,
        },
        EncoderInfo {
            encoder_type: EncoderType::Unicode,
            name: "Unicode".to_string(),
            description: "Unicode code point encoding".to_string(),
            category: EncoderCategory::Transform,
            requires_key: false,
            key_length: None,
        },
        EncoderInfo {
            encoder_type: EncoderType::UnicodeEscape,
            name: "Unicode Escape".to_string(),
            description: "Unicode escape sequences (\\uXXXX)".to_string(),
            category: EncoderCategory::Transform,
            requires_key: false,
            key_length: None,
        },
        EncoderInfo {
            encoder_type: EncoderType::UrlEncode,
            name: "URL Encode".to_string(),
            description: "URL percent encoding".to_string(),
            category: EncoderCategory::Transform,
            requires_key: false,
            key_length: None,
        },
        EncoderInfo {
            encoder_type: EncoderType::HtmlEntities,
            name: "HTML Entities".to_string(),
            description: "HTML entity encoding".to_string(),
            category: EncoderCategory::Transform,
            requires_key: false,
            key_length: None,
        },
        EncoderInfo {
            encoder_type: EncoderType::StringReverse,
            name: "String Reverse".to_string(),
            description: "Reverse the string".to_string(),
            category: EncoderCategory::Transform,
            requires_key: false,
            key_length: None,
        },
        EncoderInfo {
            encoder_type: EncoderType::CharSwap,
            name: "Character Swap".to_string(),
            description: "Swap adjacent character pairs".to_string(),
            category: EncoderCategory::Transform,
            requires_key: false,
            key_length: None,
        },
        EncoderInfo {
            encoder_type: EncoderType::ByteShuffle,
            name: "Byte Shuffle".to_string(),
            description: "Shuffle bytes using a seeded PRNG".to_string(),
            category: EncoderCategory::Transform,
            requires_key: true,
            key_length: None,
        },
    ]
}

/// Encoder information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EncoderInfo {
    pub encoder_type: EncoderType,
    pub name: String,
    pub description: String,
    pub category: EncoderCategory,
    pub requires_key: bool,
    pub key_length: Option<usize>,
}

/// Encoder categories
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum EncoderCategory {
    Xor,
    Base64,
    Encryption,
    Transform,
}

// ============================================================================
// Helper Functions
// ============================================================================

/// Generate a random key of specified length
pub fn generate_random_key(length: usize) -> String {
    use rand::Rng;
    const CHARSET: &[u8] = b"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    let mut rng = rand::thread_rng();
    (0..length)
        .map(|_| {
            let idx = rng.gen_range(0..CHARSET.len());
            CHARSET[idx] as char
        })
        .collect()
}

/// Generate random bytes of specified length
pub fn generate_random_bytes(length: usize) -> Vec<u8> {
    use rand::Rng;
    let mut rng = rand::thread_rng();
    (0..length).map(|_| rng.gen::<u8>()).collect()
}

/// Calculate SHA256 hash of data
pub fn sha256_hash(data: &[u8]) -> String {
    use sha2::{Sha256, Digest};
    let mut hasher = Sha256::new();
    hasher.update(data);
    format!("{:x}", hasher.finalize())
}

/// Create encoding metadata
pub fn create_metadata(
    original: &[u8],
    encoded: &[u8],
    iterations: u32,
    nulls_preserved: bool,
    bad_chars: Vec<u8>,
) -> EncodingMetadata {
    let original_size = original.len();
    let encoded_size = encoded.len();
    let size_ratio = if original_size > 0 {
        encoded_size as f64 / original_size as f64
    } else {
        1.0
    };

    EncodingMetadata {
        original_size,
        encoded_size,
        size_ratio,
        iterations,
        nulls_preserved,
        timestamp: Utc::now(),
        original_hash: sha256_hash(original),
        encoded_hash: sha256_hash(encoded),
        bad_chars_avoided: bad_chars,
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_encoder_chain() {
        let data = b"Hello, World!";

        let chain = EncoderChain::new()
            .add(EncoderType::Base64Standard, EncodingOptions::default())
            .add(EncoderType::Hex, EncodingOptions::default());

        let result = chain.execute(data).unwrap();
        assert!(!result.final_data.is_empty());
        assert_eq!(result.total_encoders, 2);

        // Verify we can reverse
        let decoded = chain.reverse(&result.final_data).unwrap();
        assert_eq!(decoded, data);
    }

    #[test]
    fn test_list_encoders() {
        let encoders = list_encoders();
        assert!(!encoders.is_empty());

        // Verify all categories are represented
        let has_xor = encoders.iter().any(|e| e.category == EncoderCategory::Xor);
        let has_base64 = encoders.iter().any(|e| e.category == EncoderCategory::Base64);
        let has_encryption = encoders.iter().any(|e| e.category == EncoderCategory::Encryption);
        let has_transform = encoders.iter().any(|e| e.category == EncoderCategory::Transform);

        assert!(has_xor);
        assert!(has_base64);
        assert!(has_encryption);
        assert!(has_transform);
    }

    #[test]
    fn test_generate_random_key() {
        let key1 = generate_random_key(16);
        let key2 = generate_random_key(16);

        assert_eq!(key1.len(), 16);
        assert_eq!(key2.len(), 16);
        assert_ne!(key1, key2); // Should be different
    }
}
