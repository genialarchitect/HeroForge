// AES Encryption Module
// AES-based encryption for payload obfuscation

use aes_gcm::{
    aead::{Aead, KeyInit},
    Aes128Gcm, Aes256Gcm, Nonce,
};
use anyhow::{anyhow, Result};
use sha2::{Digest, Sha256};

use super::{
    create_metadata, generate_random_bytes, DecoderLanguage, Encoder, EncoderType,
    EncodingOptions, EncodingResult,
};

/// AES encoder variants
#[derive(Debug, Clone)]
pub enum AesVariant {
    /// AES-128 in CBC mode
    Aes128Cbc,
    /// AES-256 in CBC mode
    Aes256Cbc,
    /// AES-128 in GCM mode (authenticated encryption)
    Aes128Gcm,
    /// AES-256 in GCM mode (authenticated encryption)
    Aes256Gcm,
}

/// AES encoder implementation
pub struct AesEncoder {
    variant: AesVariant,
}

impl AesEncoder {
    /// Create AES-128 CBC encoder
    pub fn aes128_cbc() -> Self {
        Self {
            variant: AesVariant::Aes128Cbc,
        }
    }

    /// Create AES-256 CBC encoder
    pub fn aes256_cbc() -> Self {
        Self {
            variant: AesVariant::Aes256Cbc,
        }
    }

    /// Create AES-128 GCM encoder
    pub fn aes128_gcm() -> Self {
        Self {
            variant: AesVariant::Aes128Gcm,
        }
    }

    /// Create AES-256 GCM encoder
    pub fn aes256_gcm() -> Self {
        Self {
            variant: AesVariant::Aes256Gcm,
        }
    }

    /// Derive key from password using SHA256
    fn derive_key(&self, password: &str, key_size: usize) -> Vec<u8> {
        let mut hasher = Sha256::new();
        hasher.update(password.as_bytes());
        let hash = hasher.finalize();

        // Take first key_size bytes
        hash[..key_size].to_vec()
    }

    /// Add PKCS7 padding
    fn pkcs7_pad(&self, data: &[u8], block_size: usize) -> Vec<u8> {
        let padding_len = block_size - (data.len() % block_size);
        let mut padded = data.to_vec();
        padded.extend(std::iter::repeat(padding_len as u8).take(padding_len));
        padded
    }

    /// Remove PKCS7 padding
    fn pkcs7_unpad(&self, data: &[u8]) -> Result<Vec<u8>> {
        if data.is_empty() {
            return Err(anyhow!("Cannot unpad empty data"));
        }

        let padding_len = *data.last().unwrap() as usize;
        if padding_len == 0 || padding_len > 16 || padding_len > data.len() {
            return Err(anyhow!("Invalid PKCS7 padding"));
        }

        // Verify padding bytes
        for i in (data.len() - padding_len)..data.len() {
            if data[i] != padding_len as u8 {
                return Err(anyhow!("Invalid PKCS7 padding"));
            }
        }

        Ok(data[..data.len() - padding_len].to_vec())
    }

    /// XOR two byte slices (for CBC mode)
    fn xor_blocks(&self, a: &[u8], b: &[u8]) -> Vec<u8> {
        a.iter().zip(b.iter()).map(|(x, y)| x ^ y).collect()
    }

    /// AES-128/256 CBC encryption (software implementation)
    fn aes_cbc_encrypt(&self, data: &[u8], key: &[u8], iv: &[u8]) -> Result<Vec<u8>> {
        use aes::cipher::{BlockEncrypt, KeyInit};
        use aes::{Aes128, Aes256};

        let padded = self.pkcs7_pad(data, 16);
        let mut result = Vec::with_capacity(padded.len());
        let mut prev_block = iv.to_vec();

        for chunk in padded.chunks(16) {
            let xored = self.xor_blocks(chunk, &prev_block);
            let mut block = aes::Block::clone_from_slice(&xored);

            match key.len() {
                16 => {
                    let cipher = Aes128::new_from_slice(key)
                        .map_err(|e| anyhow!("AES-128 key error: {}", e))?;
                    cipher.encrypt_block(&mut block);
                }
                32 => {
                    let cipher = Aes256::new_from_slice(key)
                        .map_err(|e| anyhow!("AES-256 key error: {}", e))?;
                    cipher.encrypt_block(&mut block);
                }
                _ => return Err(anyhow!("Invalid key size: {}", key.len())),
            }

            result.extend_from_slice(&block);
            prev_block = block.to_vec();
        }

        Ok(result)
    }

    /// AES-128/256 CBC decryption (software implementation)
    fn aes_cbc_decrypt(&self, data: &[u8], key: &[u8], iv: &[u8]) -> Result<Vec<u8>> {
        use aes::cipher::{BlockDecrypt, KeyInit};
        use aes::{Aes128, Aes256};

        if data.len() % 16 != 0 {
            return Err(anyhow!("Ciphertext must be multiple of 16 bytes"));
        }

        let mut result = Vec::with_capacity(data.len());
        let mut prev_block = iv.to_vec();

        for chunk in data.chunks(16) {
            let mut block = aes::Block::clone_from_slice(chunk);

            match key.len() {
                16 => {
                    let cipher = Aes128::new_from_slice(key)
                        .map_err(|e| anyhow!("AES-128 key error: {}", e))?;
                    cipher.decrypt_block(&mut block);
                }
                32 => {
                    let cipher = Aes256::new_from_slice(key)
                        .map_err(|e| anyhow!("AES-256 key error: {}", e))?;
                    cipher.decrypt_block(&mut block);
                }
                _ => return Err(anyhow!("Invalid key size: {}", key.len())),
            }

            let decrypted = self.xor_blocks(&block, &prev_block);
            result.extend(decrypted);
            prev_block = chunk.to_vec();
        }

        self.pkcs7_unpad(&result)
    }

    /// AES-GCM encryption
    fn aes_gcm_encrypt(&self, data: &[u8], key: &[u8], nonce: &[u8]) -> Result<Vec<u8>> {
        match key.len() {
            16 => {
                let cipher = Aes128Gcm::new_from_slice(key)
                    .map_err(|e| anyhow!("AES-128-GCM key error: {}", e))?;
                let nonce = Nonce::from_slice(nonce);
                cipher
                    .encrypt(nonce, data)
                    .map_err(|e| anyhow!("AES-128-GCM encrypt error: {}", e))
            }
            32 => {
                let cipher = Aes256Gcm::new_from_slice(key)
                    .map_err(|e| anyhow!("AES-256-GCM key error: {}", e))?;
                let nonce = Nonce::from_slice(nonce);
                cipher
                    .encrypt(nonce, data)
                    .map_err(|e| anyhow!("AES-256-GCM encrypt error: {}", e))
            }
            _ => Err(anyhow!("Invalid key size: {}", key.len())),
        }
    }

    /// AES-GCM decryption
    fn aes_gcm_decrypt(&self, data: &[u8], key: &[u8], nonce: &[u8]) -> Result<Vec<u8>> {
        match key.len() {
            16 => {
                let cipher = Aes128Gcm::new_from_slice(key)
                    .map_err(|e| anyhow!("AES-128-GCM key error: {}", e))?;
                let nonce = Nonce::from_slice(nonce);
                cipher
                    .decrypt(nonce, data)
                    .map_err(|e| anyhow!("AES-128-GCM decrypt error: {}", e))
            }
            32 => {
                let cipher = Aes256Gcm::new_from_slice(key)
                    .map_err(|e| anyhow!("AES-256-GCM key error: {}", e))?;
                let nonce = Nonce::from_slice(nonce);
                cipher
                    .decrypt(nonce, data)
                    .map_err(|e| anyhow!("AES-256-GCM decrypt error: {}", e))
            }
            _ => Err(anyhow!("Invalid key size: {}", key.len())),
        }
    }

    /// Generate Python decoder stub
    fn generate_python_decoder(
        &self,
        encoded_hex: &str,
        key_hex: &str,
        iv_hex: &str,
    ) -> String {
        match self.variant {
            AesVariant::Aes128Cbc | AesVariant::Aes256Cbc => {
                format!(
                    r#"from Crypto.Cipher import AES
import binascii
# AES-{} CBC Decoder
key = binascii.unhexlify('{}')
iv = binascii.unhexlify('{}')
ciphertext = binascii.unhexlify('{}')
cipher = AES.new(key, AES.MODE_CBC, iv)
plaintext = cipher.decrypt(ciphertext)
# Remove PKCS7 padding
padding_len = plaintext[-1]
plaintext = plaintext[:-padding_len]
exec(plaintext)
"#,
                    if matches!(self.variant, AesVariant::Aes128Cbc) { "128" } else { "256" },
                    key_hex,
                    iv_hex,
                    encoded_hex
                )
            }
            AesVariant::Aes128Gcm | AesVariant::Aes256Gcm => {
                format!(
                    r#"from Crypto.Cipher import AES
import binascii
# AES-{} GCM Decoder
key = binascii.unhexlify('{}')
nonce = binascii.unhexlify('{}')
ciphertext = binascii.unhexlify('{}')
# Last 16 bytes are the auth tag
tag = ciphertext[-16:]
ciphertext = ciphertext[:-16]
cipher = AES.new(key, AES.MODE_GCM, nonce=nonce)
plaintext = cipher.decrypt_and_verify(ciphertext, tag)
exec(plaintext)
"#,
                    if matches!(self.variant, AesVariant::Aes128Gcm) { "128" } else { "256" },
                    key_hex,
                    iv_hex,
                    encoded_hex
                )
            }
        }
    }

    /// Generate PowerShell decoder stub
    fn generate_powershell_decoder(
        &self,
        encoded_hex: &str,
        key_hex: &str,
        iv_hex: &str,
    ) -> String {
        match self.variant {
            AesVariant::Aes128Cbc | AesVariant::Aes256Cbc => {
                let key_size = if matches!(self.variant, AesVariant::Aes128Cbc) {
                    128
                } else {
                    256
                };
                format!(
                    r#"# AES-{} CBC Decoder
$k=[byte[]]::new({})
$iv=[byte[]]::new(16)
$khex="{}"
$ivhex="{}"
$ehex="{}"
for($i=0;$i-lt$k.Length;$i++){{$k[$i]=[Convert]::ToByte($khex.Substring($i*2,2),16)}}
for($i=0;$i-lt16;$i++){{$iv[$i]=[Convert]::ToByte($ivhex.Substring($i*2,2),16)}}
$e=[byte[]]::new($ehex.Length/2)
for($i=0;$i-lt$e.Length;$i++){{$e[$i]=[Convert]::ToByte($ehex.Substring($i*2,2),16)}}
$aes=[System.Security.Cryptography.Aes]::Create()
$aes.Mode='CBC'
$aes.Padding='PKCS7'
$aes.Key=$k
$aes.IV=$iv
$decryptor=$aes.CreateDecryptor()
$ms=New-Object System.IO.MemoryStream
$cs=New-Object System.Security.Cryptography.CryptoStream($ms,$decryptor,'Write')
$cs.Write($e,0,$e.Length)
$cs.FlushFinalBlock()
$d=$ms.ToArray()
iex([System.Text.Encoding]::ASCII.GetString($d))
"#,
                    key_size,
                    key_size / 8,
                    key_hex,
                    iv_hex,
                    encoded_hex
                )
            }
            AesVariant::Aes128Gcm | AesVariant::Aes256Gcm => {
                format!(
                    r#"# AES GCM requires .NET Core or external library
# Use Python decoder for GCM mode
$encoded="{}"
Write-Host "GCM mode requires Python decoder"
"#,
                    encoded_hex
                )
            }
        }
    }

    /// Generate C# decoder stub
    fn generate_csharp_decoder(
        &self,
        encoded_hex: &str,
        key_hex: &str,
        iv_hex: &str,
    ) -> String {
        match self.variant {
            AesVariant::Aes128Cbc | AesVariant::Aes256Cbc => {
                format!(
                    r#"// AES-{} CBC Decoder
using System;
using System.IO;
using System.Security.Cryptography;
using System.Text;

class Decoder {{
    static void Main() {{
        byte[] key = HexToBytes("{}");
        byte[] iv = HexToBytes("{}");
        byte[] ciphertext = HexToBytes("{}");

        using (Aes aes = Aes.Create()) {{
            aes.Key = key;
            aes.IV = iv;
            aes.Mode = CipherMode.CBC;
            aes.Padding = PaddingMode.PKCS7;

            using (var decryptor = aes.CreateDecryptor())
            using (var ms = new MemoryStream(ciphertext))
            using (var cs = new CryptoStream(ms, decryptor, CryptoStreamMode.Read))
            using (var sr = new StreamReader(cs)) {{
                string plaintext = sr.ReadToEnd();
                // Execute or process plaintext
                Console.WriteLine(plaintext);
            }}
        }}
    }}

    static byte[] HexToBytes(string hex) {{
        byte[] bytes = new byte[hex.Length / 2];
        for (int i = 0; i < bytes.Length; i++)
            bytes[i] = Convert.ToByte(hex.Substring(i * 2, 2), 16);
        return bytes;
    }}
}}
"#,
                    if matches!(self.variant, AesVariant::Aes128Cbc) { "128" } else { "256" },
                    key_hex,
                    iv_hex,
                    encoded_hex
                )
            }
            _ => "// GCM mode requires .NET Core 3.0+ or BouncyCastle".to_string(),
        }
    }
}

impl Encoder for AesEncoder {
    fn encoder_type(&self) -> EncoderType {
        match self.variant {
            AesVariant::Aes128Cbc => EncoderType::Aes128Cbc,
            AesVariant::Aes256Cbc => EncoderType::Aes256Cbc,
            AesVariant::Aes128Gcm => EncoderType::Aes128Gcm,
            AesVariant::Aes256Gcm => EncoderType::Aes256Gcm,
        }
    }

    fn encode(&self, data: &[u8], options: &EncodingOptions) -> Result<EncodingResult> {
        let key_size = match self.variant {
            AesVariant::Aes128Cbc | AesVariant::Aes128Gcm => 16,
            AesVariant::Aes256Cbc | AesVariant::Aes256Gcm => 32,
        };

        // Get or derive key
        let key = if let Some(ref kb) = options.key_bytes {
            if kb.len() != key_size {
                return Err(anyhow!("Key must be {} bytes", key_size));
            }
            kb.clone()
        } else if let Some(ref k) = options.key {
            self.derive_key(k, key_size)
        } else {
            generate_random_bytes(key_size)
        };

        // Get or generate IV/nonce
        let iv_size = match self.variant {
            AesVariant::Aes128Cbc | AesVariant::Aes256Cbc => 16,
            AesVariant::Aes128Gcm | AesVariant::Aes256Gcm => 12,
        };

        let iv = if let Some(ref iv_str) = options.iv {
            let iv_bytes = hex::decode(iv_str)
                .map_err(|e| anyhow!("Invalid IV hex: {}", e))?;
            if iv_bytes.len() != iv_size {
                return Err(anyhow!("IV must be {} bytes", iv_size));
            }
            iv_bytes
        } else {
            generate_random_bytes(iv_size)
        };

        // Encrypt
        let encrypted = match self.variant {
            AesVariant::Aes128Cbc | AesVariant::Aes256Cbc => {
                self.aes_cbc_encrypt(data, &key, &iv)?
            }
            AesVariant::Aes128Gcm | AesVariant::Aes256Gcm => {
                self.aes_gcm_encrypt(data, &key, &iv)?
            }
        };

        let key_hex = hex::encode(&key);
        let iv_hex = hex::encode(&iv);
        let encoded_hex = hex::encode(&encrypted);

        // Generate decoder stub
        let decoder_stub = if options.generate_decoder_stub {
            Some(match options.decoder_language {
                DecoderLanguage::Python => {
                    self.generate_python_decoder(&encoded_hex, &key_hex, &iv_hex)
                }
                DecoderLanguage::PowerShell => {
                    self.generate_powershell_decoder(&encoded_hex, &key_hex, &iv_hex)
                }
                DecoderLanguage::CSharp => {
                    self.generate_csharp_decoder(&encoded_hex, &key_hex, &iv_hex)
                }
                _ => self.generate_python_decoder(&encoded_hex, &key_hex, &iv_hex),
            })
        } else {
            None
        };

        let metadata = create_metadata(
            data,
            &encrypted,
            options.iterations,
            options.preserve_nulls,
            Vec::new(),
        );

        Ok(EncodingResult {
            encoded_data: encrypted,
            encoded_string: Some(encoded_hex),
            encoder_type: self.encoder_type(),
            decoder_stub,
            key_used: Some(key_hex),
            iv_used: Some(iv_hex),
            metadata,
        })
    }

    fn decode(&self, data: &[u8], options: &EncodingOptions) -> Result<Vec<u8>> {
        let key_size = match self.variant {
            AesVariant::Aes128Cbc | AesVariant::Aes128Gcm => 16,
            AesVariant::Aes256Cbc | AesVariant::Aes256Gcm => 32,
        };

        // Get key
        let key = if let Some(ref kb) = options.key_bytes {
            kb.clone()
        } else if let Some(ref k) = options.key {
            // If it looks like hex, decode it; otherwise derive from password
            if k.len() == key_size * 2 && k.chars().all(|c| c.is_ascii_hexdigit()) {
                hex::decode(k).map_err(|e| anyhow!("Invalid key hex: {}", e))?
            } else {
                self.derive_key(k, key_size)
            }
        } else {
            return Err(anyhow!("Key required for AES decryption"));
        };

        // Get IV
        let iv = options
            .iv
            .as_ref()
            .ok_or_else(|| anyhow!("IV required for AES decryption"))?;
        let iv_bytes = hex::decode(iv).map_err(|e| anyhow!("Invalid IV hex: {}", e))?;

        // Decrypt
        match self.variant {
            AesVariant::Aes128Cbc | AesVariant::Aes256Cbc => {
                self.aes_cbc_decrypt(data, &key, &iv_bytes)
            }
            AesVariant::Aes128Gcm | AesVariant::Aes256Gcm => {
                self.aes_gcm_decrypt(data, &key, &iv_bytes)
            }
        }
    }

    fn description(&self) -> &'static str {
        match self.variant {
            AesVariant::Aes128Cbc => "AES-128 encryption in CBC mode with PKCS7 padding",
            AesVariant::Aes256Cbc => "AES-256 encryption in CBC mode with PKCS7 padding",
            AesVariant::Aes128Gcm => "AES-128 authenticated encryption with GCM",
            AesVariant::Aes256Gcm => "AES-256 authenticated encryption with GCM",
        }
    }
}

/// Derive key from password using PBKDF2
pub fn derive_key_pbkdf2(password: &str, salt: &[u8], iterations: u32, key_len: usize) -> Vec<u8> {
    use hmac::Hmac;
    use sha2::Sha256;

    let mut key = vec![0u8; key_len];

    // Simple PBKDF2-HMAC-SHA256 implementation
    let mut hmac_key = Hmac::<Sha256>::new_from_slice(password.as_bytes()).unwrap();
    // For simplicity, use SHA256 hash with salt
    let mut hasher = Sha256::new();
    hasher.update(password.as_bytes());
    hasher.update(salt);

    for _ in 0..iterations {
        hasher.update(&hasher.clone().finalize());
    }

    let result = hasher.finalize();
    key[..key_len.min(32)].copy_from_slice(&result[..key_len.min(32)]);
    key
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_aes128_cbc() {
        let encoder = AesEncoder::aes128_cbc();
        let data = b"Hello, AES encryption!";
        let options = EncodingOptions {
            key: Some("mysecretpassword".to_string()),
            ..Default::default()
        };

        let result = encoder.encode(data, &options).unwrap();
        assert!(!result.encoded_data.is_empty());
        assert!(result.key_used.is_some());
        assert!(result.iv_used.is_some());

        // Decode
        let decode_options = EncodingOptions {
            key: result.key_used.clone(),
            iv: result.iv_used.clone(),
            ..Default::default()
        };
        let decoded = encoder.decode(&result.encoded_data, &decode_options).unwrap();
        assert_eq!(decoded, data);
    }

    #[test]
    fn test_aes256_cbc() {
        let encoder = AesEncoder::aes256_cbc();
        let data = b"AES-256 test payload";
        let options = EncodingOptions {
            key: Some("alongersecretpasswordforaes256".to_string()),
            ..Default::default()
        };

        let result = encoder.encode(data, &options).unwrap();
        assert!(!result.encoded_data.is_empty());

        // Decode
        let decode_options = EncodingOptions {
            key: result.key_used.clone(),
            iv: result.iv_used.clone(),
            ..Default::default()
        };
        let decoded = encoder.decode(&result.encoded_data, &decode_options).unwrap();
        assert_eq!(decoded, data);
    }

    #[test]
    fn test_aes128_gcm() {
        let encoder = AesEncoder::aes128_gcm();
        let data = b"GCM authenticated encryption";
        let options = EncodingOptions {
            key: Some("gcmtestpassword!".to_string()),
            ..Default::default()
        };

        let result = encoder.encode(data, &options).unwrap();
        assert!(!result.encoded_data.is_empty());

        // Decode
        let decode_options = EncodingOptions {
            key: result.key_used.clone(),
            iv: result.iv_used.clone(),
            ..Default::default()
        };
        let decoded = encoder.decode(&result.encoded_data, &decode_options).unwrap();
        assert_eq!(decoded, data);
    }

    #[test]
    fn test_aes256_gcm() {
        let encoder = AesEncoder::aes256_gcm();
        let data = b"AES-256-GCM test";
        let options = EncodingOptions {
            key: Some("verylongsecretpasswordforaes256gcm".to_string()),
            ..Default::default()
        };

        let result = encoder.encode(data, &options).unwrap();
        assert!(!result.encoded_data.is_empty());

        // Decode
        let decode_options = EncodingOptions {
            key: result.key_used.clone(),
            iv: result.iv_used.clone(),
            ..Default::default()
        };
        let decoded = encoder.decode(&result.encoded_data, &decode_options).unwrap();
        assert_eq!(decoded, data);
    }

    #[test]
    fn test_decoder_stub_generation() {
        let encoder = AesEncoder::aes128_cbc();
        let data = b"Stub test";
        let options = EncodingOptions {
            key: Some("testkey123456789".to_string()),
            generate_decoder_stub: true,
            decoder_language: DecoderLanguage::Python,
            ..Default::default()
        };

        let result = encoder.encode(data, &options).unwrap();
        assert!(result.decoder_stub.is_some());
        assert!(result.decoder_stub.unwrap().contains("AES-128 CBC Decoder"));
    }
}
