// XOR Encoding Module
// Various XOR-based encoding techniques for payload obfuscation

use anyhow::{anyhow, Result};

use super::{
    create_metadata, generate_random_bytes, generate_random_key,
    DecoderLanguage, Encoder, EncoderType, EncodingOptions, EncodingResult,
};

/// XOR encoder variants
#[derive(Debug, Clone)]
pub enum XorVariant {
    /// Single-byte XOR
    SingleByte,
    /// Multi-byte key XOR
    MultiByte,
    /// Rolling XOR (key derived from previous byte)
    Rolling,
    /// Additive XOR (feedback loop)
    Additive,
}

/// XOR encoder implementation
pub struct XorEncoder {
    variant: XorVariant,
}

impl XorEncoder {
    /// Create single-byte XOR encoder
    pub fn single_byte() -> Self {
        Self {
            variant: XorVariant::SingleByte,
        }
    }

    /// Create multi-byte XOR encoder
    pub fn multi_byte() -> Self {
        Self {
            variant: XorVariant::MultiByte,
        }
    }

    /// Create rolling XOR encoder
    pub fn rolling() -> Self {
        Self {
            variant: XorVariant::Rolling,
        }
    }

    /// Create additive XOR encoder
    pub fn additive() -> Self {
        Self {
            variant: XorVariant::Additive,
        }
    }

    /// XOR encode with single byte
    fn encode_single_byte(&self, data: &[u8], key: u8) -> Vec<u8> {
        data.iter().map(|b| b ^ key).collect()
    }

    /// XOR encode with multi-byte key
    fn encode_multi_byte(&self, data: &[u8], key: &[u8]) -> Vec<u8> {
        data.iter()
            .enumerate()
            .map(|(i, b)| b ^ key[i % key.len()])
            .collect()
    }

    /// Rolling XOR encode (each byte XORed with key + previous encoded byte)
    fn encode_rolling(&self, data: &[u8], seed: u8) -> Vec<u8> {
        let mut result = Vec::with_capacity(data.len());
        let mut key = seed;

        for &byte in data {
            let encoded = byte ^ key;
            result.push(encoded);
            key = encoded; // Next key is the encoded byte
        }

        result
    }

    /// Decode rolling XOR
    fn decode_rolling(&self, data: &[u8], seed: u8) -> Vec<u8> {
        let mut result = Vec::with_capacity(data.len());
        let mut key = seed;

        for &byte in data {
            let decoded = byte ^ key;
            result.push(decoded);
            key = byte; // Next key is the current encoded byte
        }

        result
    }

    /// Additive XOR encode (feedback with addition)
    fn encode_additive(&self, data: &[u8], key: &[u8]) -> Vec<u8> {
        let mut result = Vec::with_capacity(data.len());
        let mut feedback: u8 = 0;

        for (i, &byte) in data.iter().enumerate() {
            let k = key[i % key.len()];
            let encoded = byte ^ k.wrapping_add(feedback);
            result.push(encoded);
            feedback = encoded;
        }

        result
    }

    /// Decode additive XOR
    fn decode_additive(&self, data: &[u8], key: &[u8]) -> Vec<u8> {
        let mut result = Vec::with_capacity(data.len());
        let mut feedback: u8 = 0;

        for (i, &byte) in data.iter().enumerate() {
            let k = key[i % key.len()];
            let decoded = byte ^ k.wrapping_add(feedback);
            result.push(decoded);
            feedback = byte;
        }

        result
    }

    /// Generate Python decoder stub
    fn generate_python_decoder(
        &self,
        encoded_hex: &str,
        key_info: &str,
    ) -> String {
        match self.variant {
            XorVariant::SingleByte => {
                format!(
                    r#"import binascii
# XOR Single-Byte Decoder
key = {}
encoded = binascii.unhexlify('{}')
decoded = bytes([b ^ key for b in encoded])
exec(decoded)
"#,
                    key_info, encoded_hex
                )
            }
            XorVariant::MultiByte => {
                format!(
                    r#"import binascii
# XOR Multi-Byte Decoder
key = b'{}'
encoded = binascii.unhexlify('{}')
decoded = bytes([b ^ key[i % len(key)] for i, b in enumerate(encoded)])
exec(decoded)
"#,
                    key_info, encoded_hex
                )
            }
            XorVariant::Rolling => {
                format!(
                    r#"import binascii
# XOR Rolling Decoder
seed = {}
encoded = binascii.unhexlify('{}')
decoded = []
key = seed
for b in encoded:
    decoded.append(b ^ key)
    key = b
exec(bytes(decoded))
"#,
                    key_info, encoded_hex
                )
            }
            XorVariant::Additive => {
                format!(
                    r#"import binascii
# XOR Additive Decoder
key = b'{}'
encoded = binascii.unhexlify('{}')
decoded = []
feedback = 0
for i, b in enumerate(encoded):
    k = key[i % len(key)]
    decoded.append(b ^ ((k + feedback) & 0xFF))
    feedback = b
exec(bytes(decoded))
"#,
                    key_info, encoded_hex
                )
            }
        }
    }

    /// Generate PowerShell decoder stub
    fn generate_powershell_decoder(
        &self,
        encoded_hex: &str,
        key_info: &str,
    ) -> String {
        match self.variant {
            XorVariant::SingleByte => {
                format!(
                    r#"# XOR Single-Byte Decoder
$k={}
$e=[byte[]]::new("{}".Length/2)
for($i=0;$i-lt$e.Length;$i++){{$e[$i]=[Convert]::ToByte("{}".Substring($i*2,2),16)}}
$d=[byte[]]::new($e.Length)
for($i=0;$i-lt$e.Length;$i++){{$d[$i]=$e[$i]-bxor$k}}
iex([System.Text.Encoding]::ASCII.GetString($d))
"#,
                    key_info, encoded_hex, encoded_hex
                )
            }
            XorVariant::MultiByte => {
                format!(
                    r#"# XOR Multi-Byte Decoder
$k=[System.Text.Encoding]::ASCII.GetBytes("{}")
$h="{}"
$e=[byte[]]::new($h.Length/2)
for($i=0;$i-lt$e.Length;$i++){{$e[$i]=[Convert]::ToByte($h.Substring($i*2,2),16)}}
$d=[byte[]]::new($e.Length)
for($i=0;$i-lt$e.Length;$i++){{$d[$i]=$e[$i]-bxor$k[$i%$k.Length]}}
iex([System.Text.Encoding]::ASCII.GetString($d))
"#,
                    key_info, encoded_hex
                )
            }
            XorVariant::Rolling => {
                format!(
                    r#"# XOR Rolling Decoder
$s={}
$h="{}"
$e=[byte[]]::new($h.Length/2)
for($i=0;$i-lt$e.Length;$i++){{$e[$i]=[Convert]::ToByte($h.Substring($i*2,2),16)}}
$d=[byte[]]::new($e.Length)
$k=$s
for($i=0;$i-lt$e.Length;$i++){{$d[$i]=$e[$i]-bxor$k;$k=$e[$i]}}
iex([System.Text.Encoding]::ASCII.GetString($d))
"#,
                    key_info, encoded_hex
                )
            }
            XorVariant::Additive => {
                format!(
                    r#"# XOR Additive Decoder
$k=[System.Text.Encoding]::ASCII.GetBytes("{}")
$h="{}"
$e=[byte[]]::new($h.Length/2)
for($i=0;$i-lt$e.Length;$i++){{$e[$i]=[Convert]::ToByte($h.Substring($i*2,2),16)}}
$d=[byte[]]::new($e.Length)
$f=0
for($i=0;$i-lt$e.Length;$i++){{$d[$i]=$e[$i]-bxor(($k[$i%$k.Length]+$f)%256);$f=$e[$i]}}
iex([System.Text.Encoding]::ASCII.GetString($d))
"#,
                    key_info, encoded_hex
                )
            }
        }
    }

    /// Generate Bash decoder stub
    fn generate_bash_decoder(
        &self,
        encoded_hex: &str,
        key_info: &str,
    ) -> String {
        match self.variant {
            XorVariant::SingleByte => {
                format!(
                    r#"#!/bin/bash
# XOR Single-Byte Decoder
key={}
encoded="{}"
decoded=""
for ((i=0; i<${{#encoded}}; i+=2)); do
    byte=$((16#${{encoded:$i:2}}))
    decoded+=$(printf "\\x%02x" $(($byte ^ $key)))
done
eval "$decoded"
"#,
                    key_info, encoded_hex
                )
            }
            XorVariant::MultiByte => {
                format!(
                    r#"#!/bin/bash
# XOR Multi-Byte Decoder
key="{}"
encoded="{}"
decoded=""
keylen=${{#key}}
for ((i=0; i<${{#encoded}}; i+=2)); do
    byte=$((16#${{encoded:$i:2}}))
    ki=$(($i/2 % $keylen))
    kbyte=$(printf "%d" "'${{key:$ki:1}}")
    decoded+=$(printf "\\x%02x" $(($byte ^ $kbyte)))
done
eval "$decoded"
"#,
                    key_info, encoded_hex
                )
            }
            _ => format!("# Rolling/Additive XOR requires Python or PowerShell decoder"),
        }
    }
}

impl Encoder for XorEncoder {
    fn encoder_type(&self) -> EncoderType {
        match self.variant {
            XorVariant::SingleByte => EncoderType::XorSingleByte,
            XorVariant::MultiByte => EncoderType::XorMultiByte,
            XorVariant::Rolling => EncoderType::XorRolling,
            XorVariant::Additive => EncoderType::XorAdditive,
        }
    }

    fn encode(&self, data: &[u8], options: &EncodingOptions) -> Result<EncodingResult> {
        let (encoded, key_used) = match self.variant {
            XorVariant::SingleByte => {
                let key = if let Some(ref k) = options.key {
                    if k.is_empty() {
                        return Err(anyhow!("XOR key cannot be empty"));
                    }
                    k.as_bytes()[0]
                } else {
                    // Generate random single byte
                    generate_random_bytes(1)[0]
                };
                let encoded = self.encode_single_byte(data, key);
                (encoded, format!("{}", key))
            }
            XorVariant::MultiByte => {
                let key = if let Some(ref k) = options.key {
                    if k.is_empty() {
                        return Err(anyhow!("XOR key cannot be empty"));
                    }
                    k.as_bytes().to_vec()
                } else {
                    // Generate random key (8-16 bytes)
                    let len = 8 + (rand::random::<usize>() % 9);
                    generate_random_key(len).into_bytes()
                };
                let encoded = self.encode_multi_byte(data, &key);
                (encoded, String::from_utf8_lossy(&key).to_string())
            }
            XorVariant::Rolling => {
                let seed = if let Some(ref k) = options.key {
                    if k.is_empty() {
                        return Err(anyhow!("XOR seed cannot be empty"));
                    }
                    k.as_bytes()[0]
                } else {
                    generate_random_bytes(1)[0]
                };
                let encoded = self.encode_rolling(data, seed);
                (encoded, format!("{}", seed))
            }
            XorVariant::Additive => {
                let key = if let Some(ref k) = options.key {
                    if k.is_empty() {
                        return Err(anyhow!("XOR key cannot be empty"));
                    }
                    k.as_bytes().to_vec()
                } else {
                    let len = 8 + (rand::random::<usize>() % 9);
                    generate_random_key(len).into_bytes()
                };
                let encoded = self.encode_additive(data, &key);
                (encoded, String::from_utf8_lossy(&key).to_string())
            }
        };

        // Apply multiple iterations if requested
        let mut final_encoded = encoded;
        for _ in 1..options.iterations {
            final_encoded = match self.variant {
                XorVariant::SingleByte => {
                    self.encode_single_byte(&final_encoded, key_used.parse().unwrap_or(0))
                }
                XorVariant::MultiByte | XorVariant::Additive => {
                    self.encode_multi_byte(&final_encoded, key_used.as_bytes())
                }
                XorVariant::Rolling => {
                    self.encode_rolling(&final_encoded, key_used.parse().unwrap_or(0))
                }
            };
        }

        let encoded_hex = hex::encode(&final_encoded);

        // Generate decoder stub
        let decoder_stub = if options.generate_decoder_stub {
            Some(match options.decoder_language {
                DecoderLanguage::Python => {
                    self.generate_python_decoder(&encoded_hex, &key_used)
                }
                DecoderLanguage::PowerShell => {
                    self.generate_powershell_decoder(&encoded_hex, &key_used)
                }
                DecoderLanguage::Bash => {
                    self.generate_bash_decoder(&encoded_hex, &key_used)
                }
                _ => self.generate_python_decoder(&encoded_hex, &key_used),
            })
        } else {
            None
        };

        let metadata = create_metadata(
            data,
            &final_encoded,
            options.iterations,
            options.preserve_nulls,
            Vec::new(),
        );

        Ok(EncodingResult {
            encoded_data: final_encoded,
            encoded_string: Some(encoded_hex),
            encoder_type: self.encoder_type(),
            decoder_stub,
            key_used: Some(key_used),
            iv_used: None,
            metadata,
        })
    }

    fn decode(&self, data: &[u8], options: &EncodingOptions) -> Result<Vec<u8>> {
        let key = options
            .key
            .as_ref()
            .ok_or_else(|| anyhow!("XOR key required for decoding"))?;

        match self.variant {
            XorVariant::SingleByte => {
                let key_byte = key.parse::<u8>().unwrap_or(key.as_bytes()[0]);
                Ok(self.encode_single_byte(data, key_byte)) // XOR is symmetric
            }
            XorVariant::MultiByte => {
                Ok(self.encode_multi_byte(data, key.as_bytes())) // XOR is symmetric
            }
            XorVariant::Rolling => {
                let seed = key.parse::<u8>().unwrap_or(key.as_bytes()[0]);
                Ok(self.decode_rolling(data, seed))
            }
            XorVariant::Additive => {
                Ok(self.decode_additive(data, key.as_bytes()))
            }
        }
    }

    fn description(&self) -> &'static str {
        match self.variant {
            XorVariant::SingleByte => "XOR with a single byte key",
            XorVariant::MultiByte => "XOR with a multi-byte key",
            XorVariant::Rolling => "XOR with rolling key derived from previous byte",
            XorVariant::Additive => "XOR with additive feedback loop",
        }
    }
}

// ============================================================================
// Legacy functions for backward compatibility with existing code
// ============================================================================

/// XOR encode a string with a key (legacy function)
pub fn xor_encode(data: &str, key: &str) -> String {
    let key_bytes: Vec<u8> = key.bytes().collect();
    let encoded: Vec<u8> = data
        .bytes()
        .enumerate()
        .map(|(i, b)| b ^ key_bytes[i % key_bytes.len()])
        .collect();
    hex::encode(encoded)
}

/// XOR decode a hex string with a key (legacy function)
pub fn xor_decode(hex_data: &str, key: &str) -> Result<String, hex::FromHexError> {
    let encoded = hex::decode(hex_data)?;
    let key_bytes: Vec<u8> = key.bytes().collect();
    let decoded: Vec<u8> = encoded
        .iter()
        .enumerate()
        .map(|(i, b)| b ^ key_bytes[i % key_bytes.len()])
        .collect();
    Ok(String::from_utf8_lossy(&decoded).to_string())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_single_byte_xor() {
        let encoder = XorEncoder::single_byte();
        let data = b"Hello, World!";
        let options = EncodingOptions {
            key: Some("A".to_string()), // Use a single character key
            ..Default::default()
        };

        let result = encoder.encode(data, &options).unwrap();
        assert!(!result.encoded_data.is_empty());

        // Use the actual key that was used (stored as numeric string)
        let decode_options = EncodingOptions {
            key: result.key_used.clone(),
            ..Default::default()
        };
        let decoded = encoder.decode(&result.encoded_data, &decode_options).unwrap();
        assert_eq!(decoded, data);
    }

    #[test]
    fn test_multi_byte_xor() {
        let encoder = XorEncoder::multi_byte();
        let data = b"Test payload for XOR encoding";
        let options = EncodingOptions {
            key: Some("secretkey".to_string()),
            ..Default::default()
        };

        let result = encoder.encode(data, &options).unwrap();
        assert!(!result.encoded_data.is_empty());

        let decoded = encoder.decode(&result.encoded_data, &options).unwrap();
        assert_eq!(decoded, data);
    }

    #[test]
    fn test_rolling_xor() {
        let encoder = XorEncoder::rolling();
        let data = b"Rolling XOR test";
        let options = EncodingOptions {
            key: Some("A".to_string()), // Single character for seed
            ..Default::default()
        };

        let result = encoder.encode(data, &options).unwrap();
        assert!(!result.encoded_data.is_empty());

        // Use the actual key that was used (stored as numeric string)
        let decode_options = EncodingOptions {
            key: result.key_used.clone(),
            ..Default::default()
        };
        let decoded = encoder.decode(&result.encoded_data, &decode_options).unwrap();
        assert_eq!(decoded, data);
    }

    #[test]
    fn test_additive_xor() {
        let encoder = XorEncoder::additive();
        let data = b"Additive XOR test";
        let options = EncodingOptions {
            key: Some("feedback".to_string()),
            ..Default::default()
        };

        let result = encoder.encode(data, &options).unwrap();
        assert!(!result.encoded_data.is_empty());

        let decoded = encoder.decode(&result.encoded_data, &options).unwrap();
        assert_eq!(decoded, data);
    }

    #[test]
    fn test_auto_generated_key() {
        let encoder = XorEncoder::multi_byte();
        let data = b"Auto key test";
        let options = EncodingOptions::default();

        let result = encoder.encode(data, &options).unwrap();
        assert!(result.key_used.is_some());

        // Decode with the generated key
        let decode_options = EncodingOptions {
            key: result.key_used.clone(),
            ..Default::default()
        };
        let decoded = encoder.decode(&result.encoded_data, &decode_options).unwrap();
        assert_eq!(decoded, data);
    }

    #[test]
    fn test_decoder_stub_generation() {
        let encoder = XorEncoder::single_byte();
        let data = b"Stub test";
        let options = EncodingOptions {
            key: Some("65".to_string()),
            generate_decoder_stub: true,
            decoder_language: DecoderLanguage::Python,
            ..Default::default()
        };

        let result = encoder.encode(data, &options).unwrap();
        assert!(result.decoder_stub.is_some());
        assert!(result.decoder_stub.unwrap().contains("XOR Single-Byte Decoder"));
    }

    #[test]
    fn test_legacy_xor_encode_decode() {
        let original = "Legacy test";
        let key = "secret";

        let encoded = xor_encode(original, key);
        let decoded = xor_decode(&encoded, key).unwrap();

        assert_eq!(original, decoded);
    }
}
