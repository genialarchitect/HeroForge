// Custom Encoders Module
// Various custom encoding techniques for payload obfuscation

use anyhow::{anyhow, Result};

use super::{
    create_metadata, DecoderLanguage, Encoder, EncoderType,
    EncodingOptions, EncodingResult,
};

// ============================================================================
// Hex Encoder
// ============================================================================

/// Hex encoder variants
#[derive(Debug, Clone)]
pub enum HexVariant {
    /// Standard hex encoding
    Standard,
    /// Reversed hex encoding
    Reversed,
}

/// Hex encoder implementation
pub struct HexEncoder {
    variant: HexVariant,
}

impl HexEncoder {
    /// Create standard hex encoder
    pub fn new() -> Self {
        Self {
            variant: HexVariant::Standard,
        }
    }

    /// Create reversed hex encoder
    pub fn reversed() -> Self {
        Self {
            variant: HexVariant::Reversed,
        }
    }
}

impl Default for HexEncoder {
    fn default() -> Self {
        Self::new()
    }
}

impl Encoder for HexEncoder {
    fn encoder_type(&self) -> EncoderType {
        match self.variant {
            HexVariant::Standard => EncoderType::Hex,
            HexVariant::Reversed => EncoderType::HexReverse,
        }
    }

    fn encode(&self, data: &[u8], options: &EncodingOptions) -> Result<EncodingResult> {
        let encoded = match self.variant {
            HexVariant::Standard => hex::encode(data),
            HexVariant::Reversed => {
                let hex_str = hex::encode(data);
                hex_str.chars().rev().collect()
            }
        };

        let encoded_bytes = encoded.as_bytes().to_vec();

        let decoder_stub = if options.generate_decoder_stub {
            Some(match self.variant {
                HexVariant::Standard => {
                    match options.decoder_language {
                        DecoderLanguage::Python => format!(
                            r#"import binascii
# Hex Decoder
encoded = "{}"
decoded = binascii.unhexlify(encoded)
exec(decoded)
"#,
                            encoded
                        ),
                        DecoderLanguage::PowerShell => format!(
                            r#"# Hex Decoder
$h="{}"
$d=[byte[]]::new($h.Length/2)
for($i=0;$i-lt$d.Length;$i++){{$d[$i]=[Convert]::ToByte($h.Substring($i*2,2),16)}}
iex([System.Text.Encoding]::ASCII.GetString($d))
"#,
                            encoded
                        ),
                        _ => format!(
                            r#"import binascii
encoded = "{}"
decoded = binascii.unhexlify(encoded)
exec(decoded)
"#,
                            encoded
                        ),
                    }
                }
                HexVariant::Reversed => {
                    match options.decoder_language {
                        DecoderLanguage::Python => format!(
                            r#"import binascii
# Reversed Hex Decoder
encoded = "{}"
reversed_hex = encoded[::-1]
decoded = binascii.unhexlify(reversed_hex)
exec(decoded)
"#,
                            encoded
                        ),
                        DecoderLanguage::PowerShell => format!(
                            r#"# Reversed Hex Decoder
$h="{}"
$h=[string]::new($h.ToCharArray()[$h.Length..0])
$d=[byte[]]::new($h.Length/2)
for($i=0;$i-lt$d.Length;$i++){{$d[$i]=[Convert]::ToByte($h.Substring($i*2,2),16)}}
iex([System.Text.Encoding]::ASCII.GetString($d))
"#,
                            encoded
                        ),
                        _ => format!(
                            r#"import binascii
encoded = "{}"
reversed_hex = encoded[::-1]
decoded = binascii.unhexlify(reversed_hex)
exec(decoded)
"#,
                            encoded
                        ),
                    }
                }
            })
        } else {
            None
        };

        let metadata = create_metadata(
            data,
            &encoded_bytes,
            options.iterations,
            options.preserve_nulls,
            Vec::new(),
        );

        Ok(EncodingResult {
            encoded_data: encoded_bytes,
            encoded_string: Some(encoded),
            encoder_type: self.encoder_type(),
            decoder_stub,
            key_used: None,
            iv_used: None,
            metadata,
        })
    }

    fn decode(&self, data: &[u8], _options: &EncodingOptions) -> Result<Vec<u8>> {
        let input = std::str::from_utf8(data)
            .map_err(|e| anyhow!("Invalid UTF-8: {}", e))?;

        let hex_str = match self.variant {
            HexVariant::Standard => input.to_string(),
            HexVariant::Reversed => input.chars().rev().collect(),
        };

        hex::decode(&hex_str).map_err(|e| anyhow!("Hex decode error: {}", e))
    }

    fn description(&self) -> &'static str {
        match self.variant {
            HexVariant::Standard => "Hexadecimal encoding",
            HexVariant::Reversed => "Reversed hexadecimal encoding",
        }
    }
}

// ============================================================================
// ROT Encoder (ROT13/ROT47)
// ============================================================================

/// ROT encoder variants
#[derive(Debug, Clone)]
pub enum RotVariant {
    /// ROT13 (letters only)
    Rot13,
    /// ROT47 (printable ASCII)
    Rot47,
}

/// ROT encoder implementation
pub struct RotEncoder {
    variant: RotVariant,
}

impl RotEncoder {
    /// Create ROT13 encoder
    pub fn rot13() -> Self {
        Self {
            variant: RotVariant::Rot13,
        }
    }

    /// Create ROT47 encoder
    pub fn rot47() -> Self {
        Self {
            variant: RotVariant::Rot47,
        }
    }

    fn rot13_char(c: char) -> char {
        match c {
            'a'..='m' | 'A'..='M' => ((c as u8) + 13) as char,
            'n'..='z' | 'N'..='Z' => ((c as u8) - 13) as char,
            _ => c,
        }
    }

    fn rot47_char(c: char) -> char {
        let code = c as u8;
        if code >= 33 && code <= 126 {
            (((code - 33 + 47) % 94) + 33) as char
        } else {
            c
        }
    }
}

impl Encoder for RotEncoder {
    fn encoder_type(&self) -> EncoderType {
        match self.variant {
            RotVariant::Rot13 => EncoderType::Rot13,
            RotVariant::Rot47 => EncoderType::Rot47,
        }
    }

    fn encode(&self, data: &[u8], options: &EncodingOptions) -> Result<EncodingResult> {
        let input = std::str::from_utf8(data)
            .map_err(|e| anyhow!("Invalid UTF-8: {}", e))?;

        let encoded: String = match self.variant {
            RotVariant::Rot13 => input.chars().map(Self::rot13_char).collect(),
            RotVariant::Rot47 => input.chars().map(Self::rot47_char).collect(),
        };

        let encoded_bytes = encoded.as_bytes().to_vec();

        let decoder_stub = if options.generate_decoder_stub {
            Some(match self.variant {
                RotVariant::Rot13 => {
                    match options.decoder_language {
                        DecoderLanguage::Python => format!(
                            r#"import codecs
# ROT13 Decoder
encoded = "{}"
decoded = codecs.decode(encoded, 'rot_13')
exec(decoded)
"#,
                            encoded
                        ),
                        DecoderLanguage::Bash => format!(
                            r#"#!/bin/bash
# ROT13 Decoder
encoded="{}"
decoded=$(echo "$encoded" | tr 'A-Za-z' 'N-ZA-Mn-za-m')
eval "$decoded"
"#,
                            encoded
                        ),
                        _ => format!(
                            r#"import codecs
encoded = "{}"
decoded = codecs.decode(encoded, 'rot_13')
exec(decoded)
"#,
                            encoded
                        ),
                    }
                }
                RotVariant::Rot47 => {
                    match options.decoder_language {
                        DecoderLanguage::Python => format!(
                            r#"# ROT47 Decoder
encoded = "{}"
decoded = ''.join(chr((ord(c) - 33 + 47) % 94 + 33) if 33 <= ord(c) <= 126 else c for c in encoded)
exec(decoded)
"#,
                            encoded
                        ),
                        _ => format!(
                            r#"# ROT47 Decoder
encoded = "{}"
decoded = ''.join(chr((ord(c) - 33 + 47) % 94 + 33) if 33 <= ord(c) <= 126 else c for c in encoded)
exec(decoded)
"#,
                            encoded
                        ),
                    }
                }
            })
        } else {
            None
        };

        let metadata = create_metadata(
            data,
            &encoded_bytes,
            options.iterations,
            options.preserve_nulls,
            Vec::new(),
        );

        Ok(EncodingResult {
            encoded_data: encoded_bytes,
            encoded_string: Some(encoded),
            encoder_type: self.encoder_type(),
            decoder_stub,
            key_used: None,
            iv_used: None,
            metadata,
        })
    }

    fn decode(&self, data: &[u8], options: &EncodingOptions) -> Result<Vec<u8>> {
        // ROT13 and ROT47 are symmetric
        self.encode(data, options).map(|r| r.encoded_data)
    }

    fn description(&self) -> &'static str {
        match self.variant {
            RotVariant::Rot13 => "ROT13 letter substitution",
            RotVariant::Rot47 => "ROT47 printable ASCII substitution",
        }
    }
}

// ============================================================================
// Unicode Encoder
// ============================================================================

/// Unicode encoder variants
#[derive(Debug, Clone)]
pub enum UnicodeVariant {
    /// Unicode code points (U+XXXX)
    CodePoints,
    /// Unicode escape sequences (\uXXXX)
    Escaped,
}

/// Unicode encoder implementation
pub struct UnicodeEncoder {
    variant: UnicodeVariant,
}

impl UnicodeEncoder {
    /// Create code point encoder
    pub fn new() -> Self {
        Self {
            variant: UnicodeVariant::CodePoints,
        }
    }

    /// Create escaped encoder
    pub fn escaped() -> Self {
        Self {
            variant: UnicodeVariant::Escaped,
        }
    }
}

impl Default for UnicodeEncoder {
    fn default() -> Self {
        Self::new()
    }
}

impl Encoder for UnicodeEncoder {
    fn encoder_type(&self) -> EncoderType {
        match self.variant {
            UnicodeVariant::CodePoints => EncoderType::Unicode,
            UnicodeVariant::Escaped => EncoderType::UnicodeEscape,
        }
    }

    fn encode(&self, data: &[u8], options: &EncodingOptions) -> Result<EncodingResult> {
        let input = std::str::from_utf8(data)
            .map_err(|e| anyhow!("Invalid UTF-8: {}", e))?;

        let encoded: String = match self.variant {
            UnicodeVariant::CodePoints => {
                input
                    .chars()
                    .map(|c| format!("U+{:04X}", c as u32))
                    .collect::<Vec<_>>()
                    .join(" ")
            }
            UnicodeVariant::Escaped => {
                input
                    .chars()
                    .map(|c| format!("\\u{:04x}", c as u32))
                    .collect()
            }
        };

        let encoded_bytes = encoded.as_bytes().to_vec();

        let decoder_stub = if options.generate_decoder_stub {
            Some(match self.variant {
                UnicodeVariant::CodePoints => {
                    format!(
                        r#"# Unicode Code Points Decoder
encoded = "{}"
decoded = ''.join(chr(int(cp[2:], 16)) for cp in encoded.split())
exec(decoded)
"#,
                        encoded
                    )
                }
                UnicodeVariant::Escaped => {
                    format!(
                        r#"# Unicode Escape Decoder
encoded = "{}"
decoded = encoded.encode().decode('unicode_escape')
exec(decoded)
"#,
                        encoded.replace("\\", "\\\\")
                    )
                }
            })
        } else {
            None
        };

        let metadata = create_metadata(
            data,
            &encoded_bytes,
            options.iterations,
            options.preserve_nulls,
            Vec::new(),
        );

        Ok(EncodingResult {
            encoded_data: encoded_bytes,
            encoded_string: Some(encoded),
            encoder_type: self.encoder_type(),
            decoder_stub,
            key_used: None,
            iv_used: None,
            metadata,
        })
    }

    fn decode(&self, data: &[u8], _options: &EncodingOptions) -> Result<Vec<u8>> {
        let input = std::str::from_utf8(data)
            .map_err(|e| anyhow!("Invalid UTF-8: {}", e))?;

        let decoded: String = match self.variant {
            UnicodeVariant::CodePoints => {
                input
                    .split_whitespace()
                    .filter_map(|s| {
                        s.strip_prefix("U+")
                            .and_then(|hex| u32::from_str_radix(hex, 16).ok())
                            .and_then(char::from_u32)
                    })
                    .collect()
            }
            UnicodeVariant::Escaped => {
                let mut result = String::new();
                let mut chars = input.chars().peekable();

                while let Some(c) = chars.next() {
                    if c == '\\' && chars.peek() == Some(&'u') {
                        chars.next(); // consume 'u'
                        let hex: String = chars.by_ref().take(4).collect();
                        if let Ok(code) = u32::from_str_radix(&hex, 16) {
                            if let Some(decoded_char) = char::from_u32(code) {
                                result.push(decoded_char);
                            }
                        }
                    } else {
                        result.push(c);
                    }
                }
                result
            }
        };

        Ok(decoded.into_bytes())
    }

    fn description(&self) -> &'static str {
        match self.variant {
            UnicodeVariant::CodePoints => "Unicode code point encoding (U+XXXX)",
            UnicodeVariant::Escaped => "Unicode escape sequences (\\uXXXX)",
        }
    }
}

// ============================================================================
// URL Encoder
// ============================================================================

/// URL encoder implementation
pub struct UrlEncoder;

impl UrlEncoder {
    pub fn new() -> Self {
        Self
    }
}

impl Default for UrlEncoder {
    fn default() -> Self {
        Self::new()
    }
}

impl Encoder for UrlEncoder {
    fn encoder_type(&self) -> EncoderType {
        EncoderType::UrlEncode
    }

    fn encode(&self, data: &[u8], options: &EncodingOptions) -> Result<EncodingResult> {
        let encoded: String = data
            .iter()
            .map(|&b| {
                if b.is_ascii_alphanumeric() || b == b'-' || b == b'_' || b == b'.' || b == b'~' {
                    (b as char).to_string()
                } else {
                    format!("%{:02X}", b)
                }
            })
            .collect();

        let encoded_bytes = encoded.as_bytes().to_vec();

        let decoder_stub = if options.generate_decoder_stub {
            Some(match options.decoder_language {
                DecoderLanguage::Python => format!(
                    r#"from urllib.parse import unquote
# URL Decoder
encoded = "{}"
decoded = unquote(encoded)
exec(decoded)
"#,
                    encoded
                ),
                DecoderLanguage::PowerShell => format!(
                    r#"# URL Decoder
$e="{}"
$d=[System.Uri]::UnescapeDataString($e)
iex $d
"#,
                    encoded
                ),
                _ => format!(
                    r#"from urllib.parse import unquote
encoded = "{}"
decoded = unquote(encoded)
exec(decoded)
"#,
                    encoded
                ),
            })
        } else {
            None
        };

        let metadata = create_metadata(
            data,
            &encoded_bytes,
            options.iterations,
            options.preserve_nulls,
            Vec::new(),
        );

        Ok(EncodingResult {
            encoded_data: encoded_bytes,
            encoded_string: Some(encoded),
            encoder_type: self.encoder_type(),
            decoder_stub,
            key_used: None,
            iv_used: None,
            metadata,
        })
    }

    fn decode(&self, data: &[u8], _options: &EncodingOptions) -> Result<Vec<u8>> {
        let input = std::str::from_utf8(data)
            .map_err(|e| anyhow!("Invalid UTF-8: {}", e))?;

        let mut result = Vec::new();
        let mut chars = input.chars().peekable();

        while let Some(c) = chars.next() {
            if c == '%' {
                let hex: String = chars.by_ref().take(2).collect();
                if hex.len() == 2 {
                    if let Ok(byte) = u8::from_str_radix(&hex, 16) {
                        result.push(byte);
                        continue;
                    }
                }
                // Invalid escape, keep original
                result.push(b'%');
                result.extend(hex.bytes());
            } else {
                result.push(c as u8);
            }
        }

        Ok(result)
    }

    fn description(&self) -> &'static str {
        "URL percent encoding"
    }
}

// ============================================================================
// HTML Entity Encoder
// ============================================================================

/// HTML entity encoder implementation
pub struct HtmlEncoder;

impl HtmlEncoder {
    pub fn new() -> Self {
        Self
    }
}

impl Default for HtmlEncoder {
    fn default() -> Self {
        Self::new()
    }
}

impl Encoder for HtmlEncoder {
    fn encoder_type(&self) -> EncoderType {
        EncoderType::HtmlEntities
    }

    fn encode(&self, data: &[u8], options: &EncodingOptions) -> Result<EncodingResult> {
        let input = std::str::from_utf8(data)
            .map_err(|e| anyhow!("Invalid UTF-8: {}", e))?;

        let encoded: String = input
            .chars()
            .map(|c| format!("&#{};", c as u32))
            .collect();

        let encoded_bytes = encoded.as_bytes().to_vec();

        let decoder_stub = if options.generate_decoder_stub {
            Some(format!(
                r#"import html
# HTML Entity Decoder
encoded = "{}"
decoded = html.unescape(encoded)
exec(decoded)
"#,
                encoded
            ))
        } else {
            None
        };

        let metadata = create_metadata(
            data,
            &encoded_bytes,
            options.iterations,
            options.preserve_nulls,
            Vec::new(),
        );

        Ok(EncodingResult {
            encoded_data: encoded_bytes,
            encoded_string: Some(encoded),
            encoder_type: self.encoder_type(),
            decoder_stub,
            key_used: None,
            iv_used: None,
            metadata,
        })
    }

    fn decode(&self, data: &[u8], _options: &EncodingOptions) -> Result<Vec<u8>> {
        let input = std::str::from_utf8(data)
            .map_err(|e| anyhow!("Invalid UTF-8: {}", e))?;

        let mut result = String::new();
        let mut chars = input.chars().peekable();

        while let Some(c) = chars.next() {
            if c == '&' && chars.peek() == Some(&'#') {
                chars.next(); // consume '#'
                let num_str: String = chars.by_ref().take_while(|&c| c != ';').collect();
                if let Ok(code) = num_str.parse::<u32>() {
                    if let Some(decoded_char) = char::from_u32(code) {
                        result.push(decoded_char);
                        continue;
                    }
                }
                // Invalid entity, keep original
                result.push('&');
                result.push('#');
                result.push_str(&num_str);
            } else {
                result.push(c);
            }
        }

        Ok(result.into_bytes())
    }

    fn description(&self) -> &'static str {
        "HTML numeric entity encoding"
    }
}

// ============================================================================
// String Encoder (Reverse, CharSwap)
// ============================================================================

/// String encoder variants
#[derive(Debug, Clone)]
pub enum StringVariant {
    /// Reverse string
    Reverse,
    /// Swap adjacent character pairs
    CharSwap,
}

/// String encoder implementation
pub struct StringEncoder {
    variant: StringVariant,
}

impl StringEncoder {
    /// Create reverse encoder
    pub fn reverse() -> Self {
        Self {
            variant: StringVariant::Reverse,
        }
    }

    /// Create character swap encoder
    pub fn char_swap() -> Self {
        Self {
            variant: StringVariant::CharSwap,
        }
    }
}

impl Encoder for StringEncoder {
    fn encoder_type(&self) -> EncoderType {
        match self.variant {
            StringVariant::Reverse => EncoderType::StringReverse,
            StringVariant::CharSwap => EncoderType::CharSwap,
        }
    }

    fn encode(&self, data: &[u8], options: &EncodingOptions) -> Result<EncodingResult> {
        let input = std::str::from_utf8(data)
            .map_err(|e| anyhow!("Invalid UTF-8: {}", e))?;

        let encoded: String = match self.variant {
            StringVariant::Reverse => input.chars().rev().collect(),
            StringVariant::CharSwap => {
                let chars: Vec<char> = input.chars().collect();
                let mut result = Vec::with_capacity(chars.len());
                for i in (0..chars.len()).step_by(2) {
                    if i + 1 < chars.len() {
                        result.push(chars[i + 1]);
                        result.push(chars[i]);
                    } else {
                        result.push(chars[i]);
                    }
                }
                result.into_iter().collect()
            }
        };

        let encoded_bytes = encoded.as_bytes().to_vec();

        let decoder_stub = if options.generate_decoder_stub {
            Some(match self.variant {
                StringVariant::Reverse => format!(
                    r#"# String Reverse Decoder
encoded = "{}"
decoded = encoded[::-1]
exec(decoded)
"#,
                    encoded
                ),
                StringVariant::CharSwap => format!(
                    r#"# Character Swap Decoder
encoded = "{}"
decoded = ''.join(encoded[i+1] + encoded[i] if i + 1 < len(encoded) else encoded[i] for i in range(0, len(encoded), 2))
exec(decoded)
"#,
                    encoded
                ),
            })
        } else {
            None
        };

        let metadata = create_metadata(
            data,
            &encoded_bytes,
            options.iterations,
            options.preserve_nulls,
            Vec::new(),
        );

        Ok(EncodingResult {
            encoded_data: encoded_bytes,
            encoded_string: Some(encoded),
            encoder_type: self.encoder_type(),
            decoder_stub,
            key_used: None,
            iv_used: None,
            metadata,
        })
    }

    fn decode(&self, data: &[u8], options: &EncodingOptions) -> Result<Vec<u8>> {
        // Both operations are symmetric
        self.encode(data, options).map(|r| r.encoded_data)
    }

    fn description(&self) -> &'static str {
        match self.variant {
            StringVariant::Reverse => "Reverse the string",
            StringVariant::CharSwap => "Swap adjacent character pairs",
        }
    }
}

// ============================================================================
// Byte Shuffle Encoder
// ============================================================================

/// Byte shuffle encoder using seeded PRNG
pub struct ByteShuffleEncoder;

impl ByteShuffleEncoder {
    pub fn new() -> Self {
        Self
    }

    /// Generate shuffle permutation from seed
    fn generate_permutation(&self, seed: u64, len: usize) -> Vec<usize> {
        use rand::{rngs::StdRng, seq::SliceRandom, SeedableRng};

        let mut indices: Vec<usize> = (0..len).collect();
        let mut rng = StdRng::seed_from_u64(seed);
        indices.shuffle(&mut rng);
        indices
    }

    /// Generate inverse permutation
    #[allow(dead_code)]
    fn inverse_permutation(&self, perm: &[usize]) -> Vec<usize> {
        let mut inverse = vec![0; perm.len()];
        for (i, &p) in perm.iter().enumerate() {
            inverse[p] = i;
        }
        inverse
    }

    /// Hash string key to u64 seed
    fn key_to_seed(&self, key: &str) -> u64 {
        use sha2::{Sha256, Digest};
        let mut hasher = Sha256::new();
        hasher.update(key.as_bytes());
        let hash = hasher.finalize();
        u64::from_le_bytes(hash[..8].try_into().unwrap())
    }
}

impl Default for ByteShuffleEncoder {
    fn default() -> Self {
        Self::new()
    }
}

impl Encoder for ByteShuffleEncoder {
    fn encoder_type(&self) -> EncoderType {
        EncoderType::ByteShuffle
    }

    fn encode(&self, data: &[u8], options: &EncodingOptions) -> Result<EncodingResult> {
        let key = options
            .key
            .as_ref()
            .ok_or_else(|| anyhow!("Byte shuffle requires a key"))?;

        let seed = self.key_to_seed(key);
        let perm = self.generate_permutation(seed, data.len());

        let mut encoded = vec![0u8; data.len()];
        for (i, &p) in perm.iter().enumerate() {
            encoded[p] = data[i];
        }

        let encoded_hex = hex::encode(&encoded);

        let decoder_stub = if options.generate_decoder_stub {
            Some(format!(
                r#"import hashlib
import random
import binascii
# Byte Shuffle Decoder
key = "{}"
encoded = binascii.unhexlify("{}")

# Generate permutation from key
seed = int.from_bytes(hashlib.sha256(key.encode()).digest()[:8], 'little')
random.seed(seed)
perm = list(range(len(encoded)))
random.shuffle(perm)

# Inverse permutation
inverse = [0] * len(perm)
for i, p in enumerate(perm):
    inverse[p] = i

# Unshuffle
decoded = bytes([encoded[inverse[i]] for i in range(len(encoded))])
exec(decoded)
"#,
                key, encoded_hex
            ))
        } else {
            None
        };

        let metadata = create_metadata(
            data,
            &encoded,
            options.iterations,
            options.preserve_nulls,
            Vec::new(),
        );

        Ok(EncodingResult {
            encoded_data: encoded,
            encoded_string: Some(encoded_hex),
            encoder_type: self.encoder_type(),
            decoder_stub,
            key_used: Some(key.clone()),
            iv_used: None,
            metadata,
        })
    }

    fn decode(&self, data: &[u8], options: &EncodingOptions) -> Result<Vec<u8>> {
        let key = options
            .key
            .as_ref()
            .ok_or_else(|| anyhow!("Byte shuffle requires a key"))?;

        let seed = self.key_to_seed(key);
        let perm = self.generate_permutation(seed, data.len());

        // In encode: encoded[perm[i]] = original[i]
        // To decode: original[i] = encoded[perm[i]]
        let mut decoded = vec![0u8; data.len()];
        for (i, &p) in perm.iter().enumerate() {
            decoded[i] = data[p];
        }

        Ok(decoded)
    }

    fn description(&self) -> &'static str {
        "Shuffle bytes using a seeded PRNG"
    }
}

// ============================================================================
// Legacy Functions
// ============================================================================

/// Generate a random alphanumeric key (legacy function)
#[allow(dead_code)]
pub fn generate_random_key(length: usize) -> String {
    use rand::Rng;
    const CHARSET: &[u8] = b"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    let mut rng = rand::thread_rng();
    (0..length)
        .map(|_| {
            let idx = rng.gen_range(0..CHARSET.len());
            CHARSET[idx] as char
        })
        .collect()
}

/// Generate Python decoder stub for XOR payload (legacy function)
#[allow(dead_code)]
pub fn python_xor_decoder(hex_payload: &str, key: &str) -> String {
    format!(
        r#"import binascii
key = '{}'
payload = binascii.unhexlify('{}')
decoded = ''.join(chr(b ^ ord(key[i % len(key)])) for i, b in enumerate(payload))
exec(decoded)"#,
        key, hex_payload
    )
}

/// Generate PowerShell decoder stub for XOR payload (legacy function)
#[allow(dead_code)]
pub fn powershell_xor_decoder(hex_payload: &str, key: &str) -> String {
    format!(
        r#"$k="{}";$p="{}";$b=[byte[]]::new($p.Length/2);for($i=0;$i-lt$b.Length;$i++){{$b[$i]=[Convert]::ToByte($p.Substring($i*2,2),16)-bxor$k[$i%$k.Length]}};iex([System.Text.Encoding]::ASCII.GetString($b))"#,
        key, hex_payload
    )
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_hex_encoder() {
        let encoder = HexEncoder::new();
        let data = b"Hello";
        let options = EncodingOptions::default();

        let result = encoder.encode(data, &options).unwrap();
        assert_eq!(result.encoded_string, Some("48656c6c6f".to_string()));

        let decoded = encoder.decode(&result.encoded_data, &options).unwrap();
        assert_eq!(decoded, data);
    }

    #[test]
    fn test_hex_reversed() {
        let encoder = HexEncoder::reversed();
        let data = b"Test";
        let options = EncodingOptions::default();

        let result = encoder.encode(data, &options).unwrap();
        let decoded = encoder.decode(&result.encoded_data, &options).unwrap();
        assert_eq!(decoded, data);
    }

    #[test]
    fn test_rot13() {
        let encoder = RotEncoder::rot13();
        let data = b"Hello World";
        let options = EncodingOptions::default();

        let result = encoder.encode(data, &options).unwrap();
        assert_eq!(result.encoded_string, Some("Uryyb Jbeyq".to_string()));

        // ROT13 is symmetric
        let decoded = encoder.decode(&result.encoded_data, &options).unwrap();
        assert_eq!(decoded, data);
    }

    #[test]
    fn test_rot47() {
        let encoder = RotEncoder::rot47();
        let data = b"Test123!";
        let options = EncodingOptions::default();

        let result = encoder.encode(data, &options).unwrap();
        let decoded = encoder.decode(&result.encoded_data, &options).unwrap();
        assert_eq!(decoded, data);
    }

    #[test]
    fn test_unicode_escaped() {
        let encoder = UnicodeEncoder::escaped();
        let data = b"Hi";
        let options = EncodingOptions::default();

        let result = encoder.encode(data, &options).unwrap();
        assert_eq!(result.encoded_string, Some("\\u0048\\u0069".to_string()));

        let decoded = encoder.decode(&result.encoded_data, &options).unwrap();
        assert_eq!(decoded, data);
    }

    #[test]
    fn test_url_encoder() {
        let encoder = UrlEncoder::new();
        let data = b"Hello World!";
        let options = EncodingOptions::default();

        let result = encoder.encode(data, &options).unwrap();
        assert!(result.encoded_string.unwrap().contains("%20"));

        let decoded = encoder.decode(&result.encoded_data, &options).unwrap();
        assert_eq!(decoded, data);
    }

    #[test]
    fn test_string_reverse() {
        let encoder = StringEncoder::reverse();
        let data = b"Hello";
        let options = EncodingOptions::default();

        let result = encoder.encode(data, &options).unwrap();
        assert_eq!(result.encoded_string, Some("olleH".to_string()));

        let decoded = encoder.decode(&result.encoded_data, &options).unwrap();
        assert_eq!(decoded, data);
    }

    #[test]
    fn test_char_swap() {
        let encoder = StringEncoder::char_swap();
        let data = b"1234";
        let options = EncodingOptions::default();

        let result = encoder.encode(data, &options).unwrap();
        assert_eq!(result.encoded_string, Some("2143".to_string()));

        let decoded = encoder.decode(&result.encoded_data, &options).unwrap();
        assert_eq!(decoded, data);
    }

    #[test]
    fn test_byte_shuffle() {
        let encoder = ByteShuffleEncoder::new();
        let data = b"Shuffle test data";
        let options = EncodingOptions {
            key: Some("mysecretkey".to_string()),
            ..Default::default()
        };

        let result = encoder.encode(data, &options).unwrap();
        assert!(!result.encoded_data.is_empty());

        let decoded = encoder.decode(&result.encoded_data, &options).unwrap();
        assert_eq!(decoded, data);
    }
}
