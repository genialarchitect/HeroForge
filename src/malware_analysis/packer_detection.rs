//! Packer Detection
//!
//! Detects packers, crypters, and protectors in PE/ELF files.

use anyhow::Result;

use crate::malware_analysis::types::*;
use crate::malware_analysis::sample_store::SampleStore;

/// Packer detector
pub struct PackerDetector {
    signatures: Vec<PackerSignature>,
}

/// Packer signature definition
#[derive(Debug, Clone)]
struct PackerSignature {
    name: String,
    version: Option<String>,
    patterns: Vec<SignaturePattern>,
    entry_point_pattern: Option<Vec<u8>>,
    section_name: Option<String>,
}

/// Signature pattern
#[derive(Debug, Clone)]
struct SignaturePattern {
    offset: PatternOffset,
    bytes: Vec<u8>,
    mask: Option<Vec<u8>>,
}

/// Pattern offset type
#[derive(Debug, Clone)]
enum PatternOffset {
    EntryPoint(i64),
    FileStart(usize),
    SectionStart(String, usize),
}

impl PackerDetector {
    /// Create a new packer detector with built-in signatures
    pub fn new() -> Self {
        let mut detector = Self {
            signatures: vec![],
        };
        detector.load_signatures();
        detector
    }

    /// Load built-in packer signatures
    fn load_signatures(&mut self) {
        // UPX
        self.signatures.push(PackerSignature {
            name: "UPX".to_string(),
            version: None,
            patterns: vec![
                SignaturePattern {
                    offset: PatternOffset::SectionStart("UPX0".to_string(), 0),
                    bytes: vec![],
                    mask: None,
                },
            ],
            entry_point_pattern: Some(vec![0x60, 0xBE]), // PUSHAD; MOV ESI, ...
            section_name: Some("UPX".to_string()),
        });

        // ASPack
        self.signatures.push(PackerSignature {
            name: "ASPack".to_string(),
            version: None,
            patterns: vec![
                SignaturePattern {
                    offset: PatternOffset::EntryPoint(0),
                    bytes: vec![0x60, 0xE8, 0x00, 0x00, 0x00, 0x00, 0x5D, 0x81, 0xED],
                    mask: None,
                },
            ],
            entry_point_pattern: None,
            section_name: Some(".aspack".to_string()),
        });

        // VMProtect
        self.signatures.push(PackerSignature {
            name: "VMProtect".to_string(),
            version: None,
            patterns: vec![],
            entry_point_pattern: None,
            section_name: Some(".vmp".to_string()),
        });

        // Themida
        self.signatures.push(PackerSignature {
            name: "Themida".to_string(),
            version: None,
            patterns: vec![],
            entry_point_pattern: None,
            section_name: Some(".themida".to_string()),
        });

        // PECompact
        self.signatures.push(PackerSignature {
            name: "PECompact".to_string(),
            version: None,
            patterns: vec![
                SignaturePattern {
                    offset: PatternOffset::EntryPoint(0),
                    bytes: vec![0xB8],
                    mask: None,
                },
            ],
            entry_point_pattern: None,
            section_name: Some("PEC2".to_string()),
        });

        // FSG
        self.signatures.push(PackerSignature {
            name: "FSG".to_string(),
            version: None,
            patterns: vec![
                SignaturePattern {
                    offset: PatternOffset::EntryPoint(0),
                    bytes: vec![0x87, 0x25],
                    mask: None,
                },
            ],
            entry_point_pattern: None,
            section_name: None,
        });

        // MEW
        self.signatures.push(PackerSignature {
            name: "MEW".to_string(),
            version: None,
            patterns: vec![
                SignaturePattern {
                    offset: PatternOffset::EntryPoint(0),
                    bytes: vec![0xE9],
                    mask: None,
                },
            ],
            entry_point_pattern: None,
            section_name: Some("MEW".to_string()),
        });

        // MPRESS
        self.signatures.push(PackerSignature {
            name: "MPRESS".to_string(),
            version: None,
            patterns: vec![],
            entry_point_pattern: None,
            section_name: Some(".MPRESS".to_string()),
        });

        // Enigma Protector
        self.signatures.push(PackerSignature {
            name: "Enigma Protector".to_string(),
            version: None,
            patterns: vec![],
            entry_point_pattern: None,
            section_name: Some(".enigma".to_string()),
        });

        // PESpin
        self.signatures.push(PackerSignature {
            name: "PESpin".to_string(),
            version: None,
            patterns: vec![
                SignaturePattern {
                    offset: PatternOffset::EntryPoint(0),
                    bytes: vec![0xEB, 0x01],
                    mask: None,
                },
            ],
            entry_point_pattern: None,
            section_name: None,
        });

        // NSPack
        self.signatures.push(PackerSignature {
            name: "NSPack".to_string(),
            version: None,
            patterns: vec![],
            entry_point_pattern: None,
            section_name: Some(".nsp".to_string()),
        });

        // Armadillo
        self.signatures.push(PackerSignature {
            name: "Armadillo".to_string(),
            version: None,
            patterns: vec![],
            entry_point_pattern: Some(vec![0x55, 0x8B, 0xEC, 0x6A, 0xFF, 0x68]),
            section_name: None,
        });

        // ExeStealth
        self.signatures.push(PackerSignature {
            name: "ExeStealth".to_string(),
            version: None,
            patterns: vec![],
            entry_point_pattern: Some(vec![0xEB, 0x58, 0x00, 0x00, 0x00, 0x00]),
            section_name: None,
        });

        // Petite
        self.signatures.push(PackerSignature {
            name: "Petite".to_string(),
            version: None,
            patterns: vec![
                SignaturePattern {
                    offset: PatternOffset::EntryPoint(0),
                    bytes: vec![0xB8],
                    mask: None,
                },
            ],
            entry_point_pattern: None,
            section_name: Some(".petite".to_string()),
        });

        // yoda's Protector
        self.signatures.push(PackerSignature {
            name: "yoda's Protector".to_string(),
            version: None,
            patterns: vec![],
            entry_point_pattern: Some(vec![0x60, 0xE8, 0x00, 0x00, 0x00, 0x00, 0x5D, 0x81, 0xED, 0x00]),
            section_name: Some(".yP".to_string()),
        });
    }

    /// Detect packer in PE file
    pub fn detect_pe(&self, data: &[u8], sections: &[SectionInfo], entry_point: u64) -> Option<PackerInfo> {
        let mut best_match: Option<(String, Option<String>, f64, Vec<String>)> = None;

        for sig in &self.signatures {
            let mut confidence = 0.0;
            let mut matched_sigs = vec![];

            // Check section names
            if let Some(ref expected_section) = sig.section_name {
                if sections.iter().any(|s| s.name.contains(expected_section)) {
                    confidence += 0.5;
                    matched_sigs.push(format!("Section name: {}", expected_section));
                }
            }

            // Check entry point pattern
            if let Some(ref ep_pattern) = sig.entry_point_pattern {
                if self.check_entry_point_pattern(data, entry_point, ep_pattern) {
                    confidence += 0.3;
                    matched_sigs.push("Entry point pattern match".to_string());
                }
            }

            // Check other patterns
            for pattern in &sig.patterns {
                if self.match_pattern(data, pattern, sections, entry_point) {
                    confidence += 0.2;
                    matched_sigs.push("Pattern match".to_string());
                }
            }

            // Check for high entropy sections (common in packed files)
            let high_entropy_sections: Vec<_> = sections.iter()
                .filter(|s| s.entropy > 7.0)
                .collect();

            if !high_entropy_sections.is_empty() {
                confidence += 0.1;
            }

            if confidence > 0.3 {
                if best_match.as_ref().map_or(true, |(_, _, c, _)| confidence > *c) {
                    best_match = Some((sig.name.clone(), sig.version.clone(), confidence, matched_sigs));
                }
            }
        }

        // Also check for generic packing indicators
        if best_match.is_none() {
            let packing_indicators = self.check_generic_packing(data, sections);
            if packing_indicators > 2 {
                let confidence = (packing_indicators as f64 * 0.15).min(0.8);
                best_match = Some((
                    "Unknown Packer".to_string(),
                    None,
                    confidence,
                    vec!["High entropy".to_string(), "Few imports".to_string()],
                ));
            }
        }

        best_match.map(|(name, version, confidence, signatures_matched)| {
            PackerInfo {
                name,
                version,
                confidence,
                signatures_matched,
            }
        })
    }

    /// Check entry point pattern
    fn check_entry_point_pattern(&self, data: &[u8], entry_point: u64, pattern: &[u8]) -> bool {
        let ep = entry_point as usize;
        if ep + pattern.len() <= data.len() {
            &data[ep..ep + pattern.len()] == pattern
        } else {
            false
        }
    }

    /// Match a signature pattern
    fn match_pattern(
        &self,
        data: &[u8],
        pattern: &SignaturePattern,
        sections: &[SectionInfo],
        entry_point: u64,
    ) -> bool {
        let offset = match &pattern.offset {
            PatternOffset::EntryPoint(off) => (entry_point as i64 + off) as usize,
            PatternOffset::FileStart(off) => *off,
            PatternOffset::SectionStart(name, off) => {
                sections.iter()
                    .find(|s| s.name == *name)
                    .map_or(usize::MAX, |s| s.virtual_address as usize + off)
            }
        };

        if offset + pattern.bytes.len() > data.len() {
            return false;
        }

        if pattern.bytes.is_empty() {
            // Just checking section existence
            if let PatternOffset::SectionStart(name, _) = &pattern.offset {
                return sections.iter().any(|s| s.name.contains(name));
            }
            return false;
        }

        // Compare with optional mask
        if let Some(ref mask) = pattern.mask {
            for (i, (&byte, &mask_byte)) in pattern.bytes.iter().zip(mask.iter()).enumerate() {
                if (data[offset + i] & mask_byte) != (byte & mask_byte) {
                    return false;
                }
            }
            true
        } else {
            &data[offset..offset + pattern.bytes.len()] == pattern.bytes.as_slice()
        }
    }

    /// Check for generic packing indicators
    fn check_generic_packing(&self, data: &[u8], sections: &[SectionInfo]) -> usize {
        let mut indicators = 0;

        // High entropy in code section
        if sections.iter().any(|s| {
            s.characteristics.contains(&"CODE".to_string()) && s.entropy > 7.0
        }) {
            indicators += 1;
        }

        // High overall entropy
        let overall_entropy = SampleStore::compute_entropy(data);
        if overall_entropy > 7.0 {
            indicators += 1;
        }

        // Few sections with suspicious names
        let suspicious_section_count = sections.iter()
            .filter(|s| {
                let name = s.name.to_lowercase();
                !name.starts_with(".text") &&
                !name.starts_with(".data") &&
                !name.starts_with(".rdata") &&
                !name.starts_with(".rsrc") &&
                !name.starts_with(".reloc") &&
                !name.is_empty()
            })
            .count();

        if suspicious_section_count > 0 {
            indicators += 1;
        }

        // Section with RWX permissions
        if sections.iter().any(|s| {
            s.characteristics.contains(&"READ".to_string()) &&
            s.characteristics.contains(&"WRITE".to_string()) &&
            s.characteristics.contains(&"EXECUTE".to_string())
        }) {
            indicators += 1;
        }

        // Large difference between raw and virtual size
        if sections.iter().any(|s| {
            s.virtual_size > 0 && s.raw_size > 0 &&
            (s.virtual_size as f64 / s.raw_size as f64) > 10.0
        }) {
            indicators += 1;
        }

        indicators
    }

    /// Detect packer in ELF file
    pub fn detect_elf(&self, data: &[u8], sections: &[SectionInfo]) -> Option<PackerInfo> {
        let mut indicators = 0;
        let mut matched_sigs = vec![];

        // Check for UPX in ELF
        if sections.iter().any(|s| s.name.starts_with("UPX")) {
            return Some(PackerInfo {
                name: "UPX".to_string(),
                version: None,
                confidence: 0.9,
                signatures_matched: vec!["UPX section".to_string()],
            });
        }

        // Check for high entropy
        let overall_entropy = SampleStore::compute_entropy(data);
        if overall_entropy > 7.0 {
            indicators += 1;
            matched_sigs.push("High entropy".to_string());
        }

        // Check sections
        for section in sections {
            if section.entropy > 7.5 {
                indicators += 1;
                matched_sigs.push(format!("High entropy section: {}", section.name));
            }
        }

        if indicators >= 2 {
            Some(PackerInfo {
                name: "Unknown Packer".to_string(),
                version: None,
                confidence: (indicators as f64 * 0.2).min(0.7),
                signatures_matched: matched_sigs,
            })
        } else {
            None
        }
    }
}

impl Default for PackerDetector {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generic_packing_detection() {
        let detector = PackerDetector::new();

        // High entropy data
        let random_data: Vec<u8> = (0..1024).map(|i| (i * 17 + 31) as u8).collect();
        let sections = vec![
            SectionInfo {
                name: ".text".to_string(),
                virtual_address: 0x1000,
                virtual_size: 0x1000,
                raw_size: 0x100,
                entropy: 7.8,
                characteristics: vec!["CODE".to_string(), "EXECUTE".to_string(), "READ".to_string()],
                md5: String::new(),
            }
        ];

        let indicators = detector.check_generic_packing(&random_data, &sections);
        assert!(indicators > 0);
    }
}
