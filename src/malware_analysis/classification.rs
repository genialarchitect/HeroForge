//! Malware Classification
//!
//! Classifies malware based on analysis results.

use std::collections::HashMap;

use crate::malware_analysis::types::*;

/// Malware classifier
pub struct MalwareClassifier;

impl MalwareClassifier {
    /// Create a new classifier
    pub fn new() -> Self {
        Self
    }

    /// Classify malware based on analysis results
    pub fn classify(&self, analysis: &StaticAnalysisResult) -> ClassificationResult {
        let mut scores: HashMap<MalwareClassification, f64> = HashMap::new();
        let mut reasoning = vec![];

        // Analyze YARA matches
        for yara_match in &analysis.yara_matches {
            let (classification, score, reason) = self.classify_yara_match(yara_match);
            *scores.entry(classification).or_insert(0.0) += score;
            reasoning.push(reason);
        }

        // Analyze suspicious patterns
        for pattern in &analysis.suspicious_patterns {
            let (classification, score, reason) = self.classify_pattern(pattern);
            *scores.entry(classification).or_insert(0.0) += score;
            reasoning.push(reason);
        }

        // Analyze imports
        let (import_classifications, import_reasoning) = self.classify_imports(&analysis.imports);
        for (classification, score) in import_classifications {
            *scores.entry(classification).or_insert(0.0) += score;
        }
        reasoning.extend(import_reasoning);

        // Analyze strings
        let (string_classifications, string_reasoning) = self.classify_strings(&analysis.strings_interesting);
        for (classification, score) in string_classifications {
            *scores.entry(classification).or_insert(0.0) += score;
        }
        reasoning.extend(string_reasoning);

        // Check for packer (common in malware)
        if analysis.packer_detected.is_some() {
            reasoning.push("Sample is packed (common in malware)".to_string());
        }

        // Determine final classification
        let (classification, confidence) = self.determine_classification(&scores);

        // Determine family (if possible)
        let family = self.determine_family(&analysis.yara_matches, &analysis.strings_interesting);

        // Calculate threat score
        let threat_score = self.calculate_threat_score(&scores, analysis);

        ClassificationResult {
            classification,
            family,
            confidence,
            threat_score,
            reasoning,
            related_samples: vec![],
        }
    }

    /// Classify based on YARA match
    fn classify_yara_match(&self, yara_match: &YaraMatch) -> (MalwareClassification, f64, String) {
        let name_lower = yara_match.rule_name.to_lowercase();
        let tags: Vec<String> = yara_match.tags.iter().map(|t| t.to_lowercase()).collect();

        // Check tags first
        if tags.contains(&"ransomware".to_string()) {
            return (MalwareClassification::Ransomware, 0.8, format!("YARA rule '{}' tagged as ransomware", yara_match.rule_name));
        }
        if tags.contains(&"rat".to_string()) || tags.contains(&"trojan".to_string()) {
            return (MalwareClassification::Rat, 0.7, format!("YARA rule '{}' tagged as RAT/trojan", yara_match.rule_name));
        }
        if tags.contains(&"keylogger".to_string()) {
            return (MalwareClassification::Keylogger, 0.7, format!("YARA rule '{}' tagged as keylogger", yara_match.rule_name));
        }
        if tags.contains(&"stealer".to_string()) {
            return (MalwareClassification::Stealer, 0.7, format!("YARA rule '{}' tagged as stealer", yara_match.rule_name));
        }
        if tags.contains(&"miner".to_string()) {
            return (MalwareClassification::Miner, 0.8, format!("YARA rule '{}' tagged as miner", yara_match.rule_name));
        }

        // Check rule name
        if name_lower.contains("ransom") {
            return (MalwareClassification::Ransomware, 0.7, format!("YARA rule '{}' indicates ransomware", yara_match.rule_name));
        }
        if name_lower.contains("keylog") {
            return (MalwareClassification::Keylogger, 0.6, format!("YARA rule '{}' indicates keylogger", yara_match.rule_name));
        }
        if name_lower.contains("credential") || name_lower.contains("stealer") {
            return (MalwareClassification::Stealer, 0.6, format!("YARA rule '{}' indicates stealer", yara_match.rule_name));
        }
        if name_lower.contains("miner") || name_lower.contains("crypto") {
            return (MalwareClassification::Miner, 0.6, format!("YARA rule '{}' indicates miner", yara_match.rule_name));
        }
        if name_lower.contains("inject") {
            return (MalwareClassification::Trojan, 0.5, format!("YARA rule '{}' indicates injection capability", yara_match.rule_name));
        }

        (MalwareClassification::Unknown, 0.3, format!("YARA rule '{}' matched", yara_match.rule_name))
    }

    /// Classify based on suspicious pattern
    fn classify_pattern(&self, pattern: &SuspiciousPattern) -> (MalwareClassification, f64, String) {
        match pattern.pattern_type {
            SuspiciousPatternType::CodeInjection | SuspiciousPatternType::ProcessHollowing => {
                (MalwareClassification::Trojan, 0.6, format!("Code injection detected: {}", pattern.description))
            }
            SuspiciousPatternType::CredentialAccess => {
                (MalwareClassification::Stealer, 0.7, format!("Credential access detected: {}", pattern.description))
            }
            SuspiciousPatternType::Persistence => {
                (MalwareClassification::Trojan, 0.5, format!("Persistence mechanism detected: {}", pattern.description))
            }
            SuspiciousPatternType::CommandAndControl => {
                (MalwareClassification::Backdoor, 0.6, format!("C2 capability detected: {}", pattern.description))
            }
            SuspiciousPatternType::Collection => {
                (MalwareClassification::Spyware, 0.5, format!("Data collection detected: {}", pattern.description))
            }
            SuspiciousPatternType::Exfiltration => {
                (MalwareClassification::Stealer, 0.6, format!("Data exfiltration detected: {}", pattern.description))
            }
            SuspiciousPatternType::AntiDebug | SuspiciousPatternType::AntiVm | SuspiciousPatternType::AntiSandbox => {
                (MalwareClassification::Unknown, 0.3, format!("Evasion technique detected: {}", pattern.description))
            }
            _ => {
                (MalwareClassification::Unknown, 0.2, format!("Suspicious pattern: {}", pattern.description))
            }
        }
    }

    /// Classify based on imports
    fn classify_imports(&self, imports: &[ImportInfo]) -> (Vec<(MalwareClassification, f64)>, Vec<String>) {
        let mut classifications = vec![];
        let mut reasoning = vec![];

        let all_functions: Vec<&str> = imports.iter()
            .flat_map(|i| i.functions.iter().map(|f| f.as_str()))
            .collect();

        // Ransomware indicators
        if all_functions.iter().any(|f| f.contains("CryptEncrypt") || f.contains("CryptGenKey")) {
            classifications.push((MalwareClassification::Ransomware, 0.4));
            reasoning.push("Crypto API usage detected".to_string());
        }

        // Keylogger indicators
        if all_functions.iter().any(|f| f.contains("GetAsyncKeyState") || f.contains("SetWindowsHookEx")) {
            classifications.push((MalwareClassification::Keylogger, 0.5));
            reasoning.push("Keyboard hooking API detected".to_string());
        }

        // Downloader indicators
        if all_functions.iter().any(|f| f.contains("URLDownloadToFile") || f.contains("InternetReadFile")) {
            classifications.push((MalwareClassification::Downloader, 0.4));
            reasoning.push("Download capability detected".to_string());
        }

        // Screen capture
        if all_functions.iter().any(|f| f.contains("BitBlt") || f.contains("GetDC")) {
            classifications.push((MalwareClassification::Spyware, 0.3));
            reasoning.push("Screen capture capability detected".to_string());
        }

        (classifications, reasoning)
    }

    /// Classify based on strings
    fn classify_strings(&self, strings: &[InterestingString]) -> (Vec<(MalwareClassification, f64)>, Vec<String>) {
        let mut classifications = vec![];
        let mut reasoning = vec![];

        for string in strings {
            let value_lower = string.value.to_lowercase();

            // Ransomware strings
            if value_lower.contains("your files have been encrypted") ||
               value_lower.contains("bitcoin") && value_lower.contains("payment") ||
               value_lower.contains("decrypt") && value_lower.contains("key") {
                classifications.push((MalwareClassification::Ransomware, 0.5));
                reasoning.push(format!("Ransomware string: '{}'", &string.value[..50.min(string.value.len())]));
            }

            // Miner strings
            if value_lower.contains("stratum+tcp") ||
               value_lower.contains("mining pool") ||
               value_lower.contains("hashrate") {
                classifications.push((MalwareClassification::Miner, 0.6));
                reasoning.push(format!("Miner string: '{}'", &string.value[..50.min(string.value.len())]));
            }

            // RAT/C2 strings
            if value_lower.contains("shell") && value_lower.contains("execute") ||
               value_lower.contains("command") && value_lower.contains("receive") {
                classifications.push((MalwareClassification::Rat, 0.4));
                reasoning.push(format!("RAT-like string: '{}'", &string.value[..50.min(string.value.len())]));
            }
        }

        (classifications, reasoning)
    }

    /// Determine final classification from scores
    fn determine_classification(&self, scores: &HashMap<MalwareClassification, f64>) -> (MalwareClassification, f64) {
        if scores.is_empty() {
            return (MalwareClassification::Unknown, 0.0);
        }

        let mut best_classification = MalwareClassification::Unknown;
        let mut best_score = 0.0f64;

        for (classification, &score) in scores {
            if score > best_score {
                best_score = score;
                best_classification = classification.clone();
            }
        }

        // Normalize confidence
        let total_score: f64 = scores.values().sum();
        let confidence = if total_score > 0.0 {
            (best_score / total_score * 100.0).min(95.0)
        } else {
            0.0
        };

        (best_classification, confidence / 100.0)
    }

    /// Determine malware family
    fn determine_family(&self, yara_matches: &[YaraMatch], strings: &[InterestingString]) -> Option<String> {
        // Check YARA match metadata for family
        for yara_match in yara_matches {
            if let Some(family) = yara_match.meta.get("malware_family") {
                return Some(family.clone());
            }
            if let Some(family) = yara_match.meta.get("family") {
                return Some(family.clone());
            }
        }

        // Check for known family indicators in strings
        let known_families = [
            ("wannacry", "WannaCry"),
            ("petya", "Petya"),
            ("locky", "Locky"),
            ("emotet", "Emotet"),
            ("trickbot", "TrickBot"),
            ("qakbot", "QakBot"),
            ("cobalt strike", "Cobalt Strike"),
            ("metasploit", "Metasploit"),
            ("mimikatz", "Mimikatz"),
            ("njrat", "njRAT"),
            ("remcos", "Remcos"),
            ("asyncrat", "AsyncRAT"),
            ("agenttesla", "Agent Tesla"),
            ("formbook", "FormBook"),
            ("redline", "RedLine"),
        ];

        for string in strings {
            let value_lower = string.value.to_lowercase();
            for (pattern, family) in &known_families {
                if value_lower.contains(pattern) {
                    return Some(family.to_string());
                }
            }
        }

        None
    }

    /// Calculate threat score
    fn calculate_threat_score(&self, scores: &HashMap<MalwareClassification, f64>, analysis: &StaticAnalysisResult) -> u8 {
        let mut threat_score = 0u32;

        // Base score from classification
        let total_classification_score: f64 = scores.values().sum();
        threat_score += (total_classification_score * 10.0).min(40.0) as u32;

        // YARA matches
        threat_score += (analysis.yara_matches.len() * 5).min(20) as u32;

        // Suspicious patterns
        for pattern in &analysis.suspicious_patterns {
            threat_score += match pattern.severity {
                PatternSeverity::Critical => 10,
                PatternSeverity::High => 7,
                PatternSeverity::Medium => 4,
                PatternSeverity::Low => 2,
                PatternSeverity::Info => 1,
            };
        }

        // Packer detected
        if analysis.packer_detected.is_some() {
            threat_score += 10;
        }

        // High entropy sections
        if let Some(ref pe_info) = analysis.pe_info {
            if pe_info.sections.iter().any(|s| s.entropy > 7.5) {
                threat_score += 5;
            }
        }

        // Suspicious resources
        threat_score += (analysis.resources.iter().filter(|r| r.is_suspicious).count() * 5).min(15) as u32;

        threat_score.min(100) as u8
    }
}

impl Default for MalwareClassifier {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use chrono::Utc;

    #[test]
    fn test_ransomware_classification() {
        let classifier = MalwareClassifier::new();

        let analysis = StaticAnalysisResult {
            id: "test".to_string(),
            sample_id: "test".to_string(),
            pe_info: None,
            elf_info: None,
            imports: vec![],
            exports: vec![],
            strings_interesting: vec![
                InterestingString {
                    value: "Your files have been encrypted!".to_string(),
                    offset: 0,
                    encoding: StringEncoding::Ascii,
                    category: StringCategory::Suspicious,
                    section: None,
                },
                InterestingString {
                    value: "Send 0.5 Bitcoin to decrypt".to_string(),
                    offset: 100,
                    encoding: StringEncoding::Ascii,
                    category: StringCategory::Suspicious,
                    section: None,
                },
            ],
            yara_matches: vec![
                YaraMatch {
                    rule_name: "ransomware_indicators".to_string(),
                    rule_namespace: None,
                    tags: vec!["ransomware".to_string()],
                    meta: HashMap::new(),
                    matched_strings: vec![],
                }
            ],
            packer_detected: None,
            compiler_detected: None,
            certificates: vec![],
            resources: vec![],
            suspicious_patterns: vec![],
            created_at: Utc::now(),
        };

        let result = classifier.classify(&analysis);
        assert_eq!(result.classification, MalwareClassification::Ransomware);
        assert!(result.confidence > 0.5);
    }
}
