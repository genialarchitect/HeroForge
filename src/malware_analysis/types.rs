//! Malware Analysis Types
//!
//! Core types for malware analysis functionality.

use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};

/// Malware sample metadata
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MalwareSample {
    pub id: String,
    pub user_id: String,
    pub filename: String,
    pub file_size: u64,
    pub file_type: FileType,
    pub mime_type: Option<String>,
    pub md5: String,
    pub sha1: String,
    pub sha256: String,
    pub ssdeep: Option<String>,
    pub imphash: Option<String>,
    pub tlsh: Option<String>,
    pub entropy: f64,
    pub first_seen: DateTime<Utc>,
    pub last_seen: DateTime<Utc>,
    pub source: SampleSource,
    pub classification: Option<MalwareClassification>,
    pub family: Option<String>,
    pub threat_score: u8,
    pub tags: Vec<String>,
    pub encrypted_path: String,
    pub analysis_status: AnalysisStatus,
    pub created_at: DateTime<Utc>,
}

/// File type enumeration
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum FileType {
    Pe32,
    Pe64,
    Elf32,
    Elf64,
    MachO,
    Pdf,
    Office,
    Script,
    Archive,
    Jar,
    Apk,
    Unknown,
}

impl std::fmt::Display for FileType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            FileType::Pe32 => write!(f, "pe32"),
            FileType::Pe64 => write!(f, "pe64"),
            FileType::Elf32 => write!(f, "elf32"),
            FileType::Elf64 => write!(f, "elf64"),
            FileType::MachO => write!(f, "macho"),
            FileType::Pdf => write!(f, "pdf"),
            FileType::Office => write!(f, "office"),
            FileType::Script => write!(f, "script"),
            FileType::Archive => write!(f, "archive"),
            FileType::Jar => write!(f, "jar"),
            FileType::Apk => write!(f, "apk"),
            FileType::Unknown => write!(f, "unknown"),
        }
    }
}

/// Sample source
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum SampleSource {
    Upload,
    Sandbox,
    Feed,
    Scan,
    Import,
}

impl std::fmt::Display for SampleSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            SampleSource::Upload => write!(f, "upload"),
            SampleSource::Sandbox => write!(f, "sandbox"),
            SampleSource::Feed => write!(f, "feed"),
            SampleSource::Scan => write!(f, "scan"),
            SampleSource::Import => write!(f, "import"),
        }
    }
}

/// Malware classification
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]
#[serde(rename_all = "snake_case")]
pub enum MalwareClassification {
    Trojan,
    Ransomware,
    Rat,
    Worm,
    Virus,
    Rootkit,
    Backdoor,
    Spyware,
    Adware,
    Miner,
    Dropper,
    Downloader,
    Keylogger,
    Stealer,
    Botnet,
    Exploit,
    Pup,
    Hacktool,
    Unknown,
}

impl std::fmt::Display for MalwareClassification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            MalwareClassification::Trojan => write!(f, "trojan"),
            MalwareClassification::Ransomware => write!(f, "ransomware"),
            MalwareClassification::Rat => write!(f, "rat"),
            MalwareClassification::Worm => write!(f, "worm"),
            MalwareClassification::Virus => write!(f, "virus"),
            MalwareClassification::Rootkit => write!(f, "rootkit"),
            MalwareClassification::Backdoor => write!(f, "backdoor"),
            MalwareClassification::Spyware => write!(f, "spyware"),
            MalwareClassification::Adware => write!(f, "adware"),
            MalwareClassification::Miner => write!(f, "miner"),
            MalwareClassification::Dropper => write!(f, "dropper"),
            MalwareClassification::Downloader => write!(f, "downloader"),
            MalwareClassification::Keylogger => write!(f, "keylogger"),
            MalwareClassification::Stealer => write!(f, "stealer"),
            MalwareClassification::Botnet => write!(f, "botnet"),
            MalwareClassification::Exploit => write!(f, "exploit"),
            MalwareClassification::Pup => write!(f, "pup"),
            MalwareClassification::Hacktool => write!(f, "hacktool"),
            MalwareClassification::Unknown => write!(f, "unknown"),
        }
    }
}

/// Analysis status
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum AnalysisStatus {
    Pending,
    Analyzing,
    Completed,
    Failed,
}

impl std::fmt::Display for AnalysisStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AnalysisStatus::Pending => write!(f, "pending"),
            AnalysisStatus::Analyzing => write!(f, "analyzing"),
            AnalysisStatus::Completed => write!(f, "completed"),
            AnalysisStatus::Failed => write!(f, "failed"),
        }
    }
}

/// Static analysis results
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StaticAnalysisResult {
    pub id: String,
    pub sample_id: String,
    pub pe_info: Option<PeInfo>,
    pub elf_info: Option<ElfInfo>,
    pub imports: Vec<ImportInfo>,
    pub exports: Vec<ExportInfo>,
    pub strings_interesting: Vec<InterestingString>,
    pub yara_matches: Vec<YaraMatch>,
    pub packer_detected: Option<PackerInfo>,
    pub compiler_detected: Option<String>,
    pub certificates: Vec<CertificateInfo>,
    pub resources: Vec<EmbeddedResource>,
    pub suspicious_patterns: Vec<SuspiciousPattern>,
    pub created_at: DateTime<Utc>,
}

/// PE file information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PeInfo {
    pub machine_type: String,
    pub subsystem: String,
    pub timestamp: Option<DateTime<Utc>>,
    pub entry_point: u64,
    pub image_base: u64,
    pub checksum: u32,
    pub dll_characteristics: Vec<String>,
    pub sections: Vec<SectionInfo>,
    pub rich_header: Option<RichHeader>,
    pub debug_info: Option<DebugInfo>,
    pub tls_callbacks: Vec<u64>,
    pub is_dll: bool,
    pub is_dotnet: bool,
}

/// ELF file information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ElfInfo {
    pub machine_type: String,
    pub elf_type: String,
    pub entry_point: u64,
    pub os_abi: String,
    pub sections: Vec<SectionInfo>,
    pub symbols: Vec<String>,
    pub dynamic_libs: Vec<String>,
    pub is_stripped: bool,
    pub has_debug: bool,
    pub security_features: SecurityFeatures,
}

/// Section information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SectionInfo {
    pub name: String,
    pub virtual_address: u64,
    pub virtual_size: u64,
    pub raw_size: u64,
    pub entropy: f64,
    pub characteristics: Vec<String>,
    pub md5: String,
}

/// Rich header information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RichHeader {
    pub entries: Vec<RichHeaderEntry>,
    pub checksum: u32,
}

/// Rich header entry
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RichHeaderEntry {
    pub tool_id: u16,
    pub version: u16,
    pub count: u32,
}

/// Debug information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DebugInfo {
    pub debug_type: String,
    pub pdb_path: Option<String>,
    pub guid: Option<String>,
    pub age: Option<u32>,
}

/// Security features (for ELF)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SecurityFeatures {
    pub pie: bool,
    pub relro: String,
    pub stack_canary: bool,
    pub nx: bool,
    pub fortify: bool,
    pub rpath: Option<String>,
    pub runpath: Option<String>,
}

/// Import information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ImportInfo {
    pub library: String,
    pub functions: Vec<String>,
    pub is_delayed: bool,
}

/// Export information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExportInfo {
    pub name: String,
    pub ordinal: u32,
    pub address: u64,
    pub forwarded_to: Option<String>,
}

/// Interesting string found in binary
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InterestingString {
    pub value: String,
    pub offset: u64,
    pub encoding: StringEncoding,
    pub category: StringCategory,
    pub section: Option<String>,
}

/// String encoding
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum StringEncoding {
    Ascii,
    Utf8,
    Utf16Le,
    Utf16Be,
}

/// String category
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum StringCategory {
    Url,
    Ip,
    Domain,
    Email,
    FilePath,
    Registry,
    Command,
    Crypto,
    Debug,
    Error,
    Network,
    Suspicious,
    Other,
}

/// YARA rule match
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct YaraMatch {
    pub rule_name: String,
    pub rule_namespace: Option<String>,
    pub tags: Vec<String>,
    pub meta: std::collections::HashMap<String, String>,
    pub matched_strings: Vec<YaraStringMatch>,
}

/// YARA string match
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct YaraStringMatch {
    pub identifier: String,
    pub offset: u64,
    pub data: String,
}

/// Packer information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PackerInfo {
    pub name: String,
    pub version: Option<String>,
    pub confidence: f64,
    pub signatures_matched: Vec<String>,
}

/// Certificate information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CertificateInfo {
    pub subject: String,
    pub issuer: String,
    pub serial_number: String,
    pub not_before: DateTime<Utc>,
    pub not_after: DateTime<Utc>,
    pub is_valid: bool,
    pub is_trusted: bool,
    pub signature_algorithm: String,
    pub thumbprint_sha1: String,
    pub thumbprint_sha256: String,
}

/// Embedded resource
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EmbeddedResource {
    pub name: String,
    pub resource_type: String,
    pub language: String,
    pub size: u64,
    pub entropy: f64,
    pub md5: String,
    pub sha256: String,
    pub file_type: Option<String>,
    pub is_suspicious: bool,
}

/// Suspicious pattern detected
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SuspiciousPattern {
    pub pattern_type: SuspiciousPatternType,
    pub description: String,
    pub severity: PatternSeverity,
    pub indicators: Vec<String>,
    pub mitre_techniques: Vec<String>,
}

/// Type of suspicious pattern
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum SuspiciousPatternType {
    AntiDebug,
    AntiVm,
    AntiSandbox,
    CodeInjection,
    ProcessHollowing,
    Persistence,
    PrivilegeEscalation,
    DefenseEvasion,
    CredentialAccess,
    Discovery,
    LateralMovement,
    Collection,
    Exfiltration,
    CommandAndControl,
    Execution,
    Other,
}

/// Pattern severity
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum PatternSeverity {
    Critical,
    High,
    Medium,
    Low,
    Info,
}

/// Malware IOC
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MalwareIoc {
    pub id: String,
    pub sample_id: String,
    pub ioc_type: IocType,
    pub ioc_value: String,
    pub context: Option<String>,
    pub confidence: u8,
    pub source: IocSource,
    pub created_at: DateTime<Utc>,
}

/// IOC type
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum IocType {
    Ip,
    Domain,
    Url,
    Hash,
    Mutex,
    Registry,
    File,
    Email,
    UserAgent,
    JA3,
    Certificate,
    BitcoinAddress,
}

impl std::fmt::Display for IocType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            IocType::Ip => write!(f, "ip"),
            IocType::Domain => write!(f, "domain"),
            IocType::Url => write!(f, "url"),
            IocType::Hash => write!(f, "hash"),
            IocType::Mutex => write!(f, "mutex"),
            IocType::Registry => write!(f, "registry"),
            IocType::File => write!(f, "file"),
            IocType::Email => write!(f, "email"),
            IocType::UserAgent => write!(f, "user_agent"),
            IocType::JA3 => write!(f, "ja3"),
            IocType::Certificate => write!(f, "certificate"),
            IocType::BitcoinAddress => write!(f, "bitcoin_address"),
        }
    }
}

/// IOC source
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum IocSource {
    Static,
    Dynamic,
    Sandbox,
    Manual,
}

impl std::fmt::Display for IocSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            IocSource::Static => write!(f, "static"),
            IocSource::Dynamic => write!(f, "dynamic"),
            IocSource::Sandbox => write!(f, "sandbox"),
            IocSource::Manual => write!(f, "manual"),
        }
    }
}

/// YARA rule definition
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct YaraRule {
    pub id: String,
    pub user_id: Option<String>,
    pub name: String,
    pub description: Option<String>,
    pub rule_content: String,
    pub tags: Vec<String>,
    pub category: String,
    pub threat_type: Option<String>,
    pub source: String,
    pub author: Option<String>,
    pub reference_urls: Vec<String>,
    pub enabled: bool,
    pub matches_count: u32,
    pub false_positive_count: u32,
    pub last_matched_at: Option<DateTime<Utc>>,
    pub version: u32,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

/// Classification result
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ClassificationResult {
    pub classification: MalwareClassification,
    pub family: Option<String>,
    pub confidence: f64,
    pub threat_score: u8,
    pub reasoning: Vec<String>,
    pub related_samples: Vec<String>,
}

/// Analysis summary for dashboard
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AnalysisSummary {
    pub total_samples: u64,
    pub analyzed_today: u64,
    pub pending_analysis: u64,
    pub malicious_count: u64,
    pub clean_count: u64,
    pub unknown_count: u64,
    pub top_classifications: Vec<(String, u64)>,
    pub top_families: Vec<(String, u64)>,
    pub recent_samples: Vec<MalwareSample>,
}
