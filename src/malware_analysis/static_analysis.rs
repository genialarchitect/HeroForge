//! Static Analysis Pipeline
//!
//! Provides automated static analysis of malware samples.

use std::collections::HashMap;
use chrono::Utc;
use goblin::Object;
use anyhow::{Result, anyhow};

use crate::malware_analysis::types::*;
use crate::malware_analysis::sample_store::SampleStore;
use crate::binary_analysis::hashing::compute_md5;

/// Static analyzer for malware samples
pub struct StaticAnalyzer {
    sample_store: SampleStore,
}

impl StaticAnalyzer {
    /// Create a new static analyzer
    pub fn new(sample_store: SampleStore) -> Self {
        Self { sample_store }
    }

    /// Analyze a sample
    pub fn analyze(&self, data: &[u8]) -> Result<StaticAnalysisResult> {
        let id = uuid::Uuid::new_v4().to_string();

        // Parse the binary
        let object = Object::parse(data)?;

        let (pe_info, elf_info, imports, exports) = match object {
            Object::PE(pe) => {
                let pe_info = self.analyze_pe(&pe, data);
                let imports = self.extract_pe_imports(&pe);
                let exports = self.extract_pe_exports(&pe);
                (Some(pe_info), None, imports, exports)
            }
            Object::Elf(elf) => {
                let elf_info = self.analyze_elf(&elf, data);
                let imports = self.extract_elf_imports(&elf);
                let exports = self.extract_elf_exports(&elf);
                (None, Some(elf_info), imports, exports)
            }
            _ => (None, None, vec![], vec![]),
        };

        // Extract strings
        let strings_interesting = self.extract_interesting_strings(data);

        Ok(StaticAnalysisResult {
            id,
            sample_id: String::new(), // Will be set by caller
            pe_info,
            elf_info,
            imports,
            exports,
            strings_interesting,
            yara_matches: vec![],     // Will be populated by YARA engine
            packer_detected: None,     // Will be populated by packer detector
            compiler_detected: None,
            certificates: vec![],      // Will be populated by certificate analyzer
            resources: vec![],         // Will be populated by resource extractor
            suspicious_patterns: vec![], // Will be populated by API pattern analyzer
            created_at: Utc::now(),
        })
    }

    /// Analyze PE file
    fn analyze_pe(&self, pe: &goblin::pe::PE, data: &[u8]) -> PeInfo {
        use goblin::pe::header::*;

        let header = &pe.header;
        let optional_header = header.optional_header.as_ref();

        let machine_type = match header.coff_header.machine {
            COFF_MACHINE_X86 => "x86".to_string(),
            COFF_MACHINE_X86_64 => "x64".to_string(),
            COFF_MACHINE_ARM => "arm".to_string(),
            COFF_MACHINE_ARM64 => "arm64".to_string(),
            m => format!("unknown(0x{:04x})", m),
        };

        let subsystem = optional_header
            .map(|oh| match oh.windows_fields.subsystem {
                1 => "native".to_string(),
                2 => "windows_gui".to_string(),
                3 => "windows_cui".to_string(),
                5 => "os2_cui".to_string(),
                7 => "posix_cui".to_string(),
                9 => "windows_ce_gui".to_string(),
                10 => "efi_application".to_string(),
                _ => "unknown".to_string(),
            })
            .unwrap_or_else(|| "unknown".to_string());

        let timestamp = optional_header
            .map(|_| {
                let ts = header.coff_header.time_date_stamp as i64;
                chrono::DateTime::from_timestamp(ts, 0)
            })
            .flatten();

        let entry_point = optional_header
            .map(|oh| oh.standard_fields.address_of_entry_point as u64)
            .unwrap_or(0);

        let image_base = optional_header
            .map(|oh| oh.windows_fields.image_base)
            .unwrap_or(0);

        let checksum = optional_header
            .map(|oh| oh.windows_fields.check_sum)
            .unwrap_or(0);

        let dll_characteristics = optional_header
            .map(|oh| {
                let wf = &oh.windows_fields;
                let mut chars = vec![];
                let dc = wf.dll_characteristics;
                if dc & 0x0020 != 0 { chars.push("HIGH_ENTROPY_VA".to_string()); }
                if dc & 0x0040 != 0 { chars.push("DYNAMIC_BASE".to_string()); }
                if dc & 0x0080 != 0 { chars.push("FORCE_INTEGRITY".to_string()); }
                if dc & 0x0100 != 0 { chars.push("NX_COMPAT".to_string()); }
                if dc & 0x0200 != 0 { chars.push("NO_ISOLATION".to_string()); }
                if dc & 0x0400 != 0 { chars.push("NO_SEH".to_string()); }
                if dc & 0x0800 != 0 { chars.push("NO_BIND".to_string()); }
                if dc & 0x1000 != 0 { chars.push("APPCONTAINER".to_string()); }
                if dc & 0x2000 != 0 { chars.push("WDM_DRIVER".to_string()); }
                if dc & 0x4000 != 0 { chars.push("GUARD_CF".to_string()); }
                if dc & 0x8000 != 0 { chars.push("TERMINAL_SERVER_AWARE".to_string()); }
                chars
            })
            .unwrap_or_default();

        let sections: Vec<SectionInfo> = pe.sections.iter().map(|section| {
            let name = String::from_utf8_lossy(&section.name)
                .trim_end_matches('\0')
                .to_string();

            let section_data = if section.pointer_to_raw_data as usize + section.size_of_raw_data as usize <= data.len() {
                &data[section.pointer_to_raw_data as usize..
                      section.pointer_to_raw_data as usize + section.size_of_raw_data as usize]
            } else {
                &[]
            };

            let entropy = SampleStore::compute_entropy(section_data);
            let md5 = compute_md5(section_data);

            let mut chars = vec![];
            let c = section.characteristics;
            if c & 0x00000020 != 0 { chars.push("CODE".to_string()); }
            if c & 0x00000040 != 0 { chars.push("INITIALIZED_DATA".to_string()); }
            if c & 0x00000080 != 0 { chars.push("UNINITIALIZED_DATA".to_string()); }
            if c & 0x20000000 != 0 { chars.push("EXECUTE".to_string()); }
            if c & 0x40000000 != 0 { chars.push("READ".to_string()); }
            if c & 0x80000000 != 0 { chars.push("WRITE".to_string()); }

            SectionInfo {
                name,
                virtual_address: section.virtual_address as u64,
                virtual_size: section.virtual_size as u64,
                raw_size: section.size_of_raw_data as u64,
                entropy,
                characteristics: chars,
                md5,
            }
        }).collect();

        let is_dll = header.coff_header.characteristics & 0x2000 != 0;

        // Check for .NET
        let is_dotnet = pe.sections.iter().any(|s| {
            let name = String::from_utf8_lossy(&s.name);
            name.contains(".cormeta") || name.contains(".rsrc")
        }) && pe.imports.iter().any(|import| {
            import.name.to_lowercase().contains("mscoree")
        });

        PeInfo {
            machine_type,
            subsystem,
            timestamp,
            entry_point,
            image_base,
            checksum,
            dll_characteristics,
            sections,
            rich_header: None, // Rich header parsing would go here
            debug_info: None,  // Debug info parsing would go here
            tls_callbacks: vec![],
            is_dll,
            is_dotnet,
        }
    }

    /// Analyze ELF file
    fn analyze_elf(&self, elf: &goblin::elf::Elf, data: &[u8]) -> ElfInfo {
        use goblin::elf::header::*;

        let machine_type = match elf.header.e_machine {
            EM_386 => "x86".to_string(),
            EM_X86_64 => "x86_64".to_string(),
            EM_ARM => "arm".to_string(),
            EM_AARCH64 => "aarch64".to_string(),
            EM_MIPS => "mips".to_string(),
            EM_PPC => "ppc".to_string(),
            EM_PPC64 => "ppc64".to_string(),
            m => format!("unknown({})", m),
        };

        let elf_type = match elf.header.e_type {
            ET_NONE => "none".to_string(),
            ET_REL => "relocatable".to_string(),
            ET_EXEC => "executable".to_string(),
            ET_DYN => "shared_object".to_string(),
            ET_CORE => "core".to_string(),
            _ => "unknown".to_string(),
        };

        let os_abi = match elf.header.e_ident[EI_OSABI] {
            ELFOSABI_NONE | ELFOSABI_SYSV => "SYSV".to_string(),
            ELFOSABI_HPUX => "HP-UX".to_string(),
            ELFOSABI_NETBSD => "NetBSD".to_string(),
            ELFOSABI_LINUX => "Linux".to_string(),
            ELFOSABI_SOLARIS => "Solaris".to_string(),
            ELFOSABI_FREEBSD => "FreeBSD".to_string(),
            _ => "unknown".to_string(),
        };

        let sections: Vec<SectionInfo> = elf.section_headers.iter().map(|section| {
            let name = elf.shdr_strtab.get_at(section.sh_name).unwrap_or("").to_string();

            let section_data = if section.sh_offset as usize + section.sh_size as usize <= data.len() {
                &data[section.sh_offset as usize..section.sh_offset as usize + section.sh_size as usize]
            } else {
                &[]
            };

            let entropy = SampleStore::compute_entropy(section_data);
            let md5 = compute_md5(section_data);

            let mut chars = vec![];
            if section.sh_flags & 0x1 != 0 { chars.push("WRITE".to_string()); }
            if section.sh_flags & 0x2 != 0 { chars.push("ALLOC".to_string()); }
            if section.sh_flags & 0x4 != 0 { chars.push("EXECINSTR".to_string()); }

            SectionInfo {
                name,
                virtual_address: section.sh_addr,
                virtual_size: section.sh_size,
                raw_size: section.sh_size,
                entropy,
                characteristics: chars,
                md5,
            }
        }).collect();

        let symbols: Vec<String> = elf.syms.iter()
            .filter_map(|sym| {
                elf.strtab.get_at(sym.st_name).map(|s| s.to_string())
            })
            .filter(|s| !s.is_empty())
            .take(1000) // Limit to prevent huge outputs
            .collect();

        let dynamic_libs: Vec<String> = elf.libraries.iter()
            .map(|s| s.to_string())
            .collect();

        let is_stripped = symbols.is_empty() || symbols.len() < 10;
        let has_debug = elf.section_headers.iter().any(|s| {
            let name = elf.shdr_strtab.get_at(s.sh_name).unwrap_or("");
            name.starts_with(".debug") || name == ".symtab"
        });

        // Check security features
        let security_features = self.check_elf_security_features(elf);

        ElfInfo {
            machine_type,
            elf_type,
            entry_point: elf.entry,
            os_abi,
            sections,
            symbols,
            dynamic_libs,
            is_stripped,
            has_debug,
            security_features,
        }
    }

    /// Check ELF security features
    fn check_elf_security_features(&self, elf: &goblin::elf::Elf) -> SecurityFeatures {
        // Check for PIE
        let pie = elf.header.e_type == goblin::elf::header::ET_DYN;

        // Check RELRO
        let relro = if elf.program_headers.iter().any(|ph| ph.p_type == goblin::elf::program_header::PT_GNU_RELRO) {
            if elf.dynamic.as_ref().map_or(false, |d| {
                d.dyns.iter().any(|dyn_entry| dyn_entry.d_tag == goblin::elf::dynamic::DT_BIND_NOW)
            }) {
                "full".to_string()
            } else {
                "partial".to_string()
            }
        } else {
            "none".to_string()
        };

        // Check for stack canary (look for __stack_chk_fail)
        let stack_canary = elf.syms.iter().any(|sym| {
            elf.strtab.get_at(sym.st_name).map_or(false, |s| s.contains("__stack_chk_fail"))
        });

        // Check NX (no execute stack)
        let nx = elf.program_headers.iter()
            .find(|ph| ph.p_type == goblin::elf::program_header::PT_GNU_STACK)
            .map_or(true, |ph| ph.p_flags & 1 == 0); // Check if execute bit is NOT set

        // Check for FORTIFY
        let fortify = elf.syms.iter().any(|sym| {
            elf.strtab.get_at(sym.st_name).map_or(false, |s| s.contains("__fortify_fail"))
        });

        // Check RPATH/RUNPATH
        let rpath = elf.dynamic.as_ref().and_then(|d| {
            d.dyns.iter().find(|dyn_entry| dyn_entry.d_tag == goblin::elf::dynamic::DT_RPATH)
                .map(|_| "present".to_string())
        });

        let runpath = elf.dynamic.as_ref().and_then(|d| {
            d.dyns.iter().find(|dyn_entry| dyn_entry.d_tag == goblin::elf::dynamic::DT_RUNPATH)
                .map(|_| "present".to_string())
        });

        SecurityFeatures {
            pie,
            relro,
            stack_canary,
            nx,
            fortify,
            rpath,
            runpath,
        }
    }

    /// Extract PE imports
    fn extract_pe_imports(&self, pe: &goblin::pe::PE) -> Vec<ImportInfo> {
        // Group imports by DLL
        let mut imports_by_dll: HashMap<String, Vec<String>> = HashMap::new();
        for import in &pe.imports {
            let dll = import.dll.to_string();
            let func_name = import.name.to_string();
            imports_by_dll.entry(dll).or_default().push(func_name);
        }

        imports_by_dll.into_iter().map(|(library, functions)| {
            ImportInfo {
                library,
                functions,
                is_delayed: false,
            }
        }).collect()
    }

    /// Extract PE exports
    fn extract_pe_exports(&self, pe: &goblin::pe::PE) -> Vec<ExportInfo> {
        pe.exports.iter().enumerate().map(|(i, export)| {
            ExportInfo {
                name: export.name.unwrap_or("ordinal").to_string(),
                ordinal: (i + 1) as u32, // Use index as ordinal approximation
                address: export.rva as u64,
                forwarded_to: None,
            }
        }).collect()
    }

    /// Extract ELF imports (dynamic symbols)
    fn extract_elf_imports(&self, elf: &goblin::elf::Elf) -> Vec<ImportInfo> {
        let mut imports_by_lib: HashMap<String, Vec<String>> = HashMap::new();

        // Group imported symbols by library
        for lib in &elf.libraries {
            imports_by_lib.insert(lib.to_string(), vec![]);
        }

        // Add symbols that are undefined (imports)
        for sym in elf.dynsyms.iter() {
            if sym.is_import() {
                if let Some(name) = elf.dynstrtab.get_at(sym.st_name) {
                    if !name.is_empty() {
                        // For now, add to first library (simplified)
                        if let Some(lib) = elf.libraries.first() {
                            imports_by_lib.entry(lib.to_string())
                                .or_default()
                                .push(name.to_string());
                        }
                    }
                }
            }
        }

        imports_by_lib.into_iter().map(|(library, functions)| {
            ImportInfo {
                library,
                functions,
                is_delayed: false,
            }
        }).collect()
    }

    /// Extract ELF exports
    fn extract_elf_exports(&self, elf: &goblin::elf::Elf) -> Vec<ExportInfo> {
        elf.dynsyms.iter()
            .filter(|sym| !sym.is_import() && sym.st_value != 0)
            .filter_map(|sym| {
                elf.dynstrtab.get_at(sym.st_name).map(|name| {
                    ExportInfo {
                        name: name.to_string(),
                        ordinal: 0,
                        address: sym.st_value,
                        forwarded_to: None,
                    }
                })
            })
            .take(1000) // Limit
            .collect()
    }

    /// Extract interesting strings from binary
    fn extract_interesting_strings(&self, data: &[u8]) -> Vec<InterestingString> {
        let mut strings = vec![];
        let min_length = 4;
        let max_strings = 500;

        // Extract ASCII strings
        let mut current_string = Vec::new();
        let mut start_offset = 0;

        for (i, &byte) in data.iter().enumerate() {
            if byte >= 0x20 && byte < 0x7f {
                if current_string.is_empty() {
                    start_offset = i;
                }
                current_string.push(byte);
            } else {
                if current_string.len() >= min_length {
                    let s = String::from_utf8_lossy(&current_string).to_string();
                    if let Some(interesting) = self.categorize_string(&s, start_offset as u64, StringEncoding::Ascii) {
                        strings.push(interesting);
                        if strings.len() >= max_strings {
                            break;
                        }
                    }
                }
                current_string.clear();
            }
        }

        // Handle trailing string
        if current_string.len() >= min_length && strings.len() < max_strings {
            let s = String::from_utf8_lossy(&current_string).to_string();
            if let Some(interesting) = self.categorize_string(&s, start_offset as u64, StringEncoding::Ascii) {
                strings.push(interesting);
            }
        }

        // Extract UTF-16LE strings
        if strings.len() < max_strings && data.len() >= 4 {
            let mut i = 0;
            while i + 1 < data.len() && strings.len() < max_strings {
                let mut utf16_chars = Vec::new();
                let string_start = i;

                while i + 1 < data.len() {
                    let char_val = u16::from_le_bytes([data[i], data[i + 1]]);
                    if char_val >= 0x20 && char_val < 0x7f {
                        utf16_chars.push(char_val);
                        i += 2;
                    } else {
                        break;
                    }
                }

                if utf16_chars.len() >= min_length {
                    let s: String = utf16_chars.iter()
                        .filter_map(|&c| char::from_u32(c as u32))
                        .collect();

                    if let Some(interesting) = self.categorize_string(&s, string_start as u64, StringEncoding::Utf16Le) {
                        strings.push(interesting);
                    }
                }

                i += 2;
            }
        }

        strings
    }

    /// Categorize a string
    fn categorize_string(&self, s: &str, offset: u64, encoding: StringEncoding) -> Option<InterestingString> {
        let trimmed = s.trim();
        if trimmed.len() < 4 {
            return None;
        }

        let category = self.determine_string_category(trimmed);

        // Filter out uninteresting strings
        match category {
            StringCategory::Other => {
                // Only include "other" if it looks suspicious or meaningful
                if trimmed.len() < 8 || !trimmed.chars().any(|c| c.is_alphabetic()) {
                    return None;
                }
            }
            _ => {}
        }

        Some(InterestingString {
            value: trimmed.to_string(),
            offset,
            encoding,
            category,
            section: None,
        })
    }

    /// Determine the category of a string
    fn determine_string_category(&self, s: &str) -> StringCategory {
        let lower = s.to_lowercase();

        // URL pattern
        if s.starts_with("http://") || s.starts_with("https://") || s.starts_with("ftp://") {
            return StringCategory::Url;
        }

        // IP address pattern
        if self.is_ip_address(s) {
            return StringCategory::Ip;
        }

        // Domain pattern
        if self.looks_like_domain(s) {
            return StringCategory::Domain;
        }

        // Email pattern
        if s.contains('@') && s.contains('.') && !s.contains(' ') {
            return StringCategory::Email;
        }

        // File path patterns
        if s.starts_with("C:\\") || s.starts_with("/") || s.contains(":\\") || s.contains("\\\\") {
            return StringCategory::FilePath;
        }

        // Registry patterns
        if lower.starts_with("hkey_") || lower.contains("\\software\\") || lower.contains("\\currentversion\\") {
            return StringCategory::Registry;
        }

        // Command patterns
        if lower.contains("cmd.exe") || lower.contains("powershell") || lower.contains("/bin/sh")
            || lower.contains("system32") || s.starts_with("-") && s.len() < 20 {
            return StringCategory::Command;
        }

        // Crypto-related
        if lower.contains("aes") || lower.contains("rsa") || lower.contains("encrypt")
            || lower.contains("decrypt") || lower.contains("cipher") || lower.contains("key") {
            return StringCategory::Crypto;
        }

        // Debug strings
        if lower.contains("debug") || lower.contains("assert") || lower.contains("trace") {
            return StringCategory::Debug;
        }

        // Error strings
        if lower.contains("error") || lower.contains("failed") || lower.contains("exception") {
            return StringCategory::Error;
        }

        // Network-related
        if lower.contains("socket") || lower.contains("connect") || lower.contains("recv")
            || lower.contains("send") || lower.contains("http") || lower.contains("proxy") {
            return StringCategory::Network;
        }

        // Suspicious keywords
        if lower.contains("password") || lower.contains("credential") || lower.contains("admin")
            || lower.contains("inject") || lower.contains("hook") || lower.contains("keylog")
            || lower.contains("ransom") || lower.contains("bitcoin") || lower.contains("wallet")
            || lower.contains("decrypt") || lower.contains("victim") {
            return StringCategory::Suspicious;
        }

        StringCategory::Other
    }

    /// Check if string is an IP address
    fn is_ip_address(&self, s: &str) -> bool {
        // IPv4 pattern
        let parts: Vec<&str> = s.split('.').collect();
        if parts.len() == 4 {
            if parts.iter().all(|p| p.parse::<u8>().is_ok()) {
                return true;
            }
        }

        // IPv6 pattern (simplified check)
        if s.contains(':') && s.chars().all(|c| c.is_ascii_hexdigit() || c == ':') {
            return true;
        }

        false
    }

    /// Check if string looks like a domain
    fn looks_like_domain(&self, s: &str) -> bool {
        if s.len() < 4 || s.len() > 253 {
            return false;
        }

        let parts: Vec<&str> = s.split('.').collect();
        if parts.len() < 2 {
            return false;
        }

        // Check TLD
        let tld = parts.last().unwrap();
        if tld.len() < 2 || tld.len() > 6 {
            return false;
        }

        // Check if all parts are valid
        parts.iter().all(|p| {
            !p.is_empty() && p.chars().all(|c| c.is_alphanumeric() || c == '-')
        })
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_string_categorization() {
        let store = SampleStore::from_env().unwrap();
        let analyzer = StaticAnalyzer::new(store);

        assert_eq!(
            analyzer.determine_string_category("http://malware.com/payload"),
            StringCategory::Url
        );
        assert_eq!(
            analyzer.determine_string_category("192.168.1.1"),
            StringCategory::Ip
        );
        assert_eq!(
            analyzer.determine_string_category("C:\\Windows\\System32\\cmd.exe"),
            StringCategory::FilePath
        );
    }
}
