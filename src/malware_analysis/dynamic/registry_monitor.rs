//! Registry Monitoring Module (Windows)
//!
//! Analyzes Windows registry operations including:
//! - Registry key/value modifications
//! - Persistence mechanism detection
//! - Configuration changes
//! - Defense evasion techniques

use super::types::*;
use super::RawRegistryOperation;
use std::collections::{HashMap, HashSet};

/// Registry operation analyzer
pub struct RegistryMonitor {
    /// Persistence registry paths
    persistence_paths: Vec<PersistencePath>,
    /// Sensitive registry keys
    sensitive_keys: Vec<SensitiveKey>,
    /// Known malware registry indicators
    malware_indicators: Vec<MalwareRegistryIndicator>,
}

#[derive(Debug, Clone)]
struct PersistencePath {
    pattern: String,
    persistence_type: PersistenceType,
    description: String,
    mitre_technique: String,
}

#[derive(Debug, Clone)]
struct SensitiveKey {
    pattern: String,
    description: String,
    severity: BehaviorSeverity,
}

#[derive(Debug, Clone)]
struct MalwareRegistryIndicator {
    key_pattern: String,
    value_pattern: Option<String>,
    malware_family: String,
}

impl RegistryMonitor {
    pub fn new() -> Self {
        Self {
            persistence_paths: get_persistence_paths(),
            sensitive_keys: get_sensitive_keys(),
            malware_indicators: get_malware_indicators(),
        }
    }

    /// Analyze raw registry operations
    pub fn analyze_registry_ops(&self, raw_ops: &[RawRegistryOperation]) -> Vec<RegistryOperation> {
        raw_ops
            .iter()
            .map(|op| self.analyze_operation(op))
            .collect()
    }

    fn analyze_operation(&self, op: &RawRegistryOperation) -> RegistryOperation {
        let operation_type = self.parse_operation_type(&op.operation);
        let value_type = op.value_type.as_ref().map(|t| self.parse_value_type(t));
        let is_persistence = self.check_persistence(&op.key_path, &operation_type);
        let (is_suspicious, suspicion_reason) = self.check_suspicious(
            &op.key_path,
            &op.value_name,
            &op.value_data,
            &operation_type,
        );

        RegistryOperation {
            id: uuid::Uuid::new_v4().to_string(),
            timestamp: op.timestamp,
            pid: op.pid,
            process_name: op.process_name.clone(),
            operation_type,
            key_path: op.key_path.clone(),
            value_name: op.value_name.clone(),
            value_type,
            value_data: op.value_data.clone(),
            is_persistence,
            is_suspicious: is_suspicious || is_persistence,
            suspicion_reason: if is_persistence && suspicion_reason.is_none() {
                Some("Persistence mechanism modification".to_string())
            } else {
                suspicion_reason
            },
        }
    }

    fn parse_operation_type(&self, operation: &str) -> RegistryOperationType {
        match operation.to_lowercase().as_str() {
            "createkey" | "regcreatekey" | "regcreatekeyex" | "ntcreatekey" => {
                RegistryOperationType::CreateKey
            }
            "openkey" | "regopenkey" | "regopenkeyex" | "ntopenkey" => {
                RegistryOperationType::OpenKey
            }
            "deletekey" | "regdeletekey" | "regdeletekeyex" | "ntdeletekey" => {
                RegistryOperationType::DeleteKey
            }
            "setvalue" | "regsetvalue" | "regsetvalueex" | "ntsetvaluekey" => {
                RegistryOperationType::SetValue
            }
            "deletevalue" | "regdeletevalue" | "ntdeletevaluekey" => {
                RegistryOperationType::DeleteValue
            }
            "querykey" | "regquerykey" | "ntquerykey" => RegistryOperationType::QueryKey,
            "queryvalue" | "regqueryvalue" | "regqueryvalueex" | "ntqueryvaluekey" => {
                RegistryOperationType::QueryValue
            }
            "enumkey" | "regenumkey" | "regenumkeyex" | "ntenumeratekey" => {
                RegistryOperationType::EnumerateKey
            }
            "enumvalue" | "regenumvalue" | "ntenumeratevaluekey" => {
                RegistryOperationType::EnumerateValue
            }
            _ => RegistryOperationType::QueryKey,
        }
    }

    fn parse_value_type(&self, value_type: &str) -> RegistryValueType {
        match value_type.to_uppercase().as_str() {
            "REG_SZ" | "SZ" | "STRING" => RegistryValueType::String,
            "REG_EXPAND_SZ" | "EXPAND_SZ" => RegistryValueType::ExpandString,
            "REG_BINARY" | "BINARY" => RegistryValueType::Binary,
            "REG_DWORD" | "DWORD" => RegistryValueType::Dword,
            "REG_QWORD" | "QWORD" => RegistryValueType::Qword,
            "REG_MULTI_SZ" | "MULTI_SZ" => RegistryValueType::MultiString,
            "REG_LINK" | "LINK" => RegistryValueType::Link,
            "REG_NONE" | "NONE" => RegistryValueType::None,
            _ => RegistryValueType::Unknown,
        }
    }

    fn check_persistence(&self, key_path: &str, operation: &RegistryOperationType) -> bool {
        // Only check for modifications
        if !matches!(
            operation,
            RegistryOperationType::SetValue
                | RegistryOperationType::CreateKey
                | RegistryOperationType::DeleteKey
                | RegistryOperationType::DeleteValue
        ) {
            return false;
        }

        let key_lower = key_path.to_lowercase();
        for persistence in &self.persistence_paths {
            if key_lower.contains(&persistence.pattern.to_lowercase()) {
                return true;
            }
        }
        false
    }

    fn check_suspicious(
        &self,
        key_path: &str,
        value_name: &Option<String>,
        value_data: &Option<String>,
        operation: &RegistryOperationType,
    ) -> (bool, Option<String>) {
        let key_lower = key_path.to_lowercase();

        // Check sensitive keys
        for sensitive in &self.sensitive_keys {
            if key_lower.contains(&sensitive.pattern.to_lowercase()) {
                return (true, Some(sensitive.description.clone()));
            }
        }

        // Check for known malware indicators
        for indicator in &self.malware_indicators {
            if key_lower.contains(&indicator.key_pattern.to_lowercase()) {
                if let Some(ref value_pattern) = indicator.value_pattern {
                    if let Some(ref data) = value_data {
                        if data.to_lowercase().contains(&value_pattern.to_lowercase()) {
                            return (
                                true,
                                Some(format!(
                                    "Known {} registry indicator",
                                    indicator.malware_family
                                )),
                            );
                        }
                    }
                } else {
                    return (
                        true,
                        Some(format!(
                            "Known {} registry indicator",
                            indicator.malware_family
                        )),
                    );
                }
            }
        }

        // Check for suspicious patterns in value data
        if let Some(ref data) = value_data {
            let data_lower = data.to_lowercase();

            // Check for encoded commands
            if data_lower.contains("-enc") || data_lower.contains("-encodedcommand") {
                return (true, Some("Encoded PowerShell command in registry".to_string()));
            }

            // Check for suspicious executables
            if data_lower.contains("powershell") && matches!(operation, RegistryOperationType::SetValue) {
                return (true, Some("PowerShell execution in registry value".to_string()));
            }

            // Check for rundll32/regsvr32 abuse
            if (data_lower.contains("rundll32") || data_lower.contains("regsvr32"))
                && data_lower.contains("javascript:")
            {
                return (true, Some("Script execution via system binary".to_string()));
            }

            // Check for mshta abuse
            if data_lower.contains("mshta") && data_lower.contains("vbscript:") {
                return (true, Some("MSHTA script execution".to_string()));
            }
        }

        // Check for DisableAntiSpyware-like modifications
        if key_lower.contains("windows defender") || key_lower.contains("security center") {
            if matches!(operation, RegistryOperationType::SetValue | RegistryOperationType::DeleteKey) {
                return (true, Some("Security software configuration change".to_string()));
            }
        }

        // Check for UAC bypass attempts
        if key_lower.contains("policies\\system") {
            if let Some(ref name) = value_name {
                let name_lower = name.to_lowercase();
                if name_lower.contains("enablelua") || name_lower.contains("consentprompt") {
                    return (true, Some("UAC configuration modification".to_string()));
                }
            }
        }

        (false, None)
    }

    /// Detect persistence locations
    pub fn detect_persistence(&self, operations: &[RegistryOperation]) -> Vec<PersistenceLocation> {
        let mut locations = Vec::new();

        for op in operations {
            if !op.is_persistence {
                continue;
            }

            // Find matching persistence type
            let key_lower = op.key_path.to_lowercase();
            for persistence in &self.persistence_paths {
                if key_lower.contains(&persistence.pattern.to_lowercase()) {
                    locations.push(PersistenceLocation {
                        id: uuid::Uuid::new_v4().to_string(),
                        persistence_type: persistence.persistence_type.clone(),
                        location: op.key_path.clone(),
                        value: op.value_data.clone().unwrap_or_default(),
                        detected_at: op.timestamp,
                        pid: op.pid,
                        process_name: op.process_name.clone(),
                    });
                    break;
                }
            }
        }

        locations
    }

    /// Get registry operation statistics
    pub fn get_statistics(&self, operations: &[RegistryOperation]) -> RegistryStatistics {
        let mut operation_counts: HashMap<RegistryOperationType, usize> = HashMap::new();
        let mut hive_counts: HashMap<String, usize> = HashMap::new();
        let mut persistence_count = 0;
        let mut suspicious_count = 0;

        for op in operations {
            *operation_counts.entry(op.operation_type.clone()).or_insert(0) += 1;

            // Extract hive
            let hive = op.key_path.split(['\\', '/']).next().unwrap_or("unknown");
            *hive_counts.entry(hive.to_uppercase()).or_insert(0) += 1;

            if op.is_persistence {
                persistence_count += 1;
            }
            if op.is_suspicious {
                suspicious_count += 1;
            }
        }

        let modified_keys: HashSet<_> = operations
            .iter()
            .filter(|op| matches!(
                op.operation_type,
                RegistryOperationType::SetValue
                    | RegistryOperationType::CreateKey
                    | RegistryOperationType::DeleteKey
                    | RegistryOperationType::DeleteValue
            ))
            .map(|op| &op.key_path)
            .collect();

        RegistryStatistics {
            total_operations: operations.len(),
            operation_distribution: operation_counts,
            hive_distribution: hive_counts,
            persistence_modifications: persistence_count,
            suspicious_operations: suspicious_count,
            unique_keys_modified: modified_keys.len(),
        }
    }
}

impl Default for RegistryMonitor {
    fn default() -> Self {
        Self::new()
    }
}

#[derive(Debug, Clone)]
pub struct RegistryStatistics {
    pub total_operations: usize,
    pub operation_distribution: HashMap<RegistryOperationType, usize>,
    pub hive_distribution: HashMap<String, usize>,
    pub persistence_modifications: usize,
    pub suspicious_operations: usize,
    pub unique_keys_modified: usize,
}

// Helper functions

fn get_persistence_paths() -> Vec<PersistencePath> {
    vec![
        // Run keys
        PersistencePath {
            pattern: "\\software\\microsoft\\windows\\currentversion\\run".to_string(),
            persistence_type: PersistenceType::RegistryRun,
            description: "Run key persistence".to_string(),
            mitre_technique: "T1547.001".to_string(),
        },
        PersistencePath {
            pattern: "\\software\\microsoft\\windows\\currentversion\\runonce".to_string(),
            persistence_type: PersistenceType::RegistryRunOnce,
            description: "RunOnce key persistence".to_string(),
            mitre_technique: "T1547.001".to_string(),
        },
        PersistencePath {
            pattern: "\\software\\wow6432node\\microsoft\\windows\\currentversion\\run".to_string(),
            persistence_type: PersistenceType::RegistryRun,
            description: "Run key persistence (WoW64)".to_string(),
            mitre_technique: "T1547.001".to_string(),
        },

        // Services
        PersistencePath {
            pattern: "\\system\\currentcontrolset\\services".to_string(),
            persistence_type: PersistenceType::RegistryServices,
            description: "Service registration".to_string(),
            mitre_technique: "T1543.003".to_string(),
        },

        // Winlogon
        PersistencePath {
            pattern: "\\software\\microsoft\\windows nt\\currentversion\\winlogon".to_string(),
            persistence_type: PersistenceType::Winlogon,
            description: "Winlogon persistence".to_string(),
            mitre_technique: "T1547.004".to_string(),
        },

        // AppInit_DLLs
        PersistencePath {
            pattern: "\\software\\microsoft\\windows nt\\currentversion\\windows\\appinit_dlls".to_string(),
            persistence_type: PersistenceType::AppInit,
            description: "AppInit_DLLs injection".to_string(),
            mitre_technique: "T1546.010".to_string(),
        },

        // LSA
        PersistencePath {
            pattern: "\\system\\currentcontrolset\\control\\lsa".to_string(),
            persistence_type: PersistenceType::Lsa,
            description: "LSA persistence".to_string(),
            mitre_technique: "T1547.002".to_string(),
        },

        // Boot Execute
        PersistencePath {
            pattern: "\\system\\currentcontrolset\\control\\session manager\\bootexecute".to_string(),
            persistence_type: PersistenceType::BootExecute,
            description: "Boot Execute persistence".to_string(),
            mitre_technique: "T1547.012".to_string(),
        },

        // Shell extensions
        PersistencePath {
            pattern: "\\software\\classes\\clsid".to_string(),
            persistence_type: PersistenceType::ShellExtension,
            description: "Shell extension/COM hijacking".to_string(),
            mitre_technique: "T1546.015".to_string(),
        },

        // Startup approved
        PersistencePath {
            pattern: "\\software\\microsoft\\windows\\currentversion\\explorer\\startupapproved".to_string(),
            persistence_type: PersistenceType::StartupFolder,
            description: "Startup approval modification".to_string(),
            mitre_technique: "T1547.001".to_string(),
        },

        // Image File Execution Options (debugger persistence)
        PersistencePath {
            pattern: "\\software\\microsoft\\windows nt\\currentversion\\image file execution options".to_string(),
            persistence_type: PersistenceType::Other,
            description: "Image File Execution Options hijacking".to_string(),
            mitre_technique: "T1546.012".to_string(),
        },

        // Scheduled tasks (registry)
        PersistencePath {
            pattern: "\\software\\microsoft\\windows nt\\currentversion\\schedule\\taskcache".to_string(),
            persistence_type: PersistenceType::ScheduledTask,
            description: "Scheduled task modification".to_string(),
            mitre_technique: "T1053.005".to_string(),
        },

        // Browser extensions
        PersistencePath {
            pattern: "\\software\\google\\chrome\\extensions".to_string(),
            persistence_type: PersistenceType::BrowserExtension,
            description: "Chrome extension persistence".to_string(),
            mitre_technique: "T1176".to_string(),
        },
        PersistencePath {
            pattern: "\\software\\mozilla\\firefox\\extensions".to_string(),
            persistence_type: PersistenceType::BrowserExtension,
            description: "Firefox extension persistence".to_string(),
            mitre_technique: "T1176".to_string(),
        },

        // Office add-ins
        PersistencePath {
            pattern: "\\software\\microsoft\\office".to_string(),
            persistence_type: PersistenceType::OfficeAddin,
            description: "Office add-in persistence".to_string(),
            mitre_technique: "T1137".to_string(),
        },
    ]
}

fn get_sensitive_keys() -> Vec<SensitiveKey> {
    vec![
        // Security settings
        SensitiveKey {
            pattern: "windows defender".to_string(),
            description: "Windows Defender configuration".to_string(),
            severity: BehaviorSeverity::High,
        },
        SensitiveKey {
            pattern: "disableantispy".to_string(),
            description: "Anti-spyware disable attempt".to_string(),
            severity: BehaviorSeverity::Critical,
        },
        SensitiveKey {
            pattern: "security center".to_string(),
            description: "Security Center modification".to_string(),
            severity: BehaviorSeverity::High,
        },

        // Firewall
        SensitiveKey {
            pattern: "firewall".to_string(),
            description: "Firewall configuration".to_string(),
            severity: BehaviorSeverity::High,
        },

        // UAC
        SensitiveKey {
            pattern: "policies\\system".to_string(),
            description: "System policy modification".to_string(),
            severity: BehaviorSeverity::High,
        },

        // Terminal Services
        SensitiveKey {
            pattern: "terminal services".to_string(),
            description: "Remote Desktop configuration".to_string(),
            severity: BehaviorSeverity::Medium,
        },
        SensitiveKey {
            pattern: "\\control\\terminal server".to_string(),
            description: "Terminal Server configuration".to_string(),
            severity: BehaviorSeverity::Medium,
        },

        // Internet settings
        SensitiveKey {
            pattern: "internet settings\\zonemap".to_string(),
            description: "Internet zone mapping".to_string(),
            severity: BehaviorSeverity::Medium,
        },

        // Credential handling
        SensitiveKey {
            pattern: "credentials".to_string(),
            description: "Credential storage access".to_string(),
            severity: BehaviorSeverity::High,
        },

        // PowerShell execution policy
        SensitiveKey {
            pattern: "powershell".to_string(),
            description: "PowerShell configuration".to_string(),
            severity: BehaviorSeverity::Medium,
        },
    ]
}

fn get_malware_indicators() -> Vec<MalwareRegistryIndicator> {
    vec![
        MalwareRegistryIndicator {
            key_pattern: "run".to_string(),
            value_pattern: Some("wscript".to_string()),
            malware_family: "Generic script dropper".to_string(),
        },
        MalwareRegistryIndicator {
            key_pattern: "run".to_string(),
            value_pattern: Some("mshta".to_string()),
            malware_family: "HTA-based malware".to_string(),
        },
        MalwareRegistryIndicator {
            key_pattern: "\\clsid\\".to_string(),
            value_pattern: Some("scrobj.dll".to_string()),
            malware_family: "COM scriptlet".to_string(),
        },
    ]
}
