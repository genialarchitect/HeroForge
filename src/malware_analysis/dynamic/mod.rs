//! Dynamic Malware Analysis Module
//!
//! Provides comprehensive dynamic analysis capabilities including:
//! - Process monitoring and tree tracking
//! - API call hooking and interception patterns
//! - Network activity capture and analysis
//! - File system operation monitoring
//! - Registry operation monitoring (Windows)
//! - Behavior timeline generation
//! - Anti-analysis technique detection
//!
//! This module defines the patterns and analysis logic. Actual execution
//! happens in external sandboxes (Cuckoo, Any.Run, etc.) which provide
//! the raw behavioral data that these modules parse and analyze.

pub mod types;
pub mod process_monitor;
pub mod api_hooks;
pub mod network_capture;
pub mod filesystem_monitor;
pub mod registry_monitor;
pub mod behavior_timeline;
pub mod anti_analysis;

pub use types::*;
pub use process_monitor::ProcessMonitor;
pub use api_hooks::ApiHookAnalyzer;
pub use network_capture::NetworkCaptureAnalyzer;
pub use filesystem_monitor::FilesystemMonitor;
pub use registry_monitor::RegistryMonitor;
pub use behavior_timeline::BehaviorTimelineBuilder;
pub use anti_analysis::AntiAnalysisDetector;

use chrono::Utc;
use serde::{Serialize, Deserialize};
use std::collections::HashMap;

/// Main dynamic analysis orchestrator
pub struct DynamicAnalyzer {
    process_monitor: ProcessMonitor,
    api_analyzer: ApiHookAnalyzer,
    network_analyzer: NetworkCaptureAnalyzer,
    filesystem_monitor: FilesystemMonitor,
    registry_monitor: RegistryMonitor,
    timeline_builder: BehaviorTimelineBuilder,
    anti_analysis_detector: AntiAnalysisDetector,
}

impl DynamicAnalyzer {
    /// Create a new dynamic analyzer instance
    pub fn new() -> Self {
        Self {
            process_monitor: ProcessMonitor::new(),
            api_analyzer: ApiHookAnalyzer::new(),
            network_analyzer: NetworkCaptureAnalyzer::new(),
            filesystem_monitor: FilesystemMonitor::new(),
            registry_monitor: RegistryMonitor::new(),
            timeline_builder: BehaviorTimelineBuilder::new(),
            anti_analysis_detector: AntiAnalysisDetector::new(),
        }
    }

    /// Analyze raw behavioral data from sandbox execution
    pub fn analyze(&self, raw_data: &RawBehavioralData) -> DynamicAnalysisResult {
        // Process all behavioral data
        let processes = self.process_monitor.analyze_processes(&raw_data.processes);
        let api_calls = self.api_analyzer.analyze_api_calls(&raw_data.api_calls);
        let network_activity = self.network_analyzer.analyze_network(&raw_data.network);
        let file_operations = self.filesystem_monitor.analyze_file_ops(&raw_data.file_ops);
        let registry_operations = self.registry_monitor.analyze_registry_ops(&raw_data.registry_ops);
        let mutex_operations = self.analyze_mutex_ops(&raw_data.mutex_ops);
        let dropped_files = self.analyze_dropped_files(&raw_data.dropped_files);

        // Detect anti-analysis techniques
        let anti_analysis = self.anti_analysis_detector.detect_all(
            &api_calls,
            &registry_operations,
            &file_operations,
            &processes,
        );

        // Build behavior timeline
        let timeline = self.timeline_builder.build(
            &processes,
            &api_calls,
            &network_activity,
            &file_operations,
            &registry_operations,
        );

        // Extract IOCs
        let iocs = self.extract_iocs(
            &network_activity,
            &file_operations,
            &registry_operations,
            &dropped_files,
        );

        // Generate verdict
        let verdict = self.generate_verdict(
            &processes,
            &api_calls,
            &network_activity,
            &file_operations,
            &registry_operations,
            &anti_analysis,
            &dropped_files,
        );

        // Calculate threat score
        let threat_score = self.calculate_threat_score(
            &api_calls,
            &network_activity,
            &file_operations,
            &registry_operations,
            &anti_analysis,
            &dropped_files,
        );

        DynamicAnalysisResult {
            id: uuid::Uuid::new_v4().to_string(),
            session_id: raw_data.session_id.clone(),
            sample_id: raw_data.sample_id.clone(),
            processes,
            api_calls,
            network_activity,
            file_operations,
            registry_operations,
            mutex_operations,
            behavior_timeline: timeline,
            dropped_files,
            memory_dumps: raw_data.memory_dumps.clone(),
            screenshots: raw_data.screenshots.clone(),
            anti_analysis_detected: anti_analysis,
            iocs_extracted: iocs,
            verdict,
            threat_score,
            created_at: Utc::now(),
        }
    }

    fn analyze_mutex_ops(&self, raw_mutex_ops: &[RawMutexOperation]) -> Vec<MutexOperation> {
        let known_malware_mutexes = get_known_malware_mutexes();

        raw_mutex_ops
            .iter()
            .map(|op| {
                let known_family = known_malware_mutexes.get(&op.mutex_name.to_lowercase()).cloned();
                MutexOperation {
                    id: uuid::Uuid::new_v4().to_string(),
                    timestamp: op.timestamp,
                    pid: op.pid,
                    process_name: op.process_name.clone(),
                    operation_type: op.operation_type.clone(),
                    mutex_name: op.mutex_name.clone(),
                    is_known_malware: known_family.is_some(),
                    known_malware_family: known_family,
                }
            })
            .collect()
    }

    fn analyze_dropped_files(&self, raw_dropped: &[RawDroppedFile]) -> Vec<DroppedFile> {
        raw_dropped
            .iter()
            .map(|f| DroppedFile {
                id: uuid::Uuid::new_v4().to_string(),
                path: f.path.clone(),
                original_path: f.original_path.clone(),
                filename: f.filename.clone(),
                size: f.size,
                md5: f.md5.clone(),
                sha256: f.sha256.clone(),
                file_type: f.file_type.clone(),
                mime_type: f.mime_type.clone(),
                is_executable: is_executable_extension(&f.filename),
                is_script: is_script_extension(&f.filename),
                dropped_by_pid: f.dropped_by_pid,
                dropped_by_process: f.dropped_by_process.clone(),
                dropped_at: f.dropped_at,
                execution_attempted: f.execution_attempted,
                yara_matches: f.yara_matches.clone(),
            })
            .collect()
    }

    fn extract_iocs(
        &self,
        network: &[NetworkActivity],
        files: &[FileOperation],
        registry: &[RegistryOperation],
        dropped: &[DroppedFile],
    ) -> Vec<DynamicIoc> {
        let mut iocs = Vec::new();
        let now = Utc::now();

        // Extract network IOCs
        for activity in network {
            // C2 candidates
            if !is_private_ip(&activity.remote_address) && activity.remote_port != 80 && activity.remote_port != 443 {
                iocs.push(DynamicIoc {
                    id: uuid::Uuid::new_v4().to_string(),
                    ioc_type: DynamicIocType::C2Server,
                    value: format!("{}:{}", activity.remote_address, activity.remote_port),
                    context: format!("Connection by {}", activity.process_name),
                    source_event_id: activity.id.clone(),
                    confidence: 70,
                    first_seen: activity.timestamp,
                    last_seen: activity.timestamp,
                    occurrence_count: 1,
                });
            }

            // DNS queries
            if let Some(dns) = &activity.dns_query {
                let ioc_type = if dns.is_dga {
                    DynamicIocType::DgaDomain
                } else {
                    DynamicIocType::Domain
                };
                iocs.push(DynamicIoc {
                    id: uuid::Uuid::new_v4().to_string(),
                    ioc_type,
                    value: dns.query_name.clone(),
                    context: format!("DNS query by {}", activity.process_name),
                    source_event_id: activity.id.clone(),
                    confidence: if dns.is_dga { 90 } else { 50 },
                    first_seen: activity.timestamp,
                    last_seen: activity.timestamp,
                    occurrence_count: 1,
                });
            }

            // HTTP User agents
            if let Some(http) = &activity.http_request {
                if let Some(ua) = &http.user_agent {
                    iocs.push(DynamicIoc {
                        id: uuid::Uuid::new_v4().to_string(),
                        ioc_type: DynamicIocType::UserAgent,
                        value: ua.clone(),
                        context: format!("HTTP request to {}", http.host),
                        source_event_id: activity.id.clone(),
                        confidence: 60,
                        first_seen: activity.timestamp,
                        last_seen: activity.timestamp,
                        occurrence_count: 1,
                    });
                }

                // URLs
                iocs.push(DynamicIoc {
                    id: uuid::Uuid::new_v4().to_string(),
                    ioc_type: DynamicIocType::Url,
                    value: http.url.clone(),
                    context: format!("{} request by {}", http.method, activity.process_name),
                    source_event_id: activity.id.clone(),
                    confidence: 70,
                    first_seen: activity.timestamp,
                    last_seen: activity.timestamp,
                    occurrence_count: 1,
                });
            }

            // JA3 hashes
            if let Some(tls) = &activity.tls_info {
                if let Some(ja3) = &tls.ja3_hash {
                    iocs.push(DynamicIoc {
                        id: uuid::Uuid::new_v4().to_string(),
                        ioc_type: DynamicIocType::Ja3,
                        value: ja3.clone(),
                        context: format!("TLS connection by {}", activity.process_name),
                        source_event_id: activity.id.clone(),
                        confidence: 80,
                        first_seen: activity.timestamp,
                        last_seen: activity.timestamp,
                        occurrence_count: 1,
                    });
                }
            }
        }

        // Extract file IOCs
        for file in files {
            if file.is_suspicious {
                iocs.push(DynamicIoc {
                    id: uuid::Uuid::new_v4().to_string(),
                    ioc_type: DynamicIocType::FilePath,
                    value: file.path.clone(),
                    context: format!("{:?} by {}", file.operation_type, file.process_name),
                    source_event_id: file.id.clone(),
                    confidence: 75,
                    first_seen: file.timestamp,
                    last_seen: file.timestamp,
                    occurrence_count: 1,
                });
            }
        }

        // Extract registry IOCs (persistence)
        for reg in registry {
            if reg.is_persistence || reg.is_suspicious {
                iocs.push(DynamicIoc {
                    id: uuid::Uuid::new_v4().to_string(),
                    ioc_type: DynamicIocType::RegistryKey,
                    value: format!("{}\\{}", reg.key_path, reg.value_name.as_ref().unwrap_or(&String::new())),
                    context: format!("{:?} by {}", reg.operation_type, reg.process_name),
                    source_event_id: reg.id.clone(),
                    confidence: if reg.is_persistence { 90 } else { 70 },
                    first_seen: reg.timestamp,
                    last_seen: reg.timestamp,
                    occurrence_count: 1,
                });
            }
        }

        // Extract dropped file IOCs
        for file in dropped {
            iocs.push(DynamicIoc {
                id: uuid::Uuid::new_v4().to_string(),
                ioc_type: DynamicIocType::DroppedFile,
                value: file.sha256.clone(),
                context: format!("{} dropped at {}", file.filename, file.path),
                source_event_id: file.id.clone(),
                confidence: 85,
                first_seen: file.dropped_at,
                last_seen: file.dropped_at,
                occurrence_count: 1,
            });
        }

        // Deduplicate and aggregate
        deduplicate_iocs(iocs)
    }

    fn generate_verdict(
        &self,
        processes: &[ProcessInfo],
        api_calls: &[ApiCallInfo],
        network: &[NetworkActivity],
        files: &[FileOperation],
        registry: &[RegistryOperation],
        anti_analysis: &[AntiAnalysisTechnique],
        dropped: &[DroppedFile],
    ) -> AnalysisVerdict {
        let mut threat_score: u32 = 0;
        let mut categories: Vec<ThreatCategory> = Vec::new();
        let mut reasons: Vec<String> = Vec::new();

        // Check for process injection
        let injected_procs: Vec<_> = processes.iter().filter(|p| p.is_injected || p.is_hollowed).collect();
        if !injected_procs.is_empty() {
            threat_score += 30;
            reasons.push(format!("{} process(es) with code injection detected", injected_procs.len()));
        }

        // Check suspicious API calls
        let critical_apis: Vec<_> = api_calls.iter().filter(|a| a.severity == ApiSeverity::Critical).collect();
        let high_apis: Vec<_> = api_calls.iter().filter(|a| a.severity == ApiSeverity::High).collect();
        threat_score += (critical_apis.len() * 10 + high_apis.len() * 5) as u32;
        if !critical_apis.is_empty() {
            reasons.push(format!("{} critical API calls detected", critical_apis.len()));
        }

        // Check suspicious network activity
        let suspicious_net: Vec<_> = network.iter().filter(|n| n.is_suspicious).collect();
        threat_score += (suspicious_net.len() * 5) as u32;
        if !suspicious_net.is_empty() {
            reasons.push(format!("{} suspicious network connections", suspicious_net.len()));
        }

        // Check DGA domains
        let dga_domains: Vec<_> = network.iter()
            .filter_map(|n| n.dns_query.as_ref())
            .filter(|d| d.is_dga)
            .collect();
        if !dga_domains.is_empty() {
            threat_score += 25;
            categories.push(ThreatCategory::Botnet);
            reasons.push(format!("{} DGA domains detected", dga_domains.len()));
        }

        // Check persistence
        let persistence: Vec<_> = registry.iter().filter(|r| r.is_persistence).collect();
        if !persistence.is_empty() {
            threat_score += 20;
            reasons.push(format!("{} persistence mechanisms detected", persistence.len()));
        }

        // Check dropped executables
        let dropped_exes: Vec<_> = dropped.iter().filter(|d| d.is_executable).collect();
        if !dropped_exes.is_empty() {
            threat_score += 15;
            reasons.push(format!("{} executable(s) dropped", dropped_exes.len()));
            if dropped_exes.iter().any(|d| d.execution_attempted) {
                categories.push(ThreatCategory::Dropper);
            }
        }

        // Check anti-analysis
        if !anti_analysis.is_empty() {
            threat_score += 10;
            reasons.push(format!("{} anti-analysis techniques detected", anti_analysis.len()));
        }

        // Determine classification
        let classification = if threat_score >= 70 {
            VerdictClassification::Malicious
        } else if threat_score >= 30 {
            VerdictClassification::Suspicious
        } else if threat_score > 0 {
            VerdictClassification::Suspicious
        } else if processes.is_empty() && api_calls.is_empty() {
            VerdictClassification::Inconclusive
        } else {
            VerdictClassification::Clean
        };

        // Categorize threats
        if api_calls.iter().any(|a| a.api_category == ApiCategory::Crypto) {
            if files.iter().any(|f| f.operation_type == FileOperationType::Write) {
                categories.push(ThreatCategory::Ransomware);
            }
        }
        if network.iter().any(|n| n.is_suspicious) && !dga_domains.is_empty() {
            if !categories.contains(&ThreatCategory::Botnet) {
                categories.push(ThreatCategory::Botnet);
            }
        }
        if api_calls.iter().any(|a| a.api_category == ApiCategory::Injection) {
            categories.push(ThreatCategory::Rat);
        }
        if categories.is_empty() && classification == VerdictClassification::Malicious {
            categories.push(ThreatCategory::Trojan);
        }

        let confidence = (threat_score.min(100) as f64) / 100.0;

        let summary = match classification {
            VerdictClassification::Malicious => format!(
                "Sample exhibits malicious behavior with {} threat indicators.",
                reasons.len()
            ),
            VerdictClassification::Suspicious => format!(
                "Sample shows suspicious activity requiring further analysis.",
            ),
            VerdictClassification::Clean => String::from("No malicious behavior detected."),
            VerdictClassification::Inconclusive => String::from("Analysis could not determine behavior. Sample may require longer execution time or different environment."),
        };

        let recommendations = generate_recommendations(&classification, &categories, &reasons);

        AnalysisVerdict {
            classification,
            confidence,
            malware_family: None, // Would require signature matching
            threat_categories: categories,
            summary,
            recommendations,
        }
    }

    fn calculate_threat_score(
        &self,
        api_calls: &[ApiCallInfo],
        network: &[NetworkActivity],
        files: &[FileOperation],
        registry: &[RegistryOperation],
        anti_analysis: &[AntiAnalysisTechnique],
        dropped: &[DroppedFile],
    ) -> u8 {
        let mut score: u32 = 0;

        // API call severity
        for call in api_calls {
            score += match call.severity {
                ApiSeverity::Critical => 10,
                ApiSeverity::High => 5,
                ApiSeverity::Medium => 2,
                ApiSeverity::Low => 1,
                ApiSeverity::Info => 0,
            };
        }

        // Suspicious network
        score += network.iter().filter(|n| n.is_suspicious).count() as u32 * 5;

        // Suspicious files
        score += files.iter().filter(|f| f.is_suspicious).count() as u32 * 3;

        // Registry persistence
        score += registry.iter().filter(|r| r.is_persistence).count() as u32 * 8;
        score += registry.iter().filter(|r| r.is_suspicious && !r.is_persistence).count() as u32 * 3;

        // Anti-analysis
        score += anti_analysis.len() as u32 * 5;

        // Dropped executables
        score += dropped.iter().filter(|d| d.is_executable).count() as u32 * 10;
        score += dropped.iter().filter(|d| d.is_script).count() as u32 * 5;

        score.min(100) as u8
    }
}

impl Default for DynamicAnalyzer {
    fn default() -> Self {
        Self::new()
    }
}

/// Raw behavioral data from sandbox
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RawBehavioralData {
    pub session_id: String,
    pub sample_id: String,
    pub processes: Vec<RawProcess>,
    pub api_calls: Vec<RawApiCall>,
    pub network: Vec<RawNetworkEvent>,
    pub file_ops: Vec<RawFileOperation>,
    pub registry_ops: Vec<RawRegistryOperation>,
    pub mutex_ops: Vec<RawMutexOperation>,
    pub dropped_files: Vec<RawDroppedFile>,
    pub memory_dumps: Vec<MemoryDump>,
    pub screenshots: Vec<Screenshot>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RawProcess {
    pub pid: u32,
    pub parent_pid: u32,
    pub name: String,
    pub path: String,
    pub command_line: String,
    pub username: String,
    pub integrity_level: Option<String>,
    pub started_at: chrono::DateTime<Utc>,
    pub terminated_at: Option<chrono::DateTime<Utc>>,
    pub exit_code: Option<i32>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RawApiCall {
    pub timestamp: chrono::DateTime<Utc>,
    pub pid: u32,
    pub process_name: String,
    pub module: String,
    pub function: String,
    pub arguments: Vec<(String, String, String)>, // (name, type, value)
    pub return_value: String,
    pub stack_trace: Option<Vec<String>>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RawNetworkEvent {
    pub timestamp: chrono::DateTime<Utc>,
    pub pid: u32,
    pub process_name: String,
    pub protocol: String,
    pub local_address: String,
    pub local_port: u16,
    pub remote_address: String,
    pub remote_port: u16,
    pub direction: String,
    pub state: String,
    pub bytes_sent: u64,
    pub bytes_received: u64,
    pub dns_query: Option<String>,
    pub dns_response: Option<Vec<String>>,
    pub http_data: Option<RawHttpData>,
    pub tls_data: Option<RawTlsData>,
    pub payload: Option<Vec<u8>>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RawHttpData {
    pub method: String,
    pub url: String,
    pub host: String,
    pub path: String,
    pub headers: HashMap<String, String>,
    pub body: Option<Vec<u8>>,
    pub response_code: Option<u16>,
    pub response_body: Option<Vec<u8>>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RawTlsData {
    pub version: String,
    pub cipher_suite: String,
    pub server_name: Option<String>,
    pub certificate_chain: Option<Vec<String>>,
    pub ja3: Option<String>,
    pub ja3s: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RawFileOperation {
    pub timestamp: chrono::DateTime<Utc>,
    pub pid: u32,
    pub process_name: String,
    pub operation: String,
    pub path: String,
    pub new_path: Option<String>,
    pub attributes: Option<u32>,
    pub bytes_affected: Option<u64>,
    pub content_preview: Option<Vec<u8>>,
    pub file_hash: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RawRegistryOperation {
    pub timestamp: chrono::DateTime<Utc>,
    pub pid: u32,
    pub process_name: String,
    pub operation: String,
    pub key_path: String,
    pub value_name: Option<String>,
    pub value_type: Option<String>,
    pub value_data: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RawMutexOperation {
    pub timestamp: chrono::DateTime<Utc>,
    pub pid: u32,
    pub process_name: String,
    pub operation_type: MutexOperationType,
    pub mutex_name: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RawDroppedFile {
    pub path: String,
    pub original_path: String,
    pub filename: String,
    pub size: u64,
    pub md5: String,
    pub sha256: String,
    pub file_type: String,
    pub mime_type: Option<String>,
    pub dropped_by_pid: u32,
    pub dropped_by_process: String,
    pub dropped_at: chrono::DateTime<Utc>,
    pub execution_attempted: bool,
    pub yara_matches: Vec<String>,
}

// Helper functions

fn get_known_malware_mutexes() -> HashMap<String, String> {
    let mut mutexes = HashMap::new();
    mutexes.insert("dc_mutex_zxqrwr".to_string(), "DarkComet".to_string());
    mutexes.insert("zxcvbnm_mutex".to_string(), "NanoCore".to_string());
    mutexes.insert("warzone160".to_string(), "Warzone RAT".to_string());
    mutexes.insert("remcos_mutex_inj".to_string(), "Remcos RAT".to_string());
    mutexes.insert("asyncrat_mutex".to_string(), "AsyncRAT".to_string());
    mutexes.insert("njrat_mutex".to_string(), "njRAT".to_string());
    mutexes.insert("quasar_mutex_".to_string(), "Quasar RAT".to_string());
    mutexes.insert("hwid-mtx".to_string(), "Agent Tesla".to_string());
    mutexes.insert("formbook_mutex".to_string(), "FormBook".to_string());
    mutexes.insert("lokibot_mutex".to_string(), "LokiBot".to_string());
    mutexes
}

fn is_executable_extension(filename: &str) -> bool {
    let ext = filename.rsplit('.').next().unwrap_or("").to_lowercase();
    matches!(
        ext.as_str(),
        "exe" | "dll" | "sys" | "scr" | "com" | "pif" | "msi" | "msp"
    )
}

fn is_script_extension(filename: &str) -> bool {
    let ext = filename.rsplit('.').next().unwrap_or("").to_lowercase();
    matches!(
        ext.as_str(),
        "ps1" | "bat" | "cmd" | "vbs" | "js" | "jse" | "wsf" | "wsh" | "hta" | "py" | "sh"
    )
}

fn is_private_ip(ip: &str) -> bool {
    if let Ok(addr) = ip.parse::<std::net::Ipv4Addr>() {
        addr.is_private() || addr.is_loopback() || addr.is_link_local()
    } else {
        false
    }
}

fn deduplicate_iocs(iocs: Vec<DynamicIoc>) -> Vec<DynamicIoc> {
    let mut seen: HashMap<(String, String), DynamicIoc> = HashMap::new();

    for ioc in iocs {
        let key = (format!("{:?}", ioc.ioc_type), ioc.value.clone());
        if let Some(existing) = seen.get_mut(&key) {
            existing.occurrence_count += 1;
            if ioc.first_seen < existing.first_seen {
                existing.first_seen = ioc.first_seen;
            }
            if ioc.last_seen > existing.last_seen {
                existing.last_seen = ioc.last_seen;
            }
        } else {
            seen.insert(key, ioc);
        }
    }

    seen.into_values().collect()
}

fn generate_recommendations(
    classification: &VerdictClassification,
    categories: &[ThreatCategory],
    _reasons: &[String],
) -> Vec<String> {
    let mut recommendations = Vec::new();

    match classification {
        VerdictClassification::Malicious => {
            recommendations.push("Quarantine the sample immediately.".to_string());
            recommendations.push("Check for indicators of compromise on affected systems.".to_string());
            recommendations.push("Block associated IOCs at network and endpoint level.".to_string());

            if categories.contains(&ThreatCategory::Ransomware) {
                recommendations.push("Isolate affected systems from network immediately.".to_string());
                recommendations.push("Preserve system state for forensic analysis.".to_string());
            }
            if categories.contains(&ThreatCategory::Rat) || categories.contains(&ThreatCategory::Backdoor) {
                recommendations.push("Investigate potential data exfiltration.".to_string());
                recommendations.push("Review network logs for C2 communication patterns.".to_string());
            }
            if categories.contains(&ThreatCategory::Stealer) {
                recommendations.push("Reset credentials for affected users.".to_string());
                recommendations.push("Monitor for unauthorized access attempts.".to_string());
            }
        }
        VerdictClassification::Suspicious => {
            recommendations.push("Submit to additional analysis sandboxes.".to_string());
            recommendations.push("Monitor systems where sample was discovered.".to_string());
            recommendations.push("Consider blocking execution pending further analysis.".to_string());
        }
        VerdictClassification::Clean => {
            recommendations.push("No immediate action required.".to_string());
            recommendations.push("Continue monitoring for behavioral changes.".to_string());
        }
        VerdictClassification::Inconclusive => {
            recommendations.push("Re-run analysis with extended timeout.".to_string());
            recommendations.push("Try analysis in different environment configuration.".to_string());
            recommendations.push("Consider manual analysis of the sample.".to_string());
        }
    }

    recommendations
}
