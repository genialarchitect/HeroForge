//! Process Monitoring Module
//!
//! Analyzes process behavior including:
//! - Process tree tracking
//! - Process injection detection
//! - Process hollowing detection
//! - Module loading analysis
//! - Command line analysis

use super::types::*;
use super::{RawProcess, RawApiCall};
use std::collections::{HashMap, HashSet};

/// Process monitoring and analysis
pub struct ProcessMonitor {
    /// Known legitimate process names
    known_legitimate: HashSet<String>,
    /// Suspicious process patterns
    suspicious_patterns: Vec<SuspiciousProcessPattern>,
}

#[derive(Debug, Clone)]
struct SuspiciousProcessPattern {
    pattern: String,
    description: String,
    severity: BehaviorSeverity,
}

impl ProcessMonitor {
    pub fn new() -> Self {
        Self {
            known_legitimate: get_known_legitimate_processes(),
            suspicious_patterns: get_suspicious_process_patterns(),
        }
    }

    /// Analyze raw process data
    pub fn analyze_processes(&self, raw_processes: &[RawProcess]) -> Vec<ProcessInfo> {
        let mut processes = Vec::new();
        let mut pid_to_children: HashMap<u32, Vec<u32>> = HashMap::new();

        // Build parent-child relationships
        for proc in raw_processes {
            pid_to_children
                .entry(proc.parent_pid)
                .or_default()
                .push(proc.pid);
        }

        for proc in raw_processes {
            let children = pid_to_children.get(&proc.pid).cloned().unwrap_or_default();

            processes.push(ProcessInfo {
                pid: proc.pid,
                parent_pid: proc.parent_pid,
                name: proc.name.clone(),
                path: proc.path.clone(),
                command_line: proc.command_line.clone(),
                username: proc.username.clone(),
                integrity_level: proc.integrity_level.clone(),
                is_injected: false, // Will be updated by injection analysis
                is_hollowed: false, // Will be updated by hollowing analysis
                started_at: proc.started_at,
                terminated_at: proc.terminated_at,
                exit_code: proc.exit_code,
                children,
                modules_loaded: Vec::new(), // Will be populated from API calls
            });
        }

        processes
    }

    /// Detect process injection from API calls
    pub fn detect_injection(&self, api_calls: &[RawApiCall], processes: &mut [ProcessInfo]) {
        let injection_indicators: HashSet<u32> = api_calls
            .iter()
            .filter(|call| is_injection_api(&call.function))
            .filter_map(|call| {
                // Try to find target PID from arguments
                extract_target_pid(call)
            })
            .collect();

        for proc in processes.iter_mut() {
            if injection_indicators.contains(&proc.pid) {
                proc.is_injected = true;
            }
        }
    }

    /// Detect process hollowing
    pub fn detect_hollowing(&self, api_calls: &[RawApiCall], processes: &mut [ProcessInfo]) {
        let mut hollowing_candidates: HashMap<u32, HollowingState> = HashMap::new();

        for call in api_calls {
            let func = call.function.to_lowercase();

            // Track process creation with suspended flag
            if func.contains("createprocess") {
                if let Some(flags) = get_creation_flags(call) {
                    if flags & 0x4 != 0 { // CREATE_SUSPENDED
                        if let Some(child_pid) = get_child_pid(call) {
                            hollowing_candidates.insert(child_pid, HollowingState::Suspended);
                        }
                    }
                }
            }

            // Track memory unmapping
            if func.contains("ntunmapviewofsection") || func.contains("zwunmapviewofsection") {
                if let Some(target_pid) = extract_target_pid(call) {
                    if let Some(state) = hollowing_candidates.get_mut(&target_pid) {
                        if *state == HollowingState::Suspended {
                            *state = HollowingState::Unmapped;
                        }
                    }
                }
            }

            // Track memory writing
            if func.contains("ntwritevirtualmemory") || func.contains("writeprocessmemory") {
                if let Some(target_pid) = extract_target_pid(call) {
                    if let Some(state) = hollowing_candidates.get_mut(&target_pid) {
                        if *state == HollowingState::Unmapped {
                            *state = HollowingState::Written;
                        }
                    }
                }
            }

            // Track thread context modification and resume
            if func.contains("ntsetcontextthread") || func.contains("setthreadcontext") {
                if let Some(target_pid) = extract_target_pid(call) {
                    if let Some(state) = hollowing_candidates.get_mut(&target_pid) {
                        if *state == HollowingState::Written {
                            *state = HollowingState::ContextSet;
                        }
                    }
                }
            }

            if func.contains("ntresumethread") || func.contains("resumethread") {
                if let Some(target_pid) = extract_target_pid(call) {
                    if let Some(state) = hollowing_candidates.get_mut(&target_pid) {
                        if *state == HollowingState::ContextSet {
                            *state = HollowingState::Hollowed;
                        }
                    }
                }
            }
        }

        // Mark hollowed processes
        for proc in processes.iter_mut() {
            if let Some(HollowingState::Hollowed) = hollowing_candidates.get(&proc.pid) {
                proc.is_hollowed = true;
            }
        }
    }

    /// Analyze process tree for suspicious patterns
    pub fn analyze_process_tree(&self, processes: &[ProcessInfo]) -> Vec<SuspiciousTreePattern> {
        let mut findings = Vec::new();
        let pid_map: HashMap<u32, &ProcessInfo> = processes.iter().map(|p| (p.pid, p)).collect();

        for proc in processes {
            // Check for suspicious parent-child relationships
            if let Some(parent) = pid_map.get(&proc.parent_pid) {
                // Check for script engines spawning from Office
                if is_office_process(&parent.name) && is_script_engine(&proc.name) {
                    findings.push(SuspiciousTreePattern {
                        pattern_type: TreePatternType::OfficeSpawningScript,
                        parent_pid: parent.pid,
                        parent_name: parent.name.clone(),
                        child_pid: proc.pid,
                        child_name: proc.name.clone(),
                        description: format!(
                            "Office application {} spawned script engine {}",
                            parent.name, proc.name
                        ),
                        severity: BehaviorSeverity::High,
                        mitre_technique: Some("T1059".to_string()),
                    });
                }

                // Check for cmd/powershell spawning from unexpected parents
                if is_script_engine(&proc.name) && !is_expected_script_parent(&parent.name) {
                    findings.push(SuspiciousTreePattern {
                        pattern_type: TreePatternType::UnexpectedScriptParent,
                        parent_pid: parent.pid,
                        parent_name: parent.name.clone(),
                        child_pid: proc.pid,
                        child_name: proc.name.clone(),
                        description: format!(
                            "Script engine {} spawned from unexpected parent {}",
                            proc.name, parent.name
                        ),
                        severity: BehaviorSeverity::Medium,
                        mitre_technique: Some("T1059".to_string()),
                    });
                }

                // Check for LOLBins usage
                if is_lolbin(&proc.name) {
                    findings.push(SuspiciousTreePattern {
                        pattern_type: TreePatternType::LolbinExecution,
                        parent_pid: parent.pid,
                        parent_name: parent.name.clone(),
                        child_pid: proc.pid,
                        child_name: proc.name.clone(),
                        description: format!("LOLBin {} executed", proc.name),
                        severity: BehaviorSeverity::Medium,
                        mitre_technique: get_lolbin_technique(&proc.name),
                    });
                }
            }

            // Check command line for suspicious patterns
            for pattern in &self.suspicious_patterns {
                if proc.command_line.to_lowercase().contains(&pattern.pattern.to_lowercase()) {
                    findings.push(SuspiciousTreePattern {
                        pattern_type: TreePatternType::SuspiciousCommandLine,
                        parent_pid: proc.parent_pid,
                        parent_name: String::new(),
                        child_pid: proc.pid,
                        child_name: proc.name.clone(),
                        description: pattern.description.clone(),
                        severity: pattern.severity.clone(),
                        mitre_technique: None,
                    });
                }
            }
        }

        findings
    }

    /// Get statistics about process behavior
    pub fn get_statistics(&self, processes: &[ProcessInfo]) -> ProcessStatistics {
        let total = processes.len();
        let injected = processes.iter().filter(|p| p.is_injected).count();
        let hollowed = processes.iter().filter(|p| p.is_hollowed).count();
        let unique_names: HashSet<_> = processes.iter().map(|p| &p.name).collect();

        ProcessStatistics {
            total_processes: total,
            unique_process_names: unique_names.len(),
            injected_processes: injected,
            hollowed_processes: hollowed,
            max_tree_depth: calculate_tree_depth(processes),
            spawned_scripts: processes.iter().filter(|p| is_script_engine(&p.name)).count(),
        }
    }
}

impl Default for ProcessMonitor {
    fn default() -> Self {
        Self::new()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
enum HollowingState {
    Suspended,
    Unmapped,
    Written,
    ContextSet,
    Hollowed,
}

#[derive(Debug, Clone)]
pub struct SuspiciousTreePattern {
    pub pattern_type: TreePatternType,
    pub parent_pid: u32,
    pub parent_name: String,
    pub child_pid: u32,
    pub child_name: String,
    pub description: String,
    pub severity: BehaviorSeverity,
    pub mitre_technique: Option<String>,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum TreePatternType {
    OfficeSpawningScript,
    UnexpectedScriptParent,
    LolbinExecution,
    SuspiciousCommandLine,
    DeepProcessTree,
    ProcessMasquerading,
}

#[derive(Debug, Clone)]
pub struct ProcessStatistics {
    pub total_processes: usize,
    pub unique_process_names: usize,
    pub injected_processes: usize,
    pub hollowed_processes: usize,
    pub max_tree_depth: usize,
    pub spawned_scripts: usize,
}

// Helper functions

fn get_known_legitimate_processes() -> HashSet<String> {
    vec![
        "explorer.exe", "svchost.exe", "csrss.exe", "winlogon.exe", "lsass.exe",
        "services.exe", "smss.exe", "wininit.exe", "dwm.exe", "taskhostw.exe",
        "conhost.exe", "dllhost.exe", "spoolsv.exe", "searchindexer.exe",
        "runtimebroker.exe", "sihost.exe", "fontdrvhost.exe", "msdtc.exe",
    ]
    .into_iter()
    .map(String::from)
    .collect()
}

fn get_suspicious_process_patterns() -> Vec<SuspiciousProcessPattern> {
    vec![
        SuspiciousProcessPattern {
            pattern: "-enc ".to_string(),
            description: "Encoded PowerShell command detected".to_string(),
            severity: BehaviorSeverity::High,
        },
        SuspiciousProcessPattern {
            pattern: "-encodedcommand".to_string(),
            description: "Encoded PowerShell command detected".to_string(),
            severity: BehaviorSeverity::High,
        },
        SuspiciousProcessPattern {
            pattern: "-nop -w hidden".to_string(),
            description: "Hidden PowerShell execution".to_string(),
            severity: BehaviorSeverity::High,
        },
        SuspiciousProcessPattern {
            pattern: "iex(".to_string(),
            description: "PowerShell Invoke-Expression detected".to_string(),
            severity: BehaviorSeverity::High,
        },
        SuspiciousProcessPattern {
            pattern: "downloadstring".to_string(),
            description: "PowerShell download attempt".to_string(),
            severity: BehaviorSeverity::High,
        },
        SuspiciousProcessPattern {
            pattern: "bypass".to_string(),
            description: "Execution policy bypass attempt".to_string(),
            severity: BehaviorSeverity::Medium,
        },
        SuspiciousProcessPattern {
            pattern: "certutil -urlcache".to_string(),
            description: "File download via certutil".to_string(),
            severity: BehaviorSeverity::High,
        },
        SuspiciousProcessPattern {
            pattern: "bitsadmin /transfer".to_string(),
            description: "File download via BITS".to_string(),
            severity: BehaviorSeverity::High,
        },
        SuspiciousProcessPattern {
            pattern: "mshta vbscript:".to_string(),
            description: "MSHTA script execution".to_string(),
            severity: BehaviorSeverity::High,
        },
        SuspiciousProcessPattern {
            pattern: "regsvr32 /s /n /u /i:".to_string(),
            description: "Regsvr32 script execution".to_string(),
            severity: BehaviorSeverity::High,
        },
    ]
}

fn is_injection_api(function: &str) -> bool {
    let func_lower = function.to_lowercase();
    func_lower.contains("virtualallocex")
        || func_lower.contains("writeprocessmemory")
        || func_lower.contains("ntwritevirtualmemory")
        || func_lower.contains("createremotethread")
        || func_lower.contains("ntcreatethread")
        || func_lower.contains("queueuserapc")
        || func_lower.contains("setthreadcontext")
        || func_lower.contains("ntsetcontextthread")
}

fn extract_target_pid(call: &RawApiCall) -> Option<u32> {
    for (name, _, value) in &call.arguments {
        let name_lower = name.to_lowercase();
        if name_lower.contains("processhandle") || name_lower.contains("hprocess") || name_lower == "pid" {
            if let Ok(pid) = value.parse::<u32>() {
                return Some(pid);
            }
            // Handle hex format
            if value.starts_with("0x") {
                if let Ok(pid) = u32::from_str_radix(&value[2..], 16) {
                    return Some(pid);
                }
            }
        }
    }
    None
}

fn get_creation_flags(call: &RawApiCall) -> Option<u32> {
    for (name, _, value) in &call.arguments {
        if name.to_lowercase().contains("creationflags") || name.to_lowercase().contains("dwcreationflags") {
            if let Ok(flags) = value.parse::<u32>() {
                return Some(flags);
            }
            if value.starts_with("0x") {
                if let Ok(flags) = u32::from_str_radix(&value[2..], 16) {
                    return Some(flags);
                }
            }
        }
    }
    None
}

fn get_child_pid(call: &RawApiCall) -> Option<u32> {
    // For CreateProcess, the PID would be in the PROCESS_INFORMATION structure
    for (name, _, value) in &call.arguments {
        if name.to_lowercase().contains("processid") || name.to_lowercase().contains("dwprocessid") {
            if let Ok(pid) = value.parse::<u32>() {
                return Some(pid);
            }
        }
    }
    None
}

fn is_office_process(name: &str) -> bool {
    let name_lower = name.to_lowercase();
    name_lower.contains("winword")
        || name_lower.contains("excel")
        || name_lower.contains("powerpnt")
        || name_lower.contains("outlook")
        || name_lower.contains("msaccess")
        || name_lower.contains("mspub")
}

fn is_script_engine(name: &str) -> bool {
    let name_lower = name.to_lowercase();
    name_lower.contains("powershell")
        || name_lower.contains("cmd.exe")
        || name_lower.contains("wscript")
        || name_lower.contains("cscript")
        || name_lower.contains("mshta")
        || name_lower.contains("python")
        || name_lower.contains("perl")
        || name_lower.contains("ruby")
}

fn is_expected_script_parent(name: &str) -> bool {
    let name_lower = name.to_lowercase();
    name_lower.contains("explorer")
        || name_lower.contains("cmd")
        || name_lower.contains("powershell")
        || name_lower.contains("svchost")
        || name_lower.contains("services")
        || name_lower.contains("taskscheduler")
}

fn is_lolbin(name: &str) -> bool {
    let name_lower = name.to_lowercase();
    let lolbins = [
        "certutil", "mshta", "regsvr32", "rundll32", "msiexec",
        "bitsadmin", "cmstp", "installutil", "regasm", "regsvcs",
        "msbuild", "csc", "vbc", "jsc", "control",
        "fodhelper", "pcalua", "presentationhost", "syncappvpublishingserver",
        "forfiles", "bash", "scriptrunner", "dnscmd", "desktopimgdownldr",
        "eudcedit", "msdt", "diantz", "makecab", "extrac32", "expand",
        "findstr", "hh", "ie4uinit", "infdefaultinstall", "msdeploy",
    ];
    lolbins.iter().any(|lol| name_lower.contains(lol))
}

fn get_lolbin_technique(name: &str) -> Option<String> {
    let name_lower = name.to_lowercase();
    if name_lower.contains("mshta") {
        Some("T1218.005".to_string())
    } else if name_lower.contains("regsvr32") {
        Some("T1218.010".to_string())
    } else if name_lower.contains("rundll32") {
        Some("T1218.011".to_string())
    } else if name_lower.contains("msiexec") {
        Some("T1218.007".to_string())
    } else if name_lower.contains("certutil") {
        Some("T1105".to_string())
    } else if name_lower.contains("bitsadmin") {
        Some("T1197".to_string())
    } else if name_lower.contains("msbuild") {
        Some("T1127.001".to_string())
    } else {
        Some("T1218".to_string())
    }
}

fn calculate_tree_depth(processes: &[ProcessInfo]) -> usize {
    let pid_map: HashMap<u32, &ProcessInfo> = processes.iter().map(|p| (p.pid, p)).collect();

    let mut max_depth = 0;
    for proc in processes {
        let mut depth = 1;
        let mut current_pid = proc.parent_pid;
        while let Some(parent) = pid_map.get(&current_pid) {
            depth += 1;
            current_pid = parent.parent_pid;
            if depth > 100 { break; } // Prevent infinite loops
        }
        max_depth = max_depth.max(depth);
    }

    max_depth
}
