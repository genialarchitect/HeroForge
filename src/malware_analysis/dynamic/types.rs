//! Dynamic Analysis Types
//!
//! Core types for dynamic malware analysis functionality.

use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

/// Dynamic analysis session
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DynamicAnalysisSession {
    pub id: String,
    pub sample_id: String,
    pub user_id: String,
    pub environment: ExecutionEnvironment,
    pub status: SessionStatus,
    pub configuration: AnalysisConfiguration,
    pub started_at: Option<DateTime<Utc>>,
    pub completed_at: Option<DateTime<Utc>>,
    pub duration_seconds: Option<u64>,
    pub created_at: DateTime<Utc>,
}

/// Execution environment configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExecutionEnvironment {
    pub os_type: OsType,
    pub os_version: String,
    pub architecture: Architecture,
    pub is_sandboxed: bool,
    pub has_network: bool,
    pub has_internet: bool,
    pub memory_mb: u32,
    pub cpu_cores: u8,
    pub installed_software: Vec<String>,
}

/// Operating system type
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum OsType {
    Windows7,
    Windows10,
    Windows11,
    WindowsServer2019,
    WindowsServer2022,
    Ubuntu20,
    Ubuntu22,
    Debian11,
    CentOs7,
    Kali,
    MacOsMonterey,
    MacOsVentura,
    Android,
    Custom,
}

impl std::fmt::Display for OsType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            OsType::Windows7 => write!(f, "windows_7"),
            OsType::Windows10 => write!(f, "windows_10"),
            OsType::Windows11 => write!(f, "windows_11"),
            OsType::WindowsServer2019 => write!(f, "windows_server_2019"),
            OsType::WindowsServer2022 => write!(f, "windows_server_2022"),
            OsType::Ubuntu20 => write!(f, "ubuntu_20"),
            OsType::Ubuntu22 => write!(f, "ubuntu_22"),
            OsType::Debian11 => write!(f, "debian_11"),
            OsType::CentOs7 => write!(f, "centos_7"),
            OsType::Kali => write!(f, "kali"),
            OsType::MacOsMonterey => write!(f, "macos_monterey"),
            OsType::MacOsVentura => write!(f, "macos_ventura"),
            OsType::Android => write!(f, "android"),
            OsType::Custom => write!(f, "custom"),
        }
    }
}

/// CPU architecture
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum Architecture {
    X86,
    X64,
    Arm,
    Arm64,
}

impl std::fmt::Display for Architecture {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Architecture::X86 => write!(f, "x86"),
            Architecture::X64 => write!(f, "x64"),
            Architecture::Arm => write!(f, "arm"),
            Architecture::Arm64 => write!(f, "arm64"),
        }
    }
}

/// Session status
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum SessionStatus {
    Pending,
    Preparing,
    Running,
    Completed,
    Failed,
    Timeout,
    Cancelled,
}

impl std::fmt::Display for SessionStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            SessionStatus::Pending => write!(f, "pending"),
            SessionStatus::Preparing => write!(f, "preparing"),
            SessionStatus::Running => write!(f, "running"),
            SessionStatus::Completed => write!(f, "completed"),
            SessionStatus::Failed => write!(f, "failed"),
            SessionStatus::Timeout => write!(f, "timeout"),
            SessionStatus::Cancelled => write!(f, "cancelled"),
        }
    }
}

/// Analysis configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AnalysisConfiguration {
    pub timeout_seconds: u32,
    pub enable_process_monitoring: bool,
    pub enable_api_hooks: bool,
    pub enable_network_capture: bool,
    pub enable_filesystem_monitoring: bool,
    pub enable_registry_monitoring: bool,
    pub enable_memory_dumps: bool,
    pub enable_screenshots: bool,
    pub screenshot_interval_seconds: u32,
    pub execution_arguments: Option<String>,
    pub environment_variables: HashMap<String, String>,
    pub user_interaction: Option<UserInteraction>,
    pub network_simulation: NetworkSimulation,
}

impl Default for AnalysisConfiguration {
    fn default() -> Self {
        Self {
            timeout_seconds: 120,
            enable_process_monitoring: true,
            enable_api_hooks: true,
            enable_network_capture: true,
            enable_filesystem_monitoring: true,
            enable_registry_monitoring: true,
            enable_memory_dumps: false,
            enable_screenshots: true,
            screenshot_interval_seconds: 10,
            execution_arguments: None,
            environment_variables: HashMap::new(),
            user_interaction: None,
            network_simulation: NetworkSimulation::default(),
        }
    }
}

/// User interaction simulation
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UserInteraction {
    pub click_dialogs: bool,
    pub move_mouse: bool,
    pub type_keys: bool,
    pub script: Option<String>,
}

/// Network simulation configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NetworkSimulation {
    pub mode: NetworkMode,
    pub fake_dns: bool,
    pub fake_http: bool,
    pub capture_ssl: bool,
    pub allowed_domains: Vec<String>,
    pub blocked_domains: Vec<String>,
}

impl Default for NetworkSimulation {
    fn default() -> Self {
        Self {
            mode: NetworkMode::Simulated,
            fake_dns: true,
            fake_http: true,
            capture_ssl: true,
            allowed_domains: Vec::new(),
            blocked_domains: Vec::new(),
        }
    }
}

/// Network mode
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum NetworkMode {
    Disabled,
    Simulated,
    RealLimited,
    RealFull,
}

/// Dynamic analysis result
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DynamicAnalysisResult {
    pub id: String,
    pub session_id: String,
    pub sample_id: String,
    pub processes: Vec<ProcessInfo>,
    pub api_calls: Vec<ApiCallInfo>,
    pub network_activity: Vec<NetworkActivity>,
    pub file_operations: Vec<FileOperation>,
    pub registry_operations: Vec<RegistryOperation>,
    pub mutex_operations: Vec<MutexOperation>,
    pub behavior_timeline: Vec<BehaviorEvent>,
    pub dropped_files: Vec<DroppedFile>,
    pub memory_dumps: Vec<MemoryDump>,
    pub screenshots: Vec<Screenshot>,
    pub anti_analysis_detected: Vec<AntiAnalysisTechnique>,
    pub iocs_extracted: Vec<DynamicIoc>,
    pub verdict: AnalysisVerdict,
    pub threat_score: u8,
    pub created_at: DateTime<Utc>,
}

/// Process information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProcessInfo {
    pub pid: u32,
    pub parent_pid: u32,
    pub name: String,
    pub path: String,
    pub command_line: String,
    pub username: String,
    pub integrity_level: Option<String>,
    pub is_injected: bool,
    pub is_hollowed: bool,
    pub started_at: DateTime<Utc>,
    pub terminated_at: Option<DateTime<Utc>>,
    pub exit_code: Option<i32>,
    pub children: Vec<u32>,
    pub modules_loaded: Vec<ModuleInfo>,
}

/// Loaded module information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ModuleInfo {
    pub name: String,
    pub path: String,
    pub base_address: u64,
    pub size: u64,
    pub is_signed: bool,
    pub signer: Option<String>,
}

/// API call information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ApiCallInfo {
    pub id: String,
    pub timestamp: DateTime<Utc>,
    pub pid: u32,
    pub process_name: String,
    pub api_category: ApiCategory,
    pub module: String,
    pub function: String,
    pub arguments: Vec<ApiArgument>,
    pub return_value: String,
    pub is_hooked: bool,
    pub stack_trace: Option<Vec<String>>,
    pub severity: ApiSeverity,
    pub mitre_techniques: Vec<String>,
}

/// API call category
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]
#[serde(rename_all = "snake_case")]
pub enum ApiCategory {
    Process,
    Thread,
    Memory,
    File,
    Registry,
    Network,
    Crypto,
    Injection,
    AntiDebug,
    AntiVm,
    Persistence,
    Privilege,
    Discovery,
    Execution,
    Hooking,
    Other,
}

impl std::fmt::Display for ApiCategory {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ApiCategory::Process => write!(f, "process"),
            ApiCategory::Thread => write!(f, "thread"),
            ApiCategory::Memory => write!(f, "memory"),
            ApiCategory::File => write!(f, "file"),
            ApiCategory::Registry => write!(f, "registry"),
            ApiCategory::Network => write!(f, "network"),
            ApiCategory::Crypto => write!(f, "crypto"),
            ApiCategory::Injection => write!(f, "injection"),
            ApiCategory::AntiDebug => write!(f, "anti_debug"),
            ApiCategory::AntiVm => write!(f, "anti_vm"),
            ApiCategory::Persistence => write!(f, "persistence"),
            ApiCategory::Privilege => write!(f, "privilege"),
            ApiCategory::Discovery => write!(f, "discovery"),
            ApiCategory::Execution => write!(f, "execution"),
            ApiCategory::Hooking => write!(f, "hooking"),
            ApiCategory::Other => write!(f, "other"),
        }
    }
}

/// API argument
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ApiArgument {
    pub name: String,
    pub arg_type: String,
    pub value: String,
    pub is_pointer: bool,
    pub dereferenced_value: Option<String>,
}

/// API call severity
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[serde(rename_all = "snake_case")]
pub enum ApiSeverity {
    Info,
    Low,
    Medium,
    High,
    Critical,
}

/// Network activity
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NetworkActivity {
    pub id: String,
    pub timestamp: DateTime<Utc>,
    pub pid: u32,
    pub process_name: String,
    pub protocol: NetworkProtocol,
    pub local_address: String,
    pub local_port: u16,
    pub remote_address: String,
    pub remote_port: u16,
    pub direction: NetworkDirection,
    pub state: ConnectionState,
    pub bytes_sent: u64,
    pub bytes_received: u64,
    pub dns_query: Option<DnsQuery>,
    pub http_request: Option<HttpRequest>,
    pub tls_info: Option<TlsInfo>,
    pub payload_preview: Option<String>,
    pub is_suspicious: bool,
    pub suspicion_reason: Option<String>,
}

/// Network protocol
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]
#[serde(rename_all = "snake_case")]
pub enum NetworkProtocol {
    Tcp,
    Udp,
    Icmp,
    Dns,
    Http,
    Https,
    Smtp,
    Ftp,
    Irc,
    Other,
}

/// Network direction
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum NetworkDirection {
    Inbound,
    Outbound,
}

/// Connection state
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum ConnectionState {
    Connecting,
    Connected,
    Listening,
    Closed,
    Failed,
}

/// DNS query information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DnsQuery {
    pub query_name: String,
    pub query_type: String,
    pub resolved_ips: Vec<String>,
    pub is_dga: bool,
    pub dga_score: Option<f64>,
}

/// HTTP request information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct HttpRequest {
    pub method: String,
    pub url: String,
    pub host: String,
    pub path: String,
    pub user_agent: Option<String>,
    pub headers: HashMap<String, String>,
    pub body_preview: Option<String>,
    pub body_size: u64,
    pub response_code: Option<u16>,
    pub response_body_preview: Option<String>,
}

/// TLS/SSL information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TlsInfo {
    pub version: String,
    pub cipher_suite: String,
    pub server_name: Option<String>,
    pub certificate_subject: Option<String>,
    pub certificate_issuer: Option<String>,
    pub ja3_hash: Option<String>,
    pub ja3s_hash: Option<String>,
}

/// File operation
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileOperation {
    pub id: String,
    pub timestamp: DateTime<Utc>,
    pub pid: u32,
    pub process_name: String,
    pub operation_type: FileOperationType,
    pub path: String,
    pub new_path: Option<String>,
    pub attributes: Option<FileAttributes>,
    pub bytes_affected: Option<u64>,
    pub content_preview: Option<String>,
    pub file_hash: Option<String>,
    pub is_suspicious: bool,
    pub suspicion_reason: Option<String>,
}

/// File operation type
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]
#[serde(rename_all = "snake_case")]
pub enum FileOperationType {
    Create,
    Open,
    Read,
    Write,
    Delete,
    Rename,
    Move,
    Copy,
    SetAttributes,
    CreateDirectory,
    DeleteDirectory,
    MapView,
    QueryInfo,
}

/// File attributes
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileAttributes {
    pub readonly: bool,
    pub hidden: bool,
    pub system: bool,
    pub archive: bool,
    pub temporary: bool,
    pub encrypted: bool,
}

/// Registry operation
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RegistryOperation {
    pub id: String,
    pub timestamp: DateTime<Utc>,
    pub pid: u32,
    pub process_name: String,
    pub operation_type: RegistryOperationType,
    pub key_path: String,
    pub value_name: Option<String>,
    pub value_type: Option<RegistryValueType>,
    pub value_data: Option<String>,
    pub is_persistence: bool,
    pub is_suspicious: bool,
    pub suspicion_reason: Option<String>,
}

/// Registry operation type
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]
#[serde(rename_all = "snake_case")]
pub enum RegistryOperationType {
    CreateKey,
    OpenKey,
    DeleteKey,
    SetValue,
    DeleteValue,
    QueryKey,
    QueryValue,
    EnumerateKey,
    EnumerateValue,
}

/// Registry value type
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum RegistryValueType {
    String,
    ExpandString,
    Binary,
    Dword,
    Qword,
    MultiString,
    Link,
    None,
    Unknown,
}

/// Mutex operation
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MutexOperation {
    pub id: String,
    pub timestamp: DateTime<Utc>,
    pub pid: u32,
    pub process_name: String,
    pub operation_type: MutexOperationType,
    pub mutex_name: String,
    pub is_known_malware: bool,
    pub known_malware_family: Option<String>,
}

/// Mutex operation type
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum MutexOperationType {
    Create,
    Open,
    Release,
}

/// Behavior event in timeline
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BehaviorEvent {
    pub id: String,
    pub timestamp: DateTime<Utc>,
    pub event_type: BehaviorEventType,
    pub pid: u32,
    pub process_name: String,
    pub description: String,
    pub severity: BehaviorSeverity,
    pub details: serde_json::Value,
    pub mitre_techniques: Vec<String>,
    pub related_events: Vec<String>,
}

/// Behavior event type
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]
#[serde(rename_all = "snake_case")]
pub enum BehaviorEventType {
    ProcessCreated,
    ProcessTerminated,
    ProcessInjection,
    ProcessHollowing,
    ThreadInjection,
    ModuleLoad,
    ApiCall,
    NetworkConnection,
    DnsQuery,
    HttpRequest,
    FileCreated,
    FileModified,
    FileDeleted,
    RegistryModified,
    MutexCreated,
    ServiceCreated,
    ScheduledTask,
    Persistence,
    PrivilegeEscalation,
    CredentialAccess,
    AntiAnalysis,
    CryptoOperation,
    Exfiltration,
    Command,
    Screenshot,
    Keylog,
    Other,
}

impl std::fmt::Display for BehaviorEventType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            BehaviorEventType::ProcessCreated => write!(f, "process_created"),
            BehaviorEventType::ProcessTerminated => write!(f, "process_terminated"),
            BehaviorEventType::ProcessInjection => write!(f, "process_injection"),
            BehaviorEventType::ProcessHollowing => write!(f, "process_hollowing"),
            BehaviorEventType::ThreadInjection => write!(f, "thread_injection"),
            BehaviorEventType::ModuleLoad => write!(f, "module_load"),
            BehaviorEventType::ApiCall => write!(f, "api_call"),
            BehaviorEventType::NetworkConnection => write!(f, "network_connection"),
            BehaviorEventType::DnsQuery => write!(f, "dns_query"),
            BehaviorEventType::HttpRequest => write!(f, "http_request"),
            BehaviorEventType::FileCreated => write!(f, "file_created"),
            BehaviorEventType::FileModified => write!(f, "file_modified"),
            BehaviorEventType::FileDeleted => write!(f, "file_deleted"),
            BehaviorEventType::RegistryModified => write!(f, "registry_modified"),
            BehaviorEventType::MutexCreated => write!(f, "mutex_created"),
            BehaviorEventType::ServiceCreated => write!(f, "service_created"),
            BehaviorEventType::ScheduledTask => write!(f, "scheduled_task"),
            BehaviorEventType::Persistence => write!(f, "persistence"),
            BehaviorEventType::PrivilegeEscalation => write!(f, "privilege_escalation"),
            BehaviorEventType::CredentialAccess => write!(f, "credential_access"),
            BehaviorEventType::AntiAnalysis => write!(f, "anti_analysis"),
            BehaviorEventType::CryptoOperation => write!(f, "crypto_operation"),
            BehaviorEventType::Exfiltration => write!(f, "exfiltration"),
            BehaviorEventType::Command => write!(f, "command"),
            BehaviorEventType::Screenshot => write!(f, "screenshot"),
            BehaviorEventType::Keylog => write!(f, "keylog"),
            BehaviorEventType::Other => write!(f, "other"),
        }
    }
}

/// Behavior severity
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Ord, PartialOrd, Hash)]
#[serde(rename_all = "snake_case")]
pub enum BehaviorSeverity {
    Info,
    Low,
    Medium,
    High,
    Critical,
}

/// Dropped file
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DroppedFile {
    pub id: String,
    pub path: String,
    pub original_path: String,
    pub filename: String,
    pub size: u64,
    pub md5: String,
    pub sha256: String,
    pub file_type: String,
    pub mime_type: Option<String>,
    pub is_executable: bool,
    pub is_script: bool,
    pub dropped_by_pid: u32,
    pub dropped_by_process: String,
    pub dropped_at: DateTime<Utc>,
    pub execution_attempted: bool,
    pub yara_matches: Vec<String>,
}

/// Memory dump
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MemoryDump {
    pub id: String,
    pub pid: u32,
    pub process_name: String,
    pub dump_type: MemoryDumpType,
    pub base_address: u64,
    pub size: u64,
    pub path: String,
    pub md5: String,
    pub sha256: String,
    pub reason: String,
    pub captured_at: DateTime<Utc>,
}

/// Memory dump type
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum MemoryDumpType {
    ProcessDump,
    RegionDump,
    ModuleDump,
    InjectedCode,
    Shellcode,
}

/// Screenshot captured during analysis
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Screenshot {
    pub id: String,
    pub path: String,
    pub timestamp: DateTime<Utc>,
    pub width: u32,
    pub height: u32,
    pub md5: String,
    pub ocr_text: Option<String>,
}

/// Anti-analysis technique detected
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AntiAnalysisTechnique {
    pub id: String,
    pub technique_type: AntiAnalysisType,
    pub name: String,
    pub description: String,
    pub detected_at: DateTime<Utc>,
    pub pid: u32,
    pub process_name: String,
    pub indicators: Vec<String>,
    pub bypassed: bool,
    pub mitre_technique: Option<String>,
}

/// Anti-analysis type
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]
#[serde(rename_all = "snake_case")]
pub enum AntiAnalysisType {
    DebuggerDetection,
    VmDetection,
    SandboxDetection,
    TimingCheck,
    UserInteractionCheck,
    EnvironmentCheck,
    HardwareCheck,
    ProcessCheck,
    RegistryCheck,
    FileCheck,
    NetworkCheck,
    HookDetection,
    Other,
}

impl std::fmt::Display for AntiAnalysisType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AntiAnalysisType::DebuggerDetection => write!(f, "debugger_detection"),
            AntiAnalysisType::VmDetection => write!(f, "vm_detection"),
            AntiAnalysisType::SandboxDetection => write!(f, "sandbox_detection"),
            AntiAnalysisType::TimingCheck => write!(f, "timing_check"),
            AntiAnalysisType::UserInteractionCheck => write!(f, "user_interaction_check"),
            AntiAnalysisType::EnvironmentCheck => write!(f, "environment_check"),
            AntiAnalysisType::HardwareCheck => write!(f, "hardware_check"),
            AntiAnalysisType::ProcessCheck => write!(f, "process_check"),
            AntiAnalysisType::RegistryCheck => write!(f, "registry_check"),
            AntiAnalysisType::FileCheck => write!(f, "file_check"),
            AntiAnalysisType::NetworkCheck => write!(f, "network_check"),
            AntiAnalysisType::HookDetection => write!(f, "hook_detection"),
            AntiAnalysisType::Other => write!(f, "other"),
        }
    }
}

/// IOC extracted from dynamic analysis
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DynamicIoc {
    pub id: String,
    pub ioc_type: DynamicIocType,
    pub value: String,
    pub context: String,
    pub source_event_id: String,
    pub confidence: u8,
    pub first_seen: DateTime<Utc>,
    pub last_seen: DateTime<Utc>,
    pub occurrence_count: u32,
}

/// Dynamic IOC type
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum DynamicIocType {
    Ip,
    Domain,
    Url,
    UserAgent,
    Mutex,
    RegistryKey,
    FilePath,
    DroppedFile,
    C2Server,
    Ja3,
    DgaDomain,
}

/// Analysis verdict
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AnalysisVerdict {
    pub classification: VerdictClassification,
    pub confidence: f64,
    pub malware_family: Option<String>,
    pub threat_categories: Vec<ThreatCategory>,
    pub summary: String,
    pub recommendations: Vec<String>,
}

/// Verdict classification
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum VerdictClassification {
    Clean,
    Suspicious,
    Malicious,
    Inconclusive,
}

impl std::fmt::Display for VerdictClassification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            VerdictClassification::Clean => write!(f, "clean"),
            VerdictClassification::Suspicious => write!(f, "suspicious"),
            VerdictClassification::Malicious => write!(f, "malicious"),
            VerdictClassification::Inconclusive => write!(f, "inconclusive"),
        }
    }
}

/// Threat category
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum ThreatCategory {
    Ransomware,
    Rat,
    Trojan,
    Worm,
    Backdoor,
    Spyware,
    Stealer,
    Miner,
    Botnet,
    Dropper,
    Rootkit,
    Keylogger,
    Adware,
    Exploit,
    Apt,
    Other,
}

/// Analysis statistics summary
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DynamicAnalysisStats {
    pub total_sessions: u64,
    pub completed_sessions: u64,
    pub failed_sessions: u64,
    pub malicious_detected: u64,
    pub suspicious_detected: u64,
    pub clean_samples: u64,
    pub avg_analysis_time_seconds: f64,
    pub sessions_today: u64,
    pub processes_created_total: u64,
    pub network_connections_total: u64,
    pub files_dropped_total: u64,
    pub top_malware_families: Vec<(String, u64)>,
    pub top_threat_categories: Vec<(ThreatCategory, u64)>,
    pub anti_analysis_techniques_seen: u64,
}

/// API hook pattern definition
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ApiHookPattern {
    pub id: String,
    pub module: String,
    pub function: String,
    pub category: ApiCategory,
    pub description: String,
    pub severity: ApiSeverity,
    pub mitre_techniques: Vec<String>,
    pub argument_signatures: Vec<ArgumentSignature>,
    pub is_enabled: bool,
}

/// Argument signature for pattern matching
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ArgumentSignature {
    pub name: String,
    pub arg_type: String,
    pub position: usize,
    pub pattern: Option<String>,
    pub extract: bool,
}

/// Persistence location detected
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PersistenceLocation {
    pub id: String,
    pub persistence_type: PersistenceType,
    pub location: String,
    pub value: String,
    pub detected_at: DateTime<Utc>,
    pub pid: u32,
    pub process_name: String,
}

/// Persistence type
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum PersistenceType {
    RegistryRun,
    RegistryRunOnce,
    RegistryServices,
    ScheduledTask,
    StartupFolder,
    WmiSubscription,
    BootExecute,
    AppInit,
    ShellExtension,
    Lsa,
    Winlogon,
    BrowserExtension,
    OfficeAddin,
    Other,
}
