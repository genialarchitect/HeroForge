//! Behavior Timeline Generation
//!
//! Builds a comprehensive timeline of malware behavior including:
//! - Process creation/termination
//! - Network activity
//! - File operations
//! - Registry modifications
//! - API calls of interest
//! - Event correlation

use super::types::*;
use chrono::{DateTime, Utc};
use std::collections::HashMap;

/// Behavior timeline builder
pub struct BehaviorTimelineBuilder {
    /// Severity thresholds for inclusion
    min_severity_for_api: ApiSeverity,
    /// Maximum events to include
    max_events: usize,
}

impl BehaviorTimelineBuilder {
    pub fn new() -> Self {
        Self {
            min_severity_for_api: ApiSeverity::Medium,
            max_events: 1000,
        }
    }

    /// Build a comprehensive behavior timeline
    pub fn build(
        &self,
        processes: &[ProcessInfo],
        api_calls: &[ApiCallInfo],
        network: &[NetworkActivity],
        files: &[FileOperation],
        registry: &[RegistryOperation],
    ) -> Vec<BehaviorEvent> {
        let mut events = Vec::new();

        // Add process events
        for proc in processes {
            events.push(BehaviorEvent {
                id: uuid::Uuid::new_v4().to_string(),
                timestamp: proc.started_at,
                event_type: BehaviorEventType::ProcessCreated,
                pid: proc.pid,
                process_name: proc.name.clone(),
                description: format!(
                    "Process created: {} (PID: {}, Parent: {})",
                    proc.name, proc.pid, proc.parent_pid
                ),
                severity: if proc.is_injected || proc.is_hollowed {
                    BehaviorSeverity::Critical
                } else {
                    BehaviorSeverity::Info
                },
                details: serde_json::json!({
                    "command_line": proc.command_line,
                    "path": proc.path,
                    "username": proc.username,
                    "is_injected": proc.is_injected,
                    "is_hollowed": proc.is_hollowed,
                }),
                mitre_techniques: if proc.is_injected {
                    vec!["T1055".to_string()]
                } else if proc.is_hollowed {
                    vec!["T1055.012".to_string()]
                } else {
                    vec![]
                },
                related_events: vec![],
            });

            if proc.is_injected {
                events.push(BehaviorEvent {
                    id: uuid::Uuid::new_v4().to_string(),
                    timestamp: proc.started_at,
                    event_type: BehaviorEventType::ProcessInjection,
                    pid: proc.pid,
                    process_name: proc.name.clone(),
                    description: format!("Code injection detected in {}", proc.name),
                    severity: BehaviorSeverity::Critical,
                    details: serde_json::json!({"target_pid": proc.pid}),
                    mitre_techniques: vec!["T1055".to_string()],
                    related_events: vec![],
                });
            }

            if proc.is_hollowed {
                events.push(BehaviorEvent {
                    id: uuid::Uuid::new_v4().to_string(),
                    timestamp: proc.started_at,
                    event_type: BehaviorEventType::ProcessHollowing,
                    pid: proc.pid,
                    process_name: proc.name.clone(),
                    description: format!("Process hollowing detected in {}", proc.name),
                    severity: BehaviorSeverity::Critical,
                    details: serde_json::json!({"target_pid": proc.pid}),
                    mitre_techniques: vec!["T1055.012".to_string()],
                    related_events: vec![],
                });
            }

            if let Some(terminated) = proc.terminated_at {
                events.push(BehaviorEvent {
                    id: uuid::Uuid::new_v4().to_string(),
                    timestamp: terminated,
                    event_type: BehaviorEventType::ProcessTerminated,
                    pid: proc.pid,
                    process_name: proc.name.clone(),
                    description: format!(
                        "Process terminated: {} (exit code: {:?})",
                        proc.name, proc.exit_code
                    ),
                    severity: BehaviorSeverity::Info,
                    details: serde_json::json!({
                        "exit_code": proc.exit_code,
                    }),
                    mitre_techniques: vec![],
                    related_events: vec![],
                });
            }
        }

        // Add significant API calls
        for call in api_calls {
            if call.severity >= self.min_severity_for_api {
                events.push(BehaviorEvent {
                    id: uuid::Uuid::new_v4().to_string(),
                    timestamp: call.timestamp,
                    event_type: BehaviorEventType::ApiCall,
                    pid: call.pid,
                    process_name: call.process_name.clone(),
                    description: format!(
                        "{}!{} called by {}",
                        call.module, call.function, call.process_name
                    ),
                    severity: match call.severity {
                        ApiSeverity::Critical => BehaviorSeverity::Critical,
                        ApiSeverity::High => BehaviorSeverity::High,
                        ApiSeverity::Medium => BehaviorSeverity::Medium,
                        ApiSeverity::Low => BehaviorSeverity::Low,
                        ApiSeverity::Info => BehaviorSeverity::Info,
                    },
                    details: serde_json::json!({
                        "module": call.module,
                        "function": call.function,
                        "category": format!("{:?}", call.api_category),
                        "return_value": call.return_value,
                    }),
                    mitre_techniques: call.mitre_techniques.clone(),
                    related_events: vec![],
                });
            }
        }

        // Add network events
        for activity in network {
            let event_type = if activity.dns_query.is_some() {
                BehaviorEventType::DnsQuery
            } else if activity.http_request.is_some() {
                BehaviorEventType::HttpRequest
            } else {
                BehaviorEventType::NetworkConnection
            };

            let severity = if activity.is_suspicious {
                BehaviorSeverity::High
            } else if activity.dns_query.as_ref().map(|d| d.is_dga).unwrap_or(false) {
                BehaviorSeverity::Critical
            } else {
                BehaviorSeverity::Low
            };

            let description = if let Some(dns) = &activity.dns_query {
                format!("DNS query: {} by {}", dns.query_name, activity.process_name)
            } else if let Some(http) = &activity.http_request {
                format!(
                    "{} {} by {}",
                    http.method, http.url, activity.process_name
                )
            } else {
                format!(
                    "Connection to {}:{} by {}",
                    activity.remote_address, activity.remote_port, activity.process_name
                )
            };

            events.push(BehaviorEvent {
                id: uuid::Uuid::new_v4().to_string(),
                timestamp: activity.timestamp,
                event_type,
                pid: activity.pid,
                process_name: activity.process_name.clone(),
                description,
                severity,
                details: serde_json::json!({
                    "protocol": format!("{:?}", activity.protocol),
                    "remote_address": activity.remote_address,
                    "remote_port": activity.remote_port,
                    "bytes_sent": activity.bytes_sent,
                    "bytes_received": activity.bytes_received,
                    "is_suspicious": activity.is_suspicious,
                    "suspicion_reason": activity.suspicion_reason,
                }),
                mitre_techniques: if activity.dns_query.as_ref().map(|d| d.is_dga).unwrap_or(false) {
                    vec!["T1568.002".to_string()]
                } else if activity.is_suspicious {
                    vec!["T1071".to_string()]
                } else {
                    vec![]
                },
                related_events: vec![],
            });
        }

        // Add file events (suspicious ones only)
        for op in files {
            if !op.is_suspicious {
                continue;
            }

            let event_type = match op.operation_type {
                FileOperationType::Create | FileOperationType::Write => BehaviorEventType::FileCreated,
                FileOperationType::Delete | FileOperationType::DeleteDirectory => BehaviorEventType::FileDeleted,
                _ => BehaviorEventType::FileModified,
            };

            events.push(BehaviorEvent {
                id: uuid::Uuid::new_v4().to_string(),
                timestamp: op.timestamp,
                event_type,
                pid: op.pid,
                process_name: op.process_name.clone(),
                description: format!(
                    "{:?}: {} by {}",
                    op.operation_type, op.path, op.process_name
                ),
                severity: BehaviorSeverity::Medium,
                details: serde_json::json!({
                    "operation": format!("{:?}", op.operation_type),
                    "path": op.path,
                    "suspicion_reason": op.suspicion_reason,
                }),
                mitre_techniques: vec![],
                related_events: vec![],
            });
        }

        // Add registry events (persistence and suspicious)
        for op in registry {
            if !op.is_suspicious && !op.is_persistence {
                continue;
            }

            let event_type = if op.is_persistence {
                BehaviorEventType::Persistence
            } else {
                BehaviorEventType::RegistryModified
            };

            let severity = if op.is_persistence {
                BehaviorSeverity::High
            } else {
                BehaviorSeverity::Medium
            };

            events.push(BehaviorEvent {
                id: uuid::Uuid::new_v4().to_string(),
                timestamp: op.timestamp,
                event_type,
                pid: op.pid,
                process_name: op.process_name.clone(),
                description: format!(
                    "{:?}: {} by {}",
                    op.operation_type, op.key_path, op.process_name
                ),
                severity,
                details: serde_json::json!({
                    "operation": format!("{:?}", op.operation_type),
                    "key_path": op.key_path,
                    "value_name": op.value_name,
                    "is_persistence": op.is_persistence,
                    "suspicion_reason": op.suspicion_reason,
                }),
                mitre_techniques: if op.is_persistence {
                    vec!["T1547".to_string()]
                } else {
                    vec![]
                },
                related_events: vec![],
            });
        }

        // Sort by timestamp
        events.sort_by_key(|e| e.timestamp);

        // Limit events
        if events.len() > self.max_events {
            // Keep high severity events and sample the rest
            let critical_high: Vec<_> = events
                .iter()
                .filter(|e| matches!(e.severity, BehaviorSeverity::Critical | BehaviorSeverity::High))
                .cloned()
                .collect();

            if critical_high.len() >= self.max_events {
                events = critical_high.into_iter().take(self.max_events).collect();
            } else {
                let remaining = self.max_events - critical_high.len();
                let other_events: Vec<_> = events
                    .iter()
                    .filter(|e| !matches!(e.severity, BehaviorSeverity::Critical | BehaviorSeverity::High))
                    .cloned()
                    .collect();

                let step = other_events.len() / remaining.max(1);
                let sampled: Vec<_> = other_events.into_iter().step_by(step.max(1)).take(remaining).collect();

                events = critical_high;
                events.extend(sampled);
                events.sort_by_key(|e| e.timestamp);
            }
        }

        // Correlate related events
        self.correlate_events(&mut events);

        events
    }

    fn correlate_events(&self, events: &mut [BehaviorEvent]) {
        // Build process ID to event indices map
        let mut pid_events: HashMap<u32, Vec<usize>> = HashMap::new();
        for (i, event) in events.iter().enumerate() {
            pid_events.entry(event.pid).or_default().push(i);
        }

        // Link events by process
        for indices in pid_events.values() {
            if indices.len() < 2 {
                continue;
            }

            for i in 0..indices.len() - 1 {
                let current_idx = indices[i];
                let next_idx = indices[i + 1];

                // Link if close in time (within 5 seconds)
                let time_diff = events[next_idx].timestamp.signed_duration_since(events[current_idx].timestamp);
                if time_diff.num_seconds().abs() <= 5 {
                    events[current_idx].related_events.push(events[next_idx].id.clone());
                }
            }
        }

        // Link process injection to target process events
        for i in 0..events.len() {
            if matches!(events[i].event_type, BehaviorEventType::ProcessInjection) {
                if let Some(target_pid) = events[i].details.get("target_pid").and_then(|v| v.as_u64()) {
                    let target_pid = target_pid as u32;
                    if let Some(target_indices) = pid_events.get(&target_pid) {
                        for &idx in target_indices {
                            if idx != i {
                                events[i].related_events.push(events[idx].id.clone());
                            }
                        }
                    }
                }
            }
        }
    }

    /// Get timeline summary
    pub fn get_summary(&self, events: &[BehaviorEvent]) -> TimelineSummary {
        let mut event_counts: HashMap<BehaviorEventType, usize> = HashMap::new();
        let mut severity_counts: HashMap<BehaviorSeverity, usize> = HashMap::new();
        let mut mitre_counts: HashMap<String, usize> = HashMap::new();

        for event in events {
            *event_counts.entry(event.event_type.clone()).or_insert(0) += 1;
            *severity_counts.entry(event.severity.clone()).or_insert(0) += 1;
            for technique in &event.mitre_techniques {
                *mitre_counts.entry(technique.clone()).or_insert(0) += 1;
            }
        }

        let duration = if !events.is_empty() {
            events.last().unwrap().timestamp.signed_duration_since(events[0].timestamp)
        } else {
            chrono::Duration::zero()
        };

        let top_techniques: Vec<_> = {
            let mut sorted: Vec<_> = mitre_counts.into_iter().collect();
            sorted.sort_by(|a, b| b.1.cmp(&a.1));
            sorted.into_iter().take(10).collect()
        };

        TimelineSummary {
            total_events: events.len(),
            event_type_distribution: event_counts,
            severity_distribution: severity_counts,
            top_mitre_techniques: top_techniques,
            duration_seconds: duration.num_seconds() as u64,
            first_event: events.first().map(|e| e.timestamp),
            last_event: events.last().map(|e| e.timestamp),
        }
    }
}

impl Default for BehaviorTimelineBuilder {
    fn default() -> Self {
        Self::new()
    }
}

#[derive(Debug, Clone)]
pub struct TimelineSummary {
    pub total_events: usize,
    pub event_type_distribution: HashMap<BehaviorEventType, usize>,
    pub severity_distribution: HashMap<BehaviorSeverity, usize>,
    pub top_mitre_techniques: Vec<(String, usize)>,
    pub duration_seconds: u64,
    pub first_event: Option<DateTime<Utc>>,
    pub last_event: Option<DateTime<Utc>>,
}
