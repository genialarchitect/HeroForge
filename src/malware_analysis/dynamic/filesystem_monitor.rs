//! File System Monitoring Module
//!
//! Analyzes file system operations including:
//! - File creation, modification, deletion
//! - Directory operations
//! - Suspicious file locations detection
//! - File type analysis
//! - Ransomware behavior detection

use super::types::*;
use super::RawFileOperation;
use std::collections::{HashMap, HashSet};

/// File system operation analyzer
pub struct FilesystemMonitor {
    /// Sensitive file paths
    sensitive_paths: Vec<SensitivePath>,
    /// Suspicious extensions
    suspicious_extensions: HashSet<String>,
    /// Ransomware indicators
    ransomware_extensions: HashSet<String>,
    /// System directories
    system_directories: Vec<String>,
}

#[derive(Debug, Clone)]
struct SensitivePath {
    pattern: String,
    description: String,
    severity: BehaviorSeverity,
    mitre_technique: Option<String>,
}

impl FilesystemMonitor {
    pub fn new() -> Self {
        Self {
            sensitive_paths: get_sensitive_paths(),
            suspicious_extensions: get_suspicious_extensions(),
            ransomware_extensions: get_ransomware_extensions(),
            system_directories: get_system_directories(),
        }
    }

    /// Analyze raw file operations
    pub fn analyze_file_ops(&self, raw_ops: &[RawFileOperation]) -> Vec<FileOperation> {
        raw_ops
            .iter()
            .map(|op| self.analyze_operation(op))
            .collect()
    }

    fn analyze_operation(&self, op: &RawFileOperation) -> FileOperation {
        let operation_type = self.parse_operation_type(&op.operation);
        let attributes = op.attributes.map(|attrs| parse_file_attributes(attrs));
        let content_preview = op.content_preview.as_ref().and_then(|bytes| {
            if bytes.iter().all(|&b| b.is_ascii_graphic() || b.is_ascii_whitespace()) {
                String::from_utf8(bytes.iter().take(200).copied().collect()).ok()
            } else {
                Some(format!("Binary data ({} bytes)", bytes.len()))
            }
        });

        let (is_suspicious, suspicion_reason) = self.check_suspicious(&op.path, &operation_type);

        FileOperation {
            id: uuid::Uuid::new_v4().to_string(),
            timestamp: op.timestamp,
            pid: op.pid,
            process_name: op.process_name.clone(),
            operation_type,
            path: op.path.clone(),
            new_path: op.new_path.clone(),
            attributes,
            bytes_affected: op.bytes_affected,
            content_preview,
            file_hash: op.file_hash.clone(),
            is_suspicious,
            suspicion_reason,
        }
    }

    fn parse_operation_type(&self, operation: &str) -> FileOperationType {
        match operation.to_lowercase().as_str() {
            "create" | "createfile" | "ntcreatefile" => FileOperationType::Create,
            "open" | "openfile" | "ntopenfile" => FileOperationType::Open,
            "read" | "readfile" | "ntreadfile" => FileOperationType::Read,
            "write" | "writefile" | "ntwritefile" => FileOperationType::Write,
            "delete" | "deletefile" | "ntdeletefile" => FileOperationType::Delete,
            "rename" | "movefile" | "movefileex" => FileOperationType::Rename,
            "move" => FileOperationType::Move,
            "copy" | "copyfile" | "copyfileex" => FileOperationType::Copy,
            "setattributes" | "setfileattributes" => FileOperationType::SetAttributes,
            "createdir" | "createdirectory" => FileOperationType::CreateDirectory,
            "deletedir" | "removedirectory" => FileOperationType::DeleteDirectory,
            "mapview" | "ntmapviewofsection" => FileOperationType::MapView,
            "query" | "queryinfo" | "ntqueryinformationfile" => FileOperationType::QueryInfo,
            _ => FileOperationType::Open,
        }
    }

    fn check_suspicious(
        &self,
        path: &str,
        operation: &FileOperationType,
    ) -> (bool, Option<String>) {
        let path_lower = path.to_lowercase();

        // Check for sensitive paths
        for sensitive in &self.sensitive_paths {
            if path_lower.contains(&sensitive.pattern.to_lowercase()) {
                return (
                    true,
                    Some(format!("{} ({})", sensitive.description, path)),
                );
            }
        }

        // Check for suspicious extensions
        let extension = path.rsplit('.').next().unwrap_or("").to_lowercase();
        if self.suspicious_extensions.contains(&extension) {
            return (
                true,
                Some(format!("Suspicious file extension: .{}", extension)),
            );
        }

        // Check for ransomware extensions
        if self.ransomware_extensions.contains(&extension) {
            return (
                true,
                Some(format!("Potential ransomware extension: .{}", extension)),
            );
        }

        // Check for writes to system directories
        if matches!(operation, FileOperationType::Write | FileOperationType::Create) {
            for sys_dir in &self.system_directories {
                if path_lower.starts_with(&sys_dir.to_lowercase()) {
                    return (
                        true,
                        Some(format!("Write to system directory: {}", sys_dir)),
                    );
                }
            }
        }

        // Check for startup folder operations
        if path_lower.contains("startup") && matches!(
            operation,
            FileOperationType::Create | FileOperationType::Write | FileOperationType::Copy
        ) {
            return (
                true,
                Some("File operation in startup folder (persistence)".to_string()),
            );
        }

        // Check for hosts file modification
        if path_lower.contains("hosts") && matches!(
            operation,
            FileOperationType::Write
        ) {
            return (true, Some("Hosts file modification".to_string()));
        }

        // Check for double extension (e.g., .pdf.exe)
        let parts: Vec<&str> = path.rsplit('.').collect();
        if parts.len() >= 2 {
            let true_ext = parts[0].to_lowercase();
            let fake_ext = parts.get(1).map(|s| s.to_lowercase()).unwrap_or_default();
            if is_executable_extension(&true_ext) && is_document_extension(&fake_ext) {
                return (
                    true,
                    Some(format!("Double extension detected: .{}.{}", fake_ext, true_ext)),
                );
            }
        }

        (false, None)
    }

    /// Detect ransomware behavior
    pub fn detect_ransomware(&self, operations: &[FileOperation]) -> RansomwareIndicators {
        let mut indicators = RansomwareIndicators::default();

        // Count operations by type
        let write_count = operations.iter()
            .filter(|op| matches!(op.operation_type, FileOperationType::Write))
            .count();
        let delete_count = operations.iter()
            .filter(|op| matches!(op.operation_type, FileOperationType::Delete))
            .count();
        let rename_count = operations.iter()
            .filter(|op| matches!(op.operation_type, FileOperationType::Rename))
            .count();

        // Check for mass file operations (ransomware indicator)
        if write_count > 100 || rename_count > 50 {
            indicators.mass_file_operations = true;
            indicators.confidence += 0.3;
        }

        // Check for ransomware extensions
        let ransomware_ext_count = operations.iter()
            .filter(|op| {
                let ext = op.path.rsplit('.').next().unwrap_or("").to_lowercase();
                self.ransomware_extensions.contains(&ext)
            })
            .count();

        if ransomware_ext_count > 10 {
            indicators.ransomware_extensions_detected = true;
            indicators.extensions_found = operations.iter()
                .filter_map(|op| {
                    let ext = op.path.rsplit('.').next().unwrap_or("").to_lowercase();
                    if self.ransomware_extensions.contains(&ext) {
                        Some(ext)
                    } else {
                        None
                    }
                })
                .collect::<HashSet<_>>()
                .into_iter()
                .collect();
            indicators.confidence += 0.4;
        }

        // Check for ransom note creation
        let ransom_note_patterns = ["readme", "decrypt", "recover", "restore", "how_to", "warning"];
        for op in operations {
            if matches!(op.operation_type, FileOperationType::Create | FileOperationType::Write) {
                let filename = op.path.rsplit(['/', '\\']).next().unwrap_or("").to_lowercase();
                for pattern in &ransom_note_patterns {
                    if filename.contains(pattern) {
                        indicators.ransom_note_created = true;
                        indicators.ransom_note_path = Some(op.path.clone());
                        indicators.confidence += 0.2;
                        break;
                    }
                }
            }
        }

        // Check for shadow copy deletion attempts (would be seen in process/api calls typically)
        // This is a placeholder - real detection would check for vssadmin/wmic commands

        // Check for widespread directory traversal
        let unique_dirs: HashSet<_> = operations.iter()
            .filter(|op| matches!(op.operation_type, FileOperationType::Write))
            .filter_map(|op| {
                op.path.rsplit_once(['/', '\\']).map(|(dir, _)| dir.to_lowercase())
            })
            .collect();

        if unique_dirs.len() > 50 {
            indicators.widespread_encryption = true;
            indicators.confidence += 0.1;
        }

        indicators.confidence = indicators.confidence.min(1.0);
        indicators
    }

    /// Get file operation statistics
    pub fn get_statistics(&self, operations: &[FileOperation]) -> FilesystemStatistics {
        let mut operation_counts: HashMap<FileOperationType, usize> = HashMap::new();
        let mut extension_counts: HashMap<String, usize> = HashMap::new();
        let mut directory_counts: HashMap<String, usize> = HashMap::new();
        let mut suspicious_count = 0;
        let mut total_bytes: u64 = 0;

        for op in operations {
            *operation_counts.entry(op.operation_type.clone()).or_insert(0) += 1;

            let ext = op.path.rsplit('.').next().unwrap_or("unknown").to_lowercase();
            *extension_counts.entry(ext).or_insert(0) += 1;

            if let Some((dir, _)) = op.path.rsplit_once(['/', '\\']) {
                *directory_counts.entry(dir.to_lowercase()).or_insert(0) += 1;
            }

            if op.is_suspicious {
                suspicious_count += 1;
            }

            if let Some(bytes) = op.bytes_affected {
                total_bytes += bytes;
            }
        }

        let top_directories: Vec<_> = {
            let mut sorted: Vec<_> = directory_counts.into_iter().collect();
            sorted.sort_by(|a, b| b.1.cmp(&a.1));
            sorted.into_iter().take(10).collect()
        };

        let top_extensions: Vec<_> = {
            let mut sorted: Vec<_> = extension_counts.into_iter().collect();
            sorted.sort_by(|a, b| b.1.cmp(&a.1));
            sorted.into_iter().take(10).collect()
        };

        FilesystemStatistics {
            total_operations: operations.len(),
            operation_distribution: operation_counts,
            suspicious_operations: suspicious_count,
            total_bytes_affected: total_bytes,
            top_directories,
            top_extensions,
            unique_files: operations.iter().map(|o| &o.path).collect::<HashSet<_>>().len(),
        }
    }
}

impl Default for FilesystemMonitor {
    fn default() -> Self {
        Self::new()
    }
}

#[derive(Debug, Clone, Default)]
pub struct RansomwareIndicators {
    pub mass_file_operations: bool,
    pub ransomware_extensions_detected: bool,
    pub extensions_found: Vec<String>,
    pub ransom_note_created: bool,
    pub ransom_note_path: Option<String>,
    pub shadow_copy_deleted: bool,
    pub widespread_encryption: bool,
    pub confidence: f64,
}

#[derive(Debug, Clone)]
pub struct FilesystemStatistics {
    pub total_operations: usize,
    pub operation_distribution: HashMap<FileOperationType, usize>,
    pub suspicious_operations: usize,
    pub total_bytes_affected: u64,
    pub top_directories: Vec<(String, usize)>,
    pub top_extensions: Vec<(String, usize)>,
    pub unique_files: usize,
}

// Helper functions

fn get_sensitive_paths() -> Vec<SensitivePath> {
    vec![
        // Windows credentials
        SensitivePath {
            pattern: "\\sam".to_string(),
            description: "SAM database access".to_string(),
            severity: BehaviorSeverity::Critical,
            mitre_technique: Some("T1003.002".to_string()),
        },
        SensitivePath {
            pattern: "\\security".to_string(),
            description: "Security hive access".to_string(),
            severity: BehaviorSeverity::Critical,
            mitre_technique: Some("T1003.002".to_string()),
        },
        SensitivePath {
            pattern: "ntds.dit".to_string(),
            description: "Active Directory database".to_string(),
            severity: BehaviorSeverity::Critical,
            mitre_technique: Some("T1003.003".to_string()),
        },
        SensitivePath {
            pattern: "lsass".to_string(),
            description: "LSASS memory/dumps".to_string(),
            severity: BehaviorSeverity::Critical,
            mitre_technique: Some("T1003.001".to_string()),
        },

        // Browser credentials
        SensitivePath {
            pattern: "login data".to_string(),
            description: "Browser credentials database".to_string(),
            severity: BehaviorSeverity::High,
            mitre_technique: Some("T1555.003".to_string()),
        },
        SensitivePath {
            pattern: "cookies".to_string(),
            description: "Browser cookies access".to_string(),
            severity: BehaviorSeverity::Medium,
            mitre_technique: Some("T1539".to_string()),
        },
        SensitivePath {
            pattern: "key3.db".to_string(),
            description: "Firefox credentials".to_string(),
            severity: BehaviorSeverity::High,
            mitre_technique: Some("T1555.003".to_string()),
        },
        SensitivePath {
            pattern: "key4.db".to_string(),
            description: "Firefox credentials".to_string(),
            severity: BehaviorSeverity::High,
            mitre_technique: Some("T1555.003".to_string()),
        },

        // SSH keys
        SensitivePath {
            pattern: ".ssh".to_string(),
            description: "SSH keys access".to_string(),
            severity: BehaviorSeverity::High,
            mitre_technique: Some("T1552.004".to_string()),
        },
        SensitivePath {
            pattern: "id_rsa".to_string(),
            description: "RSA private key".to_string(),
            severity: BehaviorSeverity::Critical,
            mitre_technique: Some("T1552.004".to_string()),
        },

        // Config files
        SensitivePath {
            pattern: "web.config".to_string(),
            description: "Web server configuration".to_string(),
            severity: BehaviorSeverity::High,
            mitre_technique: Some("T1552.001".to_string()),
        },
        SensitivePath {
            pattern: ".env".to_string(),
            description: "Environment variables file".to_string(),
            severity: BehaviorSeverity::High,
            mitre_technique: Some("T1552.001".to_string()),
        },

        // Password managers
        SensitivePath {
            pattern: ".kdbx".to_string(),
            description: "KeePass database".to_string(),
            severity: BehaviorSeverity::High,
            mitre_technique: Some("T1555".to_string()),
        },
        SensitivePath {
            pattern: "vault".to_string(),
            description: "Password vault access".to_string(),
            severity: BehaviorSeverity::Medium,
            mitre_technique: Some("T1555".to_string()),
        },

        // Crypto wallets
        SensitivePath {
            pattern: "wallet.dat".to_string(),
            description: "Cryptocurrency wallet".to_string(),
            severity: BehaviorSeverity::High,
            mitre_technique: Some("T1552".to_string()),
        },

        // Windows persistence locations
        SensitivePath {
            pattern: "\\tasks\\".to_string(),
            description: "Scheduled tasks directory".to_string(),
            severity: BehaviorSeverity::Medium,
            mitre_technique: Some("T1053.005".to_string()),
        },

        // Linux persistence
        SensitivePath {
            pattern: "/etc/cron".to_string(),
            description: "Cron directory".to_string(),
            severity: BehaviorSeverity::Medium,
            mitre_technique: Some("T1053.003".to_string()),
        },
        SensitivePath {
            pattern: "/etc/passwd".to_string(),
            description: "Password file access".to_string(),
            severity: BehaviorSeverity::High,
            mitre_technique: Some("T1087.001".to_string()),
        },
        SensitivePath {
            pattern: "/etc/shadow".to_string(),
            description: "Shadow password file".to_string(),
            severity: BehaviorSeverity::Critical,
            mitre_technique: Some("T1003.008".to_string()),
        },
    ]
}

fn get_suspicious_extensions() -> HashSet<String> {
    vec![
        "exe", "dll", "sys", "scr", "pif", "com", "bat", "cmd",
        "ps1", "vbs", "vbe", "js", "jse", "wsf", "wsh", "hta",
        "cpl", "msi", "msp", "jar", "lnk", "reg",
    ]
    .into_iter()
    .map(String::from)
    .collect()
}

fn get_ransomware_extensions() -> HashSet<String> {
    vec![
        // Common ransomware extensions
        "encrypted", "locked", "crypto", "crypt", "enc",
        "locky", "cerber", "zepto", "odin", "thor",
        "wallet", "dharma", "arena", "cobra", "java",
        "globe", "purge", "sage", "spora", "jaff",
        "wannacry", "wncry", "wcry", "petya", "bad",
        "cryptowall", "cryptolocker", "ctb", "ctb2",
        "gandcrab", "sodinokibi", "revil", "ryuk",
        "conti", "lockbit", "blackcat", "alphv",
        "maze", "egregor", "ragnar", "darkside",
    ]
    .into_iter()
    .map(String::from)
    .collect()
}

fn get_system_directories() -> Vec<String> {
    vec![
        "c:\\windows\\system32".to_string(),
        "c:\\windows\\syswow64".to_string(),
        "c:\\windows\\tasks".to_string(),
        "c:\\program files".to_string(),
        "c:\\program files (x86)".to_string(),
        "/usr/bin".to_string(),
        "/usr/sbin".to_string(),
        "/bin".to_string(),
        "/sbin".to_string(),
        "/etc".to_string(),
        "/lib".to_string(),
        "/lib64".to_string(),
    ]
}

fn parse_file_attributes(attrs: u32) -> FileAttributes {
    FileAttributes {
        readonly: attrs & 0x1 != 0,
        hidden: attrs & 0x2 != 0,
        system: attrs & 0x4 != 0,
        archive: attrs & 0x20 != 0,
        temporary: attrs & 0x100 != 0,
        encrypted: attrs & 0x4000 != 0,
    }
}

fn is_executable_extension(ext: &str) -> bool {
    matches!(ext, "exe" | "dll" | "scr" | "com" | "pif" | "bat" | "cmd" | "ps1" | "vbs" | "js")
}

fn is_document_extension(ext: &str) -> bool {
    matches!(ext, "pdf" | "doc" | "docx" | "xls" | "xlsx" | "ppt" | "pptx" | "txt" | "rtf")
}
