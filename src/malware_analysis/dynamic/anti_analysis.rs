//! Anti-Analysis Detection Module
//!
//! Detects anti-analysis techniques used by malware including:
//! - Debugger detection
//! - Virtual machine detection
//! - Sandbox detection
//! - Timing attacks
//! - Environment checks

use super::types::*;

/// Anti-analysis technique detector
pub struct AntiAnalysisDetector {
    /// API patterns indicating anti-debug
    anti_debug_apis: Vec<AntiAnalysisPattern>,
    /// API patterns indicating VM detection
    anti_vm_apis: Vec<AntiAnalysisPattern>,
    /// API patterns indicating sandbox detection
    anti_sandbox_apis: Vec<AntiAnalysisPattern>,
    /// Registry paths checked for VM detection
    vm_registry_paths: Vec<String>,
    /// Files checked for sandbox detection
    sandbox_files: Vec<String>,
    /// Process names checked for analysis tools
    analysis_processes: Vec<String>,
}

#[derive(Debug, Clone)]
struct AntiAnalysisPattern {
    function: String,
    module: Option<String>,
    description: String,
    anti_type: AntiAnalysisType,
    mitre_technique: String,
    arguments_check: Option<ArgumentsCheck>,
}

#[derive(Debug, Clone)]
enum ArgumentsCheck {
    ProcessInfoClass(u32),
    RegistryContains(String),
    FileContains(String),
}

impl AntiAnalysisDetector {
    pub fn new() -> Self {
        Self {
            anti_debug_apis: get_anti_debug_patterns(),
            anti_vm_apis: get_anti_vm_patterns(),
            anti_sandbox_apis: get_anti_sandbox_patterns(),
            vm_registry_paths: get_vm_registry_paths(),
            sandbox_files: get_sandbox_files(),
            analysis_processes: get_analysis_processes(),
        }
    }

    /// Detect all anti-analysis techniques
    pub fn detect_all(
        &self,
        api_calls: &[ApiCallInfo],
        registry_ops: &[RegistryOperation],
        file_ops: &[FileOperation],
        processes: &[ProcessInfo],
    ) -> Vec<AntiAnalysisTechnique> {
        let mut techniques = Vec::new();

        // Detect from API calls
        techniques.extend(self.detect_from_apis(api_calls));

        // Detect from registry operations
        techniques.extend(self.detect_from_registry(registry_ops));

        // Detect from file operations
        techniques.extend(self.detect_from_files(file_ops));

        // Detect from process enumeration
        techniques.extend(self.detect_from_processes(api_calls, processes));

        // Detect timing attacks
        techniques.extend(self.detect_timing_attacks(api_calls));

        // Deduplicate by type and indicator
        deduplicate_techniques(techniques)
    }

    fn detect_from_apis(&self, api_calls: &[ApiCallInfo]) -> Vec<AntiAnalysisTechnique> {
        let mut techniques = Vec::new();

        for call in api_calls {
            let func_lower = call.function.to_lowercase();
            let module_lower = call.module.to_lowercase();

            // Check anti-debug patterns
            for pattern in &self.anti_debug_apis {
                if func_lower.contains(&pattern.function.to_lowercase()) {
                    if let Some(ref expected_module) = pattern.module {
                        if !module_lower.contains(&expected_module.to_lowercase()) {
                            continue;
                        }
                    }

                    // Check arguments if specified
                    if let Some(ref arg_check) = pattern.arguments_check {
                        if !self.check_arguments(&call.arguments, arg_check) {
                            continue;
                        }
                    }

                    techniques.push(AntiAnalysisTechnique {
                        id: uuid::Uuid::new_v4().to_string(),
                        technique_type: pattern.anti_type.clone(),
                        name: pattern.function.clone(),
                        description: pattern.description.clone(),
                        detected_at: call.timestamp,
                        pid: call.pid,
                        process_name: call.process_name.clone(),
                        indicators: vec![format!("{}!{}", call.module, call.function)],
                        bypassed: false,
                        mitre_technique: Some(pattern.mitre_technique.clone()),
                    });
                }
            }

            // Check anti-VM patterns
            for pattern in &self.anti_vm_apis {
                if func_lower.contains(&pattern.function.to_lowercase()) {
                    if let Some(ref expected_module) = pattern.module {
                        if !module_lower.contains(&expected_module.to_lowercase()) {
                            continue;
                        }
                    }

                    techniques.push(AntiAnalysisTechnique {
                        id: uuid::Uuid::new_v4().to_string(),
                        technique_type: pattern.anti_type.clone(),
                        name: pattern.function.clone(),
                        description: pattern.description.clone(),
                        detected_at: call.timestamp,
                        pid: call.pid,
                        process_name: call.process_name.clone(),
                        indicators: vec![format!("{}!{}", call.module, call.function)],
                        bypassed: false,
                        mitre_technique: Some(pattern.mitre_technique.clone()),
                    });
                }
            }

            // Check anti-sandbox patterns
            for pattern in &self.anti_sandbox_apis {
                if func_lower.contains(&pattern.function.to_lowercase()) {
                    techniques.push(AntiAnalysisTechnique {
                        id: uuid::Uuid::new_v4().to_string(),
                        technique_type: pattern.anti_type.clone(),
                        name: pattern.function.clone(),
                        description: pattern.description.clone(),
                        detected_at: call.timestamp,
                        pid: call.pid,
                        process_name: call.process_name.clone(),
                        indicators: vec![format!("{}!{}", call.module, call.function)],
                        bypassed: false,
                        mitre_technique: Some(pattern.mitre_technique.clone()),
                    });
                }
            }
        }

        techniques
    }

    fn detect_from_registry(&self, registry_ops: &[RegistryOperation]) -> Vec<AntiAnalysisTechnique> {
        let mut techniques = Vec::new();

        for op in registry_ops {
            if !matches!(
                op.operation_type,
                RegistryOperationType::QueryKey | RegistryOperationType::QueryValue
            ) {
                continue;
            }

            let key_lower = op.key_path.to_lowercase();

            // Check VM-related registry queries
            for vm_path in &self.vm_registry_paths {
                if key_lower.contains(&vm_path.to_lowercase()) {
                    techniques.push(AntiAnalysisTechnique {
                        id: uuid::Uuid::new_v4().to_string(),
                        technique_type: AntiAnalysisType::VmDetection,
                        name: "VM Registry Check".to_string(),
                        description: format!("Registry query for VM indicator: {}", vm_path),
                        detected_at: op.timestamp,
                        pid: op.pid,
                        process_name: op.process_name.clone(),
                        indicators: vec![op.key_path.clone()],
                        bypassed: false,
                        mitre_technique: Some("T1497.001".to_string()),
                    });
                }
            }

            // Check for debugger-related registry queries
            if key_lower.contains("debugger") || key_lower.contains("image file execution") {
                techniques.push(AntiAnalysisTechnique {
                    id: uuid::Uuid::new_v4().to_string(),
                    technique_type: AntiAnalysisType::DebuggerDetection,
                    name: "Debugger Registry Check".to_string(),
                    description: "Registry query for debugger settings".to_string(),
                    detected_at: op.timestamp,
                    pid: op.pid,
                    process_name: op.process_name.clone(),
                    indicators: vec![op.key_path.clone()],
                    bypassed: false,
                    mitre_technique: Some("T1622".to_string()),
                });
            }
        }

        techniques
    }

    fn detect_from_files(&self, file_ops: &[FileOperation]) -> Vec<AntiAnalysisTechnique> {
        let mut techniques = Vec::new();

        for op in file_ops {
            if !matches!(
                op.operation_type,
                FileOperationType::Open | FileOperationType::QueryInfo
            ) {
                continue;
            }

            let path_lower = op.path.to_lowercase();

            // Check for sandbox file queries
            for sandbox_file in &self.sandbox_files {
                if path_lower.contains(&sandbox_file.to_lowercase()) {
                    techniques.push(AntiAnalysisTechnique {
                        id: uuid::Uuid::new_v4().to_string(),
                        technique_type: AntiAnalysisType::SandboxDetection,
                        name: "Sandbox File Check".to_string(),
                        description: format!("File access to sandbox indicator: {}", sandbox_file),
                        detected_at: op.timestamp,
                        pid: op.pid,
                        process_name: op.process_name.clone(),
                        indicators: vec![op.path.clone()],
                        bypassed: false,
                        mitre_technique: Some("T1497.001".to_string()),
                    });
                }
            }

            // Check for VM-related file queries
            if path_lower.contains("vmware") || path_lower.contains("virtualbox")
                || path_lower.contains("vbox") || path_lower.contains("qemu")
                || path_lower.contains("xen")
            {
                techniques.push(AntiAnalysisTechnique {
                    id: uuid::Uuid::new_v4().to_string(),
                    technique_type: AntiAnalysisType::VmDetection,
                    name: "VM File Check".to_string(),
                    description: "File access to VM indicator".to_string(),
                    detected_at: op.timestamp,
                    pid: op.pid,
                    process_name: op.process_name.clone(),
                    indicators: vec![op.path.clone()],
                    bypassed: false,
                    mitre_technique: Some("T1497.001".to_string()),
                });
            }
        }

        techniques
    }

    fn detect_from_processes(
        &self,
        api_calls: &[ApiCallInfo],
        _processes: &[ProcessInfo],
    ) -> Vec<AntiAnalysisTechnique> {
        let mut techniques = Vec::new();

        // Look for process enumeration followed by analysis tool checks
        for call in api_calls {
            let func_lower = call.function.to_lowercase();

            if func_lower.contains("createtoolhelp32snapshot")
                || func_lower.contains("enumprocesses")
                || func_lower.contains("process32first")
                || func_lower.contains("process32next")
            {
                // Check if any known analysis tool name appears in arguments
                for arg in &call.arguments {
                    let arg_value = arg.value.to_lowercase();
                    for proc_name in &self.analysis_processes {
                        if arg_value.contains(&proc_name.to_lowercase()) {
                            techniques.push(AntiAnalysisTechnique {
                                id: uuid::Uuid::new_v4().to_string(),
                                technique_type: AntiAnalysisType::ProcessCheck,
                                name: "Analysis Tool Process Check".to_string(),
                                description: format!(
                                    "Checking for analysis tool process: {}",
                                    proc_name
                                ),
                                detected_at: call.timestamp,
                                pid: call.pid,
                                process_name: call.process_name.clone(),
                                indicators: vec![proc_name.clone()],
                                bypassed: false,
                                mitre_technique: Some("T1057".to_string()),
                            });
                        }
                    }
                }
            }
        }

        techniques
    }

    fn detect_timing_attacks(&self, api_calls: &[ApiCallInfo]) -> Vec<AntiAnalysisTechnique> {
        let mut techniques = Vec::new();

        // Look for timing-related API calls that might indicate anti-debug
        let timing_apis = [
            "gettickcount", "queryperformancecounter", "rdtsc",
            "getsystemtime", "getlocaltime", "sleep",
        ];

        let mut timing_calls: Vec<&ApiCallInfo> = api_calls
            .iter()
            .filter(|c| {
                let func_lower = c.function.to_lowercase();
                timing_apis.iter().any(|api| func_lower.contains(api))
            })
            .collect();

        timing_calls.sort_by_key(|c| c.timestamp);

        // Check for suspicious patterns (e.g., multiple timing calls in quick succession)
        if timing_calls.len() >= 3 {
            for window in timing_calls.windows(3) {
                let time_span = window[2].timestamp.signed_duration_since(window[0].timestamp);
                if time_span.num_milliseconds() < 100 {
                    techniques.push(AntiAnalysisTechnique {
                        id: uuid::Uuid::new_v4().to_string(),
                        technique_type: AntiAnalysisType::TimingCheck,
                        name: "Timing Attack".to_string(),
                        description: "Multiple timing API calls in quick succession (potential timing attack)".to_string(),
                        detected_at: window[0].timestamp,
                        pid: window[0].pid,
                        process_name: window[0].process_name.clone(),
                        indicators: window.iter().map(|c| c.function.clone()).collect(),
                        bypassed: false,
                        mitre_technique: Some("T1497.003".to_string()),
                    });
                    break;
                }
            }
        }

        // Check for RDTSC instruction usage (often used for timing-based anti-debug)
        for call in api_calls {
            if call.function.to_lowercase().contains("rdtsc") {
                techniques.push(AntiAnalysisTechnique {
                    id: uuid::Uuid::new_v4().to_string(),
                    technique_type: AntiAnalysisType::TimingCheck,
                    name: "RDTSC Timing Check".to_string(),
                    description: "RDTSC instruction used for timing-based detection".to_string(),
                    detected_at: call.timestamp,
                    pid: call.pid,
                    process_name: call.process_name.clone(),
                    indicators: vec!["RDTSC".to_string()],
                    bypassed: false,
                    mitre_technique: Some("T1497.003".to_string()),
                });
            }
        }

        techniques
    }

    fn check_arguments(&self, arguments: &[ApiArgument], check: &ArgumentsCheck) -> bool {
        match check {
            ArgumentsCheck::ProcessInfoClass(expected_class) => {
                for arg in arguments {
                    if arg.name.to_lowercase().contains("processinfoclass")
                        || arg.name.to_lowercase().contains("class")
                    {
                        if let Ok(class_val) = arg.value.parse::<u32>() {
                            return class_val == *expected_class;
                        }
                    }
                }
                false
            }
            ArgumentsCheck::RegistryContains(pattern) => {
                for arg in arguments {
                    if arg.value.to_lowercase().contains(&pattern.to_lowercase()) {
                        return true;
                    }
                }
                false
            }
            ArgumentsCheck::FileContains(pattern) => {
                for arg in arguments {
                    if arg.value.to_lowercase().contains(&pattern.to_lowercase()) {
                        return true;
                    }
                }
                false
            }
        }
    }

    /// Get statistics about detected anti-analysis techniques
    pub fn get_statistics(&self, techniques: &[AntiAnalysisTechnique]) -> AntiAnalysisStatistics {
        let mut type_counts: std::collections::HashMap<AntiAnalysisType, usize> =
            std::collections::HashMap::new();
        let mut bypassed_count = 0;

        for technique in techniques {
            *type_counts.entry(technique.technique_type.clone()).or_insert(0) += 1;
            if technique.bypassed {
                bypassed_count += 1;
            }
        }

        AntiAnalysisStatistics {
            total_detected: techniques.len(),
            type_distribution: type_counts,
            bypassed_count,
            unique_techniques: techniques
                .iter()
                .map(|t| &t.name)
                .collect::<std::collections::HashSet<_>>()
                .len(),
        }
    }
}

impl Default for AntiAnalysisDetector {
    fn default() -> Self {
        Self::new()
    }
}

#[derive(Debug, Clone)]
pub struct AntiAnalysisStatistics {
    pub total_detected: usize,
    pub type_distribution: std::collections::HashMap<AntiAnalysisType, usize>,
    pub bypassed_count: usize,
    pub unique_techniques: usize,
}

// Helper functions

fn get_anti_debug_patterns() -> Vec<AntiAnalysisPattern> {
    vec![
        AntiAnalysisPattern {
            function: "IsDebuggerPresent".to_string(),
            module: Some("kernel32".to_string()),
            description: "Checks if process is being debugged".to_string(),
            anti_type: AntiAnalysisType::DebuggerDetection,
            mitre_technique: "T1622".to_string(),
            arguments_check: None,
        },
        AntiAnalysisPattern {
            function: "CheckRemoteDebuggerPresent".to_string(),
            module: Some("kernel32".to_string()),
            description: "Checks for remote debugger".to_string(),
            anti_type: AntiAnalysisType::DebuggerDetection,
            mitre_technique: "T1622".to_string(),
            arguments_check: None,
        },
        AntiAnalysisPattern {
            function: "NtQueryInformationProcess".to_string(),
            module: Some("ntdll".to_string()),
            description: "Queries process debug port".to_string(),
            anti_type: AntiAnalysisType::DebuggerDetection,
            mitre_technique: "T1622".to_string(),
            arguments_check: Some(ArgumentsCheck::ProcessInfoClass(7)), // ProcessDebugPort
        },
        AntiAnalysisPattern {
            function: "NtSetInformationThread".to_string(),
            module: Some("ntdll".to_string()),
            description: "Hides thread from debugger".to_string(),
            anti_type: AntiAnalysisType::DebuggerDetection,
            mitre_technique: "T1622".to_string(),
            arguments_check: None,
        },
        AntiAnalysisPattern {
            function: "OutputDebugString".to_string(),
            module: Some("kernel32".to_string()),
            description: "Detects debugger via timing".to_string(),
            anti_type: AntiAnalysisType::DebuggerDetection,
            mitre_technique: "T1622".to_string(),
            arguments_check: None,
        },
        AntiAnalysisPattern {
            function: "NtQuerySystemInformation".to_string(),
            module: Some("ntdll".to_string()),
            description: "Queries system debug information".to_string(),
            anti_type: AntiAnalysisType::DebuggerDetection,
            mitre_technique: "T1622".to_string(),
            arguments_check: None,
        },
        AntiAnalysisPattern {
            function: "CloseHandle".to_string(),
            module: Some("kernel32".to_string()),
            description: "CloseHandle anti-debug (invalid handle)".to_string(),
            anti_type: AntiAnalysisType::DebuggerDetection,
            mitre_technique: "T1622".to_string(),
            arguments_check: None,
        },
    ]
}

fn get_anti_vm_patterns() -> Vec<AntiAnalysisPattern> {
    vec![
        AntiAnalysisPattern {
            function: "GetSystemFirmwareTable".to_string(),
            module: Some("kernel32".to_string()),
            description: "Reads firmware tables for VM detection".to_string(),
            anti_type: AntiAnalysisType::VmDetection,
            mitre_technique: "T1497.001".to_string(),
            arguments_check: None,
        },
        AntiAnalysisPattern {
            function: "EnumSystemFirmwareTables".to_string(),
            module: Some("kernel32".to_string()),
            description: "Enumerates firmware tables for VM detection".to_string(),
            anti_type: AntiAnalysisType::VmDetection,
            mitre_technique: "T1497.001".to_string(),
            arguments_check: None,
        },
        AntiAnalysisPattern {
            function: "SetupDiGetDeviceRegistryProperty".to_string(),
            module: Some("setupapi".to_string()),
            description: "Queries device info for VM detection".to_string(),
            anti_type: AntiAnalysisType::VmDetection,
            mitre_technique: "T1497.001".to_string(),
            arguments_check: None,
        },
        AntiAnalysisPattern {
            function: "GlobalMemoryStatusEx".to_string(),
            module: Some("kernel32".to_string()),
            description: "Checks memory size (VMs often have less)".to_string(),
            anti_type: AntiAnalysisType::VmDetection,
            mitre_technique: "T1497.001".to_string(),
            arguments_check: None,
        },
        AntiAnalysisPattern {
            function: "GetSystemInfo".to_string(),
            module: Some("kernel32".to_string()),
            description: "Checks CPU count (VMs often have fewer)".to_string(),
            anti_type: AntiAnalysisType::VmDetection,
            mitre_technique: "T1497.001".to_string(),
            arguments_check: None,
        },
    ]
}

fn get_anti_sandbox_patterns() -> Vec<AntiAnalysisPattern> {
    vec![
        AntiAnalysisPattern {
            function: "GetCursorPos".to_string(),
            module: Some("user32".to_string()),
            description: "Checks for mouse movement".to_string(),
            anti_type: AntiAnalysisType::UserInteractionCheck,
            mitre_technique: "T1497.001".to_string(),
            arguments_check: None,
        },
        AntiAnalysisPattern {
            function: "GetLastInputInfo".to_string(),
            module: Some("user32".to_string()),
            description: "Checks for user input activity".to_string(),
            anti_type: AntiAnalysisType::UserInteractionCheck,
            mitre_technique: "T1497.001".to_string(),
            arguments_check: None,
        },
        AntiAnalysisPattern {
            function: "GetForegroundWindow".to_string(),
            module: Some("user32".to_string()),
            description: "Checks foreground window".to_string(),
            anti_type: AntiAnalysisType::UserInteractionCheck,
            mitre_technique: "T1497.001".to_string(),
            arguments_check: None,
        },
        AntiAnalysisPattern {
            function: "GetUserName".to_string(),
            module: Some("advapi32".to_string()),
            description: "Checks username for sandbox indicators".to_string(),
            anti_type: AntiAnalysisType::EnvironmentCheck,
            mitre_technique: "T1497.001".to_string(),
            arguments_check: None,
        },
        AntiAnalysisPattern {
            function: "GetComputerName".to_string(),
            module: Some("kernel32".to_string()),
            description: "Checks computer name for sandbox indicators".to_string(),
            anti_type: AntiAnalysisType::EnvironmentCheck,
            mitre_technique: "T1497.001".to_string(),
            arguments_check: None,
        },
    ]
}

fn get_vm_registry_paths() -> Vec<String> {
    vec![
        "vbox".to_string(),
        "vmware".to_string(),
        "virtual".to_string(),
        "qemu".to_string(),
        "xen".to_string(),
        "hyper-v".to_string(),
        "virtualbox".to_string(),
        "parallels".to_string(),
        "bochs".to_string(),
        "vpcvmminiport".to_string(),
        "viocplx".to_string(),
        "virtio".to_string(),
    ]
}

fn get_sandbox_files() -> Vec<String> {
    vec![
        "sample.exe".to_string(),
        "sandbox".to_string(),
        "malware".to_string(),
        "virus".to_string(),
        "cuckoo".to_string(),
        "analysis".to_string(),
        "cuckoomon".to_string(),
        "sbiedll.dll".to_string(),
        "dbghelp.dll".to_string(),
        "api_log.dll".to_string(),
        "pstorec.dll".to_string(),
        "dir_watch.dll".to_string(),
        "wpespy.dll".to_string(),
    ]
}

fn get_analysis_processes() -> Vec<String> {
    vec![
        // Debuggers
        "ollydbg".to_string(),
        "x64dbg".to_string(),
        "x32dbg".to_string(),
        "windbg".to_string(),
        "ida".to_string(),
        "ida64".to_string(),
        "idaq".to_string(),
        "idaq64".to_string(),
        "immunitydebugger".to_string(),

        // Process monitors
        "procmon".to_string(),
        "procexp".to_string(),
        "procmon64".to_string(),
        "procexp64".to_string(),

        // Network monitors
        "wireshark".to_string(),
        "fiddler".to_string(),
        "tcpview".to_string(),

        // Analysis tools
        "regshot".to_string(),
        "autoruns".to_string(),
        "apitrace".to_string(),

        // Sandbox indicators
        "vboxservice".to_string(),
        "vboxtray".to_string(),
        "vmtoolsd".to_string(),
        "vmwaretray".to_string(),
        "vmwareuser".to_string(),
    ]
}

fn deduplicate_techniques(techniques: Vec<AntiAnalysisTechnique>) -> Vec<AntiAnalysisTechnique> {
    let mut seen: std::collections::HashSet<(String, String)> = std::collections::HashSet::new();
    let mut result = Vec::new();

    for technique in techniques {
        let key = (format!("{:?}", technique.technique_type), technique.name.clone());
        if !seen.contains(&key) {
            seen.insert(key);
            result.push(technique);
        }
    }

    result
}
