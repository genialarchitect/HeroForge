//! Network Capture and Analysis
//!
//! Analyzes network activity from dynamic analysis including:
//! - Protocol detection and classification
//! - DNS query analysis and DGA detection
//! - HTTP/HTTPS traffic analysis
//! - TLS fingerprinting (JA3/JA3S)
//! - C2 communication detection
//! - Suspicious connection patterns

use super::types::*;
use super::{RawNetworkEvent, RawHttpData, RawTlsData};
use std::collections::{HashMap, HashSet};
use std::net::Ipv4Addr;

/// Network capture analyzer
pub struct NetworkCaptureAnalyzer {
    /// Known malicious IPs
    known_malicious_ips: HashSet<String>,
    /// Known malicious domains
    known_malicious_domains: HashSet<String>,
    /// Known C2 ports
    known_c2_ports: HashSet<u16>,
    /// DGA detection patterns
    dga_patterns: Vec<DgaPattern>,
    /// Suspicious user agents
    suspicious_user_agents: Vec<String>,
}

#[derive(Debug, Clone)]
struct DgaPattern {
    name: String,
    min_length: usize,
    max_length: usize,
    consonant_ratio_threshold: f64,
    entropy_threshold: f64,
}

impl NetworkCaptureAnalyzer {
    pub fn new() -> Self {
        Self {
            known_malicious_ips: get_known_malicious_ips(),
            known_malicious_domains: get_known_malicious_domains(),
            known_c2_ports: get_known_c2_ports(),
            dga_patterns: get_dga_patterns(),
            suspicious_user_agents: get_suspicious_user_agents(),
        }
    }

    /// Analyze raw network events
    pub fn analyze_network(&self, raw_events: &[RawNetworkEvent]) -> Vec<NetworkActivity> {
        raw_events
            .iter()
            .map(|event| self.analyze_event(event))
            .collect()
    }

    fn analyze_event(&self, event: &RawNetworkEvent) -> NetworkActivity {
        let protocol = self.detect_protocol(event);
        let direction = if event.direction.to_lowercase() == "outbound" {
            NetworkDirection::Outbound
        } else {
            NetworkDirection::Inbound
        };
        let state = self.parse_connection_state(&event.state);

        // Analyze DNS
        let dns_query = if let Some(query) = &event.dns_query {
            let is_dga = self.detect_dga(query);
            let dga_score = if is_dga {
                Some(self.calculate_dga_score(query))
            } else {
                None
            };
            Some(DnsQuery {
                query_name: query.clone(),
                query_type: "A".to_string(),
                resolved_ips: event.dns_response.clone().unwrap_or_default(),
                is_dga,
                dga_score,
            })
        } else {
            None
        };

        // Analyze HTTP
        let http_request = event.http_data.as_ref().map(|http| {
            HttpRequest {
                method: http.method.clone(),
                url: http.url.clone(),
                host: http.host.clone(),
                path: http.path.clone(),
                user_agent: http.headers.get("User-Agent").cloned(),
                headers: http.headers.clone(),
                body_preview: http.body.as_ref().and_then(|b| {
                    String::from_utf8(b.iter().take(500).copied().collect()).ok()
                }),
                body_size: http.body.as_ref().map(|b| b.len() as u64).unwrap_or(0),
                response_code: http.response_code,
                response_body_preview: http.response_body.as_ref().and_then(|b| {
                    String::from_utf8(b.iter().take(500).copied().collect()).ok()
                }),
            }
        });

        // Analyze TLS
        let tls_info = event.tls_data.as_ref().map(|tls| TlsInfo {
            version: tls.version.clone(),
            cipher_suite: tls.cipher_suite.clone(),
            server_name: tls.server_name.clone(),
            certificate_subject: tls.certificate_chain.as_ref()
                .and_then(|chain| chain.first().cloned()),
            certificate_issuer: None,
            ja3_hash: tls.ja3.clone(),
            ja3s_hash: tls.ja3s.clone(),
        });

        // Determine if suspicious
        let (is_suspicious, suspicion_reason) = self.check_suspicious(
            &event.remote_address,
            event.remote_port,
            &dns_query,
            &http_request,
            &tls_info,
        );

        // Create payload preview
        let payload_preview = event.payload.as_ref().and_then(|p| {
            if p.iter().all(|&b| b.is_ascii_graphic() || b.is_ascii_whitespace()) {
                String::from_utf8(p.iter().take(200).copied().collect()).ok()
            } else {
                Some(format!("Binary data ({} bytes): {:02x?}", p.len(), &p[..p.len().min(32)]))
            }
        });

        NetworkActivity {
            id: uuid::Uuid::new_v4().to_string(),
            timestamp: event.timestamp,
            pid: event.pid,
            process_name: event.process_name.clone(),
            protocol,
            local_address: event.local_address.clone(),
            local_port: event.local_port,
            remote_address: event.remote_address.clone(),
            remote_port: event.remote_port,
            direction,
            state,
            bytes_sent: event.bytes_sent,
            bytes_received: event.bytes_received,
            dns_query,
            http_request,
            tls_info,
            payload_preview,
            is_suspicious,
            suspicion_reason,
        }
    }

    fn detect_protocol(&self, event: &RawNetworkEvent) -> NetworkProtocol {
        let proto_lower = event.protocol.to_lowercase();

        // Check explicit protocol
        if proto_lower.contains("tcp") {
            // Check for application layer protocols
            if event.http_data.is_some() {
                if event.tls_data.is_some() || event.remote_port == 443 {
                    return NetworkProtocol::Https;
                }
                return NetworkProtocol::Http;
            }
            if event.dns_query.is_some() || event.remote_port == 53 {
                return NetworkProtocol::Dns;
            }
            match event.remote_port {
                25 | 587 | 465 => return NetworkProtocol::Smtp,
                21 => return NetworkProtocol::Ftp,
                6667 | 6697 => return NetworkProtocol::Irc,
                _ => return NetworkProtocol::Tcp,
            }
        } else if proto_lower.contains("udp") {
            if event.dns_query.is_some() || event.remote_port == 53 {
                return NetworkProtocol::Dns;
            }
            return NetworkProtocol::Udp;
        } else if proto_lower.contains("icmp") {
            return NetworkProtocol::Icmp;
        }

        NetworkProtocol::Other
    }

    fn parse_connection_state(&self, state: &str) -> ConnectionState {
        match state.to_lowercase().as_str() {
            "connecting" | "syn_sent" => ConnectionState::Connecting,
            "connected" | "established" => ConnectionState::Connected,
            "listening" | "listen" => ConnectionState::Listening,
            "closed" | "close_wait" | "time_wait" | "fin_wait" => ConnectionState::Closed,
            _ => ConnectionState::Failed,
        }
    }

    fn detect_dga(&self, domain: &str) -> bool {
        // Skip known legitimate domains
        if is_known_legitimate_domain(domain) {
            return false;
        }

        // Get the domain without TLD
        let domain_parts: Vec<&str> = domain.split('.').collect();
        if domain_parts.len() < 2 {
            return false;
        }

        let main_part = domain_parts[0];

        // Check length
        if main_part.len() < 8 || main_part.len() > 32 {
            return self.check_dga_patterns(main_part);
        }

        // Calculate entropy
        let entropy = calculate_string_entropy(main_part);
        if entropy > 3.5 {
            return true;
        }

        // Check consonant ratio
        let consonant_ratio = calculate_consonant_ratio(main_part);
        if consonant_ratio > 0.7 {
            return true;
        }

        // Check for number patterns
        let digit_ratio = main_part.chars().filter(|c| c.is_ascii_digit()).count() as f64
            / main_part.len() as f64;
        if digit_ratio > 0.4 {
            return true;
        }

        self.check_dga_patterns(main_part)
    }

    fn check_dga_patterns(&self, domain: &str) -> bool {
        for pattern in &self.dga_patterns {
            if domain.len() >= pattern.min_length && domain.len() <= pattern.max_length {
                let entropy = calculate_string_entropy(domain);
                let consonant_ratio = calculate_consonant_ratio(domain);

                if entropy > pattern.entropy_threshold
                    && consonant_ratio > pattern.consonant_ratio_threshold
                {
                    return true;
                }
            }
        }
        false
    }

    fn calculate_dga_score(&self, domain: &str) -> f64 {
        let entropy = calculate_string_entropy(domain);
        let consonant_ratio = calculate_consonant_ratio(domain);
        let length_score = if domain.len() > 15 { 0.2 } else { 0.0 };
        let digit_score = domain.chars().filter(|c| c.is_ascii_digit()).count() as f64
            / domain.len() as f64 * 0.3;

        ((entropy / 4.0) * 0.4 + consonant_ratio * 0.3 + length_score + digit_score).min(1.0)
    }

    fn check_suspicious(
        &self,
        remote_ip: &str,
        remote_port: u16,
        dns: &Option<DnsQuery>,
        http: &Option<HttpRequest>,
        tls: &Option<TlsInfo>,
    ) -> (bool, Option<String>) {
        // Check for known malicious IP
        if self.known_malicious_ips.contains(remote_ip) {
            return (true, Some("Known malicious IP address".to_string()));
        }

        // Check for C2 ports
        if self.known_c2_ports.contains(&remote_port) {
            return (true, Some(format!("Connection to known C2 port {}", remote_port)));
        }

        // Check DNS
        if let Some(dns_query) = dns {
            if dns_query.is_dga {
                return (true, Some("DGA domain detected".to_string()));
            }
            if self.known_malicious_domains.contains(&dns_query.query_name.to_lowercase()) {
                return (true, Some("Known malicious domain".to_string()));
            }
        }

        // Check HTTP
        if let Some(http_req) = http {
            // Check for suspicious user agents
            if let Some(ua) = &http_req.user_agent {
                for suspicious_ua in &self.suspicious_user_agents {
                    if ua.to_lowercase().contains(&suspicious_ua.to_lowercase()) {
                        return (true, Some(format!("Suspicious user agent: {}", suspicious_ua)));
                    }
                }
            }

            // Check for exfiltration patterns
            if http_req.method == "POST" && http_req.body_size > 10000 {
                return (true, Some("Large POST data (potential exfiltration)".to_string()));
            }

            // Check for encoded payloads
            if let Some(body) = &http_req.body_preview {
                if body.contains("base64") || body.contains("powershell") {
                    return (true, Some("Encoded payload in request".to_string()));
                }
            }
        }

        // Check for non-standard TLS ports
        if tls.is_some() && remote_port != 443 && remote_port != 8443 {
            return (true, Some(format!("TLS on non-standard port {}", remote_port)));
        }

        // Check for connections to private IPs that might be lateral movement
        if is_private_ip(remote_ip) && !is_local_ip(remote_ip) {
            if remote_port == 445 || remote_port == 135 || remote_port == 3389 {
                return (true, Some("Potential lateral movement attempt".to_string()));
            }
        }

        (false, None)
    }

    /// Get network statistics
    pub fn get_statistics(&self, activities: &[NetworkActivity]) -> NetworkStatistics {
        let mut protocol_counts: HashMap<NetworkProtocol, usize> = HashMap::new();
        let mut unique_ips: HashSet<String> = HashSet::new();
        let mut unique_domains: HashSet<String> = HashSet::new();
        let mut total_bytes_sent: u64 = 0;
        let mut total_bytes_received: u64 = 0;
        let mut suspicious_count = 0;
        let mut dga_domains: Vec<String> = Vec::new();

        for activity in activities {
            *protocol_counts.entry(activity.protocol.clone()).or_insert(0) += 1;
            unique_ips.insert(activity.remote_address.clone());
            total_bytes_sent += activity.bytes_sent;
            total_bytes_received += activity.bytes_received;

            if activity.is_suspicious {
                suspicious_count += 1;
            }

            if let Some(dns) = &activity.dns_query {
                unique_domains.insert(dns.query_name.clone());
                if dns.is_dga {
                    dga_domains.push(dns.query_name.clone());
                }
            }

            if let Some(http) = &activity.http_request {
                unique_domains.insert(http.host.clone());
            }
        }

        NetworkStatistics {
            total_connections: activities.len(),
            protocol_distribution: protocol_counts,
            unique_ips: unique_ips.len(),
            unique_domains: unique_domains.len(),
            total_bytes_sent,
            total_bytes_received,
            suspicious_connections: suspicious_count,
            dga_domains_detected: dga_domains.len(),
            dga_domains,
        }
    }

    /// Detect beaconing behavior
    pub fn detect_beaconing(&self, activities: &[NetworkActivity]) -> Vec<BeaconingIndicator> {
        let mut indicators = Vec::new();

        // Group connections by remote endpoint
        let mut endpoint_timings: HashMap<String, Vec<i64>> = HashMap::new();

        for activity in activities {
            if activity.direction == NetworkDirection::Outbound {
                let key = format!("{}:{}", activity.remote_address, activity.remote_port);
                endpoint_timings
                    .entry(key)
                    .or_default()
                    .push(activity.timestamp.timestamp());
            }
        }

        // Analyze timing patterns
        for (endpoint, timings) in endpoint_timings {
            if timings.len() < 3 {
                continue;
            }

            let intervals: Vec<i64> = timings.windows(2)
                .map(|w| w[1] - w[0])
                .collect();

            if intervals.is_empty() {
                continue;
            }

            let avg_interval = intervals.iter().sum::<i64>() as f64 / intervals.len() as f64;
            let variance: f64 = intervals.iter()
                .map(|&i| (i as f64 - avg_interval).powi(2))
                .sum::<f64>() / intervals.len() as f64;
            let std_dev = variance.sqrt();

            // Low variance indicates regular beaconing
            let jitter = std_dev / avg_interval;

            if jitter < 0.2 && avg_interval > 10.0 && avg_interval < 3600.0 {
                indicators.push(BeaconingIndicator {
                    endpoint: endpoint.clone(),
                    connection_count: timings.len(),
                    average_interval_seconds: avg_interval as u64,
                    jitter_percentage: jitter * 100.0,
                    confidence: calculate_beacon_confidence(jitter, timings.len(), avg_interval),
                });
            }
        }

        indicators.sort_by(|a, b| b.confidence.partial_cmp(&a.confidence).unwrap_or(std::cmp::Ordering::Equal));
        indicators
    }
}

impl Default for NetworkCaptureAnalyzer {
    fn default() -> Self {
        Self::new()
    }
}

#[derive(Debug, Clone)]
pub struct NetworkStatistics {
    pub total_connections: usize,
    pub protocol_distribution: HashMap<NetworkProtocol, usize>,
    pub unique_ips: usize,
    pub unique_domains: usize,
    pub total_bytes_sent: u64,
    pub total_bytes_received: u64,
    pub suspicious_connections: usize,
    pub dga_domains_detected: usize,
    pub dga_domains: Vec<String>,
}

#[derive(Debug, Clone)]
pub struct BeaconingIndicator {
    pub endpoint: String,
    pub connection_count: usize,
    pub average_interval_seconds: u64,
    pub jitter_percentage: f64,
    pub confidence: f64,
}

// Helper functions

fn get_known_malicious_ips() -> HashSet<String> {
    // In production, this would be loaded from threat intel feeds
    HashSet::new()
}

fn get_known_malicious_domains() -> HashSet<String> {
    // In production, this would be loaded from threat intel feeds
    HashSet::new()
}

fn get_known_c2_ports() -> HashSet<u16> {
    vec![
        4444, 4445, 5555, 6666, 7777, 8888, 9999,  // Common RAT ports
        1337, 31337,                                // Leet ports
        6667, 6697,                                 // IRC
        3389,                                       // RDP (unusual as C2)
    ]
    .into_iter()
    .collect()
}

fn get_dga_patterns() -> Vec<DgaPattern> {
    vec![
        DgaPattern {
            name: "High Entropy DGA".to_string(),
            min_length: 12,
            max_length: 32,
            consonant_ratio_threshold: 0.6,
            entropy_threshold: 3.5,
        },
        DgaPattern {
            name: "Alphanumeric DGA".to_string(),
            min_length: 8,
            max_length: 20,
            consonant_ratio_threshold: 0.5,
            entropy_threshold: 3.2,
        },
    ]
}

fn get_suspicious_user_agents() -> Vec<String> {
    vec![
        "Python-urllib".to_string(),
        "curl/".to_string(),
        "wget/".to_string(),
        "PowerShell".to_string(),
        "Cobalt".to_string(),
        "Meterpreter".to_string(),
        "MINILSO".to_string(),
    ]
}

fn is_known_legitimate_domain(domain: &str) -> bool {
    let legitimate = [
        "google.com", "microsoft.com", "windows.com", "windowsupdate.com",
        "digicert.com", "symantec.com", "verisign.com", "amazonaws.com",
        "cloudflare.com", "akamai.com", "cloudfront.net", "azure.com",
        "apple.com", "facebook.com", "twitter.com", "github.com",
        "youtube.com", "linkedin.com", "office.com", "live.com",
    ];

    legitimate.iter().any(|l| domain.ends_with(l))
}

fn calculate_string_entropy(s: &str) -> f64 {
    let mut freq: HashMap<char, usize> = HashMap::new();
    for c in s.chars() {
        *freq.entry(c).or_insert(0) += 1;
    }

    let len = s.len() as f64;
    freq.values()
        .map(|&count| {
            let p = count as f64 / len;
            -p * p.log2()
        })
        .sum()
}

fn calculate_consonant_ratio(s: &str) -> f64 {
    let consonants = "bcdfghjklmnpqrstvwxyz";
    let consonant_count = s.to_lowercase()
        .chars()
        .filter(|c| consonants.contains(*c))
        .count();

    if s.is_empty() {
        0.0
    } else {
        consonant_count as f64 / s.len() as f64
    }
}

fn is_private_ip(ip: &str) -> bool {
    if let Ok(addr) = ip.parse::<Ipv4Addr>() {
        addr.is_private() || addr.is_loopback() || addr.is_link_local()
    } else {
        false
    }
}

fn is_local_ip(ip: &str) -> bool {
    if let Ok(addr) = ip.parse::<Ipv4Addr>() {
        addr.is_loopback() || ip == "127.0.0.1"
    } else {
        false
    }
}

fn calculate_beacon_confidence(jitter: f64, count: usize, avg_interval: f64) -> f64 {
    let jitter_score = (1.0 - jitter * 5.0).max(0.0); // Low jitter = high score
    let count_score = (count as f64 / 20.0).min(1.0);  // More samples = higher confidence
    let interval_score = if avg_interval >= 30.0 && avg_interval <= 900.0 {
        1.0
    } else {
        0.5
    };

    (jitter_score * 0.5 + count_score * 0.3 + interval_score * 0.2) * 100.0
}
