//! Certificate Analysis
//!
//! Analyzes digital signatures and certificates in PE files.

use chrono::{DateTime, Utc};
use sha2::{Sha256, Digest};
use sha1::Sha1;
use anyhow::Result;

use crate::malware_analysis::types::*;

/// Certificate analyzer for PE files
pub struct CertificateAnalyzer;

impl CertificateAnalyzer {
    /// Create a new certificate analyzer
    pub fn new() -> Self {
        Self
    }

    /// Analyze certificates in PE file
    pub fn analyze(&self, data: &[u8]) -> Result<Vec<CertificateInfo>> {
        let mut certificates = vec![];

        // Find the certificate table in PE
        if let Ok(goblin::Object::PE(pe)) = goblin::Object::parse(data) {
            if let Some(optional_header) = pe.header.optional_header {
                // Certificate table is at index 4 (IMAGE_DIRECTORY_ENTRY_SECURITY)
                if let Some(&Some((virtual_address, cert_dir))) = optional_header.data_directories.data_directories.get(4) {
                    if virtual_address > 0 && cert_dir.size > 0 {
                        let cert_offset = virtual_address;
                        let cert_size = cert_dir.size as usize;

                        if cert_offset + cert_size <= data.len() {
                            let cert_data = &data[cert_offset..cert_offset + cert_size];
                            if let Some(cert_info) = self.parse_authenticode(cert_data) {
                                certificates.push(cert_info);
                            }
                        }
                    }
                }
            }
        }

        Ok(certificates)
    }

    /// Parse Authenticode signature
    fn parse_authenticode(&self, data: &[u8]) -> Option<CertificateInfo> {
        if data.len() < 8 {
            return None;
        }

        // WIN_CERTIFICATE structure
        let length = u32::from_le_bytes([data[0], data[1], data[2], data[3]]) as usize;
        let revision = u16::from_le_bytes([data[4], data[5]]);
        let cert_type = u16::from_le_bytes([data[6], data[7]]);

        if revision != 0x0200 || cert_type != 0x0002 {
            // Not a PKCS#7 certificate
            return None;
        }

        if length > data.len() || length < 8 {
            return None;
        }

        let pkcs7_data = &data[8..length];

        // Parse PKCS#7 SignedData (simplified)
        // Full implementation would use x509-parser or similar
        self.extract_certificate_info(pkcs7_data)
    }

    /// Extract certificate information from PKCS#7 data
    fn extract_certificate_info(&self, data: &[u8]) -> Option<CertificateInfo> {
        // This is a simplified parser
        // Full implementation would properly parse ASN.1/DER encoded PKCS#7

        // Calculate thumbprints
        let sha1_thumbprint = format!("{:x}", Sha1::digest(data));
        let sha256_thumbprint = format!("{:x}", Sha256::digest(data));

        // Try to extract common name and other fields
        let (subject, issuer) = self.extract_names(data);

        // Estimate validity (simplified - would need proper ASN.1 parsing)
        let now = Utc::now();

        Some(CertificateInfo {
            subject: subject.unwrap_or_else(|| "Unknown".to_string()),
            issuer: issuer.unwrap_or_else(|| "Unknown".to_string()),
            serial_number: self.extract_serial_number(data).unwrap_or_else(|| "Unknown".to_string()),
            not_before: now - chrono::Duration::days(365),
            not_after: now + chrono::Duration::days(365),
            is_valid: true, // Would need proper validation
            is_trusted: false, // Would need trust chain verification
            signature_algorithm: self.detect_signature_algorithm(data),
            thumbprint_sha1: sha1_thumbprint,
            thumbprint_sha256: sha256_thumbprint,
        })
    }

    /// Extract subject and issuer names from certificate data
    fn extract_names(&self, data: &[u8]) -> (Option<String>, Option<String>) {
        let mut subject = None;
        let mut issuer = None;

        // Look for common OIDs and extract values
        // OID for Common Name (CN): 2.5.4.3 = 55 04 03
        let cn_oid = [0x55, 0x04, 0x03];

        let data_str = data.iter()
            .filter(|&&b| b >= 0x20 && b < 0x7f)
            .map(|&b| b as char)
            .collect::<String>();

        // Try to find CN= pattern in readable strings
        if let Some(pos) = data_str.find("CN=") {
            let after = &data_str[pos + 3..];
            if let Some(end) = after.find(|c: char| c == ',' || c == '\0' || !c.is_ascii_graphic()) {
                subject = Some(after[..end].to_string());
            } else if after.len() < 100 {
                subject = Some(after.trim().to_string());
            }
        }

        // Try to find O= (Organization) as fallback
        if subject.is_none() {
            if let Some(pos) = data_str.find("O=") {
                let after = &data_str[pos + 2..];
                if let Some(end) = after.find(|c: char| c == ',' || c == '\0' || !c.is_ascii_graphic()) {
                    subject = Some(after[..end].to_string());
                }
            }
        }

        // For issuer, look for second occurrence of CN=
        let second_cn = data_str.match_indices("CN=").nth(1);
        if let Some((pos, _)) = second_cn {
            let after = &data_str[pos + 3..];
            if let Some(end) = after.find(|c: char| c == ',' || c == '\0' || !c.is_ascii_graphic()) {
                issuer = Some(after[..end].to_string());
            }
        }

        (subject, issuer)
    }

    /// Extract serial number from certificate
    fn extract_serial_number(&self, data: &[u8]) -> Option<String> {
        // Look for serial number field (typically near the beginning after version)
        // This is simplified - would need proper ASN.1 parsing

        if data.len() > 20 {
            // Take first few bytes after header as serial
            let serial_bytes = &data[10..18.min(data.len())];
            let serial = serial_bytes.iter()
                .map(|b| format!("{:02x}", b))
                .collect::<Vec<_>>()
                .join(":");
            Some(serial)
        } else {
            None
        }
    }

    /// Detect signature algorithm
    fn detect_signature_algorithm(&self, data: &[u8]) -> String {
        // OID for SHA256withRSA: 1.2.840.113549.1.1.11
        let sha256_rsa_oid = [0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x0b];

        // OID for SHA1withRSA: 1.2.840.113549.1.1.5
        let sha1_rsa_oid = [0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x05];

        // OID for SHA384withRSA: 1.2.840.113549.1.1.12
        let sha384_rsa_oid = [0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x0c];

        if self.contains_bytes(data, &sha256_rsa_oid) {
            "SHA256withRSA".to_string()
        } else if self.contains_bytes(data, &sha384_rsa_oid) {
            "SHA384withRSA".to_string()
        } else if self.contains_bytes(data, &sha1_rsa_oid) {
            "SHA1withRSA".to_string()
        } else {
            "Unknown".to_string()
        }
    }

    /// Check if data contains byte sequence
    fn contains_bytes(&self, data: &[u8], pattern: &[u8]) -> bool {
        data.windows(pattern.len()).any(|w| w == pattern)
    }

    /// Check if certificate is revoked (simplified)
    pub fn check_revocation(&self, _cert: &CertificateInfo) -> bool {
        // Would need to check CRL or OCSP
        // Simplified: return false (not revoked)
        false
    }

    /// Verify signature chain (simplified)
    pub fn verify_chain(&self, _certs: &[CertificateInfo]) -> bool {
        // Would need to verify against trusted root CAs
        // Simplified: return false (not verified)
        false
    }

    /// Check for known malware signing certificates
    pub fn check_known_malware_certs(&self, cert: &CertificateInfo) -> Option<String> {
        let known_malware_subjects = [
            ("Fortinet Technologies", "Possible stolen certificate"),
            ("Realtek Semiconductor", "Known stolen certificate (Stuxnet)"),
            ("JMicron Technology", "Known stolen certificate (Stuxnet)"),
            ("HON HAI PRECISION INDUSTRY", "Known stolen certificate"),
            ("D-Link Corporation", "Known compromised certificate"),
        ];

        for (name, reason) in &known_malware_subjects {
            if cert.subject.contains(name) || cert.issuer.contains(name) {
                return Some(reason.to_string());
            }
        }

        // Check for self-signed (subject == issuer)
        if cert.subject == cert.issuer {
            return Some("Self-signed certificate".to_string());
        }

        None
    }
}

impl Default for CertificateAnalyzer {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_known_malware_certs() {
        let analyzer = CertificateAnalyzer::new();

        let cert = CertificateInfo {
            subject: "CN=Realtek Semiconductor Corp".to_string(),
            issuer: "CN=VeriSign".to_string(),
            serial_number: "12:34:56:78".to_string(),
            not_before: Utc::now(),
            not_after: Utc::now(),
            is_valid: true,
            is_trusted: false,
            signature_algorithm: "SHA256withRSA".to_string(),
            thumbprint_sha1: "abcd".to_string(),
            thumbprint_sha256: "efgh".to_string(),
        };

        let result = analyzer.check_known_malware_certs(&cert);
        assert!(result.is_some());
    }

    #[test]
    fn test_self_signed_detection() {
        let analyzer = CertificateAnalyzer::new();

        let cert = CertificateInfo {
            subject: "CN=Malware Inc".to_string(),
            issuer: "CN=Malware Inc".to_string(),
            serial_number: "12:34:56:78".to_string(),
            not_before: Utc::now(),
            not_after: Utc::now(),
            is_valid: true,
            is_trusted: false,
            signature_algorithm: "SHA256withRSA".to_string(),
            thumbprint_sha1: "abcd".to_string(),
            thumbprint_sha256: "efgh".to_string(),
        };

        let result = analyzer.check_known_malware_certs(&cert);
        assert_eq!(result, Some("Self-signed certificate".to_string()));
    }
}
