//! Certificate Analysis
//!
//! Analyzes digital signatures and certificates in PE files.

use chrono::{DateTime, Utc};
use sha2::{Sha256, Digest};
use sha1::Sha1;
use anyhow::Result;
use base64::Engine;
use std::sync::Arc;
use tokio::sync::RwLock;
use std::collections::HashMap;

use crate::malware_analysis::types::*;

/// Global CRL cache
static CRL_CACHE: std::sync::OnceLock<Arc<RwLock<CrlCache>>> = std::sync::OnceLock::new();

/// CRL cache for revocation checking
#[derive(Default)]
pub struct CrlCache {
    entries: HashMap<String, CrlData>,
    last_update: Option<chrono::DateTime<Utc>>,
}

/// Parsed CRL data
pub struct CrlData {
    pub issuer: String,
    pub revoked_serials: Vec<Vec<u8>>,
    pub next_update: chrono::DateTime<Utc>,
    pub signature_algorithm: String,
}

fn get_crl_cache() -> Arc<RwLock<CrlCache>> {
    CRL_CACHE.get_or_init(|| Arc::new(RwLock::new(CrlCache::default()))).clone()
}

/// Certificate analyzer for PE files
pub struct CertificateAnalyzer;

impl CertificateAnalyzer {
    /// Create a new certificate analyzer
    pub fn new() -> Self {
        Self
    }

    /// Analyze certificates in PE file
    pub fn analyze(&self, data: &[u8]) -> Result<Vec<CertificateInfo>> {
        let mut certificates = vec![];

        // Find the certificate table in PE
        if let Ok(goblin::Object::PE(pe)) = goblin::Object::parse(data) {
            if let Some(optional_header) = pe.header.optional_header {
                // Certificate table is at index 4 (IMAGE_DIRECTORY_ENTRY_SECURITY)
                if let Some(&Some((virtual_address, cert_dir))) = optional_header.data_directories.data_directories.get(4) {
                    if virtual_address > 0 && cert_dir.size > 0 {
                        let cert_offset = virtual_address;
                        let cert_size = cert_dir.size as usize;

                        if cert_offset + cert_size <= data.len() {
                            let cert_data = &data[cert_offset..cert_offset + cert_size];
                            if let Some(cert_info) = self.parse_authenticode(cert_data) {
                                certificates.push(cert_info);
                            }
                        }
                    }
                }
            }
        }

        Ok(certificates)
    }

    /// Parse Authenticode signature
    fn parse_authenticode(&self, data: &[u8]) -> Option<CertificateInfo> {
        if data.len() < 8 {
            return None;
        }

        // WIN_CERTIFICATE structure
        let length = u32::from_le_bytes([data[0], data[1], data[2], data[3]]) as usize;
        let revision = u16::from_le_bytes([data[4], data[5]]);
        let cert_type = u16::from_le_bytes([data[6], data[7]]);

        if revision != 0x0200 || cert_type != 0x0002 {
            // Not a PKCS#7 certificate
            return None;
        }

        if length > data.len() || length < 8 {
            return None;
        }

        let pkcs7_data = &data[8..length];

        // Parse PKCS#7 SignedData (simplified)
        // Full implementation would use x509-parser or similar
        self.extract_certificate_info(pkcs7_data)
    }

    /// Extract certificate information from PKCS#7 data
    fn extract_certificate_info(&self, data: &[u8]) -> Option<CertificateInfo> {
        // This is a simplified parser
        // Full implementation would properly parse ASN.1/DER encoded PKCS#7

        // Calculate thumbprints
        let sha1_thumbprint = format!("{:x}", Sha1::digest(data));
        let sha256_thumbprint = format!("{:x}", Sha256::digest(data));

        // Try to extract common name and other fields
        let (subject, issuer) = self.extract_names(data);

        // Estimate validity (simplified - would need proper ASN.1 parsing)
        let now = Utc::now();

        Some(CertificateInfo {
            subject: subject.unwrap_or_else(|| "Unknown".to_string()),
            issuer: issuer.unwrap_or_else(|| "Unknown".to_string()),
            serial_number: self.extract_serial_number(data).unwrap_or_else(|| "Unknown".to_string()),
            not_before: now - chrono::Duration::days(365),
            not_after: now + chrono::Duration::days(365),
            is_valid: true, // Would need proper validation
            is_trusted: false, // Would need trust chain verification
            signature_algorithm: self.detect_signature_algorithm(data),
            thumbprint_sha1: sha1_thumbprint,
            thumbprint_sha256: sha256_thumbprint,
        })
    }

    /// Extract subject and issuer names from certificate data
    fn extract_names(&self, data: &[u8]) -> (Option<String>, Option<String>) {
        let mut subject = None;
        let mut issuer = None;

        // Look for common OIDs and extract values
        // OID for Common Name (CN): 2.5.4.3 = 55 04 03
        let cn_oid = [0x55, 0x04, 0x03];

        let data_str = data.iter()
            .filter(|&&b| b >= 0x20 && b < 0x7f)
            .map(|&b| b as char)
            .collect::<String>();

        // Try to find CN= pattern in readable strings
        if let Some(pos) = data_str.find("CN=") {
            let after = &data_str[pos + 3..];
            if let Some(end) = after.find(|c: char| c == ',' || c == '\0' || !c.is_ascii_graphic()) {
                subject = Some(after[..end].to_string());
            } else if after.len() < 100 {
                subject = Some(after.trim().to_string());
            }
        }

        // Try to find O= (Organization) as fallback
        if subject.is_none() {
            if let Some(pos) = data_str.find("O=") {
                let after = &data_str[pos + 2..];
                if let Some(end) = after.find(|c: char| c == ',' || c == '\0' || !c.is_ascii_graphic()) {
                    subject = Some(after[..end].to_string());
                }
            }
        }

        // For issuer, look for second occurrence of CN=
        let second_cn = data_str.match_indices("CN=").nth(1);
        if let Some((pos, _)) = second_cn {
            let after = &data_str[pos + 3..];
            if let Some(end) = after.find(|c: char| c == ',' || c == '\0' || !c.is_ascii_graphic()) {
                issuer = Some(after[..end].to_string());
            }
        }

        (subject, issuer)
    }

    /// Extract serial number from certificate
    fn extract_serial_number(&self, data: &[u8]) -> Option<String> {
        // Look for serial number field (typically near the beginning after version)
        // This is simplified - would need proper ASN.1 parsing

        if data.len() > 20 {
            // Take first few bytes after header as serial
            let serial_bytes = &data[10..18.min(data.len())];
            let serial = serial_bytes.iter()
                .map(|b| format!("{:02x}", b))
                .collect::<Vec<_>>()
                .join(":");
            Some(serial)
        } else {
            None
        }
    }

    /// Detect signature algorithm
    fn detect_signature_algorithm(&self, data: &[u8]) -> String {
        // OID for SHA256withRSA: 1.2.840.113549.1.1.11
        let sha256_rsa_oid = [0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x0b];

        // OID for SHA1withRSA: 1.2.840.113549.1.1.5
        let sha1_rsa_oid = [0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x05];

        // OID for SHA384withRSA: 1.2.840.113549.1.1.12
        let sha384_rsa_oid = [0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x0c];

        if self.contains_bytes(data, &sha256_rsa_oid) {
            "SHA256withRSA".to_string()
        } else if self.contains_bytes(data, &sha384_rsa_oid) {
            "SHA384withRSA".to_string()
        } else if self.contains_bytes(data, &sha1_rsa_oid) {
            "SHA1withRSA".to_string()
        } else {
            "Unknown".to_string()
        }
    }

    /// Check if data contains byte sequence
    fn contains_bytes(&self, data: &[u8], pattern: &[u8]) -> bool {
        data.windows(pattern.len()).any(|w| w == pattern)
    }

    /// Check if certificate is revoked via OCSP or CRL
    pub fn check_revocation(&self, cert: &CertificateInfo) -> bool {
        // Try OCSP first (faster), then fall back to CRL
        if let Some(revoked) = self.check_ocsp_revocation(cert) {
            return revoked;
        }

        // Try CRL as fallback
        if let Some(revoked) = self.check_crl_revocation(cert) {
            return revoked;
        }

        // If we can't determine revocation status, assume not revoked
        false
    }

    /// Check certificate revocation via OCSP
    fn check_ocsp_revocation(&self, cert: &CertificateInfo) -> Option<bool> {
        // Build OCSP request
        // OCSP responder URLs are typically in the certificate's AIA extension
        // Common OCSP responder patterns
        let ocsp_responders = [
            "http://ocsp.digicert.com",
            "http://ocsp.comodoca.com",
            "http://ocsp.globalsign.com",
            "http://ocsp.sectigo.com",
            "http://ocsp.entrust.net",
            "http://ocsp.godaddy.com",
            "http://ocsp.verisign.com",
            "http://ocsp.thawte.com",
        ];

        // Build a simple OCSP request structure
        // OCSPRequest ::= SEQUENCE {
        //   tbsRequest TBSRequest,
        //   optionalSignature [0] EXPLICIT Signature OPTIONAL
        // }

        let serial_bytes = cert.serial_number
            .split(':')
            .filter_map(|s| u8::from_str_radix(s, 16).ok())
            .collect::<Vec<u8>>();

        if serial_bytes.is_empty() {
            return None;
        }

        // Create OCSP request (simplified DER encoding)
        let mut ocsp_request = Vec::new();

        // TBSRequest SEQUENCE
        ocsp_request.push(0x30); // SEQUENCE tag
        let mut tbs_request = Vec::new();

        // RequestList SEQUENCE
        tbs_request.push(0x30);
        let mut request_list = Vec::new();

        // Request SEQUENCE
        request_list.push(0x30);
        let mut request = Vec::new();

        // CertID SEQUENCE
        request.push(0x30);
        let mut cert_id = Vec::new();

        // HashAlgorithm (SHA-1)
        cert_id.extend_from_slice(&[0x30, 0x09, 0x06, 0x05, 0x2b, 0x0e, 0x03, 0x02, 0x1a, 0x05, 0x00]);

        // IssuerNameHash (placeholder - would compute SHA-1 of issuer name)
        let issuer_hash = sha1_hash(cert.issuer.as_bytes());
        cert_id.push(0x04);
        cert_id.push(issuer_hash.len() as u8);
        cert_id.extend_from_slice(&issuer_hash);

        // IssuerKeyHash (placeholder - would compute SHA-1 of issuer public key)
        let key_hash = sha1_hash(cert.issuer.as_bytes()); // Simplified
        cert_id.push(0x04);
        cert_id.push(key_hash.len() as u8);
        cert_id.extend_from_slice(&key_hash);

        // SerialNumber
        cert_id.push(0x02);
        cert_id.push(serial_bytes.len() as u8);
        cert_id.extend_from_slice(&serial_bytes);

        request.push(cert_id.len() as u8);
        request.extend_from_slice(&cert_id);

        request_list.push(request.len() as u8);
        request_list.extend_from_slice(&request);

        tbs_request.push(request_list.len() as u8);
        tbs_request.extend_from_slice(&request_list);

        ocsp_request.push(tbs_request.len() as u8);
        ocsp_request.extend_from_slice(&tbs_request);

        // Try each OCSP responder
        for responder in &ocsp_responders {
            if let Some(response) = self.send_ocsp_request(responder, &ocsp_request) {
                // Parse OCSP response
                // OCSPResponse ::= SEQUENCE {
                //   responseStatus OCSPResponseStatus,
                //   responseBytes [0] EXPLICIT ResponseBytes OPTIONAL
                // }

                if response.len() > 6 {
                    // Check responseStatus (0 = successful)
                    if response[2] == 0x0a && response[4] == 0x00 {
                        // Parse response bytes for certificate status
                        // Look for certStatus field:
                        // good [0] IMPLICIT NULL
                        // revoked [1] IMPLICIT RevokedInfo
                        // unknown [2] IMPLICIT UnknownInfo

                        for i in 0..response.len().saturating_sub(2) {
                            match response[i] {
                                0x80 => return Some(false), // good
                                0xa1 => return Some(true),  // revoked
                                0x82 => continue,           // unknown, try next
                                _ => continue,
                            }
                        }
                    }
                }
            }
        }

        None
    }

    /// Send OCSP request to responder (synchronous wrapper using tokio runtime)
    fn send_ocsp_request(&self, responder_url: &str, request: &[u8]) -> Option<Vec<u8>> {
        let request_clone = request.to_vec();
        let url = responder_url.to_string();

        // Use tokio's Handle to run async code in sync context
        let handle = tokio::runtime::Handle::try_current();

        match handle {
            Ok(handle) => {
                // We're inside a tokio runtime, use block_in_place
                tokio::task::block_in_place(|| {
                    handle.block_on(async {
                        let client = reqwest::Client::builder()
                            .timeout(std::time::Duration::from_secs(10))
                            .build()
                            .ok()?;

                        let response = client
                            .post(&url)
                            .header("Content-Type", "application/ocsp-request")
                            .body(request_clone)
                            .send()
                            .await
                            .ok()?;

                        if response.status().is_success() {
                            response.bytes().await.ok().map(|b| b.to_vec())
                        } else {
                            None
                        }
                    })
                })
            }
            Err(_) => {
                // Not in tokio runtime, create a temporary one
                let rt = tokio::runtime::Runtime::new().ok()?;
                rt.block_on(async {
                    let client = reqwest::Client::builder()
                        .timeout(std::time::Duration::from_secs(10))
                        .build()
                        .ok()?;

                    let response = client
                        .post(&url)
                        .header("Content-Type", "application/ocsp-request")
                        .body(request_clone)
                        .send()
                        .await
                        .ok()?;

                    if response.status().is_success() {
                        response.bytes().await.ok().map(|b| b.to_vec())
                    } else {
                        None
                    }
                })
            }
        }
    }

    /// Send OCSP request to responder (async version)
    pub async fn send_ocsp_request_async(&self, responder_url: &str, request: &[u8]) -> Option<Vec<u8>> {
        let client = reqwest::Client::builder()
            .timeout(std::time::Duration::from_secs(10))
            .build()
            .ok()?;

        let response = client
            .post(responder_url)
            .header("Content-Type", "application/ocsp-request")
            .body(request.to_vec())
            .send()
            .await
            .ok()?;

        if response.status().is_success() {
            response.bytes().await.ok().map(|b| b.to_vec())
        } else {
            None
        }
    }

    /// Check certificate revocation via CRL
    fn check_crl_revocation(&self, cert: &CertificateInfo) -> Option<bool> {
        let serial_bytes = cert.serial_number
            .split(':')
            .filter_map(|s| u8::from_str_radix(s, 16).ok())
            .collect::<Vec<u8>>();

        if serial_bytes.is_empty() {
            return None;
        }

        // Check local CRL cache
        let cache = get_crl_cache();

        // Try to read from cache (blocking)
        if let Ok(guard) = cache.try_read() {
            if let Some(crl_data) = guard.entries.get(&cert.issuer) {
                // Check if CRL is still valid
                if crl_data.next_update > Utc::now() {
                    for revoked in &crl_data.revoked_serials {
                        if revoked == &serial_bytes {
                            return Some(true);
                        }
                    }
                    return Some(false);
                }
            }
        }

        // Try to fetch CRL from known distribution points
        if let Some(revoked) = self.fetch_and_check_crl(&cert.issuer, &serial_bytes) {
            return Some(revoked);
        }

        None
    }

    /// Fetch CRL from distribution point and check for serial
    fn fetch_and_check_crl(&self, issuer: &str, serial_bytes: &[u8]) -> Option<bool> {
        // Known CRL distribution points for major CAs
        let crl_urls: Vec<(&str, &str)> = vec![
            ("DigiCert", "http://crl3.digicert.com/DigiCertGlobalRootCA.crl"),
            ("Comodo", "http://crl.comodoca.com/COMODORSACertificationAuthority.crl"),
            ("Sectigo", "http://crl.sectigo.com/SectigoRSADomainValidationSecureServerCA.crl"),
            ("GlobalSign", "http://crl.globalsign.com/root.crl"),
            ("Let's Encrypt", "http://crl.identrust.com/DSTROOTCAX3CRL.crl"),
            ("GoDaddy", "http://crl.godaddy.com/gdroot-g2.crl"),
            ("Amazon", "http://crl.rootca1.amazontrust.com/rootca1.crl"),
            ("Entrust", "http://crl.entrust.net/rootca1.crl"),
        ];

        let issuer_lower = issuer.to_lowercase();

        for (ca_name, crl_url) in &crl_urls {
            if issuer_lower.contains(&ca_name.to_lowercase()) {
                if let Some(crl_data) = self.download_crl(crl_url) {
                    // Update cache
                    if let Ok(cache) = get_crl_cache().try_write() {
                        let mut cache = cache;
                        cache.entries.insert(
                            issuer.to_string(),
                            CrlData {
                                issuer: issuer.to_string(),
                                revoked_serials: crl_data.clone(),
                                next_update: Utc::now() + chrono::Duration::hours(24),
                                signature_algorithm: "SHA256withRSA".to_string(),
                            },
                        );
                        cache.last_update = Some(Utc::now());
                    }

                    // Check if serial is in revoked list
                    for revoked in &crl_data {
                        if revoked == serial_bytes {
                            return Some(true);
                        }
                    }
                    return Some(false);
                }
            }
        }

        None
    }

    /// Download and parse CRL from URL (synchronous wrapper)
    fn download_crl(&self, crl_url: &str) -> Option<Vec<Vec<u8>>> {
        let url = crl_url.to_string();

        let handle = tokio::runtime::Handle::try_current();

        match handle {
            Ok(handle) => {
                tokio::task::block_in_place(|| {
                    handle.block_on(async {
                        let client = reqwest::Client::builder()
                            .timeout(std::time::Duration::from_secs(30))
                            .build()
                            .ok()?;

                        let response = client.get(&url).send().await.ok()?;

                        if !response.status().is_success() {
                            return None;
                        }

                        let crl_bytes = response.bytes().await.ok()?;
                        self.parse_crl(&crl_bytes)
                    })
                })
            }
            Err(_) => {
                let rt = tokio::runtime::Runtime::new().ok()?;
                rt.block_on(async {
                    let client = reqwest::Client::builder()
                        .timeout(std::time::Duration::from_secs(30))
                        .build()
                        .ok()?;

                    let response = client.get(&url).send().await.ok()?;

                    if !response.status().is_success() {
                        return None;
                    }

                    let crl_bytes = response.bytes().await.ok()?;
                    self.parse_crl(&crl_bytes)
                })
            }
        }
    }

    /// Download CRL async
    pub async fn download_crl_async(&self, crl_url: &str) -> Option<Vec<Vec<u8>>> {
        let client = reqwest::Client::builder()
            .timeout(std::time::Duration::from_secs(30))
            .build()
            .ok()?;

        let response = client.get(crl_url).send().await.ok()?;

        if !response.status().is_success() {
            return None;
        }

        let crl_bytes = response.bytes().await.ok()?;
        self.parse_crl(&crl_bytes)
    }

    /// Parse CRL (X.509 CRL format - DER encoded)
    fn parse_crl(&self, data: &[u8]) -> Option<Vec<Vec<u8>>> {
        // CRL structure (simplified ASN.1 parsing):
        // CertificateList ::= SEQUENCE {
        //   tbsCertList TBSCertList,
        //   signatureAlgorithm AlgorithmIdentifier,
        //   signatureValue BIT STRING
        // }
        // TBSCertList ::= SEQUENCE {
        //   version Version OPTIONAL,
        //   signature AlgorithmIdentifier,
        //   issuer Name,
        //   thisUpdate Time,
        //   nextUpdate Time OPTIONAL,
        //   revokedCertificates SEQUENCE OF SEQUENCE {
        //     userCertificate CertificateSerialNumber,
        //     revocationDate Time,
        //     crlEntryExtensions Extensions OPTIONAL
        //   } OPTIONAL,
        //   crlExtensions [0] EXPLICIT Extensions OPTIONAL
        // }

        let mut revoked_serials = Vec::new();

        if data.is_empty() || data[0] != 0x30 {
            return None; // Not a valid SEQUENCE
        }

        // Find revokedCertificates section
        // Look for SEQUENCE of SEQUENCE containing INTEGER (serial) + Time
        let mut i = 0;
        while i + 4 < data.len() {
            // Look for SEQUENCE tag
            if data[i] == 0x30 {
                // Check if next element is INTEGER (serial number)
                let len_byte = data[i + 1];
                let (content_start, _content_len) = if len_byte & 0x80 == 0 {
                    (i + 2, len_byte as usize)
                } else {
                    let num_len_bytes = (len_byte & 0x7f) as usize;
                    if i + 2 + num_len_bytes >= data.len() {
                        i += 1;
                        continue;
                    }
                    let mut len = 0usize;
                    for j in 0..num_len_bytes {
                        len = (len << 8) | data[i + 2 + j] as usize;
                    }
                    (i + 2 + num_len_bytes, len)
                };

                // Check if content starts with INTEGER tag (0x02)
                if content_start < data.len() && data[content_start] == 0x02 {
                    // Parse INTEGER (serial number)
                    let int_len = data.get(content_start + 1).copied().unwrap_or(0) as usize;
                    if int_len > 0 && content_start + 2 + int_len <= data.len() {
                        let serial = data[content_start + 2..content_start + 2 + int_len].to_vec();

                        // Verify this looks like a serial (followed by Time tag 0x17 or 0x18)
                        let after_serial = content_start + 2 + int_len;
                        if after_serial < data.len() {
                            let next_tag = data[after_serial];
                            if next_tag == 0x17 || next_tag == 0x18 {
                                // This is likely a valid revoked certificate entry
                                revoked_serials.push(serial);
                            }
                        }
                    }
                }
            }
            i += 1;
        }

        if revoked_serials.is_empty() {
            // No revoked certs found, but parsing succeeded
            Some(Vec::new())
        } else {
            Some(revoked_serials)
        }
    }

    /// Async revocation check combining OCSP and CRL
    pub async fn check_revocation_async(&self, cert: &CertificateInfo) -> bool {
        // Try OCSP first (faster)
        if let Some(ocsp_result) = self.check_ocsp_revocation_async(cert).await {
            return ocsp_result;
        }

        // Fall back to CRL
        if let Some(crl_result) = self.check_crl_revocation_async(cert).await {
            return crl_result;
        }

        // Unknown status - assume not revoked
        false
    }

    /// Async OCSP revocation check
    async fn check_ocsp_revocation_async(&self, cert: &CertificateInfo) -> Option<bool> {
        let ocsp_responders = [
            "http://ocsp.digicert.com",
            "http://ocsp.comodoca.com",
            "http://ocsp.globalsign.com",
            "http://ocsp.sectigo.com",
            "http://ocsp.entrust.net",
            "http://ocsp.godaddy.com",
        ];

        let serial_bytes = cert.serial_number
            .split(':')
            .filter_map(|s| u8::from_str_radix(s, 16).ok())
            .collect::<Vec<u8>>();

        if serial_bytes.is_empty() {
            return None;
        }

        // Build OCSP request
        let ocsp_request = self.build_ocsp_request(cert, &serial_bytes);

        for responder in &ocsp_responders {
            if let Some(response) = self.send_ocsp_request_async(responder, &ocsp_request).await {
                if let Some(status) = self.parse_ocsp_response(&response) {
                    return Some(status);
                }
            }
        }

        None
    }

    /// Async CRL revocation check
    async fn check_crl_revocation_async(&self, cert: &CertificateInfo) -> Option<bool> {
        let serial_bytes = cert.serial_number
            .split(':')
            .filter_map(|s| u8::from_str_radix(s, 16).ok())
            .collect::<Vec<u8>>();

        if serial_bytes.is_empty() {
            return None;
        }

        // Check cache first
        {
            let cache = get_crl_cache();
            let guard = cache.read().await;
            if let Some(crl_data) = guard.entries.get(&cert.issuer) {
                if crl_data.next_update > Utc::now() {
                    for revoked in &crl_data.revoked_serials {
                        if revoked == &serial_bytes {
                            return Some(true);
                        }
                    }
                    return Some(false);
                }
            }
        }

        // Fetch from known CRL distribution points
        let crl_urls: Vec<(&str, &str)> = vec![
            ("DigiCert", "http://crl3.digicert.com/DigiCertGlobalRootCA.crl"),
            ("Comodo", "http://crl.comodoca.com/COMODORSACertificationAuthority.crl"),
            ("Sectigo", "http://crl.sectigo.com/SectigoRSADomainValidationSecureServerCA.crl"),
            ("GlobalSign", "http://crl.globalsign.com/root.crl"),
        ];

        let issuer_lower = cert.issuer.to_lowercase();

        for (ca_name, crl_url) in &crl_urls {
            if issuer_lower.contains(&ca_name.to_lowercase()) {
                if let Some(crl_data) = self.download_crl_async(crl_url).await {
                    // Update cache
                    {
                        let cache = get_crl_cache();
                        let mut guard = cache.write().await;
                        guard.entries.insert(
                            cert.issuer.clone(),
                            CrlData {
                                issuer: cert.issuer.clone(),
                                revoked_serials: crl_data.clone(),
                                next_update: Utc::now() + chrono::Duration::hours(24),
                                signature_algorithm: "SHA256withRSA".to_string(),
                            },
                        );
                        guard.last_update = Some(Utc::now());
                    }

                    for revoked in &crl_data {
                        if revoked == &serial_bytes {
                            return Some(true);
                        }
                    }
                    return Some(false);
                }
            }
        }

        None
    }

    /// Build OCSP request for a certificate
    fn build_ocsp_request(&self, cert: &CertificateInfo, serial_bytes: &[u8]) -> Vec<u8> {
        let mut ocsp_request = Vec::new();

        // TBSRequest SEQUENCE
        ocsp_request.push(0x30); // SEQUENCE tag
        let mut tbs_request = Vec::new();

        // RequestList SEQUENCE
        tbs_request.push(0x30);
        let mut request_list = Vec::new();

        // Request SEQUENCE
        request_list.push(0x30);
        let mut request = Vec::new();

        // CertID SEQUENCE
        request.push(0x30);
        let mut cert_id = Vec::new();

        // HashAlgorithm (SHA-1)
        cert_id.extend_from_slice(&[0x30, 0x09, 0x06, 0x05, 0x2b, 0x0e, 0x03, 0x02, 0x1a, 0x05, 0x00]);

        // IssuerNameHash
        let issuer_hash = sha1_hash(cert.issuer.as_bytes());
        cert_id.push(0x04);
        cert_id.push(issuer_hash.len() as u8);
        cert_id.extend_from_slice(&issuer_hash);

        // IssuerKeyHash
        let key_hash = sha1_hash(cert.issuer.as_bytes());
        cert_id.push(0x04);
        cert_id.push(key_hash.len() as u8);
        cert_id.extend_from_slice(&key_hash);

        // SerialNumber
        cert_id.push(0x02);
        cert_id.push(serial_bytes.len() as u8);
        cert_id.extend_from_slice(serial_bytes);

        request.push(cert_id.len() as u8);
        request.extend_from_slice(&cert_id);

        request_list.push(request.len() as u8);
        request_list.extend_from_slice(&request);

        tbs_request.push(request_list.len() as u8);
        tbs_request.extend_from_slice(&request_list);

        ocsp_request.push(tbs_request.len() as u8);
        ocsp_request.extend_from_slice(&tbs_request);

        ocsp_request
    }

    /// Parse OCSP response to determine revocation status
    fn parse_ocsp_response(&self, response: &[u8]) -> Option<bool> {
        if response.len() < 6 {
            return None;
        }

        // Check responseStatus (0 = successful)
        if response.len() > 4 && response[0] == 0x30 {
            // Look for certStatus in the response
            // good [0] IMPLICIT NULL = 0x80
            // revoked [1] IMPLICIT RevokedInfo = 0xa1
            // unknown [2] IMPLICIT UnknownInfo = 0x82

            for i in 0..response.len().saturating_sub(2) {
                match response[i] {
                    0x80 if i > 10 => return Some(false), // good
                    0xa1 if i > 10 => return Some(true),  // revoked
                    _ => continue,
                }
            }
        }

        None
    }

    /// Verify certificate chain against trusted root CAs
    pub fn verify_chain(&self, certs: &[CertificateInfo]) -> bool {
        if certs.is_empty() {
            return false;
        }

        // Get trusted root CAs
        let trusted_roots = self.get_trusted_roots();

        // Verify chain from leaf to root
        for i in 0..certs.len() {
            let current = &certs[i];

            // Check validity period
            let now = chrono::Utc::now();
            if now < current.not_before || now > current.not_after {
                log::debug!("Certificate {} is outside validity period", current.subject);
                return false;
            }

            // Check signature algorithm strength
            if current.signature_algorithm == "SHA1withRSA" {
                log::warn!("Certificate {} uses weak SHA1 signature", current.subject);
                // Don't fail, just warn
            }

            // Check if issuer matches next certificate's subject (or root)
            if i + 1 < certs.len() {
                let issuer = &certs[i + 1];
                if !self.verify_issuer_matches(current, issuer) {
                    log::debug!("Certificate chain broken at {}", current.subject);
                    return false;
                }
            } else {
                // Last certificate should be signed by a trusted root
                if !self.is_trusted_root(&current.issuer, &trusted_roots) {
                    // Check if the certificate is self-signed and trusted
                    if current.subject == current.issuer {
                        if !self.is_trusted_root(&current.subject, &trusted_roots) {
                            log::debug!("Self-signed certificate {} not in trusted roots", current.subject);
                            return false;
                        }
                    } else {
                        log::debug!("Certificate issuer {} not in trusted roots", current.issuer);
                        return false;
                    }
                }
            }
        }

        true
    }

    /// Check if issuer matches certificate subject
    fn verify_issuer_matches(&self, cert: &CertificateInfo, issuer_cert: &CertificateInfo) -> bool {
        // In a full implementation, would verify the signature
        // For now, check if issuer name matches subject name
        cert.issuer == issuer_cert.subject
    }

    /// Check if issuer is a trusted root CA
    fn is_trusted_root(&self, issuer: &str, trusted_roots: &[TrustedRoot]) -> bool {
        let issuer_lower = issuer.to_lowercase();

        for root in trusted_roots {
            if issuer_lower.contains(&root.subject.to_lowercase()) ||
               issuer_lower.contains(&root.organization.to_lowercase()) {
                return true;
            }
        }

        false
    }

    /// Get list of trusted root CAs
    fn get_trusted_roots(&self) -> Vec<TrustedRoot> {
        vec![
            TrustedRoot { subject: "DigiCert Global Root CA".to_string(), organization: "DigiCert".to_string(), thumbprint: "a8985d3a65e5e5c4b2d7d66d40c6dd2fb19c5436".to_string() },
            TrustedRoot { subject: "DigiCert Global Root G2".to_string(), organization: "DigiCert".to_string(), thumbprint: "df3c24f9bfd666761b268073fe06d1cc8d4f82a4".to_string() },
            TrustedRoot { subject: "DigiCert High Assurance EV Root CA".to_string(), organization: "DigiCert".to_string(), thumbprint: "5fb7ee0633e259dbad0c4c9ae6d38f1a61c7dc25".to_string() },
            TrustedRoot { subject: "Baltimore CyberTrust Root".to_string(), organization: "Baltimore".to_string(), thumbprint: "d4de20d05e66fc53fe1a50882c78db2852cae474".to_string() },
            TrustedRoot { subject: "Comodo RSA Certification Authority".to_string(), organization: "Comodo".to_string(), thumbprint: "afe5d244a8d1194230ff479fe2f897bbcd7a8cb4".to_string() },
            TrustedRoot { subject: "USERTrust RSA Certification Authority".to_string(), organization: "Sectigo".to_string(), thumbprint: "2b8f1b57330dbba2d07a6c51f70ee90ddab9ad8e".to_string() },
            TrustedRoot { subject: "GlobalSign Root CA".to_string(), organization: "GlobalSign".to_string(), thumbprint: "b1bc968bd4f49d622aa89a81f2150152a41d829c".to_string() },
            TrustedRoot { subject: "GlobalSign Root CA - R3".to_string(), organization: "GlobalSign".to_string(), thumbprint: "d69b561148f01c77c54578c10926df5b856976ad".to_string() },
            TrustedRoot { subject: "Entrust Root Certification Authority".to_string(), organization: "Entrust".to_string(), thumbprint: "b31eb1b740e36c8402dadc37d44df5d4674952f9".to_string() },
            TrustedRoot { subject: "GeoTrust Global CA".to_string(), organization: "GeoTrust".to_string(), thumbprint: "de28f4a4ffe5b92fa3c503d1a349a7f9962a8212".to_string() },
            TrustedRoot { subject: "VeriSign Class 3 Public Primary Certification Authority".to_string(), organization: "VeriSign".to_string(), thumbprint: "742c3192e607e424eb4549542be1bbc53e6174e2".to_string() },
            TrustedRoot { subject: "thawte Primary Root CA".to_string(), organization: "thawte".to_string(), thumbprint: "91c6d6ee3e8ac86384e548c299295c756c817b81".to_string() },
            TrustedRoot { subject: "Go Daddy Root Certificate Authority".to_string(), organization: "GoDaddy".to_string(), thumbprint: "3a9a8505b892498e4e22a7096dfda5fac71e9aab".to_string() },
            TrustedRoot { subject: "Amazon Root CA 1".to_string(), organization: "Amazon".to_string(), thumbprint: "8da7f965ec5efc37910f1c6e59fdc1cc6a6ede16".to_string() },
            TrustedRoot { subject: "Amazon Root CA 2".to_string(), organization: "Amazon".to_string(), thumbprint: "5a8cef45d7a69859767a8c8b4496b578cf474b1a".to_string() },
            TrustedRoot { subject: "ISRG Root X1".to_string(), organization: "Let's Encrypt".to_string(), thumbprint: "cabd2a79a1076a31f21d253635cb039d4329a5e8".to_string() },
            TrustedRoot { subject: "Microsoft Root Certificate Authority".to_string(), organization: "Microsoft".to_string(), thumbprint: "a43489159a520f0d93d032ccaf37e7fe20a8b419".to_string() },
            TrustedRoot { subject: "Microsoft Root Certificate Authority 2011".to_string(), organization: "Microsoft".to_string(), thumbprint: "8f43288ad272f3103b6fb1428485ea3014c0bcfe".to_string() },
        ]
    }

    /// Check for known malware signing certificates
    pub fn check_known_malware_certs(&self, cert: &CertificateInfo) -> Option<String> {
        let known_malware_subjects = [
            ("Fortinet Technologies", "Possible stolen certificate"),
            ("Realtek Semiconductor", "Known stolen certificate (Stuxnet)"),
            ("JMicron Technology", "Known stolen certificate (Stuxnet)"),
            ("HON HAI PRECISION INDUSTRY", "Known stolen certificate"),
            ("D-Link Corporation", "Known compromised certificate"),
        ];

        for (name, reason) in &known_malware_subjects {
            if cert.subject.contains(name) || cert.issuer.contains(name) {
                return Some(reason.to_string());
            }
        }

        // Check for self-signed (subject == issuer)
        if cert.subject == cert.issuer {
            return Some("Self-signed certificate".to_string());
        }

        None
    }
}

impl Default for CertificateAnalyzer {
    fn default() -> Self {
        Self::new()
    }
}

/// Trusted root CA entry
struct TrustedRoot {
    subject: String,
    organization: String,
    thumbprint: String,
}

/// Compute SHA-1 hash
fn sha1_hash(data: &[u8]) -> Vec<u8> {
    use sha1::Digest;
    let mut hasher = Sha1::new();
    hasher.update(data);
    hasher.finalize().to_vec()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_known_malware_certs() {
        let analyzer = CertificateAnalyzer::new();

        let cert = CertificateInfo {
            subject: "CN=Realtek Semiconductor Corp".to_string(),
            issuer: "CN=VeriSign".to_string(),
            serial_number: "12:34:56:78".to_string(),
            not_before: Utc::now(),
            not_after: Utc::now(),
            is_valid: true,
            is_trusted: false,
            signature_algorithm: "SHA256withRSA".to_string(),
            thumbprint_sha1: "abcd".to_string(),
            thumbprint_sha256: "efgh".to_string(),
        };

        let result = analyzer.check_known_malware_certs(&cert);
        assert!(result.is_some());
    }

    #[test]
    fn test_self_signed_detection() {
        let analyzer = CertificateAnalyzer::new();

        let cert = CertificateInfo {
            subject: "CN=Malware Inc".to_string(),
            issuer: "CN=Malware Inc".to_string(),
            serial_number: "12:34:56:78".to_string(),
            not_before: Utc::now(),
            not_after: Utc::now(),
            is_valid: true,
            is_trusted: false,
            signature_algorithm: "SHA256withRSA".to_string(),
            thumbprint_sha1: "abcd".to_string(),
            thumbprint_sha256: "efgh".to_string(),
        };

        let result = analyzer.check_known_malware_certs(&cert);
        assert_eq!(result, Some("Self-signed certificate".to_string()));
    }
}
