//! IOC Extraction
//!
//! Extracts Indicators of Compromise from malware samples.

use std::collections::HashSet;
use chrono::Utc;
use regex::Regex;

use crate::malware_analysis::types::*;

/// IOC extractor
pub struct IocExtractor {
    ip_regex: Regex,
    domain_regex: Regex,
    url_regex: Regex,
    email_regex: Regex,
    bitcoin_regex: Regex,
    md5_regex: Regex,
    sha1_regex: Regex,
    sha256_regex: Regex,
    registry_regex: Regex,
}

impl IocExtractor {
    /// Create a new IOC extractor
    pub fn new() -> Self {
        Self {
            ip_regex: Regex::new(r"\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\b").unwrap(),
            domain_regex: Regex::new(r"\b(?:[a-zA-Z0-9](?:[a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}\b").unwrap(),
            url_regex: Regex::new(r"(?i)https?://[^\s<>]+").unwrap(),
            email_regex: Regex::new(r"\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}\b").unwrap(),
            bitcoin_regex: Regex::new(r"\b[13][a-km-zA-HJ-NP-Z1-9]{25,34}\b").unwrap(),
            md5_regex: Regex::new(r"\b[a-fA-F0-9]{32}\b").unwrap(),
            sha1_regex: Regex::new(r"\b[a-fA-F0-9]{40}\b").unwrap(),
            sha256_regex: Regex::new(r"\b[a-fA-F0-9]{64}\b").unwrap(),
            registry_regex: Regex::new(r"(?i)(HKEY_[A-Z_]+|HKLM|HKCU|HKCR|HKU|HKCC)\\[^\s\x00]+").unwrap(),
        }
    }

    /// Extract all IOCs from binary data
    pub fn extract_from_binary(&self, data: &[u8], sample_id: &str) -> Vec<MalwareIoc> {
        let mut iocs = vec![];
        let mut seen: HashSet<(String, String)> = HashSet::new();

        // Convert to string for regex matching
        let text = String::from_utf8_lossy(data);

        // Extract IPs
        for cap in self.ip_regex.find_iter(&text) {
            let ip = cap.as_str().to_string();
            if !self.is_private_ip(&ip) && seen.insert((IocType::Ip.to_string(), ip.clone())) {
                iocs.push(MalwareIoc {
                    id: uuid::Uuid::new_v4().to_string(),
                    sample_id: sample_id.to_string(),
                    ioc_type: IocType::Ip,
                    ioc_value: ip,
                    context: Some(format!("Found at offset {}", cap.start())),
                    confidence: 70,
                    source: IocSource::Static,
                    created_at: Utc::now(),
                });
            }
        }

        // Extract URLs
        for cap in self.url_regex.find_iter(&text) {
            let url = cap.as_str().to_string();
            if seen.insert((IocType::Url.to_string(), url.clone())) {
                iocs.push(MalwareIoc {
                    id: uuid::Uuid::new_v4().to_string(),
                    sample_id: sample_id.to_string(),
                    ioc_type: IocType::Url,
                    ioc_value: url.clone(),
                    context: Some(format!("Found at offset {}", cap.start())),
                    confidence: 80,
                    source: IocSource::Static,
                    created_at: Utc::now(),
                });

                // Also extract domain from URL
                if let Some(domain) = self.extract_domain_from_url(&url) {
                    if seen.insert((IocType::Domain.to_string(), domain.clone())) {
                        iocs.push(MalwareIoc {
                            id: uuid::Uuid::new_v4().to_string(),
                            sample_id: sample_id.to_string(),
                            ioc_type: IocType::Domain,
                            ioc_value: domain,
                            context: Some("Extracted from URL".to_string()),
                            confidence: 75,
                            source: IocSource::Static,
                            created_at: Utc::now(),
                        });
                    }
                }
            }
        }

        // Extract domains
        for cap in self.domain_regex.find_iter(&text) {
            let domain = cap.as_str().to_lowercase();
            if self.is_valid_domain(&domain) && !self.is_common_domain(&domain) {
                if seen.insert((IocType::Domain.to_string(), domain.clone())) {
                    iocs.push(MalwareIoc {
                        id: uuid::Uuid::new_v4().to_string(),
                        sample_id: sample_id.to_string(),
                        ioc_type: IocType::Domain,
                        ioc_value: domain,
                        context: Some(format!("Found at offset {}", cap.start())),
                        confidence: 60,
                        source: IocSource::Static,
                        created_at: Utc::now(),
                    });
                }
            }
        }

        // Extract emails
        for cap in self.email_regex.find_iter(&text) {
            let email = cap.as_str().to_string();
            if seen.insert((IocType::Email.to_string(), email.clone())) {
                iocs.push(MalwareIoc {
                    id: uuid::Uuid::new_v4().to_string(),
                    sample_id: sample_id.to_string(),
                    ioc_type: IocType::Email,
                    ioc_value: email,
                    context: Some(format!("Found at offset {}", cap.start())),
                    confidence: 65,
                    source: IocSource::Static,
                    created_at: Utc::now(),
                });
            }
        }

        // Extract Bitcoin addresses
        for cap in self.bitcoin_regex.find_iter(&text) {
            let address = cap.as_str().to_string();
            if seen.insert((IocType::BitcoinAddress.to_string(), address.clone())) {
                iocs.push(MalwareIoc {
                    id: uuid::Uuid::new_v4().to_string(),
                    sample_id: sample_id.to_string(),
                    ioc_type: IocType::BitcoinAddress,
                    ioc_value: address,
                    context: Some(format!("Found at offset {}", cap.start())),
                    confidence: 90,
                    source: IocSource::Static,
                    created_at: Utc::now(),
                });
            }
        }

        // Extract registry paths
        for cap in self.registry_regex.find_iter(&text) {
            let registry = cap.as_str().to_string();
            if seen.insert((IocType::Registry.to_string(), registry.clone())) {
                iocs.push(MalwareIoc {
                    id: uuid::Uuid::new_v4().to_string(),
                    sample_id: sample_id.to_string(),
                    ioc_type: IocType::Registry,
                    ioc_value: registry,
                    context: Some(format!("Found at offset {}", cap.start())),
                    confidence: 70,
                    source: IocSource::Static,
                    created_at: Utc::now(),
                });
            }
        }

        // Limit results
        if iocs.len() > 500 {
            iocs.truncate(500);
        }

        iocs
    }

    /// Extract IOCs from interesting strings
    pub fn extract_from_strings(&self, strings: &[InterestingString], sample_id: &str) -> Vec<MalwareIoc> {
        let mut iocs = vec![];
        let mut seen: HashSet<(String, String)> = HashSet::new();

        for string in strings {
            match string.category {
                StringCategory::Url => {
                    if seen.insert((IocType::Url.to_string(), string.value.clone())) {
                        iocs.push(MalwareIoc {
                            id: uuid::Uuid::new_v4().to_string(),
                            sample_id: sample_id.to_string(),
                            ioc_type: IocType::Url,
                            ioc_value: string.value.clone(),
                            context: string.section.clone(),
                            confidence: 85,
                            source: IocSource::Static,
                            created_at: Utc::now(),
                        });
                    }
                }
                StringCategory::Ip => {
                    if !self.is_private_ip(&string.value) {
                        if seen.insert((IocType::Ip.to_string(), string.value.clone())) {
                            iocs.push(MalwareIoc {
                                id: uuid::Uuid::new_v4().to_string(),
                                sample_id: sample_id.to_string(),
                                ioc_type: IocType::Ip,
                                ioc_value: string.value.clone(),
                                context: string.section.clone(),
                                confidence: 80,
                                source: IocSource::Static,
                                created_at: Utc::now(),
                            });
                        }
                    }
                }
                StringCategory::Domain => {
                    if !self.is_common_domain(&string.value) {
                        if seen.insert((IocType::Domain.to_string(), string.value.clone())) {
                            iocs.push(MalwareIoc {
                                id: uuid::Uuid::new_v4().to_string(),
                                sample_id: sample_id.to_string(),
                                ioc_type: IocType::Domain,
                                ioc_value: string.value.clone(),
                                context: string.section.clone(),
                                confidence: 75,
                                source: IocSource::Static,
                                created_at: Utc::now(),
                            });
                        }
                    }
                }
                StringCategory::Email => {
                    if seen.insert((IocType::Email.to_string(), string.value.clone())) {
                        iocs.push(MalwareIoc {
                            id: uuid::Uuid::new_v4().to_string(),
                            sample_id: sample_id.to_string(),
                            ioc_type: IocType::Email,
                            ioc_value: string.value.clone(),
                            context: string.section.clone(),
                            confidence: 70,
                            source: IocSource::Static,
                            created_at: Utc::now(),
                        });
                    }
                }
                StringCategory::Registry => {
                    if seen.insert((IocType::Registry.to_string(), string.value.clone())) {
                        iocs.push(MalwareIoc {
                            id: uuid::Uuid::new_v4().to_string(),
                            sample_id: sample_id.to_string(),
                            ioc_type: IocType::Registry,
                            ioc_value: string.value.clone(),
                            context: string.section.clone(),
                            confidence: 75,
                            source: IocSource::Static,
                            created_at: Utc::now(),
                        });
                    }
                }
                StringCategory::FilePath => {
                    if self.is_suspicious_path(&string.value) {
                        if seen.insert((IocType::File.to_string(), string.value.clone())) {
                            iocs.push(MalwareIoc {
                                id: uuid::Uuid::new_v4().to_string(),
                                sample_id: sample_id.to_string(),
                                ioc_type: IocType::File,
                                ioc_value: string.value.clone(),
                                context: string.section.clone(),
                                confidence: 60,
                                source: IocSource::Static,
                                created_at: Utc::now(),
                            });
                        }
                    }
                }
                _ => {}
            }
        }

        iocs
    }

    /// Check if IP is private/local
    fn is_private_ip(&self, ip: &str) -> bool {
        let parts: Vec<u8> = ip.split('.')
            .filter_map(|p| p.parse::<u8>().ok())
            .collect();

        if parts.len() != 4 {
            return true;
        }

        // Private ranges
        if parts[0] == 10 { return true; }
        if parts[0] == 172 && parts[1] >= 16 && parts[1] <= 31 { return true; }
        if parts[0] == 192 && parts[1] == 168 { return true; }
        if parts[0] == 127 { return true; }
        if parts[0] == 0 { return true; }
        if parts[0] >= 224 { return true; } // Multicast/reserved

        false
    }

    /// Validate domain format
    fn is_valid_domain(&self, domain: &str) -> bool {
        if domain.len() < 4 || domain.len() > 253 {
            return false;
        }

        let parts: Vec<&str> = domain.split('.').collect();
        if parts.len() < 2 {
            return false;
        }

        // Check TLD
        let tld = parts.last().unwrap();
        if tld.len() < 2 || tld.len() > 10 {
            return false;
        }

        // Check for valid characters
        domain.chars().all(|c| c.is_alphanumeric() || c == '.' || c == '-')
    }

    /// Check if domain is too common to be interesting
    fn is_common_domain(&self, domain: &str) -> bool {
        let common = [
            "microsoft.com",
            "google.com",
            "googleapis.com",
            "gstatic.com",
            "windows.com",
            "windowsupdate.com",
            "adobe.com",
            "apple.com",
            "mozilla.org",
            "mozilla.com",
            "firefox.com",
            "chrome.com",
            "example.com",
            "localhost.localdomain",
            "localhost",
            "msdn.com",
            "office.com",
            "live.com",
            "outlook.com",
            "github.com",
            "githubusercontent.com",
            "amazon.com",
            "amazonaws.com",
        ];

        let domain_lower = domain.to_lowercase();
        common.iter().any(|c| domain_lower.ends_with(c))
    }

    /// Extract domain from URL
    fn extract_domain_from_url(&self, url: &str) -> Option<String> {
        let url_lower = url.to_lowercase();
        let without_protocol = url_lower
            .trim_start_matches("http://")
            .trim_start_matches("https://");

        let domain = without_protocol.split('/').next()?;
        let domain = domain.split(':').next()?;
        let domain = domain.split('@').last()?;

        if self.is_valid_domain(domain) {
            Some(domain.to_string())
        } else {
            None
        }
    }

    /// Check if file path is suspicious
    fn is_suspicious_path(&self, path: &str) -> bool {
        let path_lower = path.to_lowercase();

        let suspicious_patterns = [
            "\\temp\\",
            "\\tmp\\",
            "/tmp/",
            "\\appdata\\",
            "\\programdata\\",
            "\\startup\\",
            "\\run\\",
            ".exe",
            ".dll",
            ".bat",
            ".ps1",
            ".vbs",
            ".js",
            "cmd.exe",
            "powershell",
            "wscript",
            "cscript",
        ];

        suspicious_patterns.iter().any(|p| path_lower.contains(p))
    }

    /// Get IOC summary
    pub fn get_summary(iocs: &[MalwareIoc]) -> IocSummary {
        let mut by_type: std::collections::HashMap<String, usize> = std::collections::HashMap::new();

        for ioc in iocs {
            *by_type.entry(ioc.ioc_type.to_string()).or_insert(0) += 1;
        }

        IocSummary {
            total: iocs.len(),
            by_type,
            high_confidence: iocs.iter().filter(|i| i.confidence >= 80).count(),
        }
    }
}

/// IOC summary statistics
#[derive(Debug, Clone)]
pub struct IocSummary {
    pub total: usize,
    pub by_type: std::collections::HashMap<String, usize>,
    pub high_confidence: usize,
}

impl Default for IocExtractor {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_ip_extraction() {
        let extractor = IocExtractor::new();
        let data = b"Connection to 192.168.1.1 failed. Trying 8.8.8.8 instead.";

        let iocs = extractor.extract_from_binary(data, "test");

        // 192.168.1.1 should be filtered as private
        assert!(iocs.iter().all(|i| i.ioc_value != "192.168.1.1"));
        // 8.8.8.8 should be extracted
        assert!(iocs.iter().any(|i| i.ioc_value == "8.8.8.8"));
    }

    #[test]
    fn test_url_extraction() {
        let extractor = IocExtractor::new();
        let data = b"Download from https://malware.evil.com/payload.exe";

        let iocs = extractor.extract_from_binary(data, "test");

        assert!(iocs.iter().any(|i| i.ioc_type == IocType::Url));
        assert!(iocs.iter().any(|i| i.ioc_type == IocType::Domain));
    }

    #[test]
    fn test_bitcoin_extraction() {
        let extractor = IocExtractor::new();
        let data = b"Send payment to 1BvBMSEYstWetqTFn5Au4m4GFg7xJaNVN2";

        let iocs = extractor.extract_from_binary(data, "test");

        assert!(iocs.iter().any(|i| i.ioc_type == IocType::BitcoinAddress));
    }
}
