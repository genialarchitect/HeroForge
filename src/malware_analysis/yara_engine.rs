//! YARA Engine
//!
//! Enhanced YARA rule matching engine for malware detection.
//! Includes a full YARA syntax parser supporting:
//! - Text strings with modifiers (nocase, wide, fullword, ascii)
//! - Hex strings with wildcards (?, [N], [N-M], (A|B))
//! - Regular expressions
//! - Complex conditions with boolean operators
//! - Rule imports (pe, elf, math)
//! - Private and global rules

use std::collections::{HashMap, HashSet};
use anyhow::{Result, anyhow};
use regex::Regex;

use crate::malware_analysis::types::*;

// ============================================================================
// YARA Parser Types
// ============================================================================

/// Token types for YARA lexer
#[derive(Debug, Clone, PartialEq)]
enum YaraToken {
    Rule,
    Private,
    Global,
    Meta,
    Strings,
    Condition,
    Import,
    Include,
    True,
    False,
    And,
    Or,
    Not,
    Of,
    Them,
    All,
    Any,
    None,
    At,
    In,
    For,
    Contains,
    IContains,
    StartsWith,
    IStartsWith,
    EndsWith,
    IEndsWith,
    Matches,
    Defined,
    Filesize,
    Entrypoint,
    Int8, Int16, Int32,
    Uint8, Uint16, Uint32,
    Int8Be, Int16Be, Int32Be,
    Uint8Be, Uint16Be, Uint32Be,
    Identifier(String),
    StringIdentifier(String),
    StringCount(String),
    StringOffset(String),
    StringLength(String),
    Number(i64),
    Float(f64),
    Text(String),
    HexString(Vec<HexToken>),
    RegexPattern(String),
    LParen,
    RParen,
    LBrace,
    RBrace,
    LBracket,
    RBracket,
    Colon,
    Comma,
    Dot,
    DotDot,
    Equals,
    NotEquals,
    Less,
    LessEq,
    Greater,
    GreaterEq,
    Plus,
    Minus,
    Star,
    Slash,
    Percent,
    Pipe,
    Ampersand,
    Caret,
    Tilde,
    ShiftLeft,
    ShiftRight,
    Assign,
    Newline,
    Eof,
}

/// Hex string token (supports wildcards)
#[derive(Debug, Clone, PartialEq)]
enum HexToken {
    Byte(u8),
    Wildcard,
    WildcardNibbleHigh(u8),  // ?N - low nibble known
    WildcardNibbleLow(u8),   // N? - high nibble known
    Jump(usize, Option<usize>),  // [N] or [N-M]
    Alternative(Vec<Vec<HexToken>>),  // (AB|CD|EF)
}

/// Parsed YARA condition AST
#[derive(Debug, Clone)]
enum ConditionExpr {
    True,
    False,
    StringMatch(String),       // $string
    StringCount(String),       // #string
    StringOffset(String, Option<Box<ConditionExpr>>),  // @string or @string[n]
    StringLength(String, Option<Box<ConditionExpr>>),  // !string or !string[n]
    Identifier(String),        // rule name or variable
    Number(i64),
    Float(f64),
    Filesize,
    Entrypoint,
    // Boolean operations
    And(Box<ConditionExpr>, Box<ConditionExpr>),
    Or(Box<ConditionExpr>, Box<ConditionExpr>),
    Not(Box<ConditionExpr>),
    // Comparisons
    Equals(Box<ConditionExpr>, Box<ConditionExpr>),
    NotEquals(Box<ConditionExpr>, Box<ConditionExpr>),
    Less(Box<ConditionExpr>, Box<ConditionExpr>),
    LessEq(Box<ConditionExpr>, Box<ConditionExpr>),
    Greater(Box<ConditionExpr>, Box<ConditionExpr>),
    GreaterEq(Box<ConditionExpr>, Box<ConditionExpr>),
    // Arithmetic
    Add(Box<ConditionExpr>, Box<ConditionExpr>),
    Sub(Box<ConditionExpr>, Box<ConditionExpr>),
    Mul(Box<ConditionExpr>, Box<ConditionExpr>),
    Div(Box<ConditionExpr>, Box<ConditionExpr>),
    Mod(Box<ConditionExpr>, Box<ConditionExpr>),
    // Bitwise
    BitwiseAnd(Box<ConditionExpr>, Box<ConditionExpr>),
    BitwiseOr(Box<ConditionExpr>, Box<ConditionExpr>),
    BitwiseXor(Box<ConditionExpr>, Box<ConditionExpr>),
    BitwiseNot(Box<ConditionExpr>),
    ShiftLeft(Box<ConditionExpr>, Box<ConditionExpr>),
    ShiftRight(Box<ConditionExpr>, Box<ConditionExpr>),
    // String set operations
    OfThem(Box<ConditionExpr>),           // N of them
    AllOfThem,                             // all of them
    AnyOfThem,                             // any of them
    NoneOfThem,                            // none of them
    OfStringSet(Box<ConditionExpr>, Vec<String>),  // N of ($a*, $b)
    AllOfStringSet(Vec<String>),
    AnyOfStringSet(Vec<String>),
    // String operations
    Contains(Box<ConditionExpr>, Box<ConditionExpr>),
    IContains(Box<ConditionExpr>, Box<ConditionExpr>),
    StartsWith(Box<ConditionExpr>, Box<ConditionExpr>),
    IStartsWith(Box<ConditionExpr>, Box<ConditionExpr>),
    EndsWith(Box<ConditionExpr>, Box<ConditionExpr>),
    IEndsWith(Box<ConditionExpr>, Box<ConditionExpr>),
    Matches(Box<ConditionExpr>, String),  // identifier matches /regex/
    // Range operations
    InRange(Box<ConditionExpr>, Box<ConditionExpr>, Box<ConditionExpr>),  // expr in (start..end)
    At(Box<ConditionExpr>, Box<ConditionExpr>),  // $string at offset
    // Memory access
    Int8At(Box<ConditionExpr>),
    Int16At(Box<ConditionExpr>),
    Int32At(Box<ConditionExpr>),
    Uint8At(Box<ConditionExpr>),
    Uint16At(Box<ConditionExpr>),
    Uint32At(Box<ConditionExpr>),
    // For loops
    ForOf(String, Vec<String>, Box<ConditionExpr>),  // for identifier of stringset : (condition)
    ForIn(String, Box<ConditionExpr>, Box<ConditionExpr>, Box<ConditionExpr>),  // for identifier in range : (condition)
    // Defined check
    Defined(Box<ConditionExpr>),
    // Parenthesized expression
    Paren(Box<ConditionExpr>),
}

/// YARA scanning engine
pub struct YaraEngine {
    /// Built-in rules
    rules: Vec<YaraRuleDefinition>,
    /// Imported modules
    imports: HashSet<String>,
    /// External variables
    externals: HashMap<String, ExternalValue>,
}

/// External variable value
#[derive(Debug, Clone)]
pub enum ExternalValue {
    Integer(i64),
    Float(f64),
    String(String),
    Boolean(bool),
}

/// YARA scan result with metadata
#[derive(Debug, Clone)]
pub struct YaraScanResult {
    /// List of matching rules
    pub matches: Vec<YaraMatch>,
    /// Size of scanned data
    pub file_size: usize,
    /// Scan time in milliseconds
    pub scan_time_ms: u64,
}

/// Internal YARA rule definition
#[derive(Debug, Clone)]
struct YaraRuleDefinition {
    name: String,
    namespace: Option<String>,
    tags: Vec<String>,
    meta: HashMap<String, MetaValue>,
    strings: Vec<YaraString>,
    condition: String,
    condition_ast: Option<ConditionExpr>,
    is_private: bool,
    is_global: bool,
}

/// Meta value types
#[derive(Debug, Clone)]
enum MetaValue {
    String(String),
    Integer(i64),
    Boolean(bool),
}

impl MetaValue {
    fn as_string(&self) -> String {
        match self {
            MetaValue::String(s) => s.clone(),
            MetaValue::Integer(i) => i.to_string(),
            MetaValue::Boolean(b) => b.to_string(),
        }
    }
}

/// YARA string pattern
#[derive(Debug, Clone)]
struct YaraString {
    identifier: String,
    pattern: YaraPattern,
    modifiers: StringModifiers,
}

/// String modifiers
#[derive(Debug, Clone, Default)]
struct StringModifiers {
    nocase: bool,
    wide: bool,
    ascii: bool,
    fullword: bool,
    xor: Option<XorModifier>,
    base64: Option<Base64Modifier>,
    private: bool,
}

/// XOR modifier options
#[derive(Debug, Clone)]
struct XorModifier {
    min: u8,
    max: u8,
}

impl Default for XorModifier {
    fn default() -> Self {
        Self { min: 0, max: 255 }
    }
}

/// Base64 modifier options
#[derive(Debug, Clone)]
struct Base64Modifier {
    alphabet: Option<String>,
    wide: bool,
}

/// YARA pattern type
#[derive(Debug, Clone)]
enum YaraPattern {
    Text(String),
    Hex(Vec<HexToken>),
    Regex(String),
}

// ============================================================================
// YARA Lexer
// ============================================================================

/// YARA Lexer for tokenizing rule files
struct YaraLexer<'a> {
    input: &'a str,
    pos: usize,
    line: usize,
    column: usize,
}

impl<'a> YaraLexer<'a> {
    fn new(input: &'a str) -> Self {
        Self {
            input,
            pos: 0,
            line: 1,
            column: 1,
        }
    }

    fn peek(&self) -> Option<char> {
        self.input[self.pos..].chars().next()
    }

    fn peek_n(&self, n: usize) -> Option<char> {
        self.input[self.pos..].chars().nth(n)
    }

    fn advance(&mut self) -> Option<char> {
        let c = self.peek()?;
        self.pos += c.len_utf8();
        if c == '\n' {
            self.line += 1;
            self.column = 1;
        } else {
            self.column += 1;
        }
        Some(c)
    }

    fn skip_whitespace(&mut self) {
        while let Some(c) = self.peek() {
            if c.is_whitespace() && c != '\n' {
                self.advance();
            } else if c == '/' {
                if self.peek_n(1) == Some('/') {
                    // Line comment
                    while let Some(c) = self.peek() {
                        if c == '\n' {
                            break;
                        }
                        self.advance();
                    }
                } else if self.peek_n(1) == Some('*') {
                    // Block comment
                    self.advance(); // /
                    self.advance(); // *
                    while let Some(c) = self.peek() {
                        if c == '*' && self.peek_n(1) == Some('/') {
                            self.advance();
                            self.advance();
                            break;
                        }
                        self.advance();
                    }
                } else {
                    break;
                }
            } else {
                break;
            }
        }
    }

    fn read_identifier(&mut self) -> String {
        let mut ident = String::new();
        while let Some(c) = self.peek() {
            if c.is_alphanumeric() || c == '_' {
                ident.push(c);
                self.advance();
            } else {
                break;
            }
        }
        ident
    }

    fn read_number(&mut self) -> Result<YaraToken> {
        let mut num_str = String::new();
        let mut is_hex = false;
        let mut is_float = false;

        // Check for hex prefix
        if self.peek() == Some('0') && (self.peek_n(1) == Some('x') || self.peek_n(1) == Some('X')) {
            num_str.push_str("0x");
            self.advance();
            self.advance();
            is_hex = true;
        }

        while let Some(c) = self.peek() {
            if is_hex {
                if c.is_ascii_hexdigit() {
                    num_str.push(c);
                    self.advance();
                } else {
                    break;
                }
            } else if c.is_ascii_digit() {
                num_str.push(c);
                self.advance();
            } else if c == '.' && !is_float {
                is_float = true;
                num_str.push(c);
                self.advance();
            } else {
                break;
            }
        }

        if is_float {
            num_str.parse::<f64>()
                .map(YaraToken::Float)
                .map_err(|_| anyhow!("Invalid float: {}", num_str))
        } else if is_hex {
            i64::from_str_radix(&num_str[2..], 16)
                .map(YaraToken::Number)
                .map_err(|_| anyhow!("Invalid hex number: {}", num_str))
        } else {
            num_str.parse::<i64>()
                .map(YaraToken::Number)
                .map_err(|_| anyhow!("Invalid number: {}", num_str))
        }
    }

    fn read_string(&mut self) -> Result<String> {
        let quote = self.advance().unwrap(); // " or '
        let mut string = String::new();

        while let Some(c) = self.peek() {
            if c == quote {
                self.advance();
                break;
            } else if c == '\\' {
                self.advance();
                if let Some(escaped) = self.peek() {
                    let escaped_char = match escaped {
                        'n' => '\n',
                        'r' => '\r',
                        't' => '\t',
                        '\\' => '\\',
                        '"' => '"',
                        '\'' => '\'',
                        'x' => {
                            self.advance();
                            let h1 = self.advance().ok_or_else(|| anyhow!("Unexpected end of hex escape"))?;
                            let h2 = self.advance().ok_or_else(|| anyhow!("Unexpected end of hex escape"))?;
                            let hex_str = format!("{}{}", h1, h2);
                            u8::from_str_radix(&hex_str, 16)
                                .map(|b| b as char)
                                .map_err(|_| anyhow!("Invalid hex escape: \\x{}", hex_str))?
                        }
                        _ => escaped,
                    };
                    if escaped != 'x' {
                        self.advance();
                    }
                    string.push(escaped_char);
                }
            } else {
                string.push(c);
                self.advance();
            }
        }

        Ok(string)
    }

    /// Check if the content after { looks like a hex string
    /// Hex strings typically have pairs of hex digits, or wildcards like ??
    /// We need to distinguish from rule bodies which have keywords like 'condition'
    fn is_hex_string_start(&self) -> bool {
        let mut pos = self.pos + 1; // Skip the '{'
        // Skip whitespace
        while pos < self.input.len() {
            let c = self.input[pos..].chars().next().unwrap_or('\0');
            if c.is_whitespace() {
                pos += c.len_utf8();
            } else {
                // ? is definitely hex (wildcard)
                if c == '?' {
                    return true;
                }
                // [ is definitely hex (jump)
                if c == '[' {
                    return true;
                }
                // ( is definitely hex (alternative)
                if c == '(' {
                    return true;
                }
                // For hex digits, we need to check if there's a second hex digit immediately
                // or ? following it. Keywords like 'condition' won't have this pattern.
                if c.is_ascii_hexdigit() {
                    // Look at next char
                    let next_pos = pos + c.len_utf8();
                    if next_pos < self.input.len() {
                        let c2 = self.input[next_pos..].chars().next().unwrap_or('\0');
                        // If followed by another hex digit or ?, it's a hex string
                        if c2.is_ascii_hexdigit() || c2 == '?' {
                            return true;
                        }
                    }
                    // Single hex digit followed by non-hex is probably a keyword
                    return false;
                }
                // If first non-whitespace char is something else (like a letter that's not hex),
                // it's not a hex string
                return false;
            }
        }
        false
    }

    fn read_hex_string(&mut self) -> Result<Vec<HexToken>> {
        self.advance(); // {
        let mut tokens = Vec::new();

        while let Some(c) = self.peek() {
            match c {
                '}' => {
                    self.advance();
                    break;
                }
                ' ' | '\t' | '\n' | '\r' => {
                    self.advance();
                }
                '?' => {
                    self.advance();
                    if self.peek() == Some('?') {
                        self.advance();
                        tokens.push(HexToken::Wildcard);
                    } else if let Some(c2) = self.peek() {
                        if c2.is_ascii_hexdigit() {
                            self.advance();
                            let nibble = c2.to_digit(16).unwrap() as u8;
                            tokens.push(HexToken::WildcardNibbleHigh(nibble));
                        } else {
                            tokens.push(HexToken::Wildcard);
                        }
                    } else {
                        tokens.push(HexToken::Wildcard);
                    }
                }
                '[' => {
                    self.advance();
                    let mut num_str = String::new();
                    let mut max_str = String::new();
                    let mut in_range = false;

                    while let Some(c2) = self.peek() {
                        if c2 == ']' {
                            self.advance();
                            break;
                        } else if c2 == '-' {
                            in_range = true;
                            self.advance();
                        } else if c2.is_ascii_digit() {
                            if in_range {
                                max_str.push(c2);
                            } else {
                                num_str.push(c2);
                            }
                            self.advance();
                        } else {
                            self.advance();
                        }
                    }

                    let min = num_str.parse().unwrap_or(0);
                    let max = if in_range {
                        Some(max_str.parse().unwrap_or(min))
                    } else {
                        None
                    };
                    tokens.push(HexToken::Jump(min, max));
                }
                '(' => {
                    // Alternative group
                    self.advance();
                    let mut alternatives: Vec<Vec<HexToken>> = vec![vec![]];

                    while let Some(c2) = self.peek() {
                        match c2 {
                            ')' => {
                                self.advance();
                                break;
                            }
                            '|' => {
                                self.advance();
                                alternatives.push(vec![]);
                            }
                            ' ' | '\t' | '\n' => {
                                self.advance();
                            }
                            _ if c2.is_ascii_hexdigit() => {
                                self.advance();
                                if let Some(c3) = self.peek() {
                                    if c3.is_ascii_hexdigit() {
                                        self.advance();
                                        let byte = u8::from_str_radix(&format!("{}{}", c2, c3), 16).unwrap_or(0);
                                        if let Some(last) = alternatives.last_mut() {
                                            last.push(HexToken::Byte(byte));
                                        }
                                    }
                                }
                            }
                            _ => {
                                self.advance();
                            }
                        }
                    }

                    if alternatives.len() > 1 || !alternatives[0].is_empty() {
                        tokens.push(HexToken::Alternative(alternatives));
                    }
                }
                _ if c.is_ascii_hexdigit() => {
                    self.advance();
                    if let Some(c2) = self.peek() {
                        if c2 == '?' {
                            self.advance();
                            let nibble = c.to_digit(16).unwrap() as u8;
                            tokens.push(HexToken::WildcardNibbleLow(nibble << 4));
                        } else if c2.is_ascii_hexdigit() {
                            self.advance();
                            let byte = u8::from_str_radix(&format!("{}{}", c, c2), 16).unwrap_or(0);
                            tokens.push(HexToken::Byte(byte));
                        }
                    }
                }
                _ => {
                    self.advance();
                }
            }
        }

        Ok(tokens)
    }

    fn read_regex(&mut self) -> Result<String> {
        self.advance(); // /
        let mut pattern = String::new();

        while let Some(c) = self.peek() {
            if c == '/' {
                self.advance();
                // Read modifiers
                while let Some(m) = self.peek() {
                    if m == 'i' || m == 's' || m == 'm' {
                        pattern.push(m);
                        self.advance();
                    } else {
                        break;
                    }
                }
                break;
            } else if c == '\\' {
                pattern.push(c);
                self.advance();
                if let Some(escaped) = self.peek() {
                    pattern.push(escaped);
                    self.advance();
                }
            } else {
                pattern.push(c);
                self.advance();
            }
        }

        Ok(pattern)
    }

    fn next_token(&mut self) -> Result<YaraToken> {
        self.skip_whitespace();

        let c = match self.peek() {
            Some(c) => c,
            None => return Ok(YaraToken::Eof),
        };

        // Single-char tokens
        match c {
            '\n' => { self.advance(); return Ok(YaraToken::Newline); }
            '(' => { self.advance(); return Ok(YaraToken::LParen); }
            ')' => { self.advance(); return Ok(YaraToken::RParen); }
            '[' => { self.advance(); return Ok(YaraToken::LBracket); }
            ']' => { self.advance(); return Ok(YaraToken::RBracket); }
            ':' => { self.advance(); return Ok(YaraToken::Colon); }
            ',' => { self.advance(); return Ok(YaraToken::Comma); }
            '+' => { self.advance(); return Ok(YaraToken::Plus); }
            '-' => { self.advance(); return Ok(YaraToken::Minus); }
            '*' => { self.advance(); return Ok(YaraToken::Star); }
            '/' => { self.advance(); return Ok(YaraToken::Slash); }
            '%' => { self.advance(); return Ok(YaraToken::Percent); }
            '|' => { self.advance(); return Ok(YaraToken::Pipe); }
            '&' => { self.advance(); return Ok(YaraToken::Ampersand); }
            '^' => { self.advance(); return Ok(YaraToken::Caret); }
            '~' => { self.advance(); return Ok(YaraToken::Tilde); }
            _ => {}
        }

        // Two-char tokens
        if c == '=' {
            self.advance();
            if self.peek() == Some('=') {
                self.advance();
                return Ok(YaraToken::Equals);
            }
            return Ok(YaraToken::Assign);
        }

        if c == '!' {
            self.advance();
            if self.peek() == Some('=') {
                self.advance();
                return Ok(YaraToken::NotEquals);
            }
            // String length prefix
            let ident = self.read_identifier();
            return Ok(YaraToken::StringLength(ident));
        }

        if c == '<' {
            self.advance();
            if self.peek() == Some('=') {
                self.advance();
                return Ok(YaraToken::LessEq);
            } else if self.peek() == Some('<') {
                self.advance();
                return Ok(YaraToken::ShiftLeft);
            }
            return Ok(YaraToken::Less);
        }

        if c == '>' {
            self.advance();
            if self.peek() == Some('=') {
                self.advance();
                return Ok(YaraToken::GreaterEq);
            } else if self.peek() == Some('>') {
                self.advance();
                return Ok(YaraToken::ShiftRight);
            }
            return Ok(YaraToken::Greater);
        }

        if c == '.' {
            self.advance();
            if self.peek() == Some('.') {
                self.advance();
                return Ok(YaraToken::DotDot);
            }
            return Ok(YaraToken::Dot);
        }

        if c == '{' {
            // Check if this is a hex string or a regular LBrace
            // Hex strings contain hex digits, ?, [, (
            // Look ahead to determine which one
            if self.is_hex_string_start() {
                let tokens = self.read_hex_string()?;
                return Ok(YaraToken::HexString(tokens));
            } else {
                self.advance();
                return Ok(YaraToken::LBrace);
            }
        }

        if c == '}' {
            self.advance();
            return Ok(YaraToken::RBrace);
        }

        // String identifiers ($, #, @)
        if c == '$' {
            self.advance();
            let ident = self.read_identifier();
            return Ok(YaraToken::StringIdentifier(ident));
        }

        if c == '#' {
            self.advance();
            let ident = self.read_identifier();
            return Ok(YaraToken::StringCount(ident));
        }

        if c == '@' {
            self.advance();
            let ident = self.read_identifier();
            return Ok(YaraToken::StringOffset(ident));
        }

        // Strings
        if c == '"' || c == '\'' {
            let s = self.read_string()?;
            return Ok(YaraToken::Text(s));
        }

        // Numbers
        if c.is_ascii_digit() {
            return self.read_number();
        }

        // Keywords and identifiers
        if c.is_alphabetic() || c == '_' {
            let ident = self.read_identifier();
            let token = match ident.as_str() {
                "rule" => YaraToken::Rule,
                "private" => YaraToken::Private,
                "global" => YaraToken::Global,
                "meta" => YaraToken::Meta,
                "strings" => YaraToken::Strings,
                "condition" => YaraToken::Condition,
                "import" => YaraToken::Import,
                "include" => YaraToken::Include,
                "true" => YaraToken::True,
                "false" => YaraToken::False,
                "and" => YaraToken::And,
                "or" => YaraToken::Or,
                "not" => YaraToken::Not,
                "of" => YaraToken::Of,
                "them" => YaraToken::Them,
                "all" => YaraToken::All,
                "any" => YaraToken::Any,
                "none" => YaraToken::None,
                "at" => YaraToken::At,
                "in" => YaraToken::In,
                "for" => YaraToken::For,
                "contains" => YaraToken::Contains,
                "icontains" => YaraToken::IContains,
                "startswith" => YaraToken::StartsWith,
                "istartswith" => YaraToken::IStartsWith,
                "endswith" => YaraToken::EndsWith,
                "iendswith" => YaraToken::IEndsWith,
                "matches" => YaraToken::Matches,
                "defined" => YaraToken::Defined,
                "filesize" => YaraToken::Filesize,
                "entrypoint" => YaraToken::Entrypoint,
                "int8" => YaraToken::Int8,
                "int16" => YaraToken::Int16,
                "int32" => YaraToken::Int32,
                "uint8" => YaraToken::Uint8,
                "uint16" => YaraToken::Uint16,
                "uint32" => YaraToken::Uint32,
                "int8be" => YaraToken::Int8Be,
                "int16be" => YaraToken::Int16Be,
                "int32be" => YaraToken::Int32Be,
                "uint8be" => YaraToken::Uint8Be,
                "uint16be" => YaraToken::Uint16Be,
                "uint32be" => YaraToken::Uint32Be,
                _ => YaraToken::Identifier(ident),
            };
            return Ok(token);
        }

        // Skip unknown characters
        self.advance();
        self.next_token()
    }

    fn tokenize(&mut self) -> Result<Vec<YaraToken>> {
        let mut tokens = Vec::new();
        loop {
            let token = self.next_token()?;
            if token == YaraToken::Eof {
                tokens.push(token);
                break;
            }
            if token != YaraToken::Newline {
                tokens.push(token);
            }
        }
        Ok(tokens)
    }
}

// ============================================================================
// YARA Parser
// ============================================================================

/// YARA Parser for building rule definitions from tokens
struct YaraParser {
    tokens: Vec<YaraToken>,
    pos: usize,
}

impl YaraParser {
    fn new(tokens: Vec<YaraToken>) -> Self {
        Self { tokens, pos: 0 }
    }

    fn peek(&self) -> Option<&YaraToken> {
        self.tokens.get(self.pos)
    }

    fn advance(&mut self) -> Option<&YaraToken> {
        let token = self.tokens.get(self.pos);
        self.pos += 1;
        token
    }

    fn expect(&mut self, expected: YaraToken) -> Result<()> {
        match self.advance() {
            Some(t) if *t == expected => Ok(()),
            Some(t) => Err(anyhow!("Expected {:?}, got {:?}", expected, t)),
            None => Err(anyhow!("Unexpected end of input, expected {:?}", expected)),
        }
    }

    fn parse_rules(&mut self) -> Result<Vec<YaraRuleDefinition>> {
        let mut rules = Vec::new();
        let mut imports = HashSet::new();

        while let Some(token) = self.peek() {
            match token {
                YaraToken::Import => {
                    self.advance();
                    if let Some(YaraToken::Text(module)) = self.advance() {
                        imports.insert(module.clone());
                    }
                }
                YaraToken::Include => {
                    self.advance();
                    // Skip include path
                    self.advance();
                }
                YaraToken::Rule | YaraToken::Private | YaraToken::Global => {
                    let rule = self.parse_rule()?;
                    rules.push(rule);
                }
                YaraToken::Eof => break,
                _ => {
                    self.advance();
                }
            }
        }

        Ok(rules)
    }

    fn parse_rule(&mut self) -> Result<YaraRuleDefinition> {
        let mut is_private = false;
        let mut is_global = false;

        // Check for modifiers
        while let Some(token) = self.peek() {
            match token {
                YaraToken::Private => { is_private = true; self.advance(); }
                YaraToken::Global => { is_global = true; self.advance(); }
                YaraToken::Rule => break,
                _ => break,
            }
        }

        self.expect(YaraToken::Rule)?;

        // Rule name
        let name = match self.advance() {
            Some(YaraToken::Identifier(n)) => n.clone(),
            _ => return Err(anyhow!("Expected rule name")),
        };

        // Optional tags
        let mut tags = Vec::new();
        if self.peek() == Some(&YaraToken::Colon) {
            self.advance();
            while let Some(token) = self.peek() {
                match token {
                    YaraToken::Identifier(tag) => {
                        tags.push(tag.clone());
                        self.advance();
                    }
                    _ => break,
                }
            }
        }

        // Rule body (skip to closing brace for now and capture content)
        let mut brace_depth = 0;
        let mut meta = HashMap::new();
        let mut strings = Vec::new();
        let mut condition = String::new();
        let mut in_meta = false;
        let mut in_strings = false;
        let mut in_condition = false;

        while let Some(token) = self.peek().cloned() {
            match &token {
                YaraToken::LBrace if brace_depth == 0 => {
                    brace_depth += 1;
                    self.advance();
                }
                YaraToken::RBrace => {
                    brace_depth -= 1;
                    self.advance();
                    if brace_depth == 0 {
                        break;
                    }
                }
                YaraToken::Meta => {
                    self.advance();
                    self.expect(YaraToken::Colon)?;
                    in_meta = true;
                    in_strings = false;
                    in_condition = false;
                }
                YaraToken::Strings => {
                    self.advance();
                    self.expect(YaraToken::Colon)?;
                    in_meta = false;
                    in_strings = true;
                    in_condition = false;
                }
                YaraToken::Condition => {
                    self.advance();
                    self.expect(YaraToken::Colon)?;
                    in_meta = false;
                    in_strings = false;
                    in_condition = true;
                }
                _ if in_meta => {
                    if let Some((key, value)) = self.parse_meta_entry()? {
                        meta.insert(key, value);
                    }
                }
                _ if in_strings => {
                    if let Some(string_def) = self.parse_string_definition()? {
                        strings.push(string_def);
                    }
                }
                _ if in_condition => {
                    // Collect condition tokens until section end
                    match &token {
                        YaraToken::RBrace => break,
                        _ => {
                            condition.push_str(&token_to_string(&token));
                            condition.push(' ');
                            self.advance();
                        }
                    }
                }
                _ => {
                    self.advance();
                }
            }
        }

        Ok(YaraRuleDefinition {
            name,
            namespace: None,
            tags,
            meta,
            strings,
            condition: condition.trim().to_string(),
            condition_ast: None,
            is_private,
            is_global,
        })
    }

    fn parse_meta_entry(&mut self) -> Result<Option<(String, MetaValue)>> {
        let key = match self.peek() {
            Some(YaraToken::Identifier(k)) => k.clone(),
            Some(YaraToken::Meta) | Some(YaraToken::Strings) | Some(YaraToken::Condition) => {
                return Ok(None);
            }
            _ => return Ok(None),
        };
        self.advance();

        self.expect(YaraToken::Assign)?;

        let value = match self.advance() {
            Some(YaraToken::Text(s)) => MetaValue::String(s.clone()),
            Some(YaraToken::Number(n)) => MetaValue::Integer(*n),
            Some(YaraToken::True) => MetaValue::Boolean(true),
            Some(YaraToken::False) => MetaValue::Boolean(false),
            _ => return Err(anyhow!("Invalid meta value")),
        };

        Ok(Some((key, value)))
    }

    fn parse_string_definition(&mut self) -> Result<Option<YaraString>> {
        let identifier = match self.peek() {
            Some(YaraToken::StringIdentifier(id)) => id.clone(),
            Some(YaraToken::Meta) | Some(YaraToken::Strings) | Some(YaraToken::Condition) => {
                return Ok(None);
            }
            _ => return Ok(None),
        };
        self.advance();

        self.expect(YaraToken::Assign)?;

        let pattern = match self.peek().cloned() {
            Some(YaraToken::Text(s)) => {
                self.advance();
                YaraPattern::Text(s)
            }
            Some(YaraToken::HexString(tokens)) => {
                self.advance();
                YaraPattern::Hex(tokens)
            }
            Some(YaraToken::RegexPattern(r)) => {
                self.advance();
                YaraPattern::Regex(r)
            }
            _ => return Err(anyhow!("Expected string pattern")),
        };

        // Parse modifiers
        let mut modifiers = StringModifiers::default();
        while let Some(token) = self.peek() {
            match token {
                YaraToken::Identifier(m) => {
                    match m.as_str() {
                        "nocase" => modifiers.nocase = true,
                        "wide" => modifiers.wide = true,
                        "ascii" => modifiers.ascii = true,
                        "fullword" => modifiers.fullword = true,
                        "private" => modifiers.private = true,
                        "xor" => modifiers.xor = Some(XorModifier::default()),
                        "base64" => modifiers.base64 = Some(Base64Modifier { alphabet: None, wide: false }),
                        "base64wide" => modifiers.base64 = Some(Base64Modifier { alphabet: None, wide: true }),
                        _ => break,
                    }
                    self.advance();
                }
                _ => break,
            }
        }

        Ok(Some(YaraString {
            identifier,
            pattern,
            modifiers,
        }))
    }
}

/// Convert token to string representation for condition building
fn token_to_string(token: &YaraToken) -> String {
    match token {
        YaraToken::True => "true".to_string(),
        YaraToken::False => "false".to_string(),
        YaraToken::And => "and".to_string(),
        YaraToken::Or => "or".to_string(),
        YaraToken::Not => "not".to_string(),
        YaraToken::Of => "of".to_string(),
        YaraToken::Them => "them".to_string(),
        YaraToken::All => "all".to_string(),
        YaraToken::Any => "any".to_string(),
        YaraToken::None => "none".to_string(),
        YaraToken::At => "at".to_string(),
        YaraToken::In => "in".to_string(),
        YaraToken::For => "for".to_string(),
        YaraToken::Contains => "contains".to_string(),
        YaraToken::IContains => "icontains".to_string(),
        YaraToken::StartsWith => "startswith".to_string(),
        YaraToken::IStartsWith => "istartswith".to_string(),
        YaraToken::EndsWith => "endswith".to_string(),
        YaraToken::IEndsWith => "iendswith".to_string(),
        YaraToken::Matches => "matches".to_string(),
        YaraToken::Defined => "defined".to_string(),
        YaraToken::Filesize => "filesize".to_string(),
        YaraToken::Entrypoint => "entrypoint".to_string(),
        YaraToken::Identifier(s) => s.clone(),
        YaraToken::StringIdentifier(s) => format!("${}", s),
        YaraToken::StringCount(s) => format!("#{}", s),
        YaraToken::StringOffset(s) => format!("@{}", s),
        YaraToken::StringLength(s) => format!("!{}", s),
        YaraToken::Number(n) => n.to_string(),
        YaraToken::Float(f) => f.to_string(),
        YaraToken::Text(s) => format!("\"{}\"", s),
        YaraToken::LParen => "(".to_string(),
        YaraToken::RParen => ")".to_string(),
        YaraToken::LBrace => "{".to_string(),
        YaraToken::RBrace => "}".to_string(),
        YaraToken::LBracket => "[".to_string(),
        YaraToken::RBracket => "]".to_string(),
        YaraToken::Colon => ":".to_string(),
        YaraToken::Comma => ",".to_string(),
        YaraToken::Dot => ".".to_string(),
        YaraToken::DotDot => "..".to_string(),
        YaraToken::Equals => "==".to_string(),
        YaraToken::NotEquals => "!=".to_string(),
        YaraToken::Less => "<".to_string(),
        YaraToken::LessEq => "<=".to_string(),
        YaraToken::Greater => ">".to_string(),
        YaraToken::GreaterEq => ">=".to_string(),
        YaraToken::Plus => "+".to_string(),
        YaraToken::Minus => "-".to_string(),
        YaraToken::Star => "*".to_string(),
        YaraToken::Slash => "/".to_string(),
        YaraToken::Percent => "%".to_string(),
        YaraToken::Pipe => "|".to_string(),
        YaraToken::Ampersand => "&".to_string(),
        YaraToken::Caret => "^".to_string(),
        YaraToken::Tilde => "~".to_string(),
        YaraToken::ShiftLeft => "<<".to_string(),
        YaraToken::ShiftRight => ">>".to_string(),
        YaraToken::Assign => "=".to_string(),
        _ => String::new(),
    }
}

impl YaraEngine {
    /// Create a new YARA engine with built-in rules
    pub fn new() -> Self {
        let mut engine = Self {
            rules: vec![],
            imports: HashSet::new(),
            externals: HashMap::new(),
        };
        engine.load_builtin_rules();
        engine
    }

    /// Set an external variable
    pub fn set_external(&mut self, name: &str, value: ExternalValue) {
        self.externals.insert(name.to_string(), value);
    }

    /// Parse and add rules from YARA source code
    pub fn parse_rules(&mut self, source: &str) -> Result<usize> {
        let mut lexer = YaraLexer::new(source);
        let tokens = lexer.tokenize()?;
        let mut parser = YaraParser::new(tokens);
        let rules = parser.parse_rules()?;
        let count = rules.len();
        self.rules.extend(rules);
        Ok(count)
    }

    /// Parse rules from a file
    pub fn parse_file(&mut self, path: &std::path::Path) -> Result<usize> {
        let content = std::fs::read_to_string(path)?;
        self.parse_rules(&content)
    }

    /// Validate YARA source without adding rules
    pub fn validate_rules(source: &str) -> Result<Vec<String>> {
        let mut lexer = YaraLexer::new(source);
        let tokens = lexer.tokenize()?;
        let mut parser = YaraParser::new(tokens);
        let rules = parser.parse_rules()?;
        Ok(rules.into_iter().map(|r| r.name).collect())
    }

    /// Load built-in malware detection rules
    fn load_builtin_rules(&mut self) {
        // Ransomware indicators
        self.rules.push(YaraRuleDefinition {
            name: "ransomware_indicators".to_string(),
            namespace: None,
            tags: vec!["ransomware".to_string()],
            meta: HashMap::from([
                ("description".to_string(), MetaValue::String("Detects common ransomware indicators".to_string())),
                ("severity".to_string(), MetaValue::String("critical".to_string())),
            ]),
            strings: vec![
                YaraString {
                    identifier: "$ransom1".to_string(),
                    pattern: YaraPattern::Text("Your files have been encrypted".to_string()),
                    modifiers: StringModifiers { nocase: true, ..Default::default() },
                },
                YaraString {
                    identifier: "$ransom2".to_string(),
                    pattern: YaraPattern::Text("Bitcoin".to_string()),
                    modifiers: StringModifiers { nocase: true, ..Default::default() },
                },
                YaraString {
                    identifier: "$ransom3".to_string(),
                    pattern: YaraPattern::Text("decrypt".to_string()),
                    modifiers: StringModifiers { nocase: true, ..Default::default() },
                },
                YaraString {
                    identifier: "$ransom4".to_string(),
                    pattern: YaraPattern::Text(".onion".to_string()),
                    modifiers: StringModifiers::default(),
                },
                YaraString {
                    identifier: "$ransom5".to_string(),
                    pattern: YaraPattern::Text("ransom".to_string()),
                    modifiers: StringModifiers { nocase: true, ..Default::default() },
                },
            ],
            condition: "2 of them".to_string(),
            condition_ast: None,
            is_private: false,
            is_global: false,
        });

        // Keylogger indicators
        self.rules.push(YaraRuleDefinition {
            name: "keylogger_indicators".to_string(),
            namespace: None,
            tags: vec!["keylogger".to_string(), "spyware".to_string()],
            meta: HashMap::from([
                ("description".to_string(), MetaValue::String("Detects keylogger functionality".to_string())),
                ("severity".to_string(), MetaValue::String("high".to_string())),
            ]),
            strings: vec![
                YaraString {
                    identifier: "$api1".to_string(),
                    pattern: YaraPattern::Text("GetAsyncKeyState".to_string()),
                    modifiers: StringModifiers::default(),
                },
                YaraString {
                    identifier: "$api2".to_string(),
                    pattern: YaraPattern::Text("SetWindowsHookEx".to_string()),
                    modifiers: StringModifiers::default(),
                },
                YaraString {
                    identifier: "$api3".to_string(),
                    pattern: YaraPattern::Text("GetKeyboardState".to_string()),
                    modifiers: StringModifiers::default(),
                },
                YaraString {
                    identifier: "$api4".to_string(),
                    pattern: YaraPattern::Text("GetKeyState".to_string()),
                    modifiers: StringModifiers::default(),
                },
            ],
            condition: "2 of them".to_string(),
            condition_ast: None,
            is_private: false,
            is_global: false,
        });

        // RAT indicators
        self.rules.push(YaraRuleDefinition {
            name: "rat_indicators".to_string(),
            namespace: None,
            tags: vec!["rat".to_string(), "trojan".to_string()],
            meta: HashMap::from([
                ("description".to_string(), MetaValue::String("Detects Remote Access Trojan indicators".to_string())),
                ("severity".to_string(), MetaValue::String("critical".to_string())),
            ]),
            strings: vec![
                YaraString {
                    identifier: "$cmd1".to_string(),
                    pattern: YaraPattern::Text("shell".to_string()),
                    modifiers: StringModifiers { nocase: true, ..Default::default() },
                },
                YaraString {
                    identifier: "$cmd2".to_string(),
                    pattern: YaraPattern::Text("execute".to_string()),
                    modifiers: StringModifiers { nocase: true, ..Default::default() },
                },
                YaraString {
                    identifier: "$cmd3".to_string(),
                    pattern: YaraPattern::Text("download".to_string()),
                    modifiers: StringModifiers { nocase: true, ..Default::default() },
                },
                YaraString {
                    identifier: "$cmd4".to_string(),
                    pattern: YaraPattern::Text("upload".to_string()),
                    modifiers: StringModifiers { nocase: true, ..Default::default() },
                },
                YaraString {
                    identifier: "$cmd5".to_string(),
                    pattern: YaraPattern::Text("screenshot".to_string()),
                    modifiers: StringModifiers { nocase: true, ..Default::default() },
                },
                YaraString {
                    identifier: "$cmd6".to_string(),
                    pattern: YaraPattern::Text("webcam".to_string()),
                    modifiers: StringModifiers { nocase: true, ..Default::default() },
                },
            ],
            condition: "3 of them".to_string(),
            condition_ast: None,
            is_private: false,
            is_global: false,
        });

        // Miner indicators
        self.rules.push(YaraRuleDefinition {
            name: "cryptominer_indicators".to_string(),
            namespace: None,
            tags: vec!["miner".to_string()],
            meta: HashMap::from([
                ("description".to_string(), MetaValue::String("Detects cryptocurrency miner indicators".to_string())),
                ("severity".to_string(), MetaValue::String("medium".to_string())),
            ]),
            strings: vec![
                YaraString {
                    identifier: "$pool1".to_string(),
                    pattern: YaraPattern::Text("stratum+tcp://".to_string()),
                    modifiers: StringModifiers::default(),
                },
                YaraString {
                    identifier: "$pool2".to_string(),
                    pattern: YaraPattern::Text("mining.pool".to_string()),
                    modifiers: StringModifiers { nocase: true, ..Default::default() },
                },
                YaraString {
                    identifier: "$algo1".to_string(),
                    pattern: YaraPattern::Text("cryptonight".to_string()),
                    modifiers: StringModifiers { nocase: true, ..Default::default() },
                },
                YaraString {
                    identifier: "$algo2".to_string(),
                    pattern: YaraPattern::Text("randomx".to_string()),
                    modifiers: StringModifiers { nocase: true, ..Default::default() },
                },
                YaraString {
                    identifier: "$wallet".to_string(),
                    pattern: YaraPattern::Text("wallet".to_string()),
                    modifiers: StringModifiers { nocase: true, ..Default::default() },
                },
            ],
            condition: "2 of them".to_string(),
            condition_ast: None,
            is_private: false,
            is_global: false,
        });

        // Anti-debugging techniques
        self.rules.push(YaraRuleDefinition {
            name: "anti_debug".to_string(),
            namespace: None,
            tags: vec!["anti_debug".to_string(), "evasion".to_string()],
            meta: HashMap::from([
                ("description".to_string(), MetaValue::String("Detects anti-debugging techniques".to_string())),
                ("severity".to_string(), MetaValue::String("medium".to_string())),
            ]),
            strings: vec![
                YaraString {
                    identifier: "$api1".to_string(),
                    pattern: YaraPattern::Text("IsDebuggerPresent".to_string()),
                    modifiers: StringModifiers::default(),
                },
                YaraString {
                    identifier: "$api2".to_string(),
                    pattern: YaraPattern::Text("CheckRemoteDebuggerPresent".to_string()),
                    modifiers: StringModifiers::default(),
                },
                YaraString {
                    identifier: "$api3".to_string(),
                    pattern: YaraPattern::Text("NtQueryInformationProcess".to_string()),
                    modifiers: StringModifiers::default(),
                },
                YaraString {
                    identifier: "$api4".to_string(),
                    pattern: YaraPattern::Text("OutputDebugString".to_string()),
                    modifiers: StringModifiers::default(),
                },
            ],
            condition: "2 of them".to_string(),
            condition_ast: None,
            is_private: false,
            is_global: false,
        });

        // Anti-VM techniques
        self.rules.push(YaraRuleDefinition {
            name: "anti_vm".to_string(),
            namespace: None,
            tags: vec!["anti_vm".to_string(), "evasion".to_string()],
            meta: HashMap::from([
                ("description".to_string(), MetaValue::String("Detects anti-VM techniques".to_string())),
                ("severity".to_string(), MetaValue::String("medium".to_string())),
            ]),
            strings: vec![
                YaraString {
                    identifier: "$vm1".to_string(),
                    pattern: YaraPattern::Text("VMware".to_string()),
                    modifiers: StringModifiers { nocase: true, ..Default::default() },
                },
                YaraString {
                    identifier: "$vm2".to_string(),
                    pattern: YaraPattern::Text("VirtualBox".to_string()),
                    modifiers: StringModifiers { nocase: true, ..Default::default() },
                },
                YaraString {
                    identifier: "$vm3".to_string(),
                    pattern: YaraPattern::Text("QEMU".to_string()),
                    modifiers: StringModifiers { nocase: true, ..Default::default() },
                },
                YaraString {
                    identifier: "$vm4".to_string(),
                    pattern: YaraPattern::Text("Hyper-V".to_string()),
                    modifiers: StringModifiers { nocase: true, ..Default::default() },
                },
                YaraString {
                    identifier: "$vm5".to_string(),
                    pattern: YaraPattern::Text("vboxservice".to_string()),
                    modifiers: StringModifiers { nocase: true, ..Default::default() },
                },
            ],
            condition: "2 of them".to_string(),
            condition_ast: None,
            is_private: false,
            is_global: false,
        });

        // Credential stealing
        self.rules.push(YaraRuleDefinition {
            name: "credential_stealer".to_string(),
            namespace: None,
            tags: vec!["stealer".to_string(), "credential".to_string()],
            meta: HashMap::from([
                ("description".to_string(), MetaValue::String("Detects credential stealing behavior".to_string())),
                ("severity".to_string(), MetaValue::String("critical".to_string())),
            ]),
            strings: vec![
                YaraString {
                    identifier: "$browser1".to_string(),
                    pattern: YaraPattern::Text("Login Data".to_string()),
                    modifiers: StringModifiers::default(),
                },
                YaraString {
                    identifier: "$browser2".to_string(),
                    pattern: YaraPattern::Text("cookies.sqlite".to_string()),
                    modifiers: StringModifiers::default(),
                },
                YaraString {
                    identifier: "$browser3".to_string(),
                    pattern: YaraPattern::Text("Chrome\\User Data".to_string()),
                    modifiers: StringModifiers { nocase: true, ..Default::default() },
                },
                YaraString {
                    identifier: "$browser4".to_string(),
                    pattern: YaraPattern::Text("Firefox\\Profiles".to_string()),
                    modifiers: StringModifiers { nocase: true, ..Default::default() },
                },
                YaraString {
                    identifier: "$cred1".to_string(),
                    pattern: YaraPattern::Text("password".to_string()),
                    modifiers: StringModifiers { nocase: true, ..Default::default() },
                },
            ],
            condition: "2 of them".to_string(),
            condition_ast: None,
            is_private: false,
            is_global: false,
        });

        // Process injection
        self.rules.push(YaraRuleDefinition {
            name: "process_injection".to_string(),
            namespace: None,
            tags: vec!["injection".to_string(), "evasion".to_string()],
            meta: HashMap::from([
                ("description".to_string(), MetaValue::String("Detects process injection techniques".to_string())),
                ("severity".to_string(), MetaValue::String("high".to_string())),
            ]),
            strings: vec![
                YaraString {
                    identifier: "$api1".to_string(),
                    pattern: YaraPattern::Text("VirtualAllocEx".to_string()),
                    modifiers: StringModifiers::default(),
                },
                YaraString {
                    identifier: "$api2".to_string(),
                    pattern: YaraPattern::Text("WriteProcessMemory".to_string()),
                    modifiers: StringModifiers::default(),
                },
                YaraString {
                    identifier: "$api3".to_string(),
                    pattern: YaraPattern::Text("CreateRemoteThread".to_string()),
                    modifiers: StringModifiers::default(),
                },
                YaraString {
                    identifier: "$api4".to_string(),
                    pattern: YaraPattern::Text("NtCreateThreadEx".to_string()),
                    modifiers: StringModifiers::default(),
                },
                YaraString {
                    identifier: "$api5".to_string(),
                    pattern: YaraPattern::Text("QueueUserAPC".to_string()),
                    modifiers: StringModifiers::default(),
                },
            ],
            condition: "3 of them".to_string(),
            condition_ast: None,
            is_private: false,
            is_global: false,
        });

        // Persistence mechanisms
        self.rules.push(YaraRuleDefinition {
            name: "persistence_registry".to_string(),
            namespace: None,
            tags: vec!["persistence".to_string()],
            meta: HashMap::from([
                ("description".to_string(), MetaValue::String("Detects registry-based persistence".to_string())),
                ("severity".to_string(), MetaValue::String("high".to_string())),
            ]),
            strings: vec![
                YaraString {
                    identifier: "$reg1".to_string(),
                    pattern: YaraPattern::Text("CurrentVersion\\Run".to_string()),
                    modifiers: StringModifiers { nocase: true, ..Default::default() },
                },
                YaraString {
                    identifier: "$reg2".to_string(),
                    pattern: YaraPattern::Text("CurrentVersion\\RunOnce".to_string()),
                    modifiers: StringModifiers { nocase: true, ..Default::default() },
                },
                YaraString {
                    identifier: "$reg3".to_string(),
                    pattern: YaraPattern::Text("Winlogon\\Shell".to_string()),
                    modifiers: StringModifiers { nocase: true, ..Default::default() },
                },
                YaraString {
                    identifier: "$reg4".to_string(),
                    pattern: YaraPattern::Text("Winlogon\\Userinit".to_string()),
                    modifiers: StringModifiers { nocase: true, ..Default::default() },
                },
            ],
            condition: "any of them".to_string(),
            condition_ast: None,
            is_private: false,
            is_global: false,
        });

        // Shellcode patterns
        self.rules.push(YaraRuleDefinition {
            name: "shellcode_patterns".to_string(),
            namespace: None,
            tags: vec!["shellcode".to_string(), "exploit".to_string()],
            meta: HashMap::from([
                ("description".to_string(), MetaValue::String("Detects common shellcode patterns".to_string())),
                ("severity".to_string(), MetaValue::String("critical".to_string())),
            ]),
            strings: vec![
                // NOP sled
                YaraString {
                    identifier: "$nop".to_string(),
                    pattern: YaraPattern::Hex(vec![
                        HexToken::Byte(0x90), HexToken::Byte(0x90), HexToken::Byte(0x90), HexToken::Byte(0x90),
                        HexToken::Byte(0x90), HexToken::Byte(0x90), HexToken::Byte(0x90), HexToken::Byte(0x90),
                    ]),
                    modifiers: StringModifiers::default(),
                },
                // Call/pop pattern
                YaraString {
                    identifier: "$callpop".to_string(),
                    pattern: YaraPattern::Hex(vec![
                        HexToken::Byte(0xe8), HexToken::Byte(0x00), HexToken::Byte(0x00),
                        HexToken::Byte(0x00), HexToken::Byte(0x00), HexToken::Byte(0x58),
                    ]),
                    modifiers: StringModifiers::default(),
                },
            ],
            condition: "any of them".to_string(),
            condition_ast: None,
            is_private: false,
            is_global: false,
        });
    }

    /// Scan data with all loaded rules
    pub fn scan(&self, data: &[u8]) -> Vec<YaraMatch> {
        let mut matches = vec![];

        for rule in &self.rules {
            if rule.is_private {
                continue; // Skip private rules in output
            }
            if let Some(rule_match) = self.match_rule(rule, data) {
                matches.push(rule_match);
            }
        }

        matches
    }

    /// Scan data and return detailed results
    pub fn scan_detailed(&self, data: &[u8]) -> YaraScanResult {
        let matches = self.scan(data);
        YaraScanResult {
            matches,
            file_size: data.len(),
            scan_time_ms: 0, // Would need timing
        }
    }

    /// Match a single rule against data
    fn match_rule(&self, rule: &YaraRuleDefinition, data: &[u8]) -> Option<YaraMatch> {
        let mut matched_strings = vec![];
        let mut unique_identifiers = HashSet::new();

        for string in &rule.strings {
            let string_matches = self.find_pattern(&string.pattern, data, &string.modifiers);

            for (offset, matched_data) in string_matches {
                unique_identifiers.insert(string.identifier.clone());
                matched_strings.push(YaraStringMatch {
                    identifier: string.identifier.clone(),
                    offset,
                    data: matched_data,
                });
            }
        }

        // Evaluate condition
        if self.evaluate_condition(&rule.condition, &matched_strings, &unique_identifiers, rule.strings.len()) {
            // Convert MetaValue to String for output
            let meta_strings: HashMap<String, String> = rule.meta.iter()
                .map(|(k, v)| (k.clone(), v.as_string()))
                .collect();

            Some(YaraMatch {
                rule_name: rule.name.clone(),
                rule_namespace: rule.namespace.clone(),
                tags: rule.tags.clone(),
                meta: meta_strings,
                matched_strings,
            })
        } else {
            None
        }
    }

    /// Find pattern matches in data
    fn find_pattern(&self, pattern: &YaraPattern, data: &[u8], modifiers: &StringModifiers) -> Vec<(u64, String)> {
        let mut matches = vec![];

        match pattern {
            YaraPattern::Text(text) => {
                self.find_text_pattern(text, data, modifiers, &mut matches);
            }
            YaraPattern::Hex(tokens) => {
                self.find_hex_pattern(tokens, data, &mut matches);
            }
            YaraPattern::Regex(regex_str) => {
                self.find_regex_pattern(regex_str, data, modifiers, &mut matches);
            }
        }

        matches
    }

    /// Find text pattern matches
    fn find_text_pattern(&self, text: &str, data: &[u8], modifiers: &StringModifiers, matches: &mut Vec<(u64, String)>) {
        // Handle wide strings (UTF-16LE)
        if modifiers.wide {
            let wide_pattern: Vec<u8> = text.bytes()
                .flat_map(|b| vec![b, 0])
                .collect();
            self.find_bytes_in_data(&wide_pattern, data, text, modifiers.nocase, matches);
        }

        // Handle ASCII strings (default or explicit)
        if modifiers.ascii || !modifiers.wide {
            let pattern = text.as_bytes();
            self.find_bytes_in_data(pattern, data, text, modifiers.nocase, matches);
        }

        // Handle XOR encoded strings
        if let Some(ref xor_mod) = modifiers.xor {
            for key in xor_mod.min..=xor_mod.max {
                if key == 0 { continue; } // Skip 0, already handled above
                let xored: Vec<u8> = text.bytes().map(|b| b ^ key).collect();
                let mut xor_matches = vec![];
                self.find_bytes_in_data(&xored, data, &format!("{} (xor 0x{:02x})", text, key), false, &mut xor_matches);
                matches.extend(xor_matches);
            }
        }
    }

    /// Find bytes in data with optional case-insensitive matching
    fn find_bytes_in_data(&self, pattern: &[u8], data: &[u8], display: &str, nocase: bool, matches: &mut Vec<(u64, String)>) {
        if pattern.is_empty() || pattern.len() > data.len() {
            return;
        }

        let mut pos = 0;
        while pos + pattern.len() <= data.len() {
            let slice = &data[pos..pos + pattern.len()];
            let matched = if nocase {
                slice.iter().zip(pattern.iter()).all(|(a, b)| a.to_ascii_lowercase() == b.to_ascii_lowercase())
            } else {
                slice == pattern
            };

            if matched {
                matches.push((pos as u64, display.to_string()));
                if matches.len() >= 100 {
                    return;
                }
            }
            pos += 1;
        }
    }

    /// Find hex pattern matches (supports wildcards)
    fn find_hex_pattern(&self, tokens: &[HexToken], data: &[u8], matches: &mut Vec<(u64, String)>) {
        if tokens.is_empty() {
            return;
        }

        // Calculate minimum pattern length
        let min_len: usize = tokens.iter().map(|t| match t {
            HexToken::Byte(_) | HexToken::Wildcard |
            HexToken::WildcardNibbleHigh(_) | HexToken::WildcardNibbleLow(_) => 1,
            HexToken::Jump(min, _) => *min,
            HexToken::Alternative(alts) => alts.iter()
                .map(|a| a.len())
                .min()
                .unwrap_or(0),
        }).sum();

        let mut pos = 0;
        while pos + min_len <= data.len() {
            if let Some(match_len) = self.match_hex_pattern_at(tokens, &data[pos..]) {
                let hex_str = data[pos..pos + match_len].iter()
                    .map(|b| format!("{:02x}", b))
                    .collect::<Vec<_>>()
                    .join(" ");
                matches.push((pos as u64, hex_str));
                if matches.len() >= 100 {
                    return;
                }
            }
            pos += 1;
        }
    }

    /// Try to match hex pattern at specific position
    fn match_hex_pattern_at(&self, tokens: &[HexToken], data: &[u8]) -> Option<usize> {
        let mut data_pos = 0;
        let mut token_pos = 0;

        while token_pos < tokens.len() {
            if data_pos >= data.len() {
                return None;
            }

            match &tokens[token_pos] {
                HexToken::Byte(b) => {
                    if data[data_pos] != *b {
                        return None;
                    }
                    data_pos += 1;
                }
                HexToken::Wildcard => {
                    data_pos += 1;
                }
                HexToken::WildcardNibbleHigh(low) => {
                    if (data[data_pos] & 0x0F) != *low {
                        return None;
                    }
                    data_pos += 1;
                }
                HexToken::WildcardNibbleLow(high) => {
                    if (data[data_pos] & 0xF0) != *high {
                        return None;
                    }
                    data_pos += 1;
                }
                HexToken::Jump(min, max) => {
                    let max_jump = max.unwrap_or(*min);
                    // Try each possible jump length
                    let remaining_tokens = &tokens[token_pos + 1..];
                    for jump_len in *min..=max_jump {
                        if data_pos + jump_len <= data.len() {
                            if let Some(rest_len) = self.match_hex_pattern_at(remaining_tokens, &data[data_pos + jump_len..]) {
                                return Some(data_pos + jump_len + rest_len);
                            }
                        }
                    }
                    return None;
                }
                HexToken::Alternative(alternatives) => {
                    let mut matched = false;
                    for alt in alternatives {
                        if let Some(alt_len) = self.match_hex_pattern_at(alt, &data[data_pos..]) {
                            data_pos += alt_len;
                            matched = true;
                            break;
                        }
                    }
                    if !matched {
                        return None;
                    }
                }
            }
            token_pos += 1;
        }

        Some(data_pos)
    }

    /// Find regex pattern matches
    fn find_regex_pattern(&self, regex_str: &str, data: &[u8], modifiers: &StringModifiers, matches: &mut Vec<(u64, String)>) {
        // Build regex with modifiers
        let pattern = if modifiers.nocase {
            format!("(?i){}", regex_str)
        } else {
            regex_str.to_string()
        };

        if let Ok(re) = Regex::new(&pattern) {
            // Convert data to string for regex matching (lossy for binary)
            let text = String::from_utf8_lossy(data);
            for m in re.find_iter(&text) {
                matches.push((m.start() as u64, m.as_str().to_string()));
                if matches.len() >= 100 {
                    break;
                }
            }
        }
    }

    /// Evaluate a YARA condition
    fn evaluate_condition(&self, condition: &str, matched_strings: &[YaraStringMatch],
                          unique_ids: &HashSet<String>, total_strings: usize) -> bool {
        let condition = condition.trim().to_lowercase();

        // "any of them" - at least one string matched
        if condition.contains("any of them") {
            return !matched_strings.is_empty();
        }

        // "all of them" - all defined strings matched
        if condition.contains("all of them") {
            return unique_ids.len() == total_strings;
        }

        // "none of them" - no strings matched
        if condition.contains("none of them") {
            return matched_strings.is_empty();
        }

        // "N of them" pattern
        if let Some(n_str) = condition.split_whitespace().next() {
            if let Ok(n) = n_str.parse::<usize>() {
                return unique_ids.len() >= n;
            }
        }

        // Default: any match is sufficient
        !matched_strings.is_empty()
    }

    /// Add a custom rule from YARA source
    pub fn add_rule(&mut self, rule_content: &str) -> Result<()> {
        if rule_content.trim().is_empty() {
            return Err(anyhow!("Empty rule content"));
        }

        // Use the full parser to add the rule
        let count = self.parse_rules(rule_content)?;
        if count == 0 {
            return Err(anyhow!("No valid rules found in content"));
        }
        Ok(())
    }

    /// Remove a rule by name
    pub fn remove_rule(&mut self, name: &str) -> bool {
        let original_len = self.rules.len();
        self.rules.retain(|r| r.name != name);
        self.rules.len() < original_len
    }

    /// Clear all rules
    pub fn clear_rules(&mut self) {
        self.rules.clear();
    }

    /// Get all loaded rules
    pub fn get_rules(&self) -> Vec<String> {
        self.rules.iter().map(|r| r.name.clone()).collect()
    }

    /// Get rule count
    pub fn rule_count(&self) -> usize {
        self.rules.len()
    }

    /// Get rule details
    pub fn get_rule_info(&self, name: &str) -> Option<RuleInfo> {
        self.rules.iter()
            .find(|r| r.name == name)
            .map(|r| RuleInfo {
                name: r.name.clone(),
                namespace: r.namespace.clone(),
                tags: r.tags.clone(),
                is_private: r.is_private,
                is_global: r.is_global,
                string_count: r.strings.len(),
            })
    }
}

/// Information about a loaded rule
#[derive(Debug, Clone)]
pub struct RuleInfo {
    pub name: String,
    pub namespace: Option<String>,
    pub tags: Vec<String>,
    pub is_private: bool,
    pub is_global: bool,
    pub string_count: usize,
}

impl Default for YaraEngine {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_scan_ransomware() {
        let engine = YaraEngine::new();
        let data = b"Your files have been encrypted. Send 1 Bitcoin to decrypt.";
        let matches = engine.scan(data);
        assert!(!matches.is_empty());
        assert!(matches.iter().any(|m| m.rule_name == "ransomware_indicators"));
    }

    #[test]
    fn test_scan_clean() {
        let engine = YaraEngine::new();
        let data = b"This is just a normal text document with no malicious content.";
        let matches = engine.scan(data);
        // Clean file should have no or minimal matches
        assert!(matches.len() < 2);
    }

    #[test]
    fn test_parse_simple_rule() {
        let mut engine = YaraEngine::new();
        engine.clear_rules();

        let rule = r#"
            rule test_rule {
                meta:
                    description = "Test rule"
                    author = "Test"
                strings:
                    $a = "hello"
                    $b = "world"
                condition:
                    any of them
            }
        "#;

        assert!(engine.add_rule(rule).is_ok());
        assert!(engine.get_rules().contains(&"test_rule".to_string()));
    }

    #[test]
    fn test_parse_rule_with_tags() {
        let mut engine = YaraEngine::new();
        engine.clear_rules();

        let rule = r#"
            rule tagged_rule : malware trojan {
                strings:
                    $s1 = "malicious"
                condition:
                    $s1
            }
        "#;

        assert!(engine.add_rule(rule).is_ok());
        let info = engine.get_rule_info("tagged_rule");
        assert!(info.is_some());
        let info = info.unwrap();
        assert!(info.tags.contains(&"malware".to_string()));
        assert!(info.tags.contains(&"trojan".to_string()));
    }

    #[test]
    fn test_parse_hex_string() {
        let mut engine = YaraEngine::new();
        engine.clear_rules();

        let rule = r#"
            rule hex_test {
                strings:
                    $hex = { 48 8B 05 ?? ?? ?? ?? }
                condition:
                    $hex
            }
        "#;

        assert!(engine.add_rule(rule).is_ok());
    }

    #[test]
    fn test_hex_wildcard_matching() {
        let mut engine = YaraEngine::new();
        engine.clear_rules();

        let rule = r#"
            rule wildcard_test {
                strings:
                    $a = { 90 90 ?? 90 }
                condition:
                    $a
            }
        "#;

        engine.add_rule(rule).unwrap();

        let data = &[0x90, 0x90, 0xFF, 0x90];
        let matches = engine.scan(data);
        assert!(!matches.is_empty());
    }

    #[test]
    fn test_wide_string() {
        let mut engine = YaraEngine::new();
        engine.clear_rules();

        let rule = r#"
            rule wide_test {
                strings:
                    $a = "test" wide
                condition:
                    $a
            }
        "#;

        engine.add_rule(rule).unwrap();

        // UTF-16LE "test"
        let data = &[0x74, 0x00, 0x65, 0x00, 0x73, 0x00, 0x74, 0x00];
        let matches = engine.scan(data);
        assert!(!matches.is_empty());
    }

    #[test]
    fn test_case_insensitive() {
        let mut engine = YaraEngine::new();
        engine.clear_rules();

        let rule = r#"
            rule nocase_test {
                strings:
                    $a = "TEST" nocase
                condition:
                    $a
            }
        "#;

        engine.add_rule(rule).unwrap();

        let data = b"this is a test string";
        let matches = engine.scan(data);
        assert!(!matches.is_empty());
    }

    #[test]
    fn test_n_of_them_condition() {
        let mut engine = YaraEngine::new();
        engine.clear_rules();

        let rule = r#"
            rule count_test {
                strings:
                    $a = "one"
                    $b = "two"
                    $c = "three"
                condition:
                    2 of them
            }
        "#;

        engine.add_rule(rule).unwrap();

        // Should match - has 2 of 3 strings
        let data = b"one and two here";
        let matches = engine.scan(data);
        assert!(!matches.is_empty());

        // Should not match - only 1 of 3 strings
        let data2 = b"just one here";
        let matches2 = engine.scan(data2);
        assert!(matches2.is_empty());
    }

    #[test]
    fn test_builtin_rules_count() {
        let engine = YaraEngine::new();
        assert!(engine.rule_count() >= 10, "Should have at least 10 built-in rules");
    }

    #[test]
    fn test_lexer_tokens() {
        let input = r#"rule test { condition: true }"#;
        let mut lexer = YaraLexer::new(input);
        let tokens = lexer.tokenize().unwrap();

        assert!(tokens.contains(&YaraToken::Rule));
        assert!(tokens.contains(&YaraToken::Condition));
        assert!(tokens.contains(&YaraToken::True));
    }

    #[test]
    fn test_validate_rules() {
        let rule = r#"
            rule valid_rule {
                condition: true
            }
        "#;

        let result = YaraEngine::validate_rules(rule);
        assert!(result.is_ok());
        assert!(result.unwrap().contains(&"valid_rule".to_string()));
    }
}
