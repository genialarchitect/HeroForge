//! YARA Engine
//!
//! Enhanced YARA rule matching engine for malware detection.

use std::collections::HashMap;
use anyhow::{Result, anyhow};

use crate::malware_analysis::types::*;

/// YARA scanning engine
pub struct YaraEngine {
    /// Built-in rules
    rules: Vec<YaraRuleDefinition>,
}

/// Internal YARA rule definition
#[derive(Debug, Clone)]
struct YaraRuleDefinition {
    name: String,
    tags: Vec<String>,
    meta: HashMap<String, String>,
    strings: Vec<YaraString>,
    condition: String,
}

/// YARA string pattern
#[derive(Debug, Clone)]
struct YaraString {
    identifier: String,
    pattern: YaraPattern,
    modifiers: Vec<String>,
}

/// YARA pattern type
#[derive(Debug, Clone)]
enum YaraPattern {
    Text(String),
    Hex(Vec<u8>),
    Regex(String),
}

impl YaraEngine {
    /// Create a new YARA engine with built-in rules
    pub fn new() -> Self {
        let mut engine = Self {
            rules: vec![],
        };
        engine.load_builtin_rules();
        engine
    }

    /// Load built-in malware detection rules
    fn load_builtin_rules(&mut self) {
        // Ransomware indicators
        self.rules.push(YaraRuleDefinition {
            name: "ransomware_indicators".to_string(),
            tags: vec!["ransomware".to_string()],
            meta: HashMap::from([
                ("description".to_string(), "Detects common ransomware indicators".to_string()),
                ("severity".to_string(), "critical".to_string()),
            ]),
            strings: vec![
                YaraString {
                    identifier: "$ransom1".to_string(),
                    pattern: YaraPattern::Text("Your files have been encrypted".to_string()),
                    modifiers: vec!["nocase".to_string()],
                },
                YaraString {
                    identifier: "$ransom2".to_string(),
                    pattern: YaraPattern::Text("Bitcoin".to_string()),
                    modifiers: vec!["nocase".to_string()],
                },
                YaraString {
                    identifier: "$ransom3".to_string(),
                    pattern: YaraPattern::Text("decrypt".to_string()),
                    modifiers: vec!["nocase".to_string()],
                },
                YaraString {
                    identifier: "$ransom4".to_string(),
                    pattern: YaraPattern::Text(".onion".to_string()),
                    modifiers: vec![],
                },
                YaraString {
                    identifier: "$ransom5".to_string(),
                    pattern: YaraPattern::Text("ransom".to_string()),
                    modifiers: vec!["nocase".to_string()],
                },
            ],
            condition: "2 of them".to_string(),
        });

        // Keylogger indicators
        self.rules.push(YaraRuleDefinition {
            name: "keylogger_indicators".to_string(),
            tags: vec!["keylogger".to_string(), "spyware".to_string()],
            meta: HashMap::from([
                ("description".to_string(), "Detects keylogger functionality".to_string()),
                ("severity".to_string(), "high".to_string()),
            ]),
            strings: vec![
                YaraString {
                    identifier: "$api1".to_string(),
                    pattern: YaraPattern::Text("GetAsyncKeyState".to_string()),
                    modifiers: vec![],
                },
                YaraString {
                    identifier: "$api2".to_string(),
                    pattern: YaraPattern::Text("SetWindowsHookEx".to_string()),
                    modifiers: vec![],
                },
                YaraString {
                    identifier: "$api3".to_string(),
                    pattern: YaraPattern::Text("GetKeyboardState".to_string()),
                    modifiers: vec![],
                },
                YaraString {
                    identifier: "$api4".to_string(),
                    pattern: YaraPattern::Text("GetKeyState".to_string()),
                    modifiers: vec![],
                },
            ],
            condition: "2 of them".to_string(),
        });

        // RAT indicators
        self.rules.push(YaraRuleDefinition {
            name: "rat_indicators".to_string(),
            tags: vec!["rat".to_string(), "trojan".to_string()],
            meta: HashMap::from([
                ("description".to_string(), "Detects Remote Access Trojan indicators".to_string()),
                ("severity".to_string(), "critical".to_string()),
            ]),
            strings: vec![
                YaraString {
                    identifier: "$cmd1".to_string(),
                    pattern: YaraPattern::Text("shell".to_string()),
                    modifiers: vec!["nocase".to_string()],
                },
                YaraString {
                    identifier: "$cmd2".to_string(),
                    pattern: YaraPattern::Text("execute".to_string()),
                    modifiers: vec!["nocase".to_string()],
                },
                YaraString {
                    identifier: "$cmd3".to_string(),
                    pattern: YaraPattern::Text("download".to_string()),
                    modifiers: vec!["nocase".to_string()],
                },
                YaraString {
                    identifier: "$cmd4".to_string(),
                    pattern: YaraPattern::Text("upload".to_string()),
                    modifiers: vec!["nocase".to_string()],
                },
                YaraString {
                    identifier: "$cmd5".to_string(),
                    pattern: YaraPattern::Text("screenshot".to_string()),
                    modifiers: vec!["nocase".to_string()],
                },
                YaraString {
                    identifier: "$cmd6".to_string(),
                    pattern: YaraPattern::Text("webcam".to_string()),
                    modifiers: vec!["nocase".to_string()],
                },
            ],
            condition: "3 of them".to_string(),
        });

        // Miner indicators
        self.rules.push(YaraRuleDefinition {
            name: "cryptominer_indicators".to_string(),
            tags: vec!["miner".to_string()],
            meta: HashMap::from([
                ("description".to_string(), "Detects cryptocurrency miner indicators".to_string()),
                ("severity".to_string(), "medium".to_string()),
            ]),
            strings: vec![
                YaraString {
                    identifier: "$pool1".to_string(),
                    pattern: YaraPattern::Text("stratum+tcp://".to_string()),
                    modifiers: vec![],
                },
                YaraString {
                    identifier: "$pool2".to_string(),
                    pattern: YaraPattern::Text("mining.pool".to_string()),
                    modifiers: vec!["nocase".to_string()],
                },
                YaraString {
                    identifier: "$algo1".to_string(),
                    pattern: YaraPattern::Text("cryptonight".to_string()),
                    modifiers: vec!["nocase".to_string()],
                },
                YaraString {
                    identifier: "$algo2".to_string(),
                    pattern: YaraPattern::Text("randomx".to_string()),
                    modifiers: vec!["nocase".to_string()],
                },
                YaraString {
                    identifier: "$wallet".to_string(),
                    pattern: YaraPattern::Text("wallet".to_string()),
                    modifiers: vec!["nocase".to_string()],
                },
            ],
            condition: "2 of them".to_string(),
        });

        // Anti-debugging techniques
        self.rules.push(YaraRuleDefinition {
            name: "anti_debug".to_string(),
            tags: vec!["anti_debug".to_string(), "evasion".to_string()],
            meta: HashMap::from([
                ("description".to_string(), "Detects anti-debugging techniques".to_string()),
                ("severity".to_string(), "medium".to_string()),
            ]),
            strings: vec![
                YaraString {
                    identifier: "$api1".to_string(),
                    pattern: YaraPattern::Text("IsDebuggerPresent".to_string()),
                    modifiers: vec![],
                },
                YaraString {
                    identifier: "$api2".to_string(),
                    pattern: YaraPattern::Text("CheckRemoteDebuggerPresent".to_string()),
                    modifiers: vec![],
                },
                YaraString {
                    identifier: "$api3".to_string(),
                    pattern: YaraPattern::Text("NtQueryInformationProcess".to_string()),
                    modifiers: vec![],
                },
                YaraString {
                    identifier: "$api4".to_string(),
                    pattern: YaraPattern::Text("OutputDebugString".to_string()),
                    modifiers: vec![],
                },
            ],
            condition: "2 of them".to_string(),
        });

        // Anti-VM techniques
        self.rules.push(YaraRuleDefinition {
            name: "anti_vm".to_string(),
            tags: vec!["anti_vm".to_string(), "evasion".to_string()],
            meta: HashMap::from([
                ("description".to_string(), "Detects anti-VM techniques".to_string()),
                ("severity".to_string(), "medium".to_string()),
            ]),
            strings: vec![
                YaraString {
                    identifier: "$vm1".to_string(),
                    pattern: YaraPattern::Text("VMware".to_string()),
                    modifiers: vec!["nocase".to_string()],
                },
                YaraString {
                    identifier: "$vm2".to_string(),
                    pattern: YaraPattern::Text("VirtualBox".to_string()),
                    modifiers: vec!["nocase".to_string()],
                },
                YaraString {
                    identifier: "$vm3".to_string(),
                    pattern: YaraPattern::Text("QEMU".to_string()),
                    modifiers: vec!["nocase".to_string()],
                },
                YaraString {
                    identifier: "$vm4".to_string(),
                    pattern: YaraPattern::Text("Hyper-V".to_string()),
                    modifiers: vec!["nocase".to_string()],
                },
                YaraString {
                    identifier: "$vm5".to_string(),
                    pattern: YaraPattern::Text("vboxservice".to_string()),
                    modifiers: vec!["nocase".to_string()],
                },
            ],
            condition: "2 of them".to_string(),
        });

        // Credential stealing
        self.rules.push(YaraRuleDefinition {
            name: "credential_stealer".to_string(),
            tags: vec!["stealer".to_string(), "credential".to_string()],
            meta: HashMap::from([
                ("description".to_string(), "Detects credential stealing behavior".to_string()),
                ("severity".to_string(), "critical".to_string()),
            ]),
            strings: vec![
                YaraString {
                    identifier: "$browser1".to_string(),
                    pattern: YaraPattern::Text("Login Data".to_string()),
                    modifiers: vec![],
                },
                YaraString {
                    identifier: "$browser2".to_string(),
                    pattern: YaraPattern::Text("cookies.sqlite".to_string()),
                    modifiers: vec![],
                },
                YaraString {
                    identifier: "$browser3".to_string(),
                    pattern: YaraPattern::Text("Chrome\\User Data".to_string()),
                    modifiers: vec!["nocase".to_string()],
                },
                YaraString {
                    identifier: "$browser4".to_string(),
                    pattern: YaraPattern::Text("Firefox\\Profiles".to_string()),
                    modifiers: vec!["nocase".to_string()],
                },
                YaraString {
                    identifier: "$cred1".to_string(),
                    pattern: YaraPattern::Text("password".to_string()),
                    modifiers: vec!["nocase".to_string()],
                },
            ],
            condition: "2 of them".to_string(),
        });

        // Process injection
        self.rules.push(YaraRuleDefinition {
            name: "process_injection".to_string(),
            tags: vec!["injection".to_string(), "evasion".to_string()],
            meta: HashMap::from([
                ("description".to_string(), "Detects process injection techniques".to_string()),
                ("severity".to_string(), "high".to_string()),
            ]),
            strings: vec![
                YaraString {
                    identifier: "$api1".to_string(),
                    pattern: YaraPattern::Text("VirtualAllocEx".to_string()),
                    modifiers: vec![],
                },
                YaraString {
                    identifier: "$api2".to_string(),
                    pattern: YaraPattern::Text("WriteProcessMemory".to_string()),
                    modifiers: vec![],
                },
                YaraString {
                    identifier: "$api3".to_string(),
                    pattern: YaraPattern::Text("CreateRemoteThread".to_string()),
                    modifiers: vec![],
                },
                YaraString {
                    identifier: "$api4".to_string(),
                    pattern: YaraPattern::Text("NtCreateThreadEx".to_string()),
                    modifiers: vec![],
                },
                YaraString {
                    identifier: "$api5".to_string(),
                    pattern: YaraPattern::Text("QueueUserAPC".to_string()),
                    modifiers: vec![],
                },
            ],
            condition: "3 of them".to_string(),
        });

        // Persistence mechanisms
        self.rules.push(YaraRuleDefinition {
            name: "persistence_registry".to_string(),
            tags: vec!["persistence".to_string()],
            meta: HashMap::from([
                ("description".to_string(), "Detects registry-based persistence".to_string()),
                ("severity".to_string(), "high".to_string()),
            ]),
            strings: vec![
                YaraString {
                    identifier: "$reg1".to_string(),
                    pattern: YaraPattern::Text("CurrentVersion\\Run".to_string()),
                    modifiers: vec!["nocase".to_string()],
                },
                YaraString {
                    identifier: "$reg2".to_string(),
                    pattern: YaraPattern::Text("CurrentVersion\\RunOnce".to_string()),
                    modifiers: vec!["nocase".to_string()],
                },
                YaraString {
                    identifier: "$reg3".to_string(),
                    pattern: YaraPattern::Text("Winlogon\\Shell".to_string()),
                    modifiers: vec!["nocase".to_string()],
                },
                YaraString {
                    identifier: "$reg4".to_string(),
                    pattern: YaraPattern::Text("Winlogon\\Userinit".to_string()),
                    modifiers: vec!["nocase".to_string()],
                },
            ],
            condition: "any of them".to_string(),
        });

        // Shellcode patterns
        self.rules.push(YaraRuleDefinition {
            name: "shellcode_patterns".to_string(),
            tags: vec!["shellcode".to_string(), "exploit".to_string()],
            meta: HashMap::from([
                ("description".to_string(), "Detects common shellcode patterns".to_string()),
                ("severity".to_string(), "critical".to_string()),
            ]),
            strings: vec![
                // NOP sled
                YaraString {
                    identifier: "$nop".to_string(),
                    pattern: YaraPattern::Hex(vec![0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90]),
                    modifiers: vec![],
                },
                // Call/pop pattern
                YaraString {
                    identifier: "$callpop".to_string(),
                    pattern: YaraPattern::Hex(vec![0xe8, 0x00, 0x00, 0x00, 0x00, 0x58]),
                    modifiers: vec![],
                },
            ],
            condition: "any of them".to_string(),
        });
    }

    /// Scan data with all loaded rules
    pub fn scan(&self, data: &[u8]) -> Vec<YaraMatch> {
        let mut matches = vec![];

        for rule in &self.rules {
            if let Some(rule_match) = self.match_rule(rule, data) {
                matches.push(rule_match);
            }
        }

        matches
    }

    /// Match a single rule against data
    fn match_rule(&self, rule: &YaraRuleDefinition, data: &[u8]) -> Option<YaraMatch> {
        let mut matched_strings = vec![];

        for string in &rule.strings {
            let string_matches = self.find_pattern(&string.pattern, data, &string.modifiers);

            for (offset, matched_data) in string_matches {
                matched_strings.push(YaraStringMatch {
                    identifier: string.identifier.clone(),
                    offset,
                    data: matched_data,
                });
            }
        }

        // Evaluate condition
        if self.evaluate_condition(&rule.condition, &matched_strings) {
            Some(YaraMatch {
                rule_name: rule.name.clone(),
                rule_namespace: None,
                tags: rule.tags.clone(),
                meta: rule.meta.clone(),
                matched_strings,
            })
        } else {
            None
        }
    }

    /// Find pattern matches in data
    fn find_pattern(&self, pattern: &YaraPattern, data: &[u8], modifiers: &[String]) -> Vec<(u64, String)> {
        let mut matches = vec![];
        let nocase = modifiers.contains(&"nocase".to_string());

        match pattern {
            YaraPattern::Text(text) => {
                let search_text = if nocase { text.to_lowercase() } else { text.clone() };
                let search_data = if nocase {
                    String::from_utf8_lossy(data).to_lowercase()
                } else {
                    String::from_utf8_lossy(data).to_string()
                };

                let mut start = 0;
                while let Some(pos) = search_data[start..].find(&search_text) {
                    let abs_pos = start + pos;
                    matches.push((abs_pos as u64, text.clone()));
                    start = abs_pos + 1;
                    if matches.len() >= 10 {
                        break;
                    }
                }
            }
            YaraPattern::Hex(hex_bytes) => {
                let mut i = 0;
                while i + hex_bytes.len() <= data.len() {
                    if &data[i..i + hex_bytes.len()] == hex_bytes.as_slice() {
                        let hex_str = hex_bytes.iter()
                            .map(|b| format!("{:02x}", b))
                            .collect::<Vec<_>>()
                            .join(" ");
                        matches.push((i as u64, hex_str));
                        if matches.len() >= 10 {
                            break;
                        }
                    }
                    i += 1;
                }
            }
            YaraPattern::Regex(_regex_str) => {
                // Regex matching would go here
            }
        }

        matches
    }

    /// Evaluate a YARA condition
    fn evaluate_condition(&self, condition: &str, matched_strings: &[YaraStringMatch]) -> bool {
        let condition = condition.trim().to_lowercase();

        // "any of them" - at least one string matched
        if condition.contains("any of them") {
            return !matched_strings.is_empty();
        }

        // "all of them" - all strings matched
        if condition.contains("all of them") {
            // Would need to check all defined strings matched
            return !matched_strings.is_empty();
        }

        // "N of them" pattern
        if let Some(captures) = condition.split_whitespace().next() {
            if let Ok(n) = captures.parse::<usize>() {
                return matched_strings.len() >= n;
            }
        }

        // Default: any match is sufficient
        !matched_strings.is_empty()
    }

    /// Add a custom rule
    pub fn add_rule(&mut self, rule_content: &str) -> Result<()> {
        // Parse YARA rule content
        // For now, just validate it's not empty
        if rule_content.trim().is_empty() {
            return Err(anyhow!("Empty rule content"));
        }

        // In production, would parse the YARA syntax here
        Ok(())
    }

    /// Get all loaded rules
    pub fn get_rules(&self) -> Vec<String> {
        self.rules.iter().map(|r| r.name.clone()).collect()
    }

    /// Get rule count
    pub fn rule_count(&self) -> usize {
        self.rules.len()
    }
}

impl Default for YaraEngine {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_scan_ransomware() {
        let engine = YaraEngine::new();
        let data = b"Your files have been encrypted. Send 1 Bitcoin to decrypt.";
        let matches = engine.scan(data);
        assert!(!matches.is_empty());
        assert!(matches.iter().any(|m| m.rule_name == "ransomware_indicators"));
    }

    #[test]
    fn test_scan_clean() {
        let engine = YaraEngine::new();
        let data = b"This is just a normal text document with no malicious content.";
        let matches = engine.scan(data);
        // Clean file should have no or minimal matches
        assert!(matches.len() < 2);
    }
}
