//! API Pattern Analyzer
//!
//! Detects suspicious API usage patterns in malware samples.

use std::collections::HashMap;

use crate::malware_analysis::types::*;

/// API pattern analyzer
pub struct ApiPatternAnalyzer {
    patterns: Vec<ApiPattern>,
}

/// API usage pattern definition
#[derive(Debug, Clone)]
struct ApiPattern {
    name: String,
    pattern_type: SuspiciousPatternType,
    severity: PatternSeverity,
    description: String,
    required_apis: Vec<String>,
    optional_apis: Vec<String>,
    min_required: usize,
    mitre_techniques: Vec<String>,
}

impl ApiPatternAnalyzer {
    /// Create a new API pattern analyzer
    pub fn new() -> Self {
        let mut analyzer = Self {
            patterns: vec![],
        };
        analyzer.load_patterns();
        analyzer
    }

    /// Load built-in API patterns
    fn load_patterns(&mut self) {
        // Process Injection - CreateRemoteThread
        self.patterns.push(ApiPattern {
            name: "CreateRemoteThread Injection".to_string(),
            pattern_type: SuspiciousPatternType::CodeInjection,
            severity: PatternSeverity::Critical,
            description: "Classic process injection using CreateRemoteThread".to_string(),
            required_apis: vec![
                "VirtualAllocEx".to_string(),
                "WriteProcessMemory".to_string(),
                "CreateRemoteThread".to_string(),
            ],
            optional_apis: vec![
                "OpenProcess".to_string(),
                "VirtualProtectEx".to_string(),
            ],
            min_required: 3,
            mitre_techniques: vec!["T1055.001".to_string()],
        });

        // Process Injection - QueueUserAPC
        self.patterns.push(ApiPattern {
            name: "APC Injection".to_string(),
            pattern_type: SuspiciousPatternType::CodeInjection,
            severity: PatternSeverity::Critical,
            description: "Process injection using QueueUserAPC".to_string(),
            required_apis: vec![
                "VirtualAllocEx".to_string(),
                "WriteProcessMemory".to_string(),
                "QueueUserAPC".to_string(),
            ],
            optional_apis: vec![
                "OpenThread".to_string(),
                "NtQueueApcThread".to_string(),
            ],
            min_required: 3,
            mitre_techniques: vec!["T1055.004".to_string()],
        });

        // Process Hollowing
        self.patterns.push(ApiPattern {
            name: "Process Hollowing".to_string(),
            pattern_type: SuspiciousPatternType::ProcessHollowing,
            severity: PatternSeverity::Critical,
            description: "Process hollowing technique detected".to_string(),
            required_apis: vec![
                "CreateProcess".to_string(),
                "NtUnmapViewOfSection".to_string(),
                "VirtualAllocEx".to_string(),
                "WriteProcessMemory".to_string(),
            ],
            optional_apis: vec![
                "ResumeThread".to_string(),
                "SetThreadContext".to_string(),
                "GetThreadContext".to_string(),
            ],
            min_required: 3,
            mitre_techniques: vec!["T1055.012".to_string()],
        });

        // Anti-Debug
        self.patterns.push(ApiPattern {
            name: "Anti-Debugging".to_string(),
            pattern_type: SuspiciousPatternType::AntiDebug,
            severity: PatternSeverity::Medium,
            description: "Anti-debugging techniques detected".to_string(),
            required_apis: vec![],
            optional_apis: vec![
                "IsDebuggerPresent".to_string(),
                "CheckRemoteDebuggerPresent".to_string(),
                "NtQueryInformationProcess".to_string(),
                "OutputDebugString".to_string(),
                "GetTickCount".to_string(),
                "QueryPerformanceCounter".to_string(),
            ],
            min_required: 2,
            mitre_techniques: vec!["T1622".to_string()],
        });

        // Anti-VM
        self.patterns.push(ApiPattern {
            name: "Anti-VM Detection".to_string(),
            pattern_type: SuspiciousPatternType::AntiVm,
            severity: PatternSeverity::Medium,
            description: "Virtual machine detection techniques".to_string(),
            required_apis: vec![],
            optional_apis: vec![
                "GetSystemInfo".to_string(),
                "GlobalMemoryStatusEx".to_string(),
                "GetDiskFreeSpaceEx".to_string(),
                "CreateToolhelp32Snapshot".to_string(),
                "EnumProcesses".to_string(),
            ],
            min_required: 3,
            mitre_techniques: vec!["T1497".to_string()],
        });

        // Keylogging
        self.patterns.push(ApiPattern {
            name: "Keylogging".to_string(),
            pattern_type: SuspiciousPatternType::Collection,
            severity: PatternSeverity::High,
            description: "Keylogging functionality detected".to_string(),
            required_apis: vec![],
            optional_apis: vec![
                "SetWindowsHookEx".to_string(),
                "GetAsyncKeyState".to_string(),
                "GetKeyboardState".to_string(),
                "GetKeyState".to_string(),
                "GetForegroundWindow".to_string(),
                "GetWindowText".to_string(),
            ],
            min_required: 2,
            mitre_techniques: vec!["T1056.001".to_string()],
        });

        // Screen Capture
        self.patterns.push(ApiPattern {
            name: "Screen Capture".to_string(),
            pattern_type: SuspiciousPatternType::Collection,
            severity: PatternSeverity::Medium,
            description: "Screen capture functionality detected".to_string(),
            required_apis: vec![],
            optional_apis: vec![
                "GetDC".to_string(),
                "GetWindowDC".to_string(),
                "BitBlt".to_string(),
                "CreateCompatibleDC".to_string(),
                "CreateCompatibleBitmap".to_string(),
            ],
            min_required: 3,
            mitre_techniques: vec!["T1113".to_string()],
        });

        // Registry Persistence
        self.patterns.push(ApiPattern {
            name: "Registry Persistence".to_string(),
            pattern_type: SuspiciousPatternType::Persistence,
            severity: PatternSeverity::High,
            description: "Registry-based persistence mechanism".to_string(),
            required_apis: vec![],
            optional_apis: vec![
                "RegOpenKeyEx".to_string(),
                "RegSetValueEx".to_string(),
                "RegCreateKeyEx".to_string(),
            ],
            min_required: 2,
            mitre_techniques: vec!["T1547.001".to_string()],
        });

        // Service Persistence
        self.patterns.push(ApiPattern {
            name: "Service Persistence".to_string(),
            pattern_type: SuspiciousPatternType::Persistence,
            severity: PatternSeverity::High,
            description: "Windows service-based persistence".to_string(),
            required_apis: vec![],
            optional_apis: vec![
                "OpenSCManager".to_string(),
                "CreateService".to_string(),
                "StartService".to_string(),
                "ChangeServiceConfig".to_string(),
            ],
            min_required: 2,
            mitre_techniques: vec!["T1543.003".to_string()],
        });

        // Scheduled Task Persistence
        self.patterns.push(ApiPattern {
            name: "Scheduled Task Persistence".to_string(),
            pattern_type: SuspiciousPatternType::Persistence,
            severity: PatternSeverity::High,
            description: "Scheduled task persistence mechanism".to_string(),
            required_apis: vec![],
            optional_apis: vec![
                "CoCreateInstance".to_string(),
                "ITaskService".to_string(),
            ],
            min_required: 1,
            mitre_techniques: vec!["T1053.005".to_string()],
        });

        // Credential Access
        self.patterns.push(ApiPattern {
            name: "Credential Dumping".to_string(),
            pattern_type: SuspiciousPatternType::CredentialAccess,
            severity: PatternSeverity::Critical,
            description: "Credential dumping functionality".to_string(),
            required_apis: vec![],
            optional_apis: vec![
                "LsaOpenPolicy".to_string(),
                "CredEnumerate".to_string(),
                "CryptUnprotectData".to_string(),
                "LsaQueryInformationPolicy".to_string(),
            ],
            min_required: 1,
            mitre_techniques: vec!["T1003".to_string()],
        });

        // File Download
        self.patterns.push(ApiPattern {
            name: "File Download".to_string(),
            pattern_type: SuspiciousPatternType::CommandAndControl,
            severity: PatternSeverity::Medium,
            description: "File download capability".to_string(),
            required_apis: vec![],
            optional_apis: vec![
                "URLDownloadToFile".to_string(),
                "InternetOpen".to_string(),
                "InternetOpenUrl".to_string(),
                "InternetReadFile".to_string(),
                "HttpOpenRequest".to_string(),
            ],
            min_required: 2,
            mitre_techniques: vec!["T1105".to_string()],
        });

        // Process Execution
        self.patterns.push(ApiPattern {
            name: "Process Creation".to_string(),
            pattern_type: SuspiciousPatternType::Execution,
            severity: PatternSeverity::Low,
            description: "Process creation capability".to_string(),
            required_apis: vec![],
            optional_apis: vec![
                "CreateProcess".to_string(),
                "ShellExecute".to_string(),
                "WinExec".to_string(),
                "system".to_string(),
            ],
            min_required: 1,
            mitre_techniques: vec!["T1059".to_string()],
        });

        // Privilege Escalation
        self.patterns.push(ApiPattern {
            name: "Token Manipulation".to_string(),
            pattern_type: SuspiciousPatternType::PrivilegeEscalation,
            severity: PatternSeverity::High,
            description: "Token manipulation for privilege escalation".to_string(),
            required_apis: vec![],
            optional_apis: vec![
                "AdjustTokenPrivileges".to_string(),
                "OpenProcessToken".to_string(),
                "LookupPrivilegeValue".to_string(),
                "ImpersonateLoggedOnUser".to_string(),
                "DuplicateToken".to_string(),
            ],
            min_required: 2,
            mitre_techniques: vec!["T1134".to_string()],
        });

        // Defense Evasion - Disable Security
        self.patterns.push(ApiPattern {
            name: "Security Software Evasion".to_string(),
            pattern_type: SuspiciousPatternType::DefenseEvasion,
            severity: PatternSeverity::High,
            description: "Attempts to disable security software".to_string(),
            required_apis: vec![],
            optional_apis: vec![
                "ControlService".to_string(),
                "DeleteService".to_string(),
                "TerminateProcess".to_string(),
            ],
            min_required: 1,
            mitre_techniques: vec!["T1562".to_string()],
        });

        // Network Discovery
        self.patterns.push(ApiPattern {
            name: "Network Discovery".to_string(),
            pattern_type: SuspiciousPatternType::Discovery,
            severity: PatternSeverity::Low,
            description: "Network discovery capabilities".to_string(),
            required_apis: vec![],
            optional_apis: vec![
                "GetAdaptersInfo".to_string(),
                "GetNetworkParams".to_string(),
                "NetShareEnum".to_string(),
                "NetServerEnum".to_string(),
            ],
            min_required: 2,
            mitre_techniques: vec!["T1016".to_string()],
        });
    }

    /// Analyze imports for suspicious patterns
    pub fn analyze(&self, imports: &[ImportInfo]) -> Vec<SuspiciousPattern> {
        let mut detected = vec![];

        // Flatten all imported functions
        let all_functions: Vec<&str> = imports.iter()
            .flat_map(|i| i.functions.iter().map(|f| f.as_str()))
            .collect();

        for pattern in &self.patterns {
            let matched = self.match_pattern(pattern, &all_functions);
            if matched {
                detected.push(SuspiciousPattern {
                    pattern_type: pattern.pattern_type.clone(),
                    description: pattern.description.clone(),
                    severity: pattern.severity.clone(),
                    indicators: self.get_matched_apis(pattern, &all_functions),
                    mitre_techniques: pattern.mitre_techniques.clone(),
                });
            }
        }

        detected
    }

    /// Match a pattern against function list
    fn match_pattern(&self, pattern: &ApiPattern, functions: &[&str]) -> bool {
        let mut matched_count = 0;

        // Check required APIs
        for api in &pattern.required_apis {
            if functions.iter().any(|f| f.contains(api)) {
                matched_count += 1;
            }
        }

        // All required must match
        if matched_count < pattern.required_apis.len() {
            return false;
        }

        // Check optional APIs
        for api in &pattern.optional_apis {
            if functions.iter().any(|f| f.contains(api)) {
                matched_count += 1;
            }
        }

        matched_count >= pattern.min_required
    }

    /// Get list of matched APIs for a pattern
    fn get_matched_apis(&self, pattern: &ApiPattern, functions: &[&str]) -> Vec<String> {
        let mut matched = vec![];

        for api in pattern.required_apis.iter().chain(pattern.optional_apis.iter()) {
            if functions.iter().any(|f| f.contains(api)) {
                matched.push(api.clone());
            }
        }

        matched
    }

    /// Get behavior summary based on detected patterns
    pub fn get_behavior_summary(patterns: &[SuspiciousPattern]) -> HashMap<String, Vec<String>> {
        let mut summary: HashMap<String, Vec<String>> = HashMap::new();

        for pattern in patterns {
            let category = format!("{:?}", pattern.pattern_type);
            summary.entry(category)
                .or_default()
                .push(pattern.description.clone());
        }

        summary
    }

    /// Calculate threat score based on patterns
    pub fn calculate_threat_score(patterns: &[SuspiciousPattern]) -> u8 {
        let mut score: u32 = 0;

        for pattern in patterns {
            score += match pattern.severity {
                PatternSeverity::Critical => 25,
                PatternSeverity::High => 15,
                PatternSeverity::Medium => 8,
                PatternSeverity::Low => 3,
                PatternSeverity::Info => 1,
            };
        }

        score.min(100) as u8
    }
}

impl Default for ApiPatternAnalyzer {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_injection_detection() {
        let analyzer = ApiPatternAnalyzer::new();

        let imports = vec![
            ImportInfo {
                library: "kernel32.dll".to_string(),
                functions: vec![
                    "VirtualAllocEx".to_string(),
                    "WriteProcessMemory".to_string(),
                    "CreateRemoteThread".to_string(),
                    "OpenProcess".to_string(),
                ],
                is_delayed: false,
            }
        ];

        let patterns = analyzer.analyze(&imports);
        assert!(!patterns.is_empty());
        assert!(patterns.iter().any(|p| p.pattern_type == SuspiciousPatternType::CodeInjection));
    }

    #[test]
    fn test_threat_score() {
        let patterns = vec![
            SuspiciousPattern {
                pattern_type: SuspiciousPatternType::CodeInjection,
                description: "Test".to_string(),
                severity: PatternSeverity::Critical,
                indicators: vec![],
                mitre_techniques: vec![],
            },
            SuspiciousPattern {
                pattern_type: SuspiciousPatternType::Persistence,
                description: "Test".to_string(),
                severity: PatternSeverity::High,
                indicators: vec![],
                mitre_techniques: vec![],
            },
        ];

        let score = ApiPatternAnalyzer::calculate_threat_score(&patterns);
        assert_eq!(score, 40); // 25 + 15
    }
}
