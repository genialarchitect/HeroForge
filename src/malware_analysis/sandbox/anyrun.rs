//! Any.Run Integration
//!
//! API client for Any.Run interactive malware analysis sandbox.
//! Uses the Any.Run Public API (v1).
//!
//! Features:
//! - File and URL submission
//! - Interactive analysis with screenshots
//! - Process tree extraction
//! - Network activity monitoring
//! - IOC extraction

use anyhow::{anyhow, Result};
use chrono::{DateTime, Utc};
use reqwest::{Client, multipart};
use serde::Deserialize;
use std::time::Duration;

use super::types::*;

const ANYRUN_API_BASE: &str = "https://api.any.run/v1";

/// Any.Run API client
pub struct AnyRunClient {
    client: Client,
    api_key: String,
}

impl AnyRunClient {
    /// Create a new Any.Run client
    pub fn new(api_key: &str) -> Self {
        let client = Client::builder()
            .timeout(Duration::from_secs(300))
            .build()
            .expect("Failed to create HTTP client");

        Self {
            client,
            api_key: api_key.to_string(),
        }
    }

    /// Build authenticated request
    fn build_request(&self, method: reqwest::Method, path: &str) -> reqwest::RequestBuilder {
        let url = format!("{}{}", ANYRUN_API_BASE, path);
        self.client
            .request(method, &url)
            .header("Authorization", format!("API-Key {}", self.api_key))
    }

    /// Submit a file for analysis
    pub async fn submit(
        &self,
        file_data: &[u8],
        filename: &str,
        options: &SubmissionOptions,
    ) -> Result<SandboxSubmission> {
        let mut form = multipart::Form::new()
            .part(
                "file",
                multipart::Part::bytes(file_data.to_vec())
                    .file_name(filename.to_string())
                    .mime_str("application/octet-stream")?,
            );

        // Add optional parameters
        if let Some(timeout) = options.timeout {
            form = form.text("runTime", timeout.to_string());
        }

        // Environment selection (Windows 7/10, x32/x64)
        if let Some(ref env) = options.environment {
            form = form.text("env_os", env.clone());
        } else {
            form = form.text("env_os", "windows10x64_office");
        }

        // Network settings
        if options.internet_access {
            form = form.text("opt_network_connect", "true");
        }

        // Document password
        if let Some(ref password) = options.password {
            form = form.text("opt_document_password", password.clone());
        }

        // Privacy settings
        form = form.text("opt_privacy_type", "bylink"); // private by default

        let response = self
            .build_request(reqwest::Method::POST, "/analysis")
            .multipart(form)
            .send()
            .await?;

        if !response.status().is_success() {
            let status = response.status();
            let text = response.text().await.unwrap_or_default();
            return Err(anyhow!("Any.Run submission failed: {} - {}", status, text));
        }

        let result: AnyRunSubmitResponse = response.json().await?;

        Ok(SandboxSubmission {
            sandbox_type: SandboxType::AnyRun,
            task_id: result.data.task_id.clone(),
            submission_id: Some(result.data.task_id),
            status: SandboxStatus::Pending,
            message: None,
            submitted_at: Utc::now(),
        })
    }

    /// Submit a URL for analysis
    pub async fn submit_url(
        &self,
        url: &str,
        options: &SubmissionOptions,
    ) -> Result<SandboxSubmission> {
        let mut form = multipart::Form::new()
            .text("obj_url", url.to_string())
            .text("obj_type", "url");

        if let Some(ref env) = options.environment {
            form = form.text("env_os", env.clone());
        } else {
            form = form.text("env_os", "windows10x64_office");
        }

        if options.internet_access {
            form = form.text("opt_network_connect", "true");
        }

        let response = self
            .build_request(reqwest::Method::POST, "/analysis")
            .multipart(form)
            .send()
            .await?;

        if !response.status().is_success() {
            let status = response.status();
            let text = response.text().await.unwrap_or_default();
            return Err(anyhow!("Any.Run URL submission failed: {} - {}", status, text));
        }

        let result: AnyRunSubmitResponse = response.json().await?;

        Ok(SandboxSubmission {
            sandbox_type: SandboxType::AnyRun,
            task_id: result.data.task_id.clone(),
            submission_id: Some(result.data.task_id),
            status: SandboxStatus::Pending,
            message: None,
            submitted_at: Utc::now(),
        })
    }

    /// Get task status
    pub async fn get_status(&self, task_id: &str) -> Result<SandboxStatus> {
        let response = self
            .build_request(reqwest::Method::GET, &format!("/analysis/{}", task_id))
            .send()
            .await?;

        if !response.status().is_success() {
            return Err(anyhow!("Failed to get task status: {}", response.status()));
        }

        let result: AnyRunAnalysisResponse = response.json().await?;

        Ok(match result.data.status.as_str() {
            "pending" | "queued" => SandboxStatus::Pending,
            "running" => SandboxStatus::Running,
            "done" => SandboxStatus::Completed,
            "failed" => SandboxStatus::Failed,
            "timeout" => SandboxStatus::Timeout,
            _ => SandboxStatus::Pending,
        })
    }

    /// Get analysis results (normalized)
    pub async fn get_results(&self, task_id: &str) -> Result<SandboxResult> {
        let response = self
            .build_request(reqwest::Method::GET, &format!("/analysis/{}", task_id))
            .send()
            .await?;

        if !response.status().is_success() {
            return Err(anyhow!("Failed to get report: {}", response.status()));
        }

        let report: AnyRunAnalysisResponse = response.json().await?;
        self.normalize_report(task_id, &report.data)
    }

    /// Get raw report JSON
    pub async fn get_raw_report(&self, task_id: &str) -> Result<serde_json::Value> {
        let response = self
            .build_request(reqwest::Method::GET, &format!("/analysis/{}", task_id))
            .send()
            .await?;

        if !response.status().is_success() {
            return Err(anyhow!("Failed to get raw report: {}", response.status()));
        }

        let report: serde_json::Value = response.json().await?;
        Ok(report)
    }

    /// Get screenshots
    pub async fn get_screenshots(&self, task_id: &str) -> Result<Vec<Screenshot>> {
        let response = self
            .build_request(reqwest::Method::GET, &format!("/analysis/{}", task_id))
            .send()
            .await?;

        if !response.status().is_success() {
            return Ok(vec![]);
        }

        let result: AnyRunAnalysisResponse = response.json().await?;

        Ok(result
            .data
            .screenshots
            .unwrap_or_default()
            .into_iter()
            .enumerate()
            .map(|(i, url)| Screenshot {
                id: format!("screenshot_{}", i),
                timestamp: None,
                url: Some(url),
                data: None,
                thumbnail_url: None,
            })
            .collect())
    }

    /// Get user history/recent analyses
    pub async fn get_history(&self, limit: u32) -> Result<Vec<AnyRunHistoryItem>> {
        let response = self
            .build_request(reqwest::Method::GET, &format!("/analysis?limit={}", limit))
            .send()
            .await?;

        if !response.status().is_success() {
            return Err(anyhow!("Failed to get history: {}", response.status()));
        }

        let result: AnyRunHistoryResponse = response.json().await?;
        Ok(result.data)
    }

    /// Get available environments
    pub async fn get_environments(&self) -> Result<Vec<SandboxEnvironment>> {
        // Any.Run environments are pre-defined
        Ok(vec![
            SandboxEnvironment {
                id: "windows7x64_office".to_string(),
                name: "Windows 7 x64 with Office".to_string(),
                os: "Windows".to_string(),
                os_version: Some("7".to_string()),
                architecture: "x64".to_string(),
                available: true,
                description: Some("Windows 7 64-bit with Microsoft Office".to_string()),
            },
            SandboxEnvironment {
                id: "windows10x64_office".to_string(),
                name: "Windows 10 x64 with Office".to_string(),
                os: "Windows".to_string(),
                os_version: Some("10".to_string()),
                architecture: "x64".to_string(),
                available: true,
                description: Some("Windows 10 64-bit with Microsoft Office".to_string()),
            },
            SandboxEnvironment {
                id: "windows7x64".to_string(),
                name: "Windows 7 x64".to_string(),
                os: "Windows".to_string(),
                os_version: Some("7".to_string()),
                architecture: "x64".to_string(),
                available: true,
                description: None,
            },
            SandboxEnvironment {
                id: "windows10x64".to_string(),
                name: "Windows 10 x64".to_string(),
                os: "Windows".to_string(),
                os_version: Some("10".to_string()),
                architecture: "x64".to_string(),
                available: true,
                description: None,
            },
        ])
    }

    /// Normalize Any.Run report to common format
    fn normalize_report(&self, task_id: &str, analysis: &AnyRunAnalysis) -> Result<SandboxResult> {
        // Determine verdict
        let verdict = match analysis.scores.verdict.specs.as_ref().map(|s| s.as_str()) {
            Some("malicious") => SandboxVerdict::Malicious,
            Some("suspicious") => SandboxVerdict::Suspicious,
            Some("clean" | "no-threats") => SandboxVerdict::Clean,
            _ => SandboxVerdict::Unknown,
        };

        // Extract processes
        let processes = analysis
            .processes
            .as_ref()
            .map(|procs| self.extract_processes(procs))
            .unwrap_or_default();

        // Extract network activity
        let network_activity = self.extract_network_activity(analysis);

        // Extract signatures
        let signatures = analysis
            .threats
            .as_ref()
            .map(|threats| self.extract_signatures(threats))
            .unwrap_or_default();

        // Extract MITRE techniques
        let mitre_techniques = analysis
            .mitre
            .as_ref()
            .map(|mitre| {
                mitre
                    .iter()
                    .map(|m| m.technique_id.clone())
                    .collect::<Vec<_>>()
            })
            .unwrap_or_default();

        // Extract IOCs
        let (network_iocs, file_iocs) = self.extract_iocs(analysis);

        // Extract dropped files
        let dropped_files = analysis
            .modified_files
            .as_ref()
            .map(|files| self.extract_dropped_files(files))
            .unwrap_or_default();

        let duration = analysis
            .duration
            .unwrap_or(0);

        Ok(SandboxResult {
            id: uuid::Uuid::new_v4().to_string(),
            sample_id: analysis.main_object.as_ref()
                .and_then(|m| m.hashes.as_ref())
                .map(|h| h.sha256.clone())
                .unwrap_or_default(),
            sandbox_type: SandboxType::AnyRun,
            sandbox_task_id: task_id.to_string(),
            status: match analysis.status.as_str() {
                "done" => SandboxStatus::Completed,
                "running" => SandboxStatus::Running,
                "failed" => SandboxStatus::Failed,
                _ => SandboxStatus::Pending,
            },
            verdict,
            score: analysis.scores.verdict.threat_level
                .map(|s| (s * 10.0) as u8)
                .unwrap_or(0),
            processes,
            network_activity,
            file_activity: FileActivity::default(),
            registry_activity: RegistryActivity::default(),
            dropped_files,
            signatures,
            network_iocs,
            file_iocs,
            mitre_techniques,
            screenshots: analysis
                .screenshots
                .as_ref()
                .map(|s| {
                    s.iter()
                        .enumerate()
                        .map(|(i, url)| Screenshot {
                            id: format!("screenshot_{}", i),
                            timestamp: None,
                            url: Some(url.clone()),
                            data: None,
                            thumbnail_url: None,
                        })
                        .collect()
                })
                .unwrap_or_default(),
            submitted_at: analysis.created.unwrap_or_else(Utc::now),
            completed_at: analysis.completed,
            analysis_duration_seconds: duration as u32,
        })
    }

    fn extract_processes(&self, processes: &[AnyRunProcess]) -> Vec<ProcessInfo> {
        processes
            .iter()
            .map(|p| ProcessInfo {
                pid: p.pid,
                ppid: p.ppid.unwrap_or(0),
                name: p.name.clone(),
                path: p.image.clone(),
                command_line: p.cmd.clone(),
                username: p.user.clone(),
                integrity_level: p.integrity_level.clone(),
                is_injected: p.injected.unwrap_or(false),
                is_suspicious: p.is_dangerous.unwrap_or(false),
                start_time: None,
                end_time: None,
                api_calls: vec![],
                child_processes: vec![],
            })
            .collect()
    }

    fn extract_network_activity(&self, analysis: &AnyRunAnalysis) -> NetworkActivity {
        let mut dns_queries = Vec::new();
        let mut http_requests = Vec::new();
        let mut tcp_connections = Vec::new();

        if let Some(network) = &analysis.network {
            // DNS
            if let Some(dns) = &network.dns {
                for d in dns {
                    dns_queries.push(DnsQuery {
                        domain: d.domain.clone(),
                        query_type: d.record_type.clone().unwrap_or_else(|| "A".to_string()),
                        resolved_ips: d.ips.clone().unwrap_or_default(),
                        timestamp: None,
                        is_suspicious: d.is_dangerous.unwrap_or(false),
                        dga_score: None,
                    });
                }
            }

            // HTTP
            if let Some(http) = &network.http {
                for h in http {
                    http_requests.push(HttpRequest {
                        method: h.method.clone().unwrap_or_else(|| "GET".to_string()),
                        url: h.url.clone(),
                        host: h.host.clone().unwrap_or_default(),
                        path: h.path.clone().unwrap_or_default(),
                        user_agent: h.user_agent.clone(),
                        referer: None,
                        response_code: h.status_code.map(|s| s as u16),
                        response_size: h.response_length,
                        content_type: h.content_type.clone(),
                        body_sha256: h.body_sha256.clone(),
                        timestamp: None,
                        is_suspicious: h.is_dangerous.unwrap_or(false),
                    });
                }
            }

            // Connections
            if let Some(connections) = &network.connections {
                for c in connections {
                    tcp_connections.push(TcpConnection {
                        src_ip: "0.0.0.0".to_string(),
                        src_port: 0,
                        dst_ip: c.ip.clone(),
                        dst_port: c.port,
                        protocol: c.protocol.clone(),
                        bytes_sent: 0,
                        bytes_received: 0,
                        packets_sent: 0,
                        packets_received: 0,
                        duration_ms: None,
                        is_suspicious: c.is_dangerous.unwrap_or(false),
                        geo_country: c.country.clone(),
                        asn: c.asn.clone(),
                    });
                }
            }
        }

        NetworkActivity {
            dns_queries,
            http_requests,
            tcp_connections,
            udp_flows: vec![],
            icmp_activity: vec![],
            total_bytes_sent: 0,
            total_bytes_received: 0,
        }
    }

    fn extract_signatures(&self, threats: &[AnyRunThreat]) -> Vec<SignatureMatch> {
        threats
            .iter()
            .map(|t| SignatureMatch {
                name: t.name.clone(),
                description: t.description.clone().unwrap_or_default(),
                severity: match t.threat_level.as_ref().map(|s| s.as_str()) {
                    Some("malicious") => SignatureSeverity::Critical,
                    Some("suspicious") => SignatureSeverity::High,
                    Some("notice") => SignatureSeverity::Medium,
                    _ => SignatureSeverity::Info,
                },
                category: t.category.clone().unwrap_or_default(),
                families: t.families.clone().unwrap_or_default(),
                mitre_techniques: t.mitre.clone().unwrap_or_default(),
                references: t.references.clone().unwrap_or_default(),
                indicators: t.indicators.clone().unwrap_or_default(),
            })
            .collect()
    }

    fn extract_dropped_files(&self, files: &[AnyRunModifiedFile]) -> Vec<DroppedFile> {
        files
            .iter()
            .filter(|f| f.type_ == "created" || f.type_ == "dropped")
            .map(|f| DroppedFile {
                filename: f.name.clone(),
                path: f.path.clone().unwrap_or_default(),
                file_type: f.file_type.clone(),
                size: f.size.unwrap_or(0),
                md5: f.hashes.as_ref().map(|h| h.md5.clone()).unwrap_or_default(),
                sha256: f.hashes.as_ref().map(|h| h.sha256.clone()).unwrap_or_default(),
                ssdeep: f.hashes.as_ref().and_then(|h| h.ssdeep.clone()),
                entropy: None,
                is_executable: f.is_executable.unwrap_or(false),
                is_suspicious: f.is_dangerous.unwrap_or(false),
                detection: f.detection.clone(),
                yara_matches: vec![],
                download_url: f.download_url.clone(),
            })
            .collect()
    }

    fn extract_iocs(&self, analysis: &AnyRunAnalysis) -> (Vec<NetworkIoc>, Vec<FileIoc>) {
        let mut network_iocs = Vec::new();
        let mut file_iocs = Vec::new();

        // Extract from IOCs if available
        if let Some(iocs) = &analysis.iocs {
            for ioc in iocs {
                match ioc.type_.as_str() {
                    "ip" => {
                        network_iocs.push(NetworkIoc {
                            ioc_type: NetworkIocType::Ip,
                            value: ioc.value.clone(),
                            context: ioc.context.clone(),
                            first_seen: None,
                            last_seen: None,
                            count: 1,
                            is_c2: ioc.is_c2.unwrap_or(false),
                            threat_intel_hit: ioc.threat_intel.is_some(),
                            threat_intel_source: ioc.threat_intel.clone(),
                        });
                    }
                    "domain" => {
                        network_iocs.push(NetworkIoc {
                            ioc_type: NetworkIocType::Domain,
                            value: ioc.value.clone(),
                            context: ioc.context.clone(),
                            first_seen: None,
                            last_seen: None,
                            count: 1,
                            is_c2: ioc.is_c2.unwrap_or(false),
                            threat_intel_hit: ioc.threat_intel.is_some(),
                            threat_intel_source: ioc.threat_intel.clone(),
                        });
                    }
                    "url" => {
                        network_iocs.push(NetworkIoc {
                            ioc_type: NetworkIocType::Url,
                            value: ioc.value.clone(),
                            context: ioc.context.clone(),
                            first_seen: None,
                            last_seen: None,
                            count: 1,
                            is_c2: ioc.is_c2.unwrap_or(false),
                            threat_intel_hit: ioc.threat_intel.is_some(),
                            threat_intel_source: ioc.threat_intel.clone(),
                        });
                    }
                    "sha256" | "md5" | "sha1" => {
                        file_iocs.push(FileIoc {
                            ioc_type: match ioc.type_.as_str() {
                                "sha256" => FileIocType::Sha256,
                                "md5" => FileIocType::Md5,
                                _ => FileIocType::Sha1,
                            },
                            value: ioc.value.clone(),
                            path: None,
                            context: ioc.context.clone(),
                            is_dropped: false,
                            threat_intel_hit: ioc.threat_intel.is_some(),
                            detection_name: None,
                        });
                    }
                    _ => {}
                }
            }
        }

        (network_iocs, file_iocs)
    }
}

// Any.Run API response structures

#[derive(Debug, Deserialize)]
struct AnyRunSubmitResponse {
    data: AnyRunSubmitData,
}

#[derive(Debug, Deserialize)]
struct AnyRunSubmitData {
    #[serde(rename = "taskId")]
    task_id: String,
}

#[derive(Debug, Deserialize)]
struct AnyRunAnalysisResponse {
    data: AnyRunAnalysis,
}

#[derive(Debug, Deserialize)]
struct AnyRunAnalysis {
    #[serde(rename = "taskId")]
    task_id: Option<String>,
    status: String,
    duration: Option<i64>,
    created: Option<DateTime<Utc>>,
    completed: Option<DateTime<Utc>>,
    scores: AnyRunScores,
    #[serde(rename = "mainObject")]
    main_object: Option<AnyRunMainObject>,
    processes: Option<Vec<AnyRunProcess>>,
    network: Option<AnyRunNetwork>,
    threats: Option<Vec<AnyRunThreat>>,
    mitre: Option<Vec<AnyRunMitre>>,
    iocs: Option<Vec<AnyRunIoc>>,
    screenshots: Option<Vec<String>>,
    #[serde(rename = "modifiedFiles")]
    modified_files: Option<Vec<AnyRunModifiedFile>>,
}

#[derive(Debug, Deserialize)]
struct AnyRunScores {
    verdict: AnyRunVerdict,
}

#[derive(Debug, Deserialize)]
struct AnyRunVerdict {
    specs: Option<String>,
    #[serde(rename = "threatLevel")]
    threat_level: Option<f64>,
}

#[derive(Debug, Deserialize)]
struct AnyRunMainObject {
    hashes: Option<AnyRunHashes>,
}

#[derive(Debug, Deserialize)]
struct AnyRunHashes {
    md5: String,
    sha256: String,
    ssdeep: Option<String>,
}

#[derive(Debug, Deserialize)]
struct AnyRunProcess {
    pid: u32,
    ppid: Option<u32>,
    name: String,
    image: Option<String>,
    cmd: Option<String>,
    user: Option<String>,
    #[serde(rename = "integrityLevel")]
    integrity_level: Option<String>,
    injected: Option<bool>,
    #[serde(rename = "isDangerous")]
    is_dangerous: Option<bool>,
}

#[derive(Debug, Deserialize)]
struct AnyRunNetwork {
    dns: Option<Vec<AnyRunDns>>,
    http: Option<Vec<AnyRunHttp>>,
    connections: Option<Vec<AnyRunConnection>>,
}

#[derive(Debug, Deserialize)]
struct AnyRunDns {
    domain: String,
    #[serde(rename = "recordType")]
    record_type: Option<String>,
    ips: Option<Vec<String>>,
    #[serde(rename = "isDangerous")]
    is_dangerous: Option<bool>,
}

#[derive(Debug, Deserialize)]
struct AnyRunHttp {
    url: String,
    method: Option<String>,
    host: Option<String>,
    path: Option<String>,
    #[serde(rename = "userAgent")]
    user_agent: Option<String>,
    #[serde(rename = "statusCode")]
    status_code: Option<i32>,
    #[serde(rename = "responseLength")]
    response_length: Option<u64>,
    #[serde(rename = "contentType")]
    content_type: Option<String>,
    #[serde(rename = "bodySha256")]
    body_sha256: Option<String>,
    #[serde(rename = "isDangerous")]
    is_dangerous: Option<bool>,
}

#[derive(Debug, Deserialize)]
struct AnyRunConnection {
    ip: String,
    port: u16,
    protocol: Option<String>,
    country: Option<String>,
    asn: Option<String>,
    #[serde(rename = "isDangerous")]
    is_dangerous: Option<bool>,
}

#[derive(Debug, Deserialize)]
struct AnyRunThreat {
    name: String,
    description: Option<String>,
    #[serde(rename = "threatLevel")]
    threat_level: Option<String>,
    category: Option<String>,
    families: Option<Vec<String>>,
    mitre: Option<Vec<String>>,
    references: Option<Vec<String>>,
    indicators: Option<Vec<String>>,
}

#[derive(Debug, Deserialize)]
struct AnyRunMitre {
    #[serde(rename = "techniqueId")]
    technique_id: String,
}

#[derive(Debug, Deserialize)]
struct AnyRunIoc {
    #[serde(rename = "type")]
    type_: String,
    value: String,
    context: Option<String>,
    #[serde(rename = "isC2")]
    is_c2: Option<bool>,
    #[serde(rename = "threatIntel")]
    threat_intel: Option<String>,
}

#[derive(Debug, Deserialize)]
struct AnyRunModifiedFile {
    name: String,
    path: Option<String>,
    #[serde(rename = "type")]
    type_: String, // created, modified, deleted
    #[serde(rename = "fileType")]
    file_type: Option<String>,
    size: Option<u64>,
    hashes: Option<AnyRunHashes>,
    #[serde(rename = "isExecutable")]
    is_executable: Option<bool>,
    #[serde(rename = "isDangerous")]
    is_dangerous: Option<bool>,
    detection: Option<String>,
    #[serde(rename = "downloadUrl")]
    download_url: Option<String>,
}

#[derive(Debug, Deserialize)]
struct AnyRunHistoryResponse {
    data: Vec<AnyRunHistoryItem>,
}

#[derive(Debug, Deserialize, Clone)]
pub struct AnyRunHistoryItem {
    #[serde(rename = "taskId")]
    pub task_id: String,
    pub status: String,
    pub verdict: Option<String>,
    #[serde(rename = "fileName")]
    pub file_name: Option<String>,
    pub created: Option<DateTime<Utc>>,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_client_creation() {
        let client = AnyRunClient::new("test-api-key");
        assert_eq!(client.api_key, "test-api-key");
    }
}
