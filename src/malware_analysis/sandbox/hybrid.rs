//! Hybrid Analysis Integration
//!
//! API client for Hybrid Analysis (CrowdStrike Falcon Sandbox).
//! Uses the Hybrid Analysis API v2.
//!
//! Features:
//! - File and URL submission
//! - Multiple environment support (Windows, Linux, Android)
//! - Detailed behavioral analysis
//! - MITRE ATT&CK mapping
//! - IOC extraction

use anyhow::{anyhow, Result};
use chrono::{DateTime, Utc};
use reqwest::{Client, multipart};
use serde::{Deserialize, Serialize};
use std::time::Duration;

use super::types::*;

const HYBRID_API_BASE: &str = "https://www.hybrid-analysis.com/api/v2";

/// Hybrid Analysis API client
pub struct HybridAnalysisClient {
    client: Client,
    api_key: String,
}

impl HybridAnalysisClient {
    /// Create a new Hybrid Analysis client
    pub fn new(api_key: &str) -> Self {
        let client = Client::builder()
            .timeout(Duration::from_secs(300))
            .user_agent("Falcon Sandbox")
            .build()
            .expect("Failed to create HTTP client");

        Self {
            client,
            api_key: api_key.to_string(),
        }
    }

    /// Build authenticated request
    fn build_request(&self, method: reqwest::Method, path: &str) -> reqwest::RequestBuilder {
        let url = format!("{}{}", HYBRID_API_BASE, path);
        self.client
            .request(method, &url)
            .header("api-key", &self.api_key)
            .header("accept", "application/json")
    }

    /// Submit a file for analysis
    pub async fn submit(
        &self,
        file_data: &[u8],
        filename: &str,
        options: &SubmissionOptions,
    ) -> Result<SandboxSubmission> {
        // Default environment if not specified
        let environment_id = options
            .environment
            .as_ref()
            .and_then(|e| self.environment_to_id(e))
            .unwrap_or(160); // Windows 10 64-bit

        let form = multipart::Form::new()
            .part(
                "file",
                multipart::Part::bytes(file_data.to_vec())
                    .file_name(filename.to_string())
                    .mime_str("application/octet-stream")?,
            )
            .text("environment_id", environment_id.to_string());

        // Add optional parameters
        let mut form = form;
        if options.enable_network {
            form = form.text("allow_community_access", "true");
        }
        if let Some(ref password) = options.password {
            form = form.text("document_password", password.clone());
        }
        if let Some(ref args) = options.arguments {
            form = form.text("custom_cmd_line", args.clone());
        }

        let response = self
            .build_request(reqwest::Method::POST, "/submit/file")
            .multipart(form)
            .send()
            .await?;

        if !response.status().is_success() {
            let status = response.status();
            let text = response.text().await.unwrap_or_default();
            return Err(anyhow!("Hybrid Analysis submission failed: {} - {}", status, text));
        }

        let result: HybridSubmitResponse = response.json().await?;

        Ok(SandboxSubmission {
            sandbox_type: SandboxType::HybridAnalysis,
            task_id: result.job_id.clone(),
            submission_id: result.submission_id,
            status: SandboxStatus::Pending,
            message: None,
            submitted_at: Utc::now(),
        })
    }

    /// Submit a URL for analysis
    pub async fn submit_url(
        &self,
        url: &str,
        options: &SubmissionOptions,
    ) -> Result<SandboxSubmission> {
        let environment_id = options
            .environment
            .as_ref()
            .and_then(|e| self.environment_to_id(e))
            .unwrap_or(160);

        let response = self
            .build_request(reqwest::Method::POST, "/submit/url")
            .form(&[
                ("url", url),
                ("environment_id", &environment_id.to_string()),
            ])
            .send()
            .await?;

        if !response.status().is_success() {
            let status = response.status();
            let text = response.text().await.unwrap_or_default();
            return Err(anyhow!("Hybrid Analysis URL submission failed: {} - {}", status, text));
        }

        let result: HybridSubmitResponse = response.json().await?;

        Ok(SandboxSubmission {
            sandbox_type: SandboxType::HybridAnalysis,
            task_id: result.job_id.clone(),
            submission_id: result.submission_id,
            status: SandboxStatus::Pending,
            message: None,
            submitted_at: Utc::now(),
        })
    }

    /// Get task status
    pub async fn get_status(&self, job_id: &str) -> Result<SandboxStatus> {
        let response = self
            .build_request(reqwest::Method::GET, &format!("/report/{}/state", job_id))
            .send()
            .await?;

        if !response.status().is_success() {
            return Err(anyhow!("Failed to get task status: {}", response.status()));
        }

        let result: HybridStateResponse = response.json().await?;

        Ok(match result.state.as_str() {
            "IN_QUEUE" | "IN_PROGRESS" => SandboxStatus::Running,
            "SUCCESS" => SandboxStatus::Completed,
            "ERROR" => SandboxStatus::Failed,
            "NO_CONTENT" => SandboxStatus::Pending,
            _ => SandboxStatus::Pending,
        })
    }

    /// Get analysis results (normalized)
    pub async fn get_results(&self, job_id: &str) -> Result<SandboxResult> {
        let response = self
            .build_request(reqwest::Method::GET, &format!("/report/{}/summary", job_id))
            .send()
            .await?;

        if !response.status().is_success() {
            return Err(anyhow!("Failed to get report: {}", response.status()));
        }

        let report: HybridReport = response.json().await?;
        self.normalize_report(job_id, &report)
    }

    /// Get raw report JSON
    pub async fn get_raw_report(&self, job_id: &str) -> Result<serde_json::Value> {
        let response = self
            .build_request(reqwest::Method::GET, &format!("/report/{}/summary", job_id))
            .send()
            .await?;

        if !response.status().is_success() {
            return Err(anyhow!("Failed to get raw report: {}", response.status()));
        }

        let report: serde_json::Value = response.json().await?;
        Ok(report)
    }

    /// Get screenshots
    pub async fn get_screenshots(&self, job_id: &str) -> Result<Vec<Screenshot>> {
        let response = self
            .build_request(reqwest::Method::GET, &format!("/report/{}/screenshots", job_id))
            .send()
            .await?;

        if !response.status().is_success() {
            return Ok(vec![]);
        }

        let result: Vec<HybridScreenshot> = response.json().await?;

        Ok(result
            .into_iter()
            .enumerate()
            .map(|(i, s)| Screenshot {
                id: format!("screenshot_{}", i),
                timestamp: None,
                url: Some(s.image),
                data: None,
                thumbnail_url: s.thumbnail,
            })
            .collect())
    }

    /// Get dropped files
    pub async fn get_dropped_files(&self, job_id: &str) -> Result<Vec<DroppedFile>> {
        let response = self
            .build_request(reqwest::Method::GET, &format!("/report/{}/dropped-files", job_id))
            .send()
            .await?;

        if !response.status().is_success() {
            return Ok(vec![]);
        }

        let result: Vec<HybridDroppedFile> = response.json().await?;

        Ok(result
            .into_iter()
            .map(|f| DroppedFile {
                filename: f.name.clone(),
                path: f.path.clone().unwrap_or_default(),
                file_type: f.type_tags.first().cloned(),
                size: f.size,
                md5: f.md5.clone(),
                sha256: f.sha256.clone(),
                ssdeep: f.ssdeep.clone(),
                entropy: f.entropy,
                is_executable: f.type_tags.iter().any(|t| t.contains("executable")),
                is_suspicious: f.threat_score.unwrap_or(0) > 50,
                detection: f.av_label.clone(),
                yara_matches: f.yara.clone().unwrap_or_default(),
                download_url: Some(format!("{}/report/{}/file/{}", HYBRID_API_BASE, job_id, f.sha256)),
            })
            .collect())
    }

    /// Get available environments
    pub async fn get_environments(&self) -> Result<Vec<SandboxEnvironment>> {
        let response = self
            .build_request(reqwest::Method::GET, "/system/environments")
            .send()
            .await?;

        if !response.status().is_success() {
            // Return default environments if API call fails
            return Ok(self.default_environments());
        }

        let result: Vec<HybridEnvironment> = response.json().await?;

        Ok(result
            .into_iter()
            .map(|e| SandboxEnvironment {
                id: e.id.to_string(),
                name: e.name.clone(),
                os: e.os.clone(),
                os_version: e.os_version.clone(),
                architecture: e.arch.clone().unwrap_or_else(|| "x64".to_string()),
                available: e.available,
                description: e.description.clone(),
            })
            .collect())
    }

    /// Search for existing analysis by hash
    pub async fn search_by_hash(&self, hash: &str) -> Result<Vec<HybridSearchResult>> {
        let response = self
            .build_request(reqwest::Method::POST, "/search/hash")
            .form(&[("hash", hash)])
            .send()
            .await?;

        if !response.status().is_success() {
            return Ok(vec![]);
        }

        let result: Vec<HybridSearchResult> = response.json().await?;
        Ok(result)
    }

    /// Get MITRE ATT&CK mapping for analysis
    pub async fn get_mitre_mapping(&self, job_id: &str) -> Result<Vec<MitreMapping>> {
        let response = self
            .build_request(reqwest::Method::GET, &format!("/report/{}/mitre-attack", job_id))
            .send()
            .await?;

        if !response.status().is_success() {
            return Ok(vec![]);
        }

        let result: HybridMitreResponse = response.json().await?;

        Ok(result
            .tactics
            .into_iter()
            .flat_map(|t| {
                t.techniques.into_iter().map(move |tech| MitreMapping {
                    tactic_id: t.id.clone(),
                    tactic_name: t.name.clone(),
                    technique_id: tech.id.clone(),
                    technique_name: tech.name.clone(),
                    sub_technique_id: tech.sub_technique_id,
                    relevance: tech.relevance.unwrap_or(0),
                })
            })
            .collect())
    }

    /// Convert environment name to ID
    fn environment_to_id(&self, env: &str) -> Option<u32> {
        match env.to_lowercase().as_str() {
            "windows7x64" | "windows7-x64" | "win7x64" => Some(120),
            "windows7x86" | "windows7-x86" | "win7x86" => Some(100),
            "windows10x64" | "windows10-x64" | "win10x64" => Some(160),
            "windows11x64" | "windows11-x64" | "win11x64" => Some(300),
            "linux64" | "linux-x64" | "ubuntu" => Some(200),
            "android" => Some(310),
            _ => None,
        }
    }

    /// Default environments when API call fails
    fn default_environments(&self) -> Vec<SandboxEnvironment> {
        vec![
            SandboxEnvironment {
                id: "100".to_string(),
                name: "Windows 7 32-bit".to_string(),
                os: "Windows".to_string(),
                os_version: Some("7".to_string()),
                architecture: "x86".to_string(),
                available: true,
                description: None,
            },
            SandboxEnvironment {
                id: "120".to_string(),
                name: "Windows 7 64-bit".to_string(),
                os: "Windows".to_string(),
                os_version: Some("7".to_string()),
                architecture: "x64".to_string(),
                available: true,
                description: None,
            },
            SandboxEnvironment {
                id: "160".to_string(),
                name: "Windows 10 64-bit".to_string(),
                os: "Windows".to_string(),
                os_version: Some("10".to_string()),
                architecture: "x64".to_string(),
                available: true,
                description: None,
            },
            SandboxEnvironment {
                id: "300".to_string(),
                name: "Windows 11 64-bit".to_string(),
                os: "Windows".to_string(),
                os_version: Some("11".to_string()),
                architecture: "x64".to_string(),
                available: true,
                description: None,
            },
            SandboxEnvironment {
                id: "200".to_string(),
                name: "Linux (Ubuntu 20.04)".to_string(),
                os: "Linux".to_string(),
                os_version: Some("Ubuntu 20.04".to_string()),
                architecture: "x64".to_string(),
                available: true,
                description: None,
            },
            SandboxEnvironment {
                id: "310".to_string(),
                name: "Android".to_string(),
                os: "Android".to_string(),
                os_version: None,
                architecture: "arm64".to_string(),
                available: true,
                description: None,
            },
        ]
    }

    /// Normalize Hybrid Analysis report to common format
    fn normalize_report(&self, job_id: &str, report: &HybridReport) -> Result<SandboxResult> {
        // Determine verdict based on threat score
        let verdict = if report.threat_score.unwrap_or(0) >= 70 {
            SandboxVerdict::Malicious
        } else if report.threat_score.unwrap_or(0) >= 40 {
            SandboxVerdict::Suspicious
        } else if report.threat_score.unwrap_or(0) > 0 {
            SandboxVerdict::Clean
        } else {
            SandboxVerdict::Unknown
        };

        // Extract processes
        let processes = report
            .processes
            .as_ref()
            .map(|procs| self.extract_processes(procs))
            .unwrap_or_default();

        // Extract network activity
        let network_activity = self.extract_network_activity(report);

        // Extract file activity
        let file_activity = self.extract_file_activity(report);

        // Extract registry activity
        let registry_activity = self.extract_registry_activity(report);

        // Extract signatures
        let signatures = report
            .signatures
            .as_ref()
            .map(|sigs| self.extract_signatures(sigs))
            .unwrap_or_default();

        // Extract MITRE techniques
        let mitre_techniques = report
            .mitre_attcks
            .as_ref()
            .map(|mitre| mitre.iter().map(|m| m.technique.clone()).collect::<Vec<_>>())
            .unwrap_or_default();

        // Extract IOCs
        let (network_iocs, file_iocs) = self.extract_iocs(report);

        // Extract dropped files
        let dropped_files = report
            .extracted_files
            .as_ref()
            .map(|files| self.extract_dropped_files_from_report(files))
            .unwrap_or_default();

        Ok(SandboxResult {
            id: uuid::Uuid::new_v4().to_string(),
            sample_id: report.sha256.clone().unwrap_or_default(),
            sandbox_type: SandboxType::HybridAnalysis,
            sandbox_task_id: job_id.to_string(),
            status: SandboxStatus::Completed,
            verdict,
            score: report.threat_score.unwrap_or(0) as u8,
            processes,
            network_activity,
            file_activity,
            registry_activity,
            dropped_files,
            signatures,
            network_iocs,
            file_iocs,
            mitre_techniques,
            screenshots: vec![],
            submitted_at: report.analysis_start_time.clone().unwrap_or_else(Utc::now),
            completed_at: report.analysis_end_time.clone(),
            analysis_duration_seconds: report.duration.unwrap_or(0) as u32,
        })
    }

    fn extract_processes(&self, processes: &[HybridProcess]) -> Vec<ProcessInfo> {
        processes
            .iter()
            .map(|p| ProcessInfo {
                pid: p.pid,
                ppid: p.parent_pid.unwrap_or(0),
                name: p.name.clone(),
                path: p.command_line.clone(),
                command_line: p.command_line.clone(),
                username: p.user.clone(),
                integrity_level: p.integrity.clone(),
                is_injected: p.injected.unwrap_or(false),
                is_suspicious: p.is_malicious.unwrap_or(false),
                start_time: None,
                end_time: None,
                api_calls: vec![],
                child_processes: p.children.clone().unwrap_or_default(),
            })
            .collect()
    }

    fn extract_network_activity(&self, report: &HybridReport) -> NetworkActivity {
        let mut dns_queries = Vec::new();
        let mut http_requests = Vec::new();
        let mut tcp_connections = Vec::new();

        // DNS
        if let Some(dns_list) = &report.domains {
            for domain in dns_list {
                dns_queries.push(DnsQuery {
                    domain: domain.domain.clone(),
                    query_type: "A".to_string(),
                    resolved_ips: domain.ips.clone().unwrap_or_default(),
                    timestamp: None,
                    is_suspicious: domain.is_malicious.unwrap_or(false),
                    dga_score: domain.dga_score,
                });
            }
        }

        // HTTP
        if let Some(http_list) = &report.http_requests {
            for h in http_list {
                http_requests.push(HttpRequest {
                    method: h.method.clone().unwrap_or_else(|| "GET".to_string()),
                    url: h.url.clone(),
                    host: h.host.clone().unwrap_or_default(),
                    path: h.path.clone().unwrap_or_default(),
                    user_agent: h.user_agent.clone(),
                    referer: h.referer.clone(),
                    response_code: h.response_code.map(|c| c as u16),
                    response_size: h.response_size,
                    content_type: h.content_type.clone(),
                    body_sha256: h.request_body_sha256.clone(),
                    timestamp: None,
                    is_suspicious: h.is_malicious.unwrap_or(false),
                });
            }
        }

        // Connections
        if let Some(hosts) = &report.contacted_hosts {
            for host in hosts {
                tcp_connections.push(TcpConnection {
                    src_ip: "0.0.0.0".to_string(),
                    src_port: 0,
                    dst_ip: host.ip.clone(),
                    dst_port: host.port.unwrap_or(0),
                    protocol: host.protocol.clone(),
                    bytes_sent: 0,
                    bytes_received: 0,
                    packets_sent: 0,
                    packets_received: 0,
                    duration_ms: None,
                    is_suspicious: host.is_malicious.unwrap_or(false),
                    geo_country: host.country.clone(),
                    asn: host.asn.clone(),
                });
            }
        }

        NetworkActivity {
            dns_queries,
            http_requests,
            tcp_connections,
            udp_flows: vec![],
            icmp_activity: vec![],
            total_bytes_sent: report.network_total_sent.unwrap_or(0),
            total_bytes_received: report.network_total_received.unwrap_or(0),
        }
    }

    fn extract_file_activity(&self, report: &HybridReport) -> FileActivity {
        let mut files_created = Vec::new();
        let mut files_modified = Vec::new();
        let mut files_deleted = Vec::new();
        let mut files_read = Vec::new();

        if let Some(file_ops) = &report.file_operations {
            for op in file_ops {
                let file_op = FileOperation {
                    path: op.path.clone(),
                    operation: op.operation.clone().unwrap_or_default(),
                    sha256: op.sha256.clone(),
                    size: op.size,
                    timestamp: None,
                    is_suspicious: op.is_malicious.unwrap_or(false),
                    detection: None,
                };

                match op.operation.as_deref() {
                    Some("create" | "write") => files_created.push(file_op),
                    Some("modify") => files_modified.push(file_op),
                    Some("delete") => files_deleted.push(file_op),
                    Some("read" | "open") => files_read.push(file_op),
                    _ => {}
                }
            }
        }

        FileActivity {
            files_created,
            files_modified,
            files_deleted,
            files_read,
        }
    }

    fn extract_registry_activity(&self, report: &HybridReport) -> RegistryActivity {
        let mut keys_created = Vec::new();
        let mut keys_modified = Vec::new();
        let mut values_set = Vec::new();

        if let Some(reg_ops) = &report.registry_operations {
            for op in reg_ops {
                let reg_op = RegistryOperation {
                    key: op.key.clone(),
                    value_name: op.value_name.clone(),
                    value_data: op.value_data.clone(),
                    value_type: op.value_type.clone(),
                    timestamp: None,
                    is_suspicious: op.is_malicious.unwrap_or(false),
                    is_persistence: op.is_persistence.unwrap_or(false),
                };

                match op.operation.as_deref() {
                    Some("create") => keys_created.push(reg_op),
                    Some("modify") => keys_modified.push(reg_op),
                    Some("set" | "setvalue") => values_set.push(reg_op),
                    _ => {}
                }
            }
        }

        RegistryActivity {
            keys_created,
            keys_modified,
            keys_deleted: vec![],
            values_set,
        }
    }

    fn extract_signatures(&self, signatures: &[HybridSignature]) -> Vec<SignatureMatch> {
        signatures
            .iter()
            .map(|s| SignatureMatch {
                name: s.name.clone(),
                description: s.description.clone().unwrap_or_default(),
                severity: match s.threat_level.as_deref() {
                    Some("malicious") => SignatureSeverity::Critical,
                    Some("suspicious") => SignatureSeverity::High,
                    Some("informative") => SignatureSeverity::Medium,
                    _ => SignatureSeverity::Info,
                },
                category: s.category.clone().unwrap_or_default(),
                families: s.malware_families.clone().unwrap_or_default(),
                mitre_techniques: s.attack_ids.clone().unwrap_or_default(),
                references: s.references.clone().unwrap_or_default(),
                indicators: s.indicators.clone().unwrap_or_default(),
            })
            .collect()
    }

    fn extract_dropped_files_from_report(&self, files: &[HybridExtractedFile]) -> Vec<DroppedFile> {
        files
            .iter()
            .map(|f| DroppedFile {
                filename: f.name.clone(),
                path: f.runtime_path.clone().unwrap_or_default(),
                file_type: f.type_short.clone(),
                size: f.size,
                md5: f.md5.clone().unwrap_or_default(),
                sha256: f.sha256.clone().unwrap_or_default(),
                ssdeep: f.ssdeep.clone(),
                entropy: f.entropy,
                is_executable: f.type_short.as_ref()
                    .map(|t| t.contains("PE") || t.contains("ELF"))
                    .unwrap_or(false),
                is_suspicious: f.threat_score.unwrap_or(0) > 50,
                detection: f.av_label.clone(),
                yara_matches: f.yara.clone().unwrap_or_default(),
                download_url: None,
            })
            .collect()
    }

    fn extract_iocs(&self, report: &HybridReport) -> (Vec<NetworkIoc>, Vec<FileIoc>) {
        let mut network_iocs = Vec::new();
        let mut file_iocs = Vec::new();

        // Extract from domains
        if let Some(domains) = &report.domains {
            for d in domains {
                network_iocs.push(NetworkIoc {
                    ioc_type: NetworkIocType::Domain,
                    value: d.domain.clone(),
                    context: d.associated_process.clone(),
                    first_seen: None,
                    last_seen: None,
                    count: d.count.unwrap_or(1),
                    is_c2: d.is_c2.unwrap_or(false),
                    threat_intel_hit: d.threat_intel.is_some(),
                    threat_intel_source: d.threat_intel.clone(),
                });
            }
        }

        // Extract from hosts
        if let Some(hosts) = &report.contacted_hosts {
            for h in hosts {
                if !h.ip.starts_with("10.") &&
                   !h.ip.starts_with("192.168.") &&
                   !h.ip.starts_with("172.") {
                    network_iocs.push(NetworkIoc {
                        ioc_type: NetworkIocType::Ip,
                        value: h.ip.clone(),
                        context: h.associated_process.clone(),
                        first_seen: None,
                        last_seen: None,
                        count: h.count.unwrap_or(1),
                        is_c2: h.is_c2.unwrap_or(false),
                        threat_intel_hit: h.threat_intel.is_some(),
                        threat_intel_source: h.threat_intel.clone(),
                    });
                }
            }
        }

        // Extract file hashes from dropped files
        if let Some(files) = &report.extracted_files {
            for f in files {
                if let Some(sha256) = &f.sha256 {
                    file_iocs.push(FileIoc {
                        ioc_type: FileIocType::Sha256,
                        value: sha256.clone(),
                        path: f.runtime_path.clone(),
                        context: Some("Dropped file".to_string()),
                        is_dropped: true,
                        threat_intel_hit: false,
                        detection_name: f.av_label.clone(),
                    });
                }
            }
        }

        (network_iocs, file_iocs)
    }
}

// Hybrid Analysis API response structures

#[derive(Debug, Deserialize)]
struct HybridSubmitResponse {
    job_id: String,
    submission_id: Option<String>,
}

#[derive(Debug, Deserialize)]
struct HybridStateResponse {
    state: String,
}

#[derive(Debug, Deserialize)]
struct HybridReport {
    sha256: Option<String>,
    md5: Option<String>,
    threat_score: Option<i32>,
    verdict: Option<String>,
    analysis_start_time: Option<DateTime<Utc>>,
    analysis_end_time: Option<DateTime<Utc>>,
    duration: Option<i64>,
    environment_description: Option<String>,
    processes: Option<Vec<HybridProcess>>,
    domains: Option<Vec<HybridDomain>>,
    contacted_hosts: Option<Vec<HybridHost>>,
    http_requests: Option<Vec<HybridHttpRequest>>,
    signatures: Option<Vec<HybridSignature>>,
    mitre_attcks: Option<Vec<HybridMitre>>,
    extracted_files: Option<Vec<HybridExtractedFile>>,
    file_operations: Option<Vec<HybridFileOperation>>,
    registry_operations: Option<Vec<HybridRegistryOperation>>,
    network_total_sent: Option<u64>,
    network_total_received: Option<u64>,
}

#[derive(Debug, Deserialize)]
struct HybridProcess {
    pid: u32,
    parent_pid: Option<u32>,
    name: String,
    command_line: Option<String>,
    user: Option<String>,
    integrity: Option<String>,
    injected: Option<bool>,
    is_malicious: Option<bool>,
    children: Option<Vec<u32>>,
}

#[derive(Debug, Deserialize)]
struct HybridDomain {
    domain: String,
    ips: Option<Vec<String>>,
    is_malicious: Option<bool>,
    is_c2: Option<bool>,
    dga_score: Option<f64>,
    threat_intel: Option<String>,
    associated_process: Option<String>,
    count: Option<u32>,
}

#[derive(Debug, Deserialize)]
struct HybridHost {
    ip: String,
    port: Option<u16>,
    protocol: Option<String>,
    country: Option<String>,
    asn: Option<String>,
    is_malicious: Option<bool>,
    is_c2: Option<bool>,
    threat_intel: Option<String>,
    associated_process: Option<String>,
    count: Option<u32>,
}

#[derive(Debug, Deserialize)]
struct HybridHttpRequest {
    url: String,
    method: Option<String>,
    host: Option<String>,
    path: Option<String>,
    user_agent: Option<String>,
    referer: Option<String>,
    response_code: Option<i32>,
    response_size: Option<u64>,
    content_type: Option<String>,
    request_body_sha256: Option<String>,
    is_malicious: Option<bool>,
}

#[derive(Debug, Deserialize)]
struct HybridSignature {
    name: String,
    description: Option<String>,
    threat_level: Option<String>,
    category: Option<String>,
    malware_families: Option<Vec<String>>,
    attack_ids: Option<Vec<String>>,
    references: Option<Vec<String>>,
    indicators: Option<Vec<String>>,
}

#[derive(Debug, Deserialize)]
struct HybridMitre {
    technique: String,
    tactic: Option<String>,
}

#[derive(Debug, Deserialize)]
struct HybridExtractedFile {
    name: String,
    runtime_path: Option<String>,
    type_short: Option<String>,
    size: u64,
    md5: Option<String>,
    sha256: Option<String>,
    ssdeep: Option<String>,
    entropy: Option<f64>,
    threat_score: Option<i32>,
    av_label: Option<String>,
    yara: Option<Vec<String>>,
}

#[derive(Debug, Deserialize)]
struct HybridFileOperation {
    path: String,
    operation: Option<String>,
    sha256: Option<String>,
    size: Option<u64>,
    is_malicious: Option<bool>,
}

#[derive(Debug, Deserialize)]
struct HybridRegistryOperation {
    key: String,
    operation: Option<String>,
    value_name: Option<String>,
    value_data: Option<String>,
    value_type: Option<String>,
    is_malicious: Option<bool>,
    is_persistence: Option<bool>,
}

#[derive(Debug, Deserialize)]
struct HybridScreenshot {
    image: String,
    thumbnail: Option<String>,
}

#[derive(Debug, Deserialize)]
struct HybridDroppedFile {
    name: String,
    path: Option<String>,
    #[serde(rename = "type")]
    type_tags: Vec<String>,
    size: u64,
    md5: String,
    sha256: String,
    ssdeep: Option<String>,
    entropy: Option<f64>,
    threat_score: Option<i32>,
    av_label: Option<String>,
    yara: Option<Vec<String>>,
}

#[derive(Debug, Deserialize)]
struct HybridEnvironment {
    id: u32,
    name: String,
    os: String,
    os_version: Option<String>,
    arch: Option<String>,
    available: bool,
    description: Option<String>,
}

#[derive(Debug, Deserialize, Clone)]
pub struct HybridSearchResult {
    pub job_id: String,
    pub sha256: String,
    pub verdict: Option<String>,
    pub threat_score: Option<i32>,
    pub submit_name: Option<String>,
    pub analysis_start_time: Option<DateTime<Utc>>,
}

#[derive(Debug, Deserialize)]
struct HybridMitreResponse {
    tactics: Vec<HybridMitreTactic>,
}

#[derive(Debug, Deserialize)]
struct HybridMitreTactic {
    id: String,
    name: String,
    techniques: Vec<HybridMitreTechnique>,
}

#[derive(Debug, Deserialize)]
struct HybridMitreTechnique {
    id: String,
    name: String,
    sub_technique_id: Option<String>,
    relevance: Option<u32>,
}

/// MITRE ATT&CK mapping result
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MitreMapping {
    pub tactic_id: String,
    pub tactic_name: String,
    pub technique_id: String,
    pub technique_name: String,
    pub sub_technique_id: Option<String>,
    pub relevance: u32,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_client_creation() {
        let client = HybridAnalysisClient::new("test-api-key");
        assert_eq!(client.api_key, "test-api-key");
    }

    #[test]
    fn test_environment_to_id() {
        let client = HybridAnalysisClient::new("test");
        assert_eq!(client.environment_to_id("windows10x64"), Some(160));
        assert_eq!(client.environment_to_id("linux64"), Some(200));
        assert_eq!(client.environment_to_id("unknown"), None);
    }
}
