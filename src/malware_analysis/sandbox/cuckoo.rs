//! Cuckoo Sandbox Integration
//!
//! API client for Cuckoo Sandbox (self-hosted malware analysis platform).
//! Supports Cuckoo 2.x and 3.x (Cuckoo3) API endpoints.
//!
//! Features:
//! - File submission with options
//! - Task status monitoring
//! - Report retrieval and normalization
//! - Screenshot download
//! - Dropped file download

use anyhow::{anyhow, Result};
use chrono::{DateTime, Utc};
use reqwest::{Client, multipart};
use serde::Deserialize;
use std::time::Duration;

use super::types::*;

/// Cuckoo Sandbox API client
pub struct CuckooClient {
    client: Client,
    base_url: String,
    api_key: Option<String>,
}

impl CuckooClient {
    /// Create a new Cuckoo client
    pub fn new(base_url: &str, api_key: Option<&str>) -> Self {
        let client = Client::builder()
            .timeout(Duration::from_secs(300))
            .build()
            .expect("Failed to create HTTP client");

        Self {
            client,
            base_url: base_url.trim_end_matches('/').to_string(),
            api_key: api_key.map(|s| s.to_string()),
        }
    }

    /// Build request with optional API key
    fn build_request(&self, method: reqwest::Method, path: &str) -> reqwest::RequestBuilder {
        let url = format!("{}{}", self.base_url, path);
        let mut req = self.client.request(method, &url);
        if let Some(ref key) = self.api_key {
            req = req.header("Authorization", format!("Bearer {}", key));
        }
        req
    }

    /// Submit a file for analysis
    pub async fn submit(
        &self,
        file_data: &[u8],
        filename: &str,
        options: &SubmissionOptions,
    ) -> Result<SandboxSubmission> {
        let form = multipart::Form::new()
            .part(
                "file",
                multipart::Part::bytes(file_data.to_vec())
                    .file_name(filename.to_string())
                    .mime_str("application/octet-stream")?,
            );

        // Add optional parameters
        let mut form = form;
        if let Some(timeout) = options.timeout {
            form = form.text("timeout", timeout.to_string());
        }
        if let Some(ref machine) = options.environment {
            form = form.text("machine", machine.clone());
        }
        if options.enable_network {
            form = form.text("options", "network=1");
        }
        if let Some(ref password) = options.password {
            form = form.text("password", password.clone());
        }
        if let Some(priority) = options.priority {
            form = form.text("priority", priority.to_string());
        }
        for tag in &options.tags {
            form = form.text("tags", tag.clone());
        }

        let response = self
            .build_request(reqwest::Method::POST, "/tasks/create/file")
            .multipart(form)
            .send()
            .await?;

        if !response.status().is_success() {
            let status = response.status();
            let text = response.text().await.unwrap_or_default();
            return Err(anyhow!("Cuckoo submission failed: {} - {}", status, text));
        }

        let result: CuckooSubmitResponse = response.json().await?;

        Ok(SandboxSubmission {
            sandbox_type: SandboxType::Cuckoo,
            task_id: result.task_id.to_string(),
            submission_id: Some(result.task_id.to_string()),
            status: SandboxStatus::Pending,
            message: None,
            submitted_at: Utc::now(),
        })
    }

    /// Get task status
    pub async fn get_status(&self, task_id: &str) -> Result<SandboxStatus> {
        let response = self
            .build_request(reqwest::Method::GET, &format!("/tasks/view/{}", task_id))
            .send()
            .await?;

        if !response.status().is_success() {
            return Err(anyhow!("Failed to get task status: {}", response.status()));
        }

        let result: CuckooTaskResponse = response.json().await?;

        Ok(match result.task.status.as_str() {
            "pending" => SandboxStatus::Pending,
            "running" | "processing" => SandboxStatus::Running,
            "completed" | "reported" => SandboxStatus::Completed,
            "failed_analysis" | "failed_processing" | "failed_reporting" => SandboxStatus::Failed,
            _ => SandboxStatus::Pending,
        })
    }

    /// Get analysis results (normalized)
    pub async fn get_results(&self, task_id: &str) -> Result<SandboxResult> {
        let response = self
            .build_request(reqwest::Method::GET, &format!("/tasks/report/{}", task_id))
            .send()
            .await?;

        if !response.status().is_success() {
            return Err(anyhow!("Failed to get report: {}", response.status()));
        }

        let report: CuckooReport = response.json().await?;
        self.normalize_report(task_id, &report)
    }

    /// Get raw report JSON
    pub async fn get_raw_report(&self, task_id: &str) -> Result<serde_json::Value> {
        let response = self
            .build_request(reqwest::Method::GET, &format!("/tasks/report/{}", task_id))
            .send()
            .await?;

        if !response.status().is_success() {
            return Err(anyhow!("Failed to get raw report: {}", response.status()));
        }

        let report: serde_json::Value = response.json().await?;
        Ok(report)
    }

    /// Get screenshots
    pub async fn get_screenshots(&self, task_id: &str) -> Result<Vec<Screenshot>> {
        let response = self
            .build_request(reqwest::Method::GET, &format!("/tasks/screenshots/{}", task_id))
            .send()
            .await?;

        if !response.status().is_success() {
            return Ok(vec![]); // Screenshots may not be available
        }

        let result: CuckooScreenshotsResponse = response.json().await?;

        Ok(result
            .screenshots
            .into_iter()
            .map(|s| Screenshot {
                id: s.name.clone(),
                timestamp: None,
                url: Some(format!(
                    "{}/tasks/screenshot/{}/{}",
                    self.base_url, task_id, s.name
                )),
                data: None,
                thumbnail_url: None,
            })
            .collect())
    }

    /// Download a specific screenshot
    pub async fn download_screenshot(&self, task_id: &str, screenshot_id: &str) -> Result<Vec<u8>> {
        let response = self
            .build_request(
                reqwest::Method::GET,
                &format!("/tasks/screenshot/{}/{}", task_id, screenshot_id),
            )
            .send()
            .await?;

        if !response.status().is_success() {
            return Err(anyhow!("Failed to download screenshot: {}", response.status()));
        }

        let bytes = response.bytes().await?;
        Ok(bytes.to_vec())
    }

    /// Get dropped files
    pub async fn get_dropped_files(&self, task_id: &str) -> Result<Vec<DroppedFile>> {
        let response = self
            .build_request(reqwest::Method::GET, &format!("/tasks/report/{}/dropped", task_id))
            .send()
            .await?;

        if !response.status().is_success() {
            return Ok(vec![]);
        }

        let result: CuckooDroppedResponse = response.json().await?;

        Ok(result
            .dropped
            .into_iter()
            .map(|d| DroppedFile {
                filename: d.name.clone(),
                path: d.filepath.clone(),
                file_type: d.type_.clone(),
                size: d.size,
                md5: d.md5.clone(),
                sha256: d.sha256.clone(),
                ssdeep: d.ssdeep,
                entropy: None,
                is_executable: d.type_.as_ref().map(|t| t.contains("executable")).unwrap_or(false),
                is_suspicious: false,
                detection: None,
                yara_matches: d.yara.unwrap_or_default(),
                download_url: Some(format!(
                    "{}/tasks/dropped/{}/{}",
                    self.base_url, task_id, d.sha256
                )),
            })
            .collect())
    }

    /// Download a dropped file
    pub async fn download_dropped(&self, task_id: &str, sha256: &str) -> Result<Vec<u8>> {
        let response = self
            .build_request(
                reqwest::Method::GET,
                &format!("/tasks/dropped/{}/{}", task_id, sha256),
            )
            .send()
            .await?;

        if !response.status().is_success() {
            return Err(anyhow!("Failed to download dropped file: {}", response.status()));
        }

        let bytes = response.bytes().await?;
        Ok(bytes.to_vec())
    }

    /// List available machines/environments
    pub async fn list_machines(&self) -> Result<Vec<SandboxEnvironment>> {
        let response = self
            .build_request(reqwest::Method::GET, "/machines/list")
            .send()
            .await?;

        if !response.status().is_success() {
            return Err(anyhow!("Failed to list machines: {}", response.status()));
        }

        let result: CuckooMachinesResponse = response.json().await?;

        Ok(result
            .machines
            .into_iter()
            .map(|m| SandboxEnvironment {
                id: m.name.clone(),
                name: m.label.unwrap_or(m.name.clone()),
                os: m.platform.clone(),
                os_version: None,
                architecture: m.arch.unwrap_or_else(|| "x64".to_string()),
                available: m.status == "poweroff" || m.status == "saved",
                description: m.options,
            })
            .collect())
    }

    /// Normalize Cuckoo report to common format
    fn normalize_report(&self, task_id: &str, report: &CuckooReport) -> Result<SandboxResult> {
        let info = &report.info;

        // Determine verdict based on score
        let verdict = if info.score >= 7.0 {
            SandboxVerdict::Malicious
        } else if info.score >= 4.0 {
            SandboxVerdict::Suspicious
        } else if info.score > 0.0 {
            SandboxVerdict::Clean
        } else {
            SandboxVerdict::Unknown
        };

        // Process behavior data
        let processes = report
            .behavior
            .as_ref()
            .map(|b| self.extract_processes(b))
            .unwrap_or_default();

        // Process network data
        let network_activity = report
            .network
            .as_ref()
            .map(|n| self.extract_network_activity(n))
            .unwrap_or_default();

        // Extract signatures
        let signatures = report
            .signatures
            .as_ref()
            .map(|sigs| self.extract_signatures(sigs))
            .unwrap_or_default();

        // Extract MITRE techniques
        let mitre_techniques: Vec<String> = signatures
            .iter()
            .flat_map(|s| s.mitre_techniques.clone())
            .collect();

        // Extract IOCs
        let (network_iocs, file_iocs) = self.extract_iocs(report);

        // Extract dropped files
        let dropped_files = report
            .dropped
            .as_ref()
            .map(|d| self.extract_dropped_files(d))
            .unwrap_or_default();

        Ok(SandboxResult {
            id: uuid::Uuid::new_v4().to_string(),
            sample_id: report.target.file.as_ref()
                .map(|f| f.sha256.clone())
                .unwrap_or_default(),
            sandbox_type: SandboxType::Cuckoo,
            sandbox_task_id: task_id.to_string(),
            status: SandboxStatus::Completed,
            verdict,
            score: (info.score * 10.0).min(100.0) as u8,
            processes,
            network_activity,
            file_activity: FileActivity::default(), // Would need behavior.summary parsing
            registry_activity: RegistryActivity::default(),
            dropped_files,
            signatures,
            network_iocs,
            file_iocs,
            mitre_techniques,
            screenshots: vec![],
            submitted_at: info.started.clone().unwrap_or_else(Utc::now),
            completed_at: info.ended.clone(),
            analysis_duration_seconds: info.duration as u32,
        })
    }

    fn extract_processes(&self, behavior: &CuckooBehavior) -> Vec<ProcessInfo> {
        behavior
            .processes
            .iter()
            .map(|p| ProcessInfo {
                pid: p.process_id,
                ppid: p.parent_id,
                name: p.process_name.clone(),
                path: p.module_path.clone(),
                command_line: p.command_line.clone(),
                username: None,
                integrity_level: None,
                is_injected: false,
                is_suspicious: false,
                start_time: None,
                end_time: None,
                api_calls: p
                    .calls
                    .as_ref()
                    .map(|calls| {
                        calls
                            .iter()
                            .take(100) // Limit API calls
                            .map(|c| ApiCall {
                                api_name: c.api.clone(),
                                category: c.category.clone().unwrap_or_default(),
                                arguments: c.arguments.clone().unwrap_or_default(),
                                return_value: c.return_value.clone(),
                                timestamp: None,
                                is_suspicious: c.is_suspicious.unwrap_or(false),
                            })
                            .collect()
                    })
                    .unwrap_or_default(),
                child_processes: vec![],
            })
            .collect()
    }

    fn extract_network_activity(&self, network: &CuckooNetwork) -> NetworkActivity {
        NetworkActivity {
            dns_queries: network
                .dns
                .iter()
                .map(|d| DnsQuery {
                    domain: d.request.clone(),
                    query_type: d.type_.clone().unwrap_or_else(|| "A".to_string()),
                    resolved_ips: d.answers.clone().unwrap_or_default()
                        .into_iter()
                        .filter_map(|a| a.data)
                        .collect(),
                    timestamp: None,
                    is_suspicious: false,
                    dga_score: None,
                })
                .collect(),
            http_requests: network
                .http
                .iter()
                .map(|h| HttpRequest {
                    method: h.method.clone().unwrap_or_else(|| "GET".to_string()),
                    url: h.uri.clone(),
                    host: h.host.clone(),
                    path: h.path.clone().unwrap_or_default(),
                    user_agent: h.user_agent.clone(),
                    referer: None,
                    response_code: h.status.map(|s| s as u16),
                    response_size: h.body_length,
                    content_type: h.content_type.clone(),
                    body_sha256: None,
                    timestamp: None,
                    is_suspicious: false,
                })
                .collect(),
            tcp_connections: network
                .tcp
                .iter()
                .map(|t| TcpConnection {
                    src_ip: t.src.clone(),
                    src_port: t.sport,
                    dst_ip: t.dst.clone(),
                    dst_port: t.dport,
                    protocol: None,
                    bytes_sent: 0,
                    bytes_received: 0,
                    packets_sent: 0,
                    packets_received: 0,
                    duration_ms: None,
                    is_suspicious: false,
                    geo_country: None,
                    asn: None,
                })
                .collect(),
            udp_flows: network
                .udp
                .iter()
                .map(|u| UdpFlow {
                    src_ip: u.src.clone(),
                    src_port: u.sport,
                    dst_ip: u.dst.clone(),
                    dst_port: u.dport,
                    bytes_sent: 0,
                    bytes_received: 0,
                    is_suspicious: false,
                })
                .collect(),
            icmp_activity: vec![],
            total_bytes_sent: 0,
            total_bytes_received: 0,
        }
    }

    fn extract_signatures(&self, signatures: &[CuckooSignature]) -> Vec<SignatureMatch> {
        signatures
            .iter()
            .map(|s| SignatureMatch {
                name: s.name.clone(),
                description: s.description.clone(),
                severity: match s.severity {
                    1 => SignatureSeverity::Low,
                    2 => SignatureSeverity::Medium,
                    3 => SignatureSeverity::High,
                    4 | 5 => SignatureSeverity::Critical,
                    _ => SignatureSeverity::Info,
                },
                category: s.categories.first().cloned().unwrap_or_default(),
                families: s.families.clone().unwrap_or_default(),
                mitre_techniques: s.ttp.clone().unwrap_or_default(),
                references: s.references.clone().unwrap_or_default(),
                indicators: s.marks.clone().unwrap_or_default()
                    .into_iter()
                    .filter_map(|m| m.ioc)
                    .collect(),
            })
            .collect()
    }

    fn extract_dropped_files(&self, dropped: &[CuckooDroppedFile]) -> Vec<DroppedFile> {
        dropped
            .iter()
            .map(|d| DroppedFile {
                filename: d.name.clone(),
                path: d.filepath.clone(),
                file_type: d.type_.clone(),
                size: d.size,
                md5: d.md5.clone(),
                sha256: d.sha256.clone(),
                ssdeep: d.ssdeep.clone(),
                entropy: None,
                is_executable: d.type_.as_ref()
                    .map(|t| t.contains("executable") || t.contains("PE32"))
                    .unwrap_or(false),
                is_suspicious: false,
                detection: None,
                yara_matches: d.yara.clone().unwrap_or_default(),
                download_url: None,
            })
            .collect()
    }

    fn extract_iocs(&self, report: &CuckooReport) -> (Vec<NetworkIoc>, Vec<FileIoc>) {
        let mut network_iocs = Vec::new();
        let mut file_iocs = Vec::new();

        // Extract network IOCs from network data
        if let Some(network) = &report.network {
            // Domains from DNS
            for dns in &network.dns {
                network_iocs.push(NetworkIoc {
                    ioc_type: NetworkIocType::Domain,
                    value: dns.request.clone(),
                    context: Some("DNS query".to_string()),
                    first_seen: None,
                    last_seen: None,
                    count: 1,
                    is_c2: false,
                    threat_intel_hit: false,
                    threat_intel_source: None,
                });
            }

            // IPs from TCP/UDP connections
            for tcp in &network.tcp {
                if !tcp.dst.starts_with("10.") &&
                   !tcp.dst.starts_with("192.168.") &&
                   !tcp.dst.starts_with("172.") {
                    network_iocs.push(NetworkIoc {
                        ioc_type: NetworkIocType::Ip,
                        value: tcp.dst.clone(),
                        context: Some(format!("TCP connection to port {}", tcp.dport)),
                        first_seen: None,
                        last_seen: None,
                        count: 1,
                        is_c2: false,
                        threat_intel_hit: false,
                        threat_intel_source: None,
                    });
                }
            }

            // URLs from HTTP
            for http in &network.http {
                network_iocs.push(NetworkIoc {
                    ioc_type: NetworkIocType::Url,
                    value: http.uri.clone(),
                    context: Some(format!("{} request", http.method.clone().unwrap_or_default())),
                    first_seen: None,
                    last_seen: None,
                    count: 1,
                    is_c2: false,
                    threat_intel_hit: false,
                    threat_intel_source: None,
                });
            }
        }

        // Extract file IOCs from dropped files
        if let Some(dropped) = &report.dropped {
            for file in dropped {
                file_iocs.push(FileIoc {
                    ioc_type: FileIocType::Sha256,
                    value: file.sha256.clone(),
                    path: Some(file.filepath.clone()),
                    context: Some("Dropped file".to_string()),
                    is_dropped: true,
                    threat_intel_hit: false,
                    detection_name: None,
                });
            }
        }

        // Deduplicate
        network_iocs.sort_by(|a, b| a.value.cmp(&b.value));
        network_iocs.dedup_by(|a, b| a.value == b.value && a.ioc_type == b.ioc_type);

        (network_iocs, file_iocs)
    }
}

// Cuckoo API response structures

#[derive(Debug, Deserialize)]
struct CuckooSubmitResponse {
    task_id: u64,
}

#[derive(Debug, Deserialize)]
struct CuckooTaskResponse {
    task: CuckooTask,
}

#[derive(Debug, Deserialize)]
struct CuckooTask {
    id: u64,
    status: String,
    sample: Option<CuckooSample>,
}

#[derive(Debug, Deserialize)]
struct CuckooSample {
    sha256: String,
}

#[derive(Debug, Deserialize)]
struct CuckooReport {
    info: CuckooInfo,
    target: CuckooTarget,
    behavior: Option<CuckooBehavior>,
    network: Option<CuckooNetwork>,
    signatures: Option<Vec<CuckooSignature>>,
    dropped: Option<Vec<CuckooDroppedFile>>,
}

#[derive(Debug, Deserialize)]
struct CuckooInfo {
    score: f64,
    duration: i64,
    started: Option<DateTime<Utc>>,
    ended: Option<DateTime<Utc>>,
}

#[derive(Debug, Deserialize)]
struct CuckooTarget {
    file: Option<CuckooFile>,
}

#[derive(Debug, Deserialize)]
struct CuckooFile {
    sha256: String,
    md5: String,
    name: String,
}

#[derive(Debug, Deserialize)]
struct CuckooBehavior {
    processes: Vec<CuckooProcess>,
}

#[derive(Debug, Deserialize)]
struct CuckooProcess {
    process_id: u32,
    parent_id: u32,
    process_name: String,
    module_path: Option<String>,
    command_line: Option<String>,
    calls: Option<Vec<CuckooApiCall>>,
}

#[derive(Debug, Deserialize)]
struct CuckooApiCall {
    api: String,
    category: Option<String>,
    arguments: Option<Vec<String>>,
    return_value: Option<String>,
    is_suspicious: Option<bool>,
}

#[derive(Debug, Deserialize)]
struct CuckooNetwork {
    dns: Vec<CuckooDns>,
    http: Vec<CuckooHttp>,
    tcp: Vec<CuckooTcpUdp>,
    udp: Vec<CuckooTcpUdp>,
}

#[derive(Debug, Deserialize)]
struct CuckooDns {
    request: String,
    #[serde(rename = "type")]
    type_: Option<String>,
    answers: Option<Vec<CuckooDnsAnswer>>,
}

#[derive(Debug, Clone, Deserialize)]
struct CuckooDnsAnswer {
    data: Option<String>,
}

#[derive(Debug, Deserialize)]
struct CuckooHttp {
    uri: String,
    host: String,
    method: Option<String>,
    path: Option<String>,
    user_agent: Option<String>,
    status: Option<i32>,
    body_length: Option<u64>,
    content_type: Option<String>,
}

#[derive(Debug, Deserialize)]
struct CuckooTcpUdp {
    src: String,
    sport: u16,
    dst: String,
    dport: u16,
}

#[derive(Debug, Deserialize)]
struct CuckooSignature {
    name: String,
    description: String,
    severity: u8,
    categories: Vec<String>,
    families: Option<Vec<String>>,
    ttp: Option<Vec<String>>,
    references: Option<Vec<String>>,
    marks: Option<Vec<CuckooMark>>,
}

#[derive(Debug, Clone, Deserialize)]
struct CuckooMark {
    ioc: Option<String>,
}

#[derive(Debug, Deserialize)]
struct CuckooDroppedFile {
    name: String,
    filepath: String,
    #[serde(rename = "type")]
    type_: Option<String>,
    size: u64,
    md5: String,
    sha256: String,
    ssdeep: Option<String>,
    yara: Option<Vec<String>>,
}

#[derive(Debug, Deserialize)]
struct CuckooScreenshotsResponse {
    screenshots: Vec<CuckooScreenshot>,
}

#[derive(Debug, Deserialize)]
struct CuckooScreenshot {
    name: String,
}

#[derive(Debug, Deserialize)]
struct CuckooDroppedResponse {
    dropped: Vec<CuckooDroppedFile>,
}

#[derive(Debug, Deserialize)]
struct CuckooMachinesResponse {
    machines: Vec<CuckooMachine>,
}

#[derive(Debug, Deserialize)]
struct CuckooMachine {
    name: String,
    label: Option<String>,
    platform: String,
    arch: Option<String>,
    status: String,
    options: Option<String>,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_client_creation() {
        let client = CuckooClient::new("http://localhost:8090", Some("test-key"));
        assert_eq!(client.base_url, "http://localhost:8090");
        assert_eq!(client.api_key, Some("test-key".to_string()));
    }
}
