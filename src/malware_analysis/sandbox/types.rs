//! Sandbox Types
//!
//! Normalized types for sandbox integration that work across all supported sandboxes.

use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};

/// Sandbox type enumeration
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]
#[serde(rename_all = "snake_case")]
pub enum SandboxType {
    Cuckoo,
    AnyRun,
    HybridAnalysis,
}

impl std::fmt::Display for SandboxType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            SandboxType::Cuckoo => write!(f, "cuckoo"),
            SandboxType::AnyRun => write!(f, "anyrun"),
            SandboxType::HybridAnalysis => write!(f, "hybrid_analysis"),
        }
    }
}

impl std::str::FromStr for SandboxType {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s.to_lowercase().as_str() {
            "cuckoo" => Ok(SandboxType::Cuckoo),
            "anyrun" | "any.run" => Ok(SandboxType::AnyRun),
            "hybrid_analysis" | "hybrid-analysis" | "hybridanalysis" | "falcon" => {
                Ok(SandboxType::HybridAnalysis)
            }
            _ => Err(format!("Unknown sandbox type: {}", s)),
        }
    }
}

/// Sandbox analysis status
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum SandboxStatus {
    Pending,
    Running,
    Completed,
    Failed,
    Timeout,
    Cancelled,
}

impl std::fmt::Display for SandboxStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            SandboxStatus::Pending => write!(f, "pending"),
            SandboxStatus::Running => write!(f, "running"),
            SandboxStatus::Completed => write!(f, "completed"),
            SandboxStatus::Failed => write!(f, "failed"),
            SandboxStatus::Timeout => write!(f, "timeout"),
            SandboxStatus::Cancelled => write!(f, "cancelled"),
        }
    }
}

/// Sandbox verdict
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum SandboxVerdict {
    Malicious,
    Suspicious,
    Clean,
    Unknown,
}

impl Default for SandboxVerdict {
    fn default() -> Self {
        SandboxVerdict::Unknown
    }
}

impl std::fmt::Display for SandboxVerdict {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            SandboxVerdict::Malicious => write!(f, "malicious"),
            SandboxVerdict::Suspicious => write!(f, "suspicious"),
            SandboxVerdict::Clean => write!(f, "clean"),
            SandboxVerdict::Unknown => write!(f, "unknown"),
        }
    }
}

/// Options for sandbox submission
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct SubmissionOptions {
    /// Timeout in seconds
    pub timeout: Option<u32>,
    /// Enable network simulation
    pub enable_network: bool,
    /// Operating system to use
    pub os: Option<String>,
    /// Environment/machine name
    pub environment: Option<String>,
    /// Custom command line arguments
    pub arguments: Option<String>,
    /// Document password (for encrypted files)
    pub password: Option<String>,
    /// Enable internet access
    pub internet_access: bool,
    /// Custom tags
    pub tags: Vec<String>,
    /// Priority (1-5)
    pub priority: Option<u8>,
    /// User interaction script
    pub interaction_script: Option<String>,
}

/// Sandbox submission response
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SandboxSubmission {
    pub sandbox_type: SandboxType,
    pub task_id: String,
    pub submission_id: Option<String>,
    pub status: SandboxStatus,
    pub message: Option<String>,
    pub submitted_at: DateTime<Utc>,
}

/// Normalized sandbox analysis result
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SandboxResult {
    pub id: String,
    pub sample_id: String,
    pub sandbox_type: SandboxType,
    pub sandbox_task_id: String,
    pub status: SandboxStatus,
    pub verdict: SandboxVerdict,
    pub score: u8, // 0-100
    pub processes: Vec<ProcessInfo>,
    pub network_activity: NetworkActivity,
    pub file_activity: FileActivity,
    pub registry_activity: RegistryActivity,
    pub dropped_files: Vec<DroppedFile>,
    pub signatures: Vec<SignatureMatch>,
    pub network_iocs: Vec<NetworkIoc>,
    pub file_iocs: Vec<FileIoc>,
    pub mitre_techniques: Vec<String>,
    pub screenshots: Vec<Screenshot>,
    pub submitted_at: DateTime<Utc>,
    pub completed_at: Option<DateTime<Utc>>,
    pub analysis_duration_seconds: u32,
}

/// Process information from sandbox execution
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProcessInfo {
    pub pid: u32,
    pub ppid: u32,
    pub name: String,
    pub path: Option<String>,
    pub command_line: Option<String>,
    pub username: Option<String>,
    pub integrity_level: Option<String>,
    pub is_injected: bool,
    pub is_suspicious: bool,
    pub start_time: Option<DateTime<Utc>>,
    pub end_time: Option<DateTime<Utc>>,
    pub api_calls: Vec<ApiCall>,
    pub child_processes: Vec<u32>,
}

/// API call captured during execution
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ApiCall {
    pub api_name: String,
    pub category: String,
    pub arguments: Vec<String>,
    pub return_value: Option<String>,
    pub timestamp: Option<DateTime<Utc>>,
    pub is_suspicious: bool,
}

/// Network activity during analysis
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct NetworkActivity {
    pub dns_queries: Vec<DnsQuery>,
    pub http_requests: Vec<HttpRequest>,
    pub tcp_connections: Vec<TcpConnection>,
    pub udp_flows: Vec<UdpFlow>,
    pub icmp_activity: Vec<IcmpActivity>,
    pub total_bytes_sent: u64,
    pub total_bytes_received: u64,
}

/// DNS query
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DnsQuery {
    pub domain: String,
    pub query_type: String,
    pub resolved_ips: Vec<String>,
    pub timestamp: Option<DateTime<Utc>>,
    pub is_suspicious: bool,
    pub dga_score: Option<f64>,
}

/// HTTP request
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct HttpRequest {
    pub method: String,
    pub url: String,
    pub host: String,
    pub path: String,
    pub user_agent: Option<String>,
    pub referer: Option<String>,
    pub response_code: Option<u16>,
    pub response_size: Option<u64>,
    pub content_type: Option<String>,
    pub body_sha256: Option<String>,
    pub timestamp: Option<DateTime<Utc>>,
    pub is_suspicious: bool,
}

/// TCP connection
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TcpConnection {
    pub src_ip: String,
    pub src_port: u16,
    pub dst_ip: String,
    pub dst_port: u16,
    pub protocol: Option<String>,
    pub bytes_sent: u64,
    pub bytes_received: u64,
    pub packets_sent: u32,
    pub packets_received: u32,
    pub duration_ms: Option<u64>,
    pub is_suspicious: bool,
    pub geo_country: Option<String>,
    pub asn: Option<String>,
}

/// UDP flow
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UdpFlow {
    pub src_ip: String,
    pub src_port: u16,
    pub dst_ip: String,
    pub dst_port: u16,
    pub bytes_sent: u64,
    pub bytes_received: u64,
    pub is_suspicious: bool,
}

/// ICMP activity
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct IcmpActivity {
    pub icmp_type: u8,
    pub icmp_code: u8,
    pub dst_ip: String,
    pub count: u32,
}

/// File activity during analysis
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct FileActivity {
    pub files_created: Vec<FileOperation>,
    pub files_modified: Vec<FileOperation>,
    pub files_deleted: Vec<FileOperation>,
    pub files_read: Vec<FileOperation>,
}

/// File operation
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileOperation {
    pub path: String,
    pub operation: String,
    pub sha256: Option<String>,
    pub size: Option<u64>,
    pub timestamp: Option<DateTime<Utc>>,
    pub is_suspicious: bool,
    pub detection: Option<String>,
}

/// Registry activity during analysis (Windows)
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct RegistryActivity {
    pub keys_created: Vec<RegistryOperation>,
    pub keys_modified: Vec<RegistryOperation>,
    pub keys_deleted: Vec<RegistryOperation>,
    pub values_set: Vec<RegistryOperation>,
}

/// Registry operation
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RegistryOperation {
    pub key: String,
    pub value_name: Option<String>,
    pub value_data: Option<String>,
    pub value_type: Option<String>,
    pub timestamp: Option<DateTime<Utc>>,
    pub is_suspicious: bool,
    pub is_persistence: bool,
}

/// Dropped file during analysis
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DroppedFile {
    pub filename: String,
    pub path: String,
    pub file_type: Option<String>,
    pub size: u64,
    pub md5: String,
    pub sha256: String,
    pub ssdeep: Option<String>,
    pub entropy: Option<f64>,
    pub is_executable: bool,
    pub is_suspicious: bool,
    pub detection: Option<String>,
    pub yara_matches: Vec<String>,
    pub download_url: Option<String>,
}

/// Signature match from sandbox
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SignatureMatch {
    pub name: String,
    pub description: String,
    pub severity: SignatureSeverity,
    pub category: String,
    pub families: Vec<String>,
    pub mitre_techniques: Vec<String>,
    pub references: Vec<String>,
    pub indicators: Vec<String>,
}

/// Signature severity
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum SignatureSeverity {
    Critical,
    High,
    Medium,
    Low,
    Info,
}

impl Default for SignatureSeverity {
    fn default() -> Self {
        SignatureSeverity::Info
    }
}

/// Network-based IOC
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NetworkIoc {
    pub ioc_type: NetworkIocType,
    pub value: String,
    pub context: Option<String>,
    pub first_seen: Option<DateTime<Utc>>,
    pub last_seen: Option<DateTime<Utc>>,
    pub count: u32,
    pub is_c2: bool,
    pub threat_intel_hit: bool,
    pub threat_intel_source: Option<String>,
}

/// Network IOC type
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum NetworkIocType {
    Ip,
    Domain,
    Url,
    JA3,
    JA3S,
    Sni,
    UserAgent,
}

/// File-based IOC
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileIoc {
    pub ioc_type: FileIocType,
    pub value: String,
    pub path: Option<String>,
    pub context: Option<String>,
    pub is_dropped: bool,
    pub threat_intel_hit: bool,
    pub detection_name: Option<String>,
}

/// File IOC type
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum FileIocType {
    Md5,
    Sha1,
    Sha256,
    Ssdeep,
    Imphash,
    Filename,
    Mutex,
    Registry,
}

/// Screenshot from analysis
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Screenshot {
    pub id: String,
    pub timestamp: Option<DateTime<Utc>>,
    pub url: Option<String>,
    pub data: Option<Vec<u8>>,
    pub thumbnail_url: Option<String>,
}

/// Sandbox comparison result
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct SandboxComparison {
    pub consensus_verdict: SandboxVerdict,
    pub average_score: u8,
    pub sandbox_count: usize,
    pub verdicts: Vec<(SandboxType, SandboxVerdict)>,
    pub scores: Vec<(SandboxType, u8)>,
    pub common_signatures: Vec<String>,
    pub common_mitre_techniques: Vec<String>,
    pub total_network_iocs: usize,
    pub total_file_iocs: usize,
}

/// Sandbox configuration for storage
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SandboxConfig {
    pub id: String,
    pub user_id: String,
    pub sandbox_type: SandboxType,
    pub name: String,
    pub base_url: Option<String>,
    pub api_key_encrypted: String,
    pub is_active: bool,
    pub default_timeout: u32,
    pub default_environment: Option<String>,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

/// Available sandbox environment
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SandboxEnvironment {
    pub id: String,
    pub name: String,
    pub os: String,
    pub os_version: Option<String>,
    pub architecture: String,
    pub available: bool,
    pub description: Option<String>,
}

/// Sandbox statistics
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SandboxStats {
    pub sandbox_type: SandboxType,
    pub total_submissions: u64,
    pub pending: u64,
    pub running: u64,
    pub completed: u64,
    pub failed: u64,
    pub malicious: u64,
    pub suspicious: u64,
    pub clean: u64,
    pub average_analysis_time_seconds: f64,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_sandbox_type_parsing() {
        assert_eq!("cuckoo".parse::<SandboxType>().unwrap(), SandboxType::Cuckoo);
        assert_eq!("anyrun".parse::<SandboxType>().unwrap(), SandboxType::AnyRun);
        assert_eq!("hybrid_analysis".parse::<SandboxType>().unwrap(), SandboxType::HybridAnalysis);
        assert_eq!("falcon".parse::<SandboxType>().unwrap(), SandboxType::HybridAnalysis);
    }

    #[test]
    fn test_sandbox_type_display() {
        assert_eq!(SandboxType::Cuckoo.to_string(), "cuckoo");
        assert_eq!(SandboxType::AnyRun.to_string(), "anyrun");
        assert_eq!(SandboxType::HybridAnalysis.to_string(), "hybrid_analysis");
    }
}
