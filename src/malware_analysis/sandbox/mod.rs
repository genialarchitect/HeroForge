//! Sandbox Integration Module
//!
//! Provides integration with multiple malware analysis sandboxes:
//! - Cuckoo Sandbox (self-hosted)
//! - Any.Run (cloud-based interactive sandbox)
//! - Hybrid Analysis (CrowdStrike Falcon Sandbox)
//!
//! Features:
//! - Unified submission and result retrieval
//! - Result normalization across different sandbox formats
//! - Behavioral report parsing
//! - Network/File IOC extraction
//! - Sandbox comparison view

pub mod types;
pub mod cuckoo;
pub mod anyrun;
pub mod hybrid;

pub use types::*;
pub use cuckoo::CuckooClient;
pub use anyrun::AnyRunClient;
pub use hybrid::HybridAnalysisClient;

use anyhow::{anyhow, Result};

/// Unified sandbox client that can interact with any supported sandbox
pub struct SandboxManager {
    cuckoo: Option<CuckooClient>,
    anyrun: Option<AnyRunClient>,
    hybrid: Option<HybridAnalysisClient>,
}

impl SandboxManager {
    /// Create a new sandbox manager
    pub fn new() -> Self {
        Self {
            cuckoo: None,
            anyrun: None,
            hybrid: None,
        }
    }

    /// Configure Cuckoo Sandbox
    pub fn with_cuckoo(mut self, base_url: &str, api_key: Option<&str>) -> Self {
        self.cuckoo = Some(CuckooClient::new(base_url, api_key));
        self
    }

    /// Configure Any.Run
    pub fn with_anyrun(mut self, api_key: &str) -> Self {
        self.anyrun = Some(AnyRunClient::new(api_key));
        self
    }

    /// Configure Hybrid Analysis
    pub fn with_hybrid(mut self, api_key: &str) -> Self {
        self.hybrid = Some(HybridAnalysisClient::new(api_key));
        self
    }

    /// Submit sample to specified sandbox
    pub async fn submit(
        &self,
        sandbox_type: SandboxType,
        file_data: &[u8],
        filename: &str,
        options: &SubmissionOptions,
    ) -> Result<SandboxSubmission> {
        match sandbox_type {
            SandboxType::Cuckoo => {
                let client = self.cuckoo.as_ref()
                    .ok_or_else(|| anyhow!("Cuckoo Sandbox not configured"))?;
                client.submit(file_data, filename, options).await
            }
            SandboxType::AnyRun => {
                let client = self.anyrun.as_ref()
                    .ok_or_else(|| anyhow!("Any.Run not configured"))?;
                client.submit(file_data, filename, options).await
            }
            SandboxType::HybridAnalysis => {
                let client = self.hybrid.as_ref()
                    .ok_or_else(|| anyhow!("Hybrid Analysis not configured"))?;
                client.submit(file_data, filename, options).await
            }
        }
    }

    /// Get analysis status
    pub async fn get_status(
        &self,
        sandbox_type: SandboxType,
        task_id: &str,
    ) -> Result<SandboxStatus> {
        match sandbox_type {
            SandboxType::Cuckoo => {
                let client = self.cuckoo.as_ref()
                    .ok_or_else(|| anyhow!("Cuckoo Sandbox not configured"))?;
                client.get_status(task_id).await
            }
            SandboxType::AnyRun => {
                let client = self.anyrun.as_ref()
                    .ok_or_else(|| anyhow!("Any.Run not configured"))?;
                client.get_status(task_id).await
            }
            SandboxType::HybridAnalysis => {
                let client = self.hybrid.as_ref()
                    .ok_or_else(|| anyhow!("Hybrid Analysis not configured"))?;
                client.get_status(task_id).await
            }
        }
    }

    /// Get analysis results (normalized)
    pub async fn get_results(
        &self,
        sandbox_type: SandboxType,
        task_id: &str,
    ) -> Result<SandboxResult> {
        match sandbox_type {
            SandboxType::Cuckoo => {
                let client = self.cuckoo.as_ref()
                    .ok_or_else(|| anyhow!("Cuckoo Sandbox not configured"))?;
                client.get_results(task_id).await
            }
            SandboxType::AnyRun => {
                let client = self.anyrun.as_ref()
                    .ok_or_else(|| anyhow!("Any.Run not configured"))?;
                client.get_results(task_id).await
            }
            SandboxType::HybridAnalysis => {
                let client = self.hybrid.as_ref()
                    .ok_or_else(|| anyhow!("Hybrid Analysis not configured"))?;
                client.get_results(task_id).await
            }
        }
    }

    /// Get raw report from sandbox
    pub async fn get_raw_report(
        &self,
        sandbox_type: SandboxType,
        task_id: &str,
    ) -> Result<serde_json::Value> {
        match sandbox_type {
            SandboxType::Cuckoo => {
                let client = self.cuckoo.as_ref()
                    .ok_or_else(|| anyhow!("Cuckoo Sandbox not configured"))?;
                client.get_raw_report(task_id).await
            }
            SandboxType::AnyRun => {
                let client = self.anyrun.as_ref()
                    .ok_or_else(|| anyhow!("Any.Run not configured"))?;
                client.get_raw_report(task_id).await
            }
            SandboxType::HybridAnalysis => {
                let client = self.hybrid.as_ref()
                    .ok_or_else(|| anyhow!("Hybrid Analysis not configured"))?;
                client.get_raw_report(task_id).await
            }
        }
    }

    /// Get screenshots from analysis
    pub async fn get_screenshots(
        &self,
        sandbox_type: SandboxType,
        task_id: &str,
    ) -> Result<Vec<Screenshot>> {
        match sandbox_type {
            SandboxType::Cuckoo => {
                let client = self.cuckoo.as_ref()
                    .ok_or_else(|| anyhow!("Cuckoo Sandbox not configured"))?;
                client.get_screenshots(task_id).await
            }
            SandboxType::AnyRun => {
                let client = self.anyrun.as_ref()
                    .ok_or_else(|| anyhow!("Any.Run not configured"))?;
                client.get_screenshots(task_id).await
            }
            SandboxType::HybridAnalysis => {
                let client = self.hybrid.as_ref()
                    .ok_or_else(|| anyhow!("Hybrid Analysis not configured"))?;
                client.get_screenshots(task_id).await
            }
        }
    }

    /// Check if a specific sandbox is configured
    pub fn is_configured(&self, sandbox_type: SandboxType) -> bool {
        match sandbox_type {
            SandboxType::Cuckoo => self.cuckoo.is_some(),
            SandboxType::AnyRun => self.anyrun.is_some(),
            SandboxType::HybridAnalysis => self.hybrid.is_some(),
        }
    }

    /// Get list of configured sandboxes
    pub fn configured_sandboxes(&self) -> Vec<SandboxType> {
        let mut sandboxes = Vec::new();
        if self.cuckoo.is_some() {
            sandboxes.push(SandboxType::Cuckoo);
        }
        if self.anyrun.is_some() {
            sandboxes.push(SandboxType::AnyRun);
        }
        if self.hybrid.is_some() {
            sandboxes.push(SandboxType::HybridAnalysis);
        }
        sandboxes
    }
}

impl Default for SandboxManager {
    fn default() -> Self {
        Self::new()
    }
}

/// Compare results from multiple sandboxes
pub fn compare_sandbox_results(results: &[SandboxResult]) -> SandboxComparison {
    if results.is_empty() {
        return SandboxComparison::default();
    }

    // Calculate consensus verdict
    let mut malicious_count = 0;
    let mut suspicious_count = 0;
    let mut clean_count = 0;
    let mut total_score = 0;

    for result in results {
        match result.verdict {
            SandboxVerdict::Malicious => malicious_count += 1,
            SandboxVerdict::Suspicious => suspicious_count += 1,
            SandboxVerdict::Clean => clean_count += 1,
            SandboxVerdict::Unknown => {}
        }
        total_score += result.score as u32;
    }

    let consensus_verdict = if malicious_count > results.len() / 2 {
        SandboxVerdict::Malicious
    } else if malicious_count + suspicious_count > results.len() / 2 {
        SandboxVerdict::Suspicious
    } else if clean_count > results.len() / 2 {
        SandboxVerdict::Clean
    } else {
        SandboxVerdict::Unknown
    };

    let average_score = (total_score / results.len() as u32) as u8;

    // Collect unique IOCs
    let mut all_network_iocs: Vec<NetworkIoc> = Vec::new();
    let mut all_file_iocs: Vec<FileIoc> = Vec::new();
    let mut all_signatures: Vec<String> = Vec::new();
    let mut all_mitre_techniques: Vec<String> = Vec::new();

    for result in results {
        all_network_iocs.extend(result.network_iocs.clone());
        all_file_iocs.extend(result.file_iocs.clone());
        all_signatures.extend(result.signatures.iter().map(|s| s.name.clone()));
        all_mitre_techniques.extend(result.mitre_techniques.clone());
    }

    // Deduplicate
    all_signatures.sort();
    all_signatures.dedup();
    all_mitre_techniques.sort();
    all_mitre_techniques.dedup();

    SandboxComparison {
        consensus_verdict,
        average_score,
        sandbox_count: results.len(),
        verdicts: results.iter().map(|r| (r.sandbox_type.clone(), r.verdict.clone())).collect(),
        scores: results.iter().map(|r| (r.sandbox_type.clone(), r.score)).collect(),
        common_signatures: all_signatures,
        common_mitre_techniques: all_mitre_techniques,
        total_network_iocs: all_network_iocs.len(),
        total_file_iocs: all_file_iocs.len(),
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_sandbox_manager_creation() {
        let manager = SandboxManager::new();
        assert!(!manager.is_configured(SandboxType::Cuckoo));
        assert!(!manager.is_configured(SandboxType::AnyRun));
        assert!(!manager.is_configured(SandboxType::HybridAnalysis));
    }

    #[test]
    fn test_sandbox_comparison() {
        let results = vec![
            SandboxResult {
                id: "1".to_string(),
                sample_id: "sample1".to_string(),
                sandbox_type: SandboxType::Cuckoo,
                sandbox_task_id: "task1".to_string(),
                status: SandboxStatus::Completed,
                verdict: SandboxVerdict::Malicious,
                score: 90,
                processes: vec![],
                network_activity: NetworkActivity::default(),
                file_activity: FileActivity::default(),
                registry_activity: RegistryActivity::default(),
                dropped_files: vec![],
                signatures: vec![],
                network_iocs: vec![],
                file_iocs: vec![],
                mitre_techniques: vec!["T1055".to_string()],
                screenshots: vec![],
                submitted_at: chrono::Utc::now(),
                completed_at: Some(chrono::Utc::now()),
                analysis_duration_seconds: 120,
            },
            SandboxResult {
                id: "2".to_string(),
                sample_id: "sample1".to_string(),
                sandbox_type: SandboxType::AnyRun,
                sandbox_task_id: "task2".to_string(),
                status: SandboxStatus::Completed,
                verdict: SandboxVerdict::Malicious,
                score: 85,
                processes: vec![],
                network_activity: NetworkActivity::default(),
                file_activity: FileActivity::default(),
                registry_activity: RegistryActivity::default(),
                dropped_files: vec![],
                signatures: vec![],
                network_iocs: vec![],
                file_iocs: vec![],
                mitre_techniques: vec!["T1055".to_string(), "T1059".to_string()],
                screenshots: vec![],
                submitted_at: chrono::Utc::now(),
                completed_at: Some(chrono::Utc::now()),
                analysis_duration_seconds: 180,
            },
        ];

        let comparison = compare_sandbox_results(&results);
        assert_eq!(comparison.consensus_verdict, SandboxVerdict::Malicious);
        assert_eq!(comparison.sandbox_count, 2);
        assert_eq!(comparison.average_score, 87);
    }
}
