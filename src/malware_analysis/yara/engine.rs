//! YARA Scanning Engine
//!
//! Core YARA rule matching engine with:
//! - Pattern-based rule matching (YARA-like)
//! - String, hex, and regex pattern support
//! - Condition evaluation
//! - Performance tracking

use super::types::*;
use chrono::Utc;
use regex::Regex;
use std::collections::HashMap;

/// YARA scanning engine
pub struct YaraScanner {
    compiled_rules: Vec<CompiledRule>,
    performance_tracking: bool,
}

/// Compiled rule for efficient scanning
struct CompiledRule {
    rule: YaraRule,
    patterns: Vec<CompiledPattern>,
    condition: CompiledCondition,
}

/// Compiled pattern
enum CompiledPattern {
    Text {
        identifier: String,
        pattern: Vec<u8>,
        nocase: bool,
        wide: bool,
        fullword: bool,
    },
    Hex {
        identifier: String,
        pattern: Vec<HexByte>,
    },
    Regex {
        identifier: String,
        regex: Regex,
        wide: bool,
    },
}

/// Hex pattern byte
#[derive(Clone)]
enum HexByte {
    Exact(u8),
    Wildcard,
    Jump(usize, Option<usize>),
    Alternative(Vec<u8>),
}

/// Compiled condition
enum CompiledCondition {
    All,
    Any,
    None,
    Count(usize),
    Expression(String),
}

impl YaraScanner {
    pub fn new() -> Self {
        Self {
            compiled_rules: Vec::new(),
            performance_tracking: true,
        }
    }

    /// Load rules into the scanner
    pub fn load_rules(&mut self, rules: Vec<YaraRule>) -> Result<usize, String> {
        let mut loaded = 0;
        for rule in rules {
            if !rule.enabled {
                continue;
            }
            match self.compile_rule(&rule) {
                Ok(compiled) => {
                    self.compiled_rules.push(compiled);
                    loaded += 1;
                }
                Err(e) => {
                    log::warn!("Failed to compile rule {}: {}", rule.name, e);
                }
            }
        }
        Ok(loaded)
    }

    /// Compile a single rule
    fn compile_rule(&self, rule: &YaraRule) -> Result<CompiledRule, String> {
        let (patterns, condition) = self.parse_rule_content(&rule.rule_content)?;

        Ok(CompiledRule {
            rule: rule.clone(),
            patterns,
            condition,
        })
    }

    /// Parse rule content into patterns and condition
    fn parse_rule_content(&self, content: &str) -> Result<(Vec<CompiledPattern>, CompiledCondition), String> {
        let mut patterns = Vec::new();
        let mut condition = CompiledCondition::Any;

        // Simple parser for YARA-like rules
        let mut in_strings = false;
        let mut in_condition = false;

        for line in content.lines() {
            let trimmed = line.trim();

            if trimmed.starts_with("strings:") {
                in_strings = true;
                in_condition = false;
                continue;
            }

            if trimmed.starts_with("condition:") {
                in_strings = false;
                in_condition = true;
                continue;
            }

            if in_strings && trimmed.starts_with('$') {
                if let Some(pattern) = self.parse_string_definition(trimmed) {
                    patterns.push(pattern);
                }
            }

            if in_condition {
                condition = self.parse_condition(trimmed);
            }
        }

        Ok((patterns, condition))
    }

    /// Parse a string definition line
    fn parse_string_definition(&self, line: &str) -> Option<CompiledPattern> {
        // Parse: $identifier = "string" modifiers
        // or: $identifier = { hex bytes }
        // or: $identifier = /regex/

        let parts: Vec<&str> = line.splitn(2, '=').collect();
        if parts.len() != 2 {
            return None;
        }

        let identifier = parts[0].trim().to_string();
        let value_part = parts[1].trim();

        if value_part.starts_with('"') {
            // Text string
            let end_quote = value_part[1..].find('"')?;
            let text = &value_part[1..end_quote + 1];
            let modifiers = &value_part[end_quote + 2..];

            Some(CompiledPattern::Text {
                identifier,
                pattern: text.as_bytes().to_vec(),
                nocase: modifiers.contains("nocase"),
                wide: modifiers.contains("wide"),
                fullword: modifiers.contains("fullword"),
            })
        } else if value_part.starts_with('{') {
            // Hex string
            let end_brace = value_part.find('}')?;
            let hex_str = &value_part[1..end_brace];
            let hex_pattern = self.parse_hex_pattern(hex_str)?;

            Some(CompiledPattern::Hex {
                identifier,
                pattern: hex_pattern,
            })
        } else if value_part.starts_with('/') {
            // Regex
            let end_slash = value_part[1..].find('/')?;
            let regex_str = &value_part[1..end_slash + 1];
            let modifiers = &value_part[end_slash + 2..];

            match Regex::new(regex_str) {
                Ok(regex) => Some(CompiledPattern::Regex {
                    identifier,
                    regex,
                    wide: modifiers.contains("wide"),
                }),
                Err(_) => None,
            }
        } else {
            None
        }
    }

    /// Parse hex pattern string
    fn parse_hex_pattern(&self, hex_str: &str) -> Option<Vec<HexByte>> {
        let mut pattern = Vec::new();
        let tokens: Vec<&str> = hex_str.split_whitespace().collect();

        let mut i = 0;
        while i < tokens.len() {
            let token = tokens[i];

            if token == "??" {
                pattern.push(HexByte::Wildcard);
            } else if token.starts_with('[') {
                // Jump: [n] or [n-m]
                let inner = token.trim_start_matches('[').trim_end_matches(']');
                if inner.contains('-') {
                    let parts: Vec<&str> = inner.split('-').collect();
                    let min: usize = parts[0].parse().ok()?;
                    let max: usize = parts[1].parse().ok()?;
                    pattern.push(HexByte::Jump(min, Some(max)));
                } else {
                    let n: usize = inner.parse().ok()?;
                    pattern.push(HexByte::Jump(n, None));
                }
            } else if token.starts_with('(') {
                // Alternative: (ab|cd|ef)
                let inner = token.trim_start_matches('(').trim_end_matches(')');
                let alts: Vec<u8> = inner
                    .split('|')
                    .filter_map(|s| u8::from_str_radix(s, 16).ok())
                    .collect();
                pattern.push(HexByte::Alternative(alts));
            } else if token.len() == 2 {
                // Regular hex byte
                if let Ok(byte) = u8::from_str_radix(token, 16) {
                    pattern.push(HexByte::Exact(byte));
                }
            }

            i += 1;
        }

        Some(pattern)
    }

    /// Parse condition string
    fn parse_condition(&self, condition: &str) -> CompiledCondition {
        let trimmed = condition.trim();

        if trimmed == "all of them" {
            CompiledCondition::All
        } else if trimmed == "any of them" {
            CompiledCondition::Any
        } else if trimmed == "none of them" {
            CompiledCondition::None
        } else if trimmed.starts_with("any") || trimmed.contains("of them") {
            // Parse "X of them" patterns
            if let Some(captures) = Regex::new(r"(\d+)\s+of\s+them").ok().and_then(|r| r.captures(trimmed)) {
                if let Some(count) = captures.get(1).and_then(|m| m.as_str().parse().ok()) {
                    return CompiledCondition::Count(count);
                }
            }
            CompiledCondition::Any
        } else {
            CompiledCondition::Expression(trimmed.to_string())
        }
    }

    /// Scan data against all loaded rules
    pub fn scan(&self, data: &[u8]) -> Vec<YaraMatch> {
        let mut matches = Vec::new();

        for compiled in &self.compiled_rules {
            if let Some(rule_match) = self.scan_rule(compiled, data) {
                matches.push(rule_match);
            }
        }

        matches
    }

    /// Scan data against a single compiled rule
    fn scan_rule(&self, compiled: &CompiledRule, data: &[u8]) -> Option<YaraMatch> {
        let start_time = std::time::Instant::now();
        let mut matched_strings = Vec::new();
        let mut pattern_matches: HashMap<String, Vec<MatchedString>> = HashMap::new();

        // Find all pattern matches
        for pattern in &compiled.patterns {
            let matches = self.find_pattern_matches(pattern, data);
            if !matches.is_empty() {
                let identifier = match pattern {
                    CompiledPattern::Text { identifier, .. } => identifier.clone(),
                    CompiledPattern::Hex { identifier, .. } => identifier.clone(),
                    CompiledPattern::Regex { identifier, .. } => identifier.clone(),
                };
                pattern_matches.insert(identifier, matches);
            }
        }

        // Evaluate condition
        let condition_met = match &compiled.condition {
            CompiledCondition::All => {
                pattern_matches.len() == compiled.patterns.len()
            }
            CompiledCondition::Any => {
                !pattern_matches.is_empty()
            }
            CompiledCondition::None => {
                pattern_matches.is_empty()
            }
            CompiledCondition::Count(n) => {
                pattern_matches.len() >= *n
            }
            CompiledCondition::Expression(expr) => {
                self.evaluate_expression(expr, &pattern_matches)
            }
        };

        if condition_met && !pattern_matches.is_empty() {
            // Collect all matched strings
            for (_, matches) in pattern_matches {
                matched_strings.extend(matches);
            }

            let scan_time = start_time.elapsed();

            Some(YaraMatch {
                id: uuid::Uuid::new_v4().to_string(),
                rule_id: compiled.rule.id.clone(),
                rule_name: compiled.rule.name.clone(),
                sample_id: None,
                file_path: None,
                file_hash: None,
                matched_strings,
                tags: compiled.rule.tags.clone(),
                metadata: HashMap::new(),
                scan_type: ScanType::File,
                scan_time_ms: scan_time.as_millis() as u64,
                is_false_positive: false,
                matched_at: Utc::now(),
            })
        } else {
            None
        }
    }

    /// Find pattern matches in data
    fn find_pattern_matches(&self, pattern: &CompiledPattern, data: &[u8]) -> Vec<MatchedString> {
        let mut matches = Vec::new();

        match pattern {
            CompiledPattern::Text { identifier, pattern: pat, nocase, wide, fullword } => {
                // Simple text search
                let search_pattern = if *nocase {
                    pat.to_ascii_lowercase()
                } else {
                    pat.clone()
                };

                let search_data = if *nocase {
                    data.to_ascii_lowercase()
                } else {
                    data.to_vec()
                };

                // Search for pattern
                for i in 0..search_data.len().saturating_sub(search_pattern.len()) {
                    if search_data[i..].starts_with(&search_pattern) {
                        let matched_data = &data[i..i + search_pattern.len()];

                        // Check fullword if required
                        if *fullword {
                            let before_ok = i == 0 || !data[i - 1].is_ascii_alphanumeric();
                            let after_ok = i + search_pattern.len() >= data.len()
                                || !data[i + search_pattern.len()].is_ascii_alphanumeric();
                            if !before_ok || !after_ok {
                                continue;
                            }
                        }

                        matches.push(MatchedString {
                            identifier: identifier.clone(),
                            offset: i as u64,
                            length: search_pattern.len(),
                            data: String::from_utf8_lossy(matched_data).to_string(),
                            is_xor: false,
                            xor_key: None,
                        });
                    }
                }

                // Wide string search (UTF-16LE)
                if *wide {
                    let wide_pattern: Vec<u8> = search_pattern
                        .iter()
                        .flat_map(|&b| vec![b, 0])
                        .collect();

                    for i in 0..data.len().saturating_sub(wide_pattern.len()) {
                        if data[i..].starts_with(&wide_pattern) {
                            matches.push(MatchedString {
                                identifier: identifier.clone(),
                                offset: i as u64,
                                length: wide_pattern.len(),
                                data: format!("(wide) {}", String::from_utf8_lossy(&search_pattern)),
                                is_xor: false,
                                xor_key: None,
                            });
                        }
                    }
                }
            }
            CompiledPattern::Hex { identifier, pattern: hex_pat } => {
                // Hex pattern matching
                if let Some(offset) = self.match_hex_pattern(hex_pat, data) {
                    let len = self.hex_pattern_min_length(hex_pat);
                    matches.push(MatchedString {
                        identifier: identifier.clone(),
                        offset: offset as u64,
                        length: len,
                        data: format!("{:02X?}", &data[offset..offset.saturating_add(len.min(32))]),
                        is_xor: false,
                        xor_key: None,
                    });
                }
            }
            CompiledPattern::Regex { identifier, regex, .. } => {
                // Regex matching
                if let Ok(text) = std::str::from_utf8(data) {
                    for mat in regex.find_iter(text) {
                        matches.push(MatchedString {
                            identifier: identifier.clone(),
                            offset: mat.start() as u64,
                            length: mat.len(),
                            data: mat.as_str().to_string(),
                            is_xor: false,
                            xor_key: None,
                        });
                    }
                }
            }
        }

        matches
    }

    /// Match hex pattern against data
    fn match_hex_pattern(&self, pattern: &[HexByte], data: &[u8]) -> Option<usize> {
        for start in 0..data.len() {
            if self.match_hex_at_offset(pattern, data, start) {
                return Some(start);
            }
        }
        None
    }

    /// Match hex pattern at specific offset
    fn match_hex_at_offset(&self, pattern: &[HexByte], data: &[u8], mut data_offset: usize) -> bool {
        let mut pattern_idx = 0;

        while pattern_idx < pattern.len() && data_offset < data.len() {
            match &pattern[pattern_idx] {
                HexByte::Exact(byte) => {
                    if data[data_offset] != *byte {
                        return false;
                    }
                    data_offset += 1;
                }
                HexByte::Wildcard => {
                    data_offset += 1;
                }
                HexByte::Jump(min, max) => {
                    let max_jump = max.unwrap_or(*min);
                    // Try different jump sizes
                    for jump in *min..=max_jump {
                        if self.match_hex_at_offset(&pattern[pattern_idx + 1..], data, data_offset + jump) {
                            return true;
                        }
                    }
                    return false;
                }
                HexByte::Alternative(alts) => {
                    if !alts.contains(&data[data_offset]) {
                        return false;
                    }
                    data_offset += 1;
                }
            }
            pattern_idx += 1;
        }

        pattern_idx == pattern.len()
    }

    /// Get minimum length of hex pattern
    fn hex_pattern_min_length(&self, pattern: &[HexByte]) -> usize {
        pattern.iter().map(|b| match b {
            HexByte::Exact(_) | HexByte::Wildcard | HexByte::Alternative(_) => 1,
            HexByte::Jump(min, _) => *min,
        }).sum()
    }

    /// Evaluate a condition expression
    fn evaluate_expression(&self, expr: &str, matches: &HashMap<String, Vec<MatchedString>>) -> bool {
        // Simple expression evaluation
        // Supports: $identifier, and, or, not, (, )

        let expr = expr.trim();

        // Handle simple identifier reference
        if expr.starts_with('$') {
            return matches.contains_key(expr);
        }

        // Handle "X of ($pattern*)"
        if expr.contains(" of ") {
            if let Some(captures) = Regex::new(r"(\d+|all|any)\s+of\s+\(([^)]+)\)").ok().and_then(|r| r.captures(expr)) {
                let count_str = captures.get(1).map(|m| m.as_str()).unwrap_or("any");
                let pattern = captures.get(2).map(|m| m.as_str()).unwrap_or("");

                let matching_count = if pattern.ends_with('*') {
                    let prefix = pattern.trim_end_matches('*');
                    matches.keys().filter(|k| k.starts_with(prefix)).count()
                } else {
                    if matches.contains_key(pattern) { 1 } else { 0 }
                };

                return match count_str {
                    "all" => matching_count > 0,
                    "any" => matching_count > 0,
                    n => n.parse::<usize>().map(|c| matching_count >= c).unwrap_or(false),
                };
            }
        }

        // Handle 'and' and 'or'
        if expr.contains(" and ") {
            return expr.split(" and ").all(|part| self.evaluate_expression(part.trim(), matches));
        }

        if expr.contains(" or ") {
            return expr.split(" or ").any(|part| self.evaluate_expression(part.trim(), matches));
        }

        // Handle 'not'
        if expr.starts_with("not ") {
            return !self.evaluate_expression(&expr[4..], matches);
        }

        // Default: treat as identifier
        matches.contains_key(expr)
    }

    /// Scan a file
    pub fn scan_file(&self, path: &str) -> Result<Vec<YaraMatch>, String> {
        let data = std::fs::read(path).map_err(|e| e.to_string())?;
        Ok(self.scan(&data))
    }

    /// Get number of loaded rules
    pub fn rules_count(&self) -> usize {
        self.compiled_rules.len()
    }

    /// Clear all loaded rules
    pub fn clear_rules(&mut self) {
        self.compiled_rules.clear();
    }
}

impl Default for YaraScanner {
    fn default() -> Self {
        Self::new()
    }
}

/// Built-in YARA rules for common malware patterns
pub fn get_builtin_rules() -> Vec<YaraRule> {
    vec![
        // Ransomware indicators
        YaraRule {
            id: "builtin_ransomware_extensions".to_string(),
            name: "Ransomware_Extension_List".to_string(),
            description: Some("Detects common ransomware file extensions".to_string()),
            author: Some("HeroForge".to_string()),
            reference: None,
            date: Some("2024-01-01".to_string()),
            version: 1,
            rule_content: r#"rule Ransomware_Extension_List {
    meta:
        description = "Detects ransomware extension patterns"
        severity = "high"
    strings:
        $ext1 = ".encrypted" nocase
        $ext2 = ".locked" nocase
        $ext3 = ".crypto" nocase
        $ext4 = ".crypt" nocase
        $ext5 = ".enc" nocase
        $ext6 = ".locky" nocase
        $ext7 = ".wcry" nocase
        $ext8 = ".wncry" nocase
        $ext9 = ".cerber" nocase
    condition:
        any of them
}"#.to_string(),
            category: YaraCategory::Ransomware,
            threat_type: Some(ThreatType::Ransomware),
            severity: YaraSeverity::High,
            tags: vec!["ransomware".to_string(), "encryption".to_string()],
            enabled: true,
            is_private: false,
            source: RuleSource::Custom,
            metadata: RuleMetadata::default(),
            performance: None,
            created_at: Utc::now(),
            updated_at: Utc::now(),
        },
        // RAT indicators
        YaraRule {
            id: "builtin_rat_strings".to_string(),
            name: "RAT_Common_Strings".to_string(),
            description: Some("Detects common RAT strings and patterns".to_string()),
            author: Some("HeroForge".to_string()),
            reference: None,
            date: Some("2024-01-01".to_string()),
            version: 1,
            rule_content: r#"rule RAT_Common_Strings {
    meta:
        description = "Common RAT indicators"
        severity = "high"
    strings:
        $rat1 = "keylogger" nocase
        $rat2 = "screenshot" nocase
        $rat3 = "webcam" nocase
        $rat4 = "microphone" nocase
        $rat5 = "clipboard" nocase
        $rat6 = "RemoteDesktop" nocase
        $rat7 = "shell32" nocase
        $cmd1 = "cmd.exe /c" nocase
        $cmd2 = "powershell -e" nocase
    condition:
        3 of them
}"#.to_string(),
            category: YaraCategory::Rat,
            threat_type: Some(ThreatType::Rat),
            severity: YaraSeverity::High,
            tags: vec!["rat".to_string(), "remote_access".to_string()],
            enabled: true,
            is_private: false,
            source: RuleSource::Custom,
            metadata: RuleMetadata::default(),
            performance: None,
            created_at: Utc::now(),
            updated_at: Utc::now(),
        },
        // Miner detection
        YaraRule {
            id: "builtin_miner_detection".to_string(),
            name: "Cryptocurrency_Miner".to_string(),
            description: Some("Detects cryptocurrency miner indicators".to_string()),
            author: Some("HeroForge".to_string()),
            reference: None,
            date: Some("2024-01-01".to_string()),
            version: 1,
            rule_content: r#"rule Cryptocurrency_Miner {
    meta:
        description = "Crypto miner detection"
        severity = "medium"
    strings:
        $pool1 = "stratum+tcp://" nocase
        $pool2 = "stratum+ssl://" nocase
        $pool3 = "pool.minergate" nocase
        $pool4 = "xmrpool" nocase
        $pool5 = "moneropool" nocase
        $algo1 = "cryptonight" nocase
        $algo2 = "randomx" nocase
        $wallet = /[14][a-km-zA-HJ-NP-Z1-9]{25,34}/
    condition:
        any of ($pool*) or any of ($algo*) or $wallet
}"#.to_string(),
            category: YaraCategory::Miner,
            threat_type: Some(ThreatType::Miner),
            severity: YaraSeverity::Medium,
            tags: vec!["miner".to_string(), "cryptocurrency".to_string()],
            enabled: true,
            is_private: false,
            source: RuleSource::Custom,
            metadata: RuleMetadata::default(),
            performance: None,
            created_at: Utc::now(),
            updated_at: Utc::now(),
        },
        // Webshell detection
        YaraRule {
            id: "builtin_webshell_php".to_string(),
            name: "Webshell_PHP".to_string(),
            description: Some("Detects PHP webshell patterns".to_string()),
            author: Some("HeroForge".to_string()),
            reference: None,
            date: Some("2024-01-01".to_string()),
            version: 1,
            rule_content: r#"rule Webshell_PHP {
    meta:
        description = "PHP webshell detection"
        severity = "critical"
    strings:
        $eval1 = "eval($_" nocase
        $eval2 = "eval(base64_decode" nocase
        $eval3 = "assert($_" nocase
        $shell1 = "shell_exec" nocase
        $shell2 = "passthru" nocase
        $shell3 = "system($_" nocase
        $shell4 = "exec($_" nocase
        $obf1 = "str_rot13" nocase
        $obf2 = "gzinflate" nocase
        $obf3 = "gzuncompress" nocase
    condition:
        any of ($eval*) or (any of ($shell*) and any of ($obf*))
}"#.to_string(),
            category: YaraCategory::Webshell,
            threat_type: Some(ThreatType::Backdoor),
            severity: YaraSeverity::Critical,
            tags: vec!["webshell".to_string(), "php".to_string()],
            enabled: true,
            is_private: false,
            source: RuleSource::Custom,
            metadata: RuleMetadata::default(),
            performance: None,
            created_at: Utc::now(),
            updated_at: Utc::now(),
        },
        // Packer detection
        YaraRule {
            id: "builtin_upx_packed".to_string(),
            name: "UPX_Packed".to_string(),
            description: Some("Detects UPX packed executables".to_string()),
            author: Some("HeroForge".to_string()),
            reference: None,
            date: Some("2024-01-01".to_string()),
            version: 1,
            rule_content: r#"rule UPX_Packed {
    meta:
        description = "UPX packer detection"
        severity = "low"
    strings:
        $upx1 = "UPX0"
        $upx2 = "UPX1"
        $upx3 = "UPX!"
        $sig = { 55 50 58 21 }
    condition:
        any of them
}"#.to_string(),
            category: YaraCategory::Packer,
            threat_type: None,
            severity: YaraSeverity::Low,
            tags: vec!["packer".to_string(), "upx".to_string()],
            enabled: true,
            is_private: false,
            source: RuleSource::Custom,
            metadata: RuleMetadata::default(),
            performance: None,
            created_at: Utc::now(),
            updated_at: Utc::now(),
        },
    ]
}
