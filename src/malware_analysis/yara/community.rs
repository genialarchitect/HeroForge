//! Community YARA Rule Sources
//!
//! Integration with community YARA rule repositories:
//! - YARA-Rules (GitHub)
//! - Malpedia
//! - Florian Roth's signature-base
//! - Elastic detection rules

use super::types::*;
use chrono::Utc;
use regex::Regex;

/// Community rule fetcher
pub struct CommunityRuleFetcher {
    http_client: reqwest::Client,
}

impl CommunityRuleFetcher {
    pub fn new() -> Self {
        Self {
            http_client: reqwest::Client::new(),
        }
    }

    /// Fetch rules from a community source
    pub async fn fetch_rules(&self, source: &CommunitySource) -> Result<Vec<YaraRule>, String> {
        match source.source_type {
            CommunitySourceType::GitHub => self.fetch_github_rules(&source.url).await,
            CommunitySourceType::GitLab => self.fetch_gitlab_rules(&source.url).await,
            CommunitySourceType::HttpUrl => self.fetch_http_rules(&source.url).await,
            CommunitySourceType::LocalDirectory => self.fetch_local_rules(&source.url),
            CommunitySourceType::MispFeed => self.fetch_misp_rules(&source.url).await,
        }
    }

    /// Fetch rules from GitHub repository
    async fn fetch_github_rules(&self, url: &str) -> Result<Vec<YaraRule>, String> {
        // Parse GitHub URL to get owner/repo
        let parts: Vec<&str> = url.trim_end_matches('/').split('/').collect();
        if parts.len() < 2 {
            return Err("Invalid GitHub URL".to_string());
        }

        let owner = parts[parts.len() - 2];
        let repo = parts[parts.len() - 1];

        // Use GitHub API to list files
        let api_url = format!(
            "https://api.github.com/repos/{}/{}/git/trees/main?recursive=1",
            owner, repo
        );

        let response = self.http_client
            .get(&api_url)
            .header("User-Agent", "HeroForge-YARA-Fetcher")
            .send()
            .await
            .map_err(|e| e.to_string())?;

        if !response.status().is_success() {
            return Err(format!("GitHub API error: {}", response.status()));
        }

        let tree: serde_json::Value = response.json().await.map_err(|e| e.to_string())?;

        // Find .yar and .yara files
        let mut rules = Vec::new();

        if let Some(files) = tree.get("tree").and_then(|t| t.as_array()) {
            for file in files {
                if let Some(path) = file.get("path").and_then(|p| p.as_str()) {
                    if path.ends_with(".yar") || path.ends_with(".yara") {
                        // Fetch the raw file
                        let raw_url = format!(
                            "https://raw.githubusercontent.com/{}/{}/main/{}",
                            owner, repo, path
                        );

                        if let Ok(content) = self.fetch_raw_content(&raw_url).await {
                            let parsed = self.parse_yara_file(&content, RuleSource::Community);
                            rules.extend(parsed);
                        }
                    }
                }
            }
        }

        Ok(rules)
    }

    /// Fetch rules from GitLab repository
    async fn fetch_gitlab_rules(&self, url: &str) -> Result<Vec<YaraRule>, String> {
        // Similar to GitHub but with GitLab API
        // For now, try direct HTTP fetch
        self.fetch_http_rules(url).await
    }

    /// Fetch rules from HTTP URL
    async fn fetch_http_rules(&self, url: &str) -> Result<Vec<YaraRule>, String> {
        let content = self.fetch_raw_content(url).await?;
        Ok(self.parse_yara_file(&content, RuleSource::Imported))
    }

    /// Fetch rules from local directory
    fn fetch_local_rules(&self, path: &str) -> Result<Vec<YaraRule>, String> {
        let mut rules = Vec::new();

        let dir = std::fs::read_dir(path).map_err(|e| e.to_string())?;

        for entry in dir.flatten() {
            let path = entry.path();
            if let Some(ext) = path.extension() {
                if ext == "yar" || ext == "yara" {
                    if let Ok(content) = std::fs::read_to_string(&path) {
                        let parsed = self.parse_yara_file(&content, RuleSource::Imported);
                        rules.extend(parsed);
                    }
                }
            }
        }

        Ok(rules)
    }

    /// Fetch rules from MISP feed
    async fn fetch_misp_rules(&self, url: &str) -> Result<Vec<YaraRule>, String> {
        let content = self.fetch_raw_content(url).await?;

        // Try to parse as JSON MISP event
        if let Ok(event) = serde_json::from_str::<serde_json::Value>(&content) {
            return self.parse_misp_event(&event);
        }

        // Otherwise treat as raw YARA file
        Ok(self.parse_yara_file(&content, RuleSource::MispFeed))
    }

    /// Fetch raw content from URL
    async fn fetch_raw_content(&self, url: &str) -> Result<String, String> {
        let response = self.http_client
            .get(url)
            .header("User-Agent", "HeroForge-YARA-Fetcher")
            .send()
            .await
            .map_err(|e| e.to_string())?;

        if !response.status().is_success() {
            return Err(format!("HTTP error: {}", response.status()));
        }

        response.text().await.map_err(|e| e.to_string())
    }

    /// Parse a YARA file content into rules
    pub fn parse_yara_file(&self, content: &str, source: RuleSource) -> Vec<YaraRule> {
        let mut rules = Vec::new();

        // Regex to match individual rules
        let rule_regex = Regex::new(
            r"(?s)(?:private\s+)?(?:global\s+)?rule\s+(\w+)(?:\s*:\s*[\w\s]+)?\s*\{(.*?)\}"
        ).unwrap();

        for cap in rule_regex.captures_iter(content) {
            let name = cap.get(1).map(|m| m.as_str()).unwrap_or("").to_string();
            let body = cap.get(2).map(|m| m.as_str()).unwrap_or("");
            let full_rule = cap.get(0).map(|m| m.as_str()).unwrap_or("");

            // Extract metadata
            let metadata = self.extract_metadata(body);

            // Determine category from tags or content
            let category = self.determine_category(&name, body, &metadata);

            // Determine severity
            let severity = self.determine_severity(&metadata);

            // Extract tags
            let tags = self.extract_tags(full_rule);

            rules.push(YaraRule {
                id: uuid::Uuid::new_v4().to_string(),
                name,
                description: metadata.description.clone(),
                author: metadata.author.clone(),
                reference: metadata.reference.clone(),
                date: metadata.date.clone(),
                version: 1,
                rule_content: full_rule.to_string(),
                category,
                threat_type: None,
                severity,
                tags,
                enabled: true,
                is_private: full_rule.starts_with("private"),
                source: source.clone(),
                metadata,
                performance: None,
                created_at: Utc::now(),
                updated_at: Utc::now(),
            });
        }

        rules
    }

    /// Extract metadata from rule body
    fn extract_metadata(&self, body: &str) -> RuleMetadata {
        let mut metadata = RuleMetadata::default();

        // Find meta section
        if let Some(meta_start) = body.find("meta:") {
            let meta_section = &body[meta_start..];
            let meta_end = meta_section.find("strings:").unwrap_or_else(||
                meta_section.find("condition:").unwrap_or(meta_section.len())
            );
            let meta_content = &meta_section[5..meta_end];

            // Parse key-value pairs
            for line in meta_content.lines() {
                let trimmed = line.trim();
                if let Some(eq_pos) = trimmed.find('=') {
                    let key = trimmed[..eq_pos].trim().to_lowercase();
                    let value = trimmed[eq_pos + 1..].trim().trim_matches('"').to_string();

                    match key.as_str() {
                        "description" | "desc" => metadata.description = Some(value),
                        "author" => metadata.author = Some(value),
                        "reference" | "ref" | "url" => metadata.reference = Some(value),
                        "date" => metadata.date = Some(value),
                        "version" | "ver" => metadata.version = Some(value),
                        "hash" | "md5" | "sha256" => metadata.hash = Some(value),
                        "tlp" => metadata.tlp = Some(value),
                        "malware" | "malware_family" | "family" => metadata.malware_family = Some(value),
                        "mitre" | "mitre_attack" | "attack" => {
                            metadata.mitre_attack.push(value);
                        }
                        _ => {
                            metadata.custom.insert(key, value);
                        }
                    }
                }
            }
        }

        metadata
    }

    /// Determine rule category from name and content
    fn determine_category(&self, name: &str, body: &str, metadata: &RuleMetadata) -> YaraCategory {
        let name_lower = name.to_lowercase();
        let body_lower = body.to_lowercase();

        // Check metadata hints
        if let Some(family) = &metadata.malware_family {
            let family_lower = family.to_lowercase();
            if family_lower.contains("ransomware") { return YaraCategory::Ransomware; }
            if family_lower.contains("rat") || family_lower.contains("remote") { return YaraCategory::Rat; }
            if family_lower.contains("miner") || family_lower.contains("coin") { return YaraCategory::Miner; }
        }

        // Check name patterns
        if name_lower.contains("ransomware") || name_lower.contains("ransom") {
            return YaraCategory::Ransomware;
        }
        if name_lower.contains("webshell") || name_lower.contains("shell") {
            return YaraCategory::Webshell;
        }
        if name_lower.contains("rat_") || name_lower.contains("_rat") || name_lower.contains("remote") {
            return YaraCategory::Rat;
        }
        if name_lower.contains("miner") || name_lower.contains("coin") || name_lower.contains("crypto") {
            return YaraCategory::Miner;
        }
        if name_lower.contains("apt") || name_lower.contains("apt_") {
            return YaraCategory::Apt;
        }
        if name_lower.contains("pack") || name_lower.contains("upx") || name_lower.contains("vmprotect") {
            return YaraCategory::Packer;
        }
        if name_lower.contains("exploit") || name_lower.contains("cve") {
            return YaraCategory::Exploit;
        }
        if name_lower.contains("backdoor") {
            return YaraCategory::Backdoor;
        }
        if name_lower.contains("dropper") {
            return YaraCategory::Dropper;
        }
        if name_lower.contains("loader") {
            return YaraCategory::Loader;
        }
        if name_lower.contains("stealer") || name_lower.contains("infostealer") {
            return YaraCategory::Stealer;
        }
        if name_lower.contains("keylog") {
            return YaraCategory::Keylogger;
        }
        if name_lower.contains("rootkit") {
            return YaraCategory::Rootkit;
        }
        if name_lower.contains("worm") {
            return YaraCategory::Worm;
        }
        if name_lower.contains("botnet") || name_lower.contains("bot_") {
            return YaraCategory::Botnet;
        }

        // Check body content
        if body_lower.contains("ransomware") || body_lower.contains("encrypt") && body_lower.contains("bitcoin") {
            return YaraCategory::Ransomware;
        }
        if body_lower.contains("c2") || body_lower.contains("command and control") {
            return YaraCategory::Rat;
        }

        YaraCategory::Malware
    }

    /// Determine severity from metadata
    fn determine_severity(&self, metadata: &RuleMetadata) -> YaraSeverity {
        // Check custom metadata for severity hints
        if let Some(sev) = metadata.custom.get("severity") {
            match sev.to_lowercase().as_str() {
                "critical" | "crit" => return YaraSeverity::Critical,
                "high" => return YaraSeverity::High,
                "medium" | "med" => return YaraSeverity::Medium,
                "low" => return YaraSeverity::Low,
                "info" | "informational" => return YaraSeverity::Info,
                _ => {}
            }
        }

        // Default to medium
        YaraSeverity::Medium
    }

    /// Extract tags from rule definition
    fn extract_tags(&self, rule_content: &str) -> Vec<String> {
        let mut tags = Vec::new();

        // Look for tags in rule header: rule name : tag1 tag2 {
        if let Some(captures) = Regex::new(r"rule\s+\w+\s*:\s*([\w\s]+)\s*\{")
            .ok()
            .and_then(|r| r.captures(rule_content))
        {
            if let Some(tag_str) = captures.get(1) {
                tags.extend(
                    tag_str.as_str()
                        .split_whitespace()
                        .map(|s| s.to_string())
                );
            }
        }

        tags
    }

    /// Parse MISP event for YARA rules
    fn parse_misp_event(&self, event: &serde_json::Value) -> Result<Vec<YaraRule>, String> {
        let mut rules = Vec::new();

        // Check for Event.Attribute array
        if let Some(attributes) = event.get("Event")
            .and_then(|e| e.get("Attribute"))
            .and_then(|a| a.as_array())
        {
            for attr in attributes {
                if let Some(type_str) = attr.get("type").and_then(|t| t.as_str()) {
                    if type_str == "yara" {
                        if let Some(value) = attr.get("value").and_then(|v| v.as_str()) {
                            let parsed = self.parse_yara_file(value, RuleSource::MispFeed);
                            rules.extend(parsed);
                        }
                    }
                }
            }
        }

        Ok(rules)
    }
}

impl Default for CommunityRuleFetcher {
    fn default() -> Self {
        Self::new()
    }
}

/// Get predefined community sources
pub fn get_default_community_sources() -> Vec<CommunitySource> {
    vec![
        CommunitySource {
            id: "yara-rules-github".to_string(),
            name: "YARA-Rules".to_string(),
            description: Some("Community YARA rules repository".to_string()),
            url: "https://github.com/Yara-Rules/rules".to_string(),
            source_type: CommunitySourceType::GitHub,
            enabled: true,
            auto_update: true,
            update_interval_hours: 24,
            last_updated_at: None,
            rules_count: 0,
        },
        CommunitySource {
            id: "signature-base".to_string(),
            name: "Signature Base".to_string(),
            description: Some("Florian Roth's YARA signature database".to_string()),
            url: "https://github.com/Neo23x0/signature-base".to_string(),
            source_type: CommunitySourceType::GitHub,
            enabled: true,
            auto_update: true,
            update_interval_hours: 24,
            last_updated_at: None,
            rules_count: 0,
        },
        CommunitySource {
            id: "elastic-detection".to_string(),
            name: "Elastic Detection Rules".to_string(),
            description: Some("Elastic's YARA rules for malware detection".to_string()),
            url: "https://github.com/elastic/protections-artifacts".to_string(),
            source_type: CommunitySourceType::GitHub,
            enabled: true,
            auto_update: true,
            update_interval_hours: 24,
            last_updated_at: None,
            rules_count: 0,
        },
        CommunitySource {
            id: "reversinglabs".to_string(),
            name: "ReversingLabs YARA".to_string(),
            description: Some("ReversingLabs community YARA rules".to_string()),
            url: "https://github.com/reversinglabs/reversinglabs-yara-rules".to_string(),
            source_type: CommunitySourceType::GitHub,
            enabled: false,
            auto_update: true,
            update_interval_hours: 24,
            last_updated_at: None,
            rules_count: 0,
        },
    ]
}

/// Import rules from a file content string
pub fn import_rules_from_content(
    content: &str,
    source: RuleSource,
    category_override: Option<YaraCategory>,
) -> RuleImportResult {
    let fetcher = CommunityRuleFetcher::new();
    let mut rules = fetcher.parse_yara_file(content, source);

    // Apply category override if specified
    if let Some(cat) = category_override {
        for rule in &mut rules {
            rule.category = cat.clone();
        }
    }

    RuleImportResult {
        total_rules: rules.len() as u32,
        imported: rules.len() as u32,
        skipped: 0,
        errors: Vec::new(),
        rules,
    }
}
