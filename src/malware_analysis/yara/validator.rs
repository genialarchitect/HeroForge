//! YARA Rule Validator
//!
//! Provides rule validation including:
//! - Syntax validation
//! - Performance analysis
//! - Best practice checking
//! - Complexity scoring

use super::types::*;
use regex::Regex;
use std::collections::HashSet;

/// YARA rule validator
pub struct RuleValidator {
    max_string_length: usize,
    max_strings_count: usize,
    warn_on_slow_patterns: bool,
}

impl RuleValidator {
    pub fn new() -> Self {
        Self {
            max_string_length: 10000,
            max_strings_count: 100,
            warn_on_slow_patterns: true,
        }
    }

    /// Validate a YARA rule
    pub fn validate(&self, rule_content: &str) -> ValidationResult {
        let mut errors = Vec::new();
        let mut warnings = Vec::new();
        let mut suggestions = Vec::new();

        // Parse and validate structure
        self.validate_structure(rule_content, &mut errors, &mut warnings);

        // Validate strings section
        self.validate_strings(rule_content, &mut errors, &mut warnings);

        // Validate condition
        self.validate_condition(rule_content, &mut errors, &mut warnings);

        // Check best practices
        self.check_best_practices(rule_content, &mut warnings, &mut suggestions);

        // Calculate complexity
        let complexity_score = self.calculate_complexity(rule_content);

        // Estimate performance
        let estimated_performance = self.estimate_performance(rule_content, complexity_score);

        ValidationResult {
            is_valid: errors.is_empty(),
            errors,
            warnings,
            suggestions,
            complexity_score,
            estimated_performance,
        }
    }

    /// Validate rule structure
    fn validate_structure(
        &self,
        content: &str,
        errors: &mut Vec<ValidationError>,
        _warnings: &mut Vec<ValidationWarning>,
    ) {
        // Check for rule keyword
        if !content.contains("rule ") {
            errors.push(ValidationError {
                line: Some(1),
                column: None,
                message: "Missing 'rule' keyword".to_string(),
                error_type: ValidationErrorType::SyntaxError,
            });
            return;
        }

        // Check for opening and closing braces
        let open_braces = content.matches('{').count();
        let close_braces = content.matches('}').count();

        if open_braces != close_braces {
            errors.push(ValidationError {
                line: None,
                column: None,
                message: format!("Mismatched braces: {} open, {} close", open_braces, close_braces),
                error_type: ValidationErrorType::SyntaxError,
            });
        }

        // Check for condition section
        if !content.contains("condition:") {
            errors.push(ValidationError {
                line: None,
                column: None,
                message: "Missing 'condition:' section".to_string(),
                error_type: ValidationErrorType::SyntaxError,
            });
        }

        // Validate rule name
        if let Some(captures) = Regex::new(r"rule\s+(\w+)").ok().and_then(|r| r.captures(content)) {
            let name = captures.get(1).map(|m| m.as_str()).unwrap_or("");
            if name.is_empty() {
                errors.push(ValidationError {
                    line: Some(1),
                    column: None,
                    message: "Invalid or missing rule name".to_string(),
                    error_type: ValidationErrorType::SyntaxError,
                });
            } else if !name.chars().next().map(|c| c.is_alphabetic() || c == '_').unwrap_or(false) {
                errors.push(ValidationError {
                    line: Some(1),
                    column: None,
                    message: "Rule name must start with a letter or underscore".to_string(),
                    error_type: ValidationErrorType::SyntaxError,
                });
            }
        }
    }

    /// Validate strings section
    fn validate_strings(
        &self,
        content: &str,
        errors: &mut Vec<ValidationError>,
        warnings: &mut Vec<ValidationWarning>,
    ) {
        let mut defined_strings = HashSet::new();
        let mut line_num = 0;

        for line in content.lines() {
            line_num += 1;
            let trimmed = line.trim();

            if trimmed.starts_with('$') && trimmed.contains('=') {
                // Parse string definition
                let parts: Vec<&str> = trimmed.splitn(2, '=').collect();
                if parts.len() == 2 {
                    let identifier = parts[0].trim();
                    let value = parts[1].trim();

                    // Check for duplicate identifiers
                    if defined_strings.contains(identifier) {
                        errors.push(ValidationError {
                            line: Some(line_num),
                            column: None,
                            message: format!("Duplicate string identifier: {}", identifier),
                            error_type: ValidationErrorType::DuplicateIdentifier,
                        });
                    }
                    defined_strings.insert(identifier.to_string());

                    // Validate string value
                    self.validate_string_value(value, line_num, errors, warnings);
                }
            }
        }

        // Check string count
        if defined_strings.len() > self.max_strings_count {
            warnings.push(ValidationWarning {
                line: None,
                message: format!(
                    "Rule has {} strings, which may impact performance (recommended: < {})",
                    defined_strings.len(),
                    self.max_strings_count
                ),
                warning_type: ValidationWarningType::Performance,
            });
        }
    }

    /// Validate a string value
    fn validate_string_value(
        &self,
        value: &str,
        line: u32,
        errors: &mut Vec<ValidationError>,
        warnings: &mut Vec<ValidationWarning>,
    ) {
        if value.starts_with('"') {
            // Text string
            if !value.contains('"') || value.matches('"').count() < 2 {
                errors.push(ValidationError {
                    line: Some(line),
                    column: None,
                    message: "Unclosed string literal".to_string(),
                    error_type: ValidationErrorType::SyntaxError,
                });
            }

            // Check for short strings that may cause false positives
            if let Some(end) = value[1..].find('"') {
                let string_content = &value[1..end + 1];
                if string_content.len() < 4 {
                    warnings.push(ValidationWarning {
                        line: Some(line),
                        message: format!(
                            "Very short string '{}' may cause false positives",
                            string_content
                        ),
                        warning_type: ValidationWarningType::Specificity,
                    });
                }
            }
        } else if value.starts_with('{') {
            // Hex string
            if !value.ends_with('}') && !value.contains('}') {
                errors.push(ValidationError {
                    line: Some(line),
                    column: None,
                    message: "Unclosed hex string".to_string(),
                    error_type: ValidationErrorType::InvalidHex,
                });
            } else {
                // Validate hex content
                self.validate_hex_string(value, line, errors);
            }
        } else if value.starts_with('/') {
            // Regex
            self.validate_regex_string(value, line, errors, warnings);
        }
    }

    /// Validate hex string content
    fn validate_hex_string(&self, value: &str, line: u32, errors: &mut Vec<ValidationError>) {
        let inner = value.trim_start_matches('{').trim_end_matches('}').trim();

        for token in inner.split_whitespace() {
            if token == "??" {
                continue;
            }
            if token.starts_with('[') && token.ends_with(']') {
                // Jump pattern
                let inner_jump = token.trim_start_matches('[').trim_end_matches(']');
                if inner_jump.contains('-') {
                    let parts: Vec<&str> = inner_jump.split('-').collect();
                    if parts.len() != 2 {
                        errors.push(ValidationError {
                            line: Some(line),
                            column: None,
                            message: format!("Invalid jump syntax: {}", token),
                            error_type: ValidationErrorType::InvalidHex,
                        });
                    }
                }
                continue;
            }
            if token.starts_with('(') && token.ends_with(')') {
                // Alternative pattern
                continue;
            }

            // Regular hex byte
            if token.len() == 2 {
                if u8::from_str_radix(token, 16).is_err() && token != "??" {
                    errors.push(ValidationError {
                        line: Some(line),
                        column: None,
                        message: format!("Invalid hex byte: {}", token),
                        error_type: ValidationErrorType::InvalidHex,
                    });
                }
            } else if !token.contains('?') {
                errors.push(ValidationError {
                    line: Some(line),
                    column: None,
                    message: format!("Invalid hex token: {}", token),
                    error_type: ValidationErrorType::InvalidHex,
                });
            }
        }
    }

    /// Validate regex string
    fn validate_regex_string(
        &self,
        value: &str,
        line: u32,
        errors: &mut Vec<ValidationError>,
        warnings: &mut Vec<ValidationWarning>,
    ) {
        // Find the closing /
        if let Some(end_pos) = value[1..].find('/') {
            let pattern = &value[1..end_pos + 1];

            // Try to compile the regex
            if let Err(e) = Regex::new(pattern) {
                errors.push(ValidationError {
                    line: Some(line),
                    column: None,
                    message: format!("Invalid regex: {}", e),
                    error_type: ValidationErrorType::InvalidRegex,
                });
            }

            // Warn about potentially slow patterns
            if self.warn_on_slow_patterns {
                if pattern.contains(".*.*") {
                    warnings.push(ValidationWarning {
                        line: Some(line),
                        message: "Nested wildcards (.*.*) can be slow".to_string(),
                        warning_type: ValidationWarningType::Performance,
                    });
                }
                if pattern.starts_with(".*") || pattern.starts_with(".+") {
                    warnings.push(ValidationWarning {
                        line: Some(line),
                        message: "Leading wildcards (.* or .+) can be slow".to_string(),
                        warning_type: ValidationWarningType::Performance,
                    });
                }
            }
        } else {
            errors.push(ValidationError {
                line: Some(line),
                column: None,
                message: "Unclosed regex pattern".to_string(),
                error_type: ValidationErrorType::InvalidRegex,
            });
        }
    }

    /// Validate condition section
    fn validate_condition(
        &self,
        content: &str,
        errors: &mut Vec<ValidationError>,
        _warnings: &mut Vec<ValidationWarning>,
    ) {
        // Extract condition
        if let Some(cond_start) = content.find("condition:") {
            let condition_section = &content[cond_start + 10..];
            let condition = if let Some(end) = condition_section.find('}') {
                condition_section[..end].trim()
            } else {
                condition_section.trim()
            };

            if condition.is_empty() {
                errors.push(ValidationError {
                    line: None,
                    column: None,
                    message: "Empty condition".to_string(),
                    error_type: ValidationErrorType::InvalidCondition,
                });
                return;
            }

            // Check parentheses balance
            let open_parens = condition.matches('(').count();
            let close_parens = condition.matches(')').count();
            if open_parens != close_parens {
                errors.push(ValidationError {
                    line: None,
                    column: None,
                    message: format!(
                        "Unbalanced parentheses in condition: {} open, {} close",
                        open_parens, close_parens
                    ),
                    error_type: ValidationErrorType::InvalidCondition,
                });
            }

            // Collect defined string identifiers
            let defined_strings: HashSet<String> = content
                .lines()
                .filter(|l| l.trim().starts_with('$') && l.contains('='))
                .map(|l| l.trim().split('=').next().unwrap_or("").trim().to_string())
                .collect();

            // Check for undefined string references in condition
            let ident_regex = Regex::new(r"\$\w+").unwrap();
            for cap in ident_regex.captures_iter(condition) {
                let ident = cap.get(0).unwrap().as_str();
                if !defined_strings.contains(ident) {
                    // Check if it's a wildcard reference
                    if !ident.ends_with('*') && !condition.contains(&format!("{}*", ident.trim_end_matches(char::is_numeric))) {
                        errors.push(ValidationError {
                            line: None,
                            column: None,
                            message: format!("Undefined string identifier: {}", ident),
                            error_type: ValidationErrorType::UndefinedIdentifier,
                        });
                    }
                }
            }
        }
    }

    /// Check best practices
    fn check_best_practices(
        &self,
        content: &str,
        warnings: &mut Vec<ValidationWarning>,
        suggestions: &mut Vec<String>,
    ) {
        // Check for meta section
        if !content.contains("meta:") {
            suggestions.push("Consider adding a 'meta:' section with description and author".to_string());
        }

        // Check for description
        if content.contains("meta:") && !content.to_lowercase().contains("description") {
            suggestions.push("Consider adding a 'description' in the meta section".to_string());
        }

        // Check for very generic conditions
        if content.contains("condition:") {
            let cond_lower = content.to_lowercase();
            if cond_lower.contains("any of them") && !content.contains("and") && !content.contains("filesize") {
                warnings.push(ValidationWarning {
                    line: None,
                    message: "'any of them' without additional constraints may cause false positives".to_string(),
                    warning_type: ValidationWarningType::Specificity,
                });
            }
        }

        // Suggest using filesize constraint for performance
        if !content.contains("filesize") {
            suggestions.push("Consider adding 'filesize' constraints to improve performance".to_string());
        }
    }

    /// Calculate rule complexity score
    fn calculate_complexity(&self, content: &str) -> u32 {
        let mut score: u32 = 0;

        // Count strings
        let string_count = content.lines().filter(|l| l.trim().starts_with('$')).count() as u32;
        score += string_count * 5;

        // Count regex patterns
        let regex_count = content.matches("= /").count() as u32;
        score += regex_count * 15;

        // Count hex patterns
        let hex_count = content.matches("= {").count() as u32;
        score += hex_count * 10;

        // Check condition complexity
        if content.contains(" and ") {
            score += content.matches(" and ").count() as u32 * 5;
        }
        if content.contains(" or ") {
            score += content.matches(" or ").count() as u32 * 3;
        }
        if content.contains("for ") {
            score += 20; // Loop constructs
        }

        score.min(100)
    }

    /// Estimate performance characteristics
    fn estimate_performance(&self, content: &str, complexity: u32) -> PerformanceEstimate {
        let string_count = content.lines().filter(|l| l.trim().starts_with('$')).count();
        let regex_count = content.matches("= /").count();
        let has_wildcards = content.contains(".*") || content.contains(".+");

        let rating = if complexity < 20 && regex_count == 0 {
            PerformanceRating::Excellent
        } else if complexity < 40 && regex_count <= 2 && !has_wildcards {
            PerformanceRating::Good
        } else if complexity < 60 {
            PerformanceRating::Average
        } else if complexity < 80 {
            PerformanceRating::Poor
        } else {
            PerformanceRating::Critical
        };

        let estimated_time = (string_count as f64 * 0.5) + (regex_count as f64 * 5.0) + (complexity as f64 * 0.1);

        let memory_impact = if string_count > 50 || regex_count > 10 {
            MemoryImpact::High
        } else if string_count > 20 || regex_count > 5 {
            MemoryImpact::Medium
        } else {
            MemoryImpact::Low
        };

        let mut notes = Vec::new();
        if regex_count > 5 {
            notes.push("High regex count may impact scanning speed".to_string());
        }
        if has_wildcards {
            notes.push("Wildcards in regex patterns can be slow".to_string());
        }

        PerformanceEstimate {
            rating,
            estimated_time_ms: estimated_time,
            memory_impact,
            notes,
        }
    }
}

impl Default for RuleValidator {
    fn default() -> Self {
        Self::new()
    }
}

/// Build YARA rule content from builder spec
pub fn build_rule_from_spec(spec: &RuleBuilderSpec) -> String {
    let mut rule = format!("rule {} {{\n", spec.name);

    // Meta section
    if !spec.metadata.is_empty() || spec.description.is_some() {
        rule.push_str("    meta:\n");
        if let Some(desc) = &spec.description {
            rule.push_str(&format!("        description = \"{}\"\n", desc.replace('"', "\\\"")));
        }
        for entry in &spec.metadata {
            rule.push_str(&format!("        {} = \"{}\"\n", entry.key, entry.value.replace('"', "\\\"")));
        }
    }

    // Strings section
    if !spec.strings.is_empty() {
        rule.push_str("    strings:\n");
        for string_def in &spec.strings {
            let value = match string_def.string_type {
                StringType::Text => format!("\"{}\"", string_def.value.replace('"', "\\\"")),
                StringType::Hex => format!("{{ {} }}", string_def.value),
                StringType::Regex => format!("/{}/", string_def.value),
            };

            let mut modifiers = Vec::new();
            if string_def.modifiers.nocase { modifiers.push("nocase"); }
            if string_def.modifiers.wide { modifiers.push("wide"); }
            if string_def.modifiers.ascii { modifiers.push("ascii"); }
            if string_def.modifiers.fullword { modifiers.push("fullword"); }
            if string_def.modifiers.xor { modifiers.push("xor"); }
            if string_def.modifiers.base64 { modifiers.push("base64"); }

            let modifier_str = if modifiers.is_empty() {
                String::new()
            } else {
                format!(" {}", modifiers.join(" "))
            };

            rule.push_str(&format!("        {} = {}{}\n", string_def.identifier, value, modifier_str));
        }
    }

    // Condition section
    rule.push_str("    condition:\n");
    let condition_str = build_condition_string(&spec.condition);
    rule.push_str(&format!("        {}\n", condition_str));

    rule.push_str("}\n");
    rule
}

/// Build condition string from builder
fn build_condition_string(condition: &ConditionBuilder) -> String {
    match condition.condition_type {
        ConditionType::All => "all of them".to_string(),
        ConditionType::Any => "any of them".to_string(),
        ConditionType::None => "none of them".to_string(),
        ConditionType::Count => {
            if let Some(ConditionOperand::CountOf { prefix, count }) = condition.operands.first() {
                format!("{} of ({}*)", count, prefix)
            } else {
                "any of them".to_string()
            }
        }
        ConditionType::And => {
            let parts: Vec<String> = condition.operands.iter().map(operand_to_string).collect();
            parts.join(" and ")
        }
        ConditionType::Or => {
            let parts: Vec<String> = condition.operands.iter().map(operand_to_string).collect();
            parts.join(" or ")
        }
        ConditionType::Not => {
            if let Some(operand) = condition.operands.first() {
                format!("not {}", operand_to_string(operand))
            } else {
                "false".to_string()
            }
        }
        ConditionType::Custom => {
            if let Some(ConditionOperand::Raw { expression }) = condition.operands.first() {
                expression.clone()
            } else {
                "true".to_string()
            }
        }
        _ => "any of them".to_string(),
    }
}

/// Convert operand to string
fn operand_to_string(operand: &ConditionOperand) -> String {
    match operand {
        ConditionOperand::StringRef { identifier } => identifier.clone(),
        ConditionOperand::AllOf { prefix } => format!("all of ({}*)", prefix),
        ConditionOperand::AnyOf { prefix } => format!("any of ({}*)", prefix),
        ConditionOperand::CountOf { prefix, count } => format!("{} of ({}*)", count, prefix),
        ConditionOperand::FileSize { operator, size } => format!("filesize {} {}", operator, size),
        ConditionOperand::EntryPoint => "entrypoint".to_string(),
        ConditionOperand::Nested { condition } => format!("({})", build_condition_string(condition)),
        ConditionOperand::Raw { expression } => expression.clone(),
    }
}
