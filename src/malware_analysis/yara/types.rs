//! YARA Rule Management Types
//!
//! Comprehensive types for YARA rule management including:
//! - Rule definitions and metadata
//! - Visual builder components
//! - Rule testing and validation
//! - Performance metrics
//! - Community rule integration

use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

/// YARA rule with full metadata
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct YaraRule {
    pub id: String,
    pub name: String,
    pub description: Option<String>,
    pub author: Option<String>,
    pub reference: Option<String>,
    pub date: Option<String>,
    pub version: u32,
    pub rule_content: String,
    pub category: YaraCategory,
    pub threat_type: Option<ThreatType>,
    pub severity: YaraSeverity,
    pub tags: Vec<String>,
    pub enabled: bool,
    pub is_private: bool,
    pub source: RuleSource,
    pub metadata: RuleMetadata,
    pub performance: Option<RulePerformance>,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

/// YARA rule category
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum YaraCategory {
    Malware,
    Packer,
    Webshell,
    Exploit,
    Cve,
    Apt,
    Ransomware,
    Miner,
    Rat,
    Backdoor,
    Dropper,
    Loader,
    Stealer,
    Keylogger,
    Rootkit,
    Worm,
    Botnet,
    Generic,
    Custom,
}

impl std::fmt::Display for YaraCategory {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            YaraCategory::Malware => write!(f, "malware"),
            YaraCategory::Packer => write!(f, "packer"),
            YaraCategory::Webshell => write!(f, "webshell"),
            YaraCategory::Exploit => write!(f, "exploit"),
            YaraCategory::Cve => write!(f, "cve"),
            YaraCategory::Apt => write!(f, "apt"),
            YaraCategory::Ransomware => write!(f, "ransomware"),
            YaraCategory::Miner => write!(f, "miner"),
            YaraCategory::Rat => write!(f, "rat"),
            YaraCategory::Backdoor => write!(f, "backdoor"),
            YaraCategory::Dropper => write!(f, "dropper"),
            YaraCategory::Loader => write!(f, "loader"),
            YaraCategory::Stealer => write!(f, "stealer"),
            YaraCategory::Keylogger => write!(f, "keylogger"),
            YaraCategory::Rootkit => write!(f, "rootkit"),
            YaraCategory::Worm => write!(f, "worm"),
            YaraCategory::Botnet => write!(f, "botnet"),
            YaraCategory::Generic => write!(f, "generic"),
            YaraCategory::Custom => write!(f, "custom"),
        }
    }
}

/// Threat type classification
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum ThreatType {
    Trojan,
    Ransomware,
    Spyware,
    Adware,
    Worm,
    Virus,
    Rootkit,
    Backdoor,
    Rat,
    Miner,
    Botnet,
    Dropper,
    Downloader,
    Exploit,
    Hacktool,
    Pup,
    Other,
}

/// Rule severity level
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, PartialOrd, Ord)]
#[serde(rename_all = "snake_case")]
pub enum YaraSeverity {
    Info,
    Low,
    Medium,
    High,
    Critical,
}

/// Rule source
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum RuleSource {
    Custom,
    Community,
    YaraRules,
    Malpedia,
    VirusTotal,
    Elastic,
    Florian,
    Signature,
    Imported,
    MispFeed,
}

impl std::fmt::Display for RuleSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            RuleSource::Custom => write!(f, "custom"),
            RuleSource::Community => write!(f, "community"),
            RuleSource::YaraRules => write!(f, "yara-rules"),
            RuleSource::Malpedia => write!(f, "malpedia"),
            RuleSource::VirusTotal => write!(f, "virustotal"),
            RuleSource::Elastic => write!(f, "elastic"),
            RuleSource::Florian => write!(f, "florian"),
            RuleSource::Signature => write!(f, "signature"),
            RuleSource::Imported => write!(f, "imported"),
            RuleSource::MispFeed => write!(f, "misp-feed"),
        }
    }
}

/// Rule metadata from YARA file
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct RuleMetadata {
    pub hash: Option<String>,
    pub date: Option<String>,
    pub version: Option<String>,
    pub author: Option<String>,
    pub reference: Option<String>,
    pub description: Option<String>,
    pub tlp: Option<String>,
    pub malware_family: Option<String>,
    pub mitre_attack: Vec<String>,
    pub custom: HashMap<String, String>,
}

/// Rule performance metrics
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RulePerformance {
    pub avg_scan_time_ms: f64,
    pub max_scan_time_ms: f64,
    pub min_scan_time_ms: f64,
    pub total_scans: u64,
    pub total_matches: u64,
    pub false_positives: u64,
    pub true_positives: u64,
    pub effectiveness_score: f64,
    pub last_measured_at: DateTime<Utc>,
}

/// Rule match result
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct YaraMatch {
    pub id: String,
    pub rule_id: String,
    pub rule_name: String,
    pub sample_id: Option<String>,
    pub file_path: Option<String>,
    pub file_hash: Option<String>,
    pub matched_strings: Vec<MatchedString>,
    pub tags: Vec<String>,
    pub metadata: HashMap<String, String>,
    pub scan_type: ScanType,
    pub scan_time_ms: u64,
    pub is_false_positive: bool,
    pub matched_at: DateTime<Utc>,
}

/// Matched string details
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MatchedString {
    pub identifier: String,
    pub offset: u64,
    pub length: usize,
    pub data: String,
    pub is_xor: bool,
    pub xor_key: Option<u8>,
}

/// Scan type
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum ScanType {
    File,
    Memory,
    Process,
    Network,
    Bulk,
}

/// Visual rule builder components
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RuleBuilderSpec {
    pub name: String,
    pub description: Option<String>,
    pub tags: Vec<String>,
    pub metadata: Vec<MetadataEntry>,
    pub strings: Vec<StringDefinition>,
    pub condition: ConditionBuilder,
}

/// Metadata entry for builder
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MetadataEntry {
    pub key: String,
    pub value: String,
}

/// String definition for visual builder
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StringDefinition {
    pub identifier: String,
    pub string_type: StringType,
    pub value: String,
    pub modifiers: StringModifiers,
}

/// String type
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum StringType {
    Text,
    Hex,
    Regex,
}

/// String modifiers
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct StringModifiers {
    pub nocase: bool,
    pub wide: bool,
    pub ascii: bool,
    pub xor: bool,
    pub xor_min: Option<u8>,
    pub xor_max: Option<u8>,
    pub base64: bool,
    pub base64wide: bool,
    pub fullword: bool,
    pub private: bool,
}

/// Condition builder for visual editor
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ConditionBuilder {
    pub condition_type: ConditionType,
    pub operands: Vec<ConditionOperand>,
}

/// Condition type
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum ConditionType {
    All,
    Any,
    None,
    Count,
    AtOffset,
    InRange,
    Custom,
    And,
    Or,
    Not,
}

/// Condition operand
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum ConditionOperand {
    StringRef { identifier: String },
    AllOf { prefix: String },
    AnyOf { prefix: String },
    CountOf { prefix: String, count: u32 },
    FileSize { operator: String, size: u64 },
    EntryPoint,
    Nested { condition: Box<ConditionBuilder> },
    Raw { expression: String },
}

/// Rule validation result
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ValidationResult {
    pub is_valid: bool,
    pub errors: Vec<ValidationError>,
    pub warnings: Vec<ValidationWarning>,
    pub suggestions: Vec<String>,
    pub complexity_score: u32,
    pub estimated_performance: PerformanceEstimate,
}

/// Validation error
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ValidationError {
    pub line: Option<u32>,
    pub column: Option<u32>,
    pub message: String,
    pub error_type: ValidationErrorType,
}

/// Validation error type
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum ValidationErrorType {
    SyntaxError,
    UndefinedIdentifier,
    DuplicateIdentifier,
    InvalidModifier,
    InvalidCondition,
    InvalidRegex,
    InvalidHex,
    Other,
}

/// Validation warning
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ValidationWarning {
    pub line: Option<u32>,
    pub message: String,
    pub warning_type: ValidationWarningType,
}

/// Warning type
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum ValidationWarningType {
    Performance,
    Specificity,
    Deprecated,
    BestPractice,
}

/// Performance estimate
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PerformanceEstimate {
    pub rating: PerformanceRating,
    pub estimated_time_ms: f64,
    pub memory_impact: MemoryImpact,
    pub notes: Vec<String>,
}

/// Performance rating
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum PerformanceRating {
    Excellent,
    Good,
    Average,
    Poor,
    Critical,
}

/// Memory impact
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum MemoryImpact {
    Low,
    Medium,
    High,
}

/// Rule version for history tracking
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RuleVersion {
    pub id: String,
    pub rule_id: String,
    pub version: u32,
    pub rule_content: String,
    pub change_summary: Option<String>,
    pub changed_by: String,
    pub created_at: DateTime<Utc>,
}

/// Community rule source
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CommunitySource {
    pub id: String,
    pub name: String,
    pub description: Option<String>,
    pub url: String,
    pub source_type: CommunitySourceType,
    pub enabled: bool,
    pub auto_update: bool,
    pub update_interval_hours: u32,
    pub last_updated_at: Option<DateTime<Utc>>,
    pub rules_count: u32,
}

/// Community source type
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum CommunitySourceType {
    GitHub,
    GitLab,
    LocalDirectory,
    HttpUrl,
    MispFeed,
}

/// Bulk scan job
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BulkScanJob {
    pub id: String,
    pub user_id: String,
    pub name: String,
    pub description: Option<String>,
    pub rule_ids: Vec<String>,
    pub target_type: BulkScanTarget,
    pub target_ids: Vec<String>,
    pub status: BulkScanStatus,
    pub total_files: u32,
    pub scanned_files: u32,
    pub matches_found: u32,
    pub errors: u32,
    pub started_at: Option<DateTime<Utc>>,
    pub completed_at: Option<DateTime<Utc>>,
    pub created_at: DateTime<Utc>,
}

/// Bulk scan target type
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum BulkScanTarget {
    MalwareSamples,
    BinarySamples,
    Directory,
    PcapFiles,
}

/// Bulk scan status
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum BulkScanStatus {
    Pending,
    Running,
    Completed,
    Failed,
    Cancelled,
}

/// Rule test request
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RuleTestRequest {
    pub rule_content: String,
    pub test_type: RuleTestType,
    pub sample_ids: Option<Vec<String>>,
    pub test_data: Option<String>,
}

/// Rule test type
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum RuleTestType {
    Syntax,
    Sample,
    Data,
    Performance,
}

/// Rule test result
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RuleTestResult {
    pub is_valid: bool,
    pub syntax_errors: Vec<String>,
    pub matches: Vec<TestMatch>,
    pub scan_time_ms: u64,
    pub performance_notes: Vec<String>,
}

/// Test match
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TestMatch {
    pub sample_id: Option<String>,
    pub file_name: Option<String>,
    pub matched_strings: Vec<String>,
}

/// YARA rule import request
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RuleImportRequest {
    pub content: String,
    pub source: RuleSource,
    pub category: Option<YaraCategory>,
    pub overwrite_existing: bool,
}

/// YARA rule import result
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RuleImportResult {
    pub total_rules: u32,
    pub imported: u32,
    pub skipped: u32,
    pub errors: Vec<ImportError>,
    pub rules: Vec<YaraRule>,
}

/// Import error
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ImportError {
    pub rule_name: Option<String>,
    pub line: Option<u32>,
    pub message: String,
}

/// Rule statistics
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RuleStatistics {
    pub total_rules: u64,
    pub enabled_rules: u64,
    pub disabled_rules: u64,
    pub by_category: HashMap<String, u64>,
    pub by_source: HashMap<String, u64>,
    pub by_severity: HashMap<String, u64>,
    pub total_matches: u64,
    pub avg_effectiveness: f64,
    pub top_performing_rules: Vec<RulePerformanceSummary>,
    pub rules_needing_review: Vec<String>,
}

/// Rule performance summary
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RulePerformanceSummary {
    pub rule_id: String,
    pub rule_name: String,
    pub matches: u64,
    pub effectiveness: f64,
}
