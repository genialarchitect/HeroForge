//! Local Malware Sandboxing Module
//!
//! Provides local sandboxing capabilities for malware analysis using:
//! - Docker containers for isolated execution
//! - Process monitoring and behavior analysis
//! - Network traffic capture
//! - File system monitoring
//! - API call hooking (via external tools)
//!
//! **Security Warning**: This module executes potentially malicious code.
//! Only use in isolated environments with proper security controls.

use anyhow::{anyhow, Result};
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::path::{Path, PathBuf};
use std::process::Command;
use uuid::Uuid;

// =============================================================================
// Sandbox Configuration
// =============================================================================

/// Local sandbox configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LocalSandboxConfig {
    pub sandbox_type: LocalSandboxType,
    pub network_mode: SandboxNetworkMode,
    pub execution_timeout_secs: u64,
    pub memory_limit_mb: u64,
    pub cpu_limit: f64,
    pub capture_network: bool,
    pub capture_filesystem: bool,
    pub capture_registry: bool,
    pub capture_api_calls: bool,
    pub enable_screenshots: bool,
    pub snapshot_interval_secs: u64,
    pub working_directory: PathBuf,
    pub docker_image: Option<String>,
}

impl Default for LocalSandboxConfig {
    fn default() -> Self {
        Self {
            sandbox_type: LocalSandboxType::Docker,
            network_mode: SandboxNetworkMode::Isolated,
            execution_timeout_secs: 120,
            memory_limit_mb: 2048,
            cpu_limit: 1.0,
            capture_network: true,
            capture_filesystem: true,
            capture_registry: true,
            capture_api_calls: true,
            enable_screenshots: true,
            snapshot_interval_secs: 5,
            working_directory: PathBuf::from("/tmp/sandbox"),
            docker_image: Some("heroforge/sandbox:latest".to_string()),
        }
    }
}

/// Type of local sandbox
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "lowercase")]
pub enum LocalSandboxType {
    Docker,
    Qemu,
    Firecracker,
    NsJail,
    Bubblewrap,
}

/// Network mode for sandbox
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "lowercase")]
pub enum SandboxNetworkMode {
    Isolated,
    NAT,
    INetSim,
    Custom(String),
}

// =============================================================================
// Sample Management
// =============================================================================

/// Malware sample information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MalwareSample {
    pub id: String,
    pub filename: String,
    pub file_path: PathBuf,
    pub file_size: u64,
    pub file_type: String,
    pub mime_type: String,
    pub hashes: SampleHashes,
    pub submission_time: DateTime<Utc>,
    pub source: String,
    pub tags: Vec<String>,
    pub metadata: HashMap<String, String>,
}

/// Hash values for a sample
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SampleHashes {
    pub md5: String,
    pub sha1: String,
    pub sha256: String,
    pub ssdeep: Option<String>,
    pub imphash: Option<String>,
}

// =============================================================================
// Execution Results
// =============================================================================

/// Result of sandbox execution
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SandboxExecutionResult {
    pub id: String,
    pub sample_id: String,
    pub status: ExecutionStatus,
    pub started_at: DateTime<Utc>,
    pub completed_at: Option<DateTime<Utc>>,
    pub duration_secs: u64,
    pub exit_code: Option<i32>,
    pub process_tree: Vec<ProcessInfo>,
    pub network_activity: NetworkActivity,
    pub filesystem_activity: FilesystemActivity,
    pub registry_activity: RegistryActivity,
    pub api_calls: Vec<ApiCall>,
    pub dropped_files: Vec<DroppedFile>,
    pub screenshots: Vec<Screenshot>,
    pub behavior_signatures: Vec<BehaviorSignature>,
    pub iocs: Vec<ExtractedIoc>,
    pub verdict: SandboxVerdict,
    pub confidence: f64,
    pub error_message: Option<String>,
}

/// Execution status
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "lowercase")]
pub enum ExecutionStatus {
    Queued,
    Running,
    Completed,
    Failed,
    Timeout,
    Crashed,
}

/// Final verdict
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "lowercase")]
pub enum SandboxVerdict {
    Malicious,
    Suspicious,
    Clean,
    Unknown,
}

// =============================================================================
// Behavior Analysis Types
// =============================================================================

/// Process information from execution
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProcessInfo {
    pub pid: u32,
    pub ppid: u32,
    pub name: String,
    pub command_line: String,
    pub image_path: String,
    pub started_at: DateTime<Utc>,
    pub exited_at: Option<DateTime<Utc>>,
    pub exit_code: Option<i32>,
    pub username: Option<String>,
    pub integrity_level: Option<String>,
    pub is_injected: bool,
}

/// Network activity during execution
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct NetworkActivity {
    pub dns_queries: Vec<DnsQuery>,
    pub http_requests: Vec<HttpRequest>,
    pub tcp_connections: Vec<TcpConnection>,
    pub udp_flows: Vec<UdpFlow>,
    pub total_bytes_sent: u64,
    pub total_bytes_received: u64,
    pub unique_ips: Vec<String>,
    pub unique_domains: Vec<String>,
}

/// DNS query
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DnsQuery {
    pub timestamp: DateTime<Utc>,
    pub query: String,
    pub query_type: String,
    pub response: Vec<String>,
    pub successful: bool,
}

/// HTTP request
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct HttpRequest {
    pub timestamp: DateTime<Utc>,
    pub method: String,
    pub url: String,
    pub host: String,
    pub user_agent: Option<String>,
    pub content_type: Option<String>,
    pub request_body: Option<String>,
    pub response_code: Option<u16>,
    pub response_body: Option<String>,
}

/// TCP connection
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TcpConnection {
    pub timestamp: DateTime<Utc>,
    pub src_ip: String,
    pub src_port: u16,
    pub dst_ip: String,
    pub dst_port: u16,
    pub bytes_sent: u64,
    pub bytes_received: u64,
    pub protocol_detected: Option<String>,
}

/// UDP flow
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UdpFlow {
    pub timestamp: DateTime<Utc>,
    pub src_ip: String,
    pub src_port: u16,
    pub dst_ip: String,
    pub dst_port: u16,
    pub payload_preview: Option<String>,
}

/// Filesystem activity
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct FilesystemActivity {
    pub files_created: Vec<FileOperation>,
    pub files_modified: Vec<FileOperation>,
    pub files_deleted: Vec<FileOperation>,
    pub files_read: Vec<FileOperation>,
}

/// File operation
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileOperation {
    pub timestamp: DateTime<Utc>,
    pub pid: u32,
    pub path: String,
    pub operation: String,
    pub size: Option<u64>,
    pub hash: Option<String>,
}

/// Registry activity (Windows)
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct RegistryActivity {
    pub keys_created: Vec<RegistryOperation>,
    pub keys_deleted: Vec<RegistryOperation>,
    pub values_set: Vec<RegistryOperation>,
    pub values_deleted: Vec<RegistryOperation>,
}

/// Registry operation
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RegistryOperation {
    pub timestamp: DateTime<Utc>,
    pub pid: u32,
    pub key: String,
    pub value_name: Option<String>,
    pub value_data: Option<String>,
    pub value_type: Option<String>,
}

/// API call
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ApiCall {
    pub timestamp: DateTime<Utc>,
    pub pid: u32,
    pub api_name: String,
    pub category: String,
    pub arguments: Vec<String>,
    pub return_value: Option<String>,
    pub is_suspicious: bool,
}

/// Dropped file
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DroppedFile {
    pub path: String,
    pub filename: String,
    pub size: u64,
    pub file_type: String,
    pub hashes: SampleHashes,
    pub yara_matches: Vec<String>,
}

/// Screenshot during execution
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Screenshot {
    pub timestamp: DateTime<Utc>,
    pub path: PathBuf,
    pub ocr_text: Option<String>,
}

/// Behavior signature match
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BehaviorSignature {
    pub name: String,
    pub description: String,
    pub severity: SignatureSeverity,
    pub category: String,
    pub ttps: Vec<String>,
    pub evidence: Vec<String>,
}

/// Signature severity
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "lowercase")]
pub enum SignatureSeverity {
    Critical,
    High,
    Medium,
    Low,
    Info,
}

/// Extracted IOC
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExtractedIoc {
    pub ioc_type: String,
    pub value: String,
    pub context: String,
    pub confidence: f64,
}

// =============================================================================
// Local Sandbox Manager
// =============================================================================

/// Local sandbox manager
pub struct LocalSandboxManager {
    config: LocalSandboxConfig,
    samples: HashMap<String, MalwareSample>,
    results: HashMap<String, SandboxExecutionResult>,
    behavior_signatures: Vec<BehaviorSignatureRule>,
}

/// Behavior signature rule
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BehaviorSignatureRule {
    pub name: String,
    pub description: String,
    pub severity: SignatureSeverity,
    pub category: String,
    pub conditions: Vec<SignatureCondition>,
    pub ttps: Vec<String>,
}

/// Signature condition
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SignatureCondition {
    pub condition_type: ConditionType,
    pub pattern: String,
    pub count: Option<u32>,
}

/// Type of condition
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "snake_case")]
pub enum ConditionType {
    ProcessName,
    ProcessCmdLine,
    FileCreated,
    FileModified,
    RegistryKey,
    RegistryValue,
    DnsQuery,
    HttpHost,
    HttpUrl,
    TcpPort,
    ApiCall,
}

impl LocalSandboxManager {
    /// Create a new sandbox manager
    pub fn new(config: LocalSandboxConfig) -> Self {
        Self {
            config,
            samples: HashMap::new(),
            results: HashMap::new(),
            behavior_signatures: Self::load_builtin_signatures(),
        }
    }

    /// Load built-in behavior signatures
    fn load_builtin_signatures() -> Vec<BehaviorSignatureRule> {
        vec![
            BehaviorSignatureRule {
                name: "Process Injection Detected".to_string(),
                description: "Malware injected code into another process".to_string(),
                severity: SignatureSeverity::High,
                category: "injection".to_string(),
                conditions: vec![
                    SignatureCondition {
                        condition_type: ConditionType::ApiCall,
                        pattern: "WriteProcessMemory".to_string(),
                        count: Some(1),
                    },
                    SignatureCondition {
                        condition_type: ConditionType::ApiCall,
                        pattern: "CreateRemoteThread".to_string(),
                        count: Some(1),
                    },
                ],
                ttps: vec!["T1055".to_string()],
            },
            BehaviorSignatureRule {
                name: "Persistence via Registry".to_string(),
                description: "Malware established persistence through registry Run keys".to_string(),
                severity: SignatureSeverity::High,
                category: "persistence".to_string(),
                conditions: vec![
                    SignatureCondition {
                        condition_type: ConditionType::RegistryKey,
                        pattern: r"\\Software\\Microsoft\\Windows\\CurrentVersion\\Run".to_string(),
                        count: Some(1),
                    },
                ],
                ttps: vec!["T1547.001".to_string()],
            },
            BehaviorSignatureRule {
                name: "Credential Dumping".to_string(),
                description: "Attempt to access LSASS or SAM for credentials".to_string(),
                severity: SignatureSeverity::Critical,
                category: "credential_access".to_string(),
                conditions: vec![
                    SignatureCondition {
                        condition_type: ConditionType::ProcessName,
                        pattern: "lsass.exe".to_string(),
                        count: Some(1),
                    },
                ],
                ttps: vec!["T1003.001".to_string()],
            },
            BehaviorSignatureRule {
                name: "Scheduled Task Creation".to_string(),
                description: "Malware created a scheduled task for persistence".to_string(),
                severity: SignatureSeverity::Medium,
                category: "persistence".to_string(),
                conditions: vec![
                    SignatureCondition {
                        condition_type: ConditionType::ProcessCmdLine,
                        pattern: "schtasks".to_string(),
                        count: Some(1),
                    },
                ],
                ttps: vec!["T1053.005".to_string()],
            },
            BehaviorSignatureRule {
                name: "C2 Beacon Communication".to_string(),
                description: "Periodic network beaconing detected".to_string(),
                severity: SignatureSeverity::High,
                category: "command_and_control".to_string(),
                conditions: vec![
                    SignatureCondition {
                        condition_type: ConditionType::HttpHost,
                        pattern: ".*".to_string(),  // Check for periodic connections
                        count: Some(5),
                    },
                ],
                ttps: vec!["T1071.001".to_string()],
            },
            BehaviorSignatureRule {
                name: "Disable Security Tools".to_string(),
                description: "Attempt to disable security software".to_string(),
                severity: SignatureSeverity::High,
                category: "defense_evasion".to_string(),
                conditions: vec![
                    SignatureCondition {
                        condition_type: ConditionType::ProcessCmdLine,
                        pattern: "net stop".to_string(),
                        count: Some(1),
                    },
                ],
                ttps: vec!["T1562.001".to_string()],
            },
        ]
    }

    /// Submit a sample for analysis
    pub fn submit_sample(&mut self, file_path: &Path, source: &str, tags: Vec<String>) -> Result<String> {
        if !file_path.exists() {
            return Err(anyhow!("File not found: {:?}", file_path));
        }

        let file_data = std::fs::read(file_path)?;
        let metadata = std::fs::metadata(file_path)?;

        let hashes = self.calculate_hashes(&file_data);
        let file_type = self.detect_file_type(&file_data);

        let sample = MalwareSample {
            id: Uuid::new_v4().to_string(),
            filename: file_path.file_name()
                .map(|n| n.to_string_lossy().to_string())
                .unwrap_or_default(),
            file_path: file_path.to_path_buf(),
            file_size: metadata.len(),
            file_type: file_type.clone(),
            mime_type: self.detect_mime_type(&file_data),
            hashes,
            submission_time: Utc::now(),
            source: source.to_string(),
            tags,
            metadata: HashMap::new(),
        };

        let id = sample.id.clone();
        self.samples.insert(id.clone(), sample);

        Ok(id)
    }

    /// Execute a sample in the sandbox
    pub async fn execute(&self, sample_id: &str) -> Result<SandboxExecutionResult> {
        let sample = self.samples.get(sample_id)
            .ok_or_else(|| anyhow!("Sample not found: {}", sample_id))?;

        let result_id = Uuid::new_v4().to_string();
        let start_time = Utc::now();

        // Create sandbox container
        let container_id = self.create_sandbox_container(sample).await?;

        // Execute sample and monitor
        let execution_result = match self.config.sandbox_type {
            LocalSandboxType::Docker => {
                self.execute_in_docker(&container_id, sample).await
            }
            _ => Err(anyhow!("Unsupported sandbox type")),
        };

        // Cleanup container
        let _ = self.cleanup_container(&container_id).await;

        let (exit_code, process_tree, network_activity, filesystem_activity,
             registry_activity, api_calls, dropped_files, status) = match execution_result {
            Ok(result) => result,
            Err(e) => {
                return Ok(SandboxExecutionResult {
                    id: result_id,
                    sample_id: sample_id.to_string(),
                    status: ExecutionStatus::Failed,
                    started_at: start_time,
                    completed_at: Some(Utc::now()),
                    duration_secs: 0,
                    exit_code: None,
                    process_tree: vec![],
                    network_activity: NetworkActivity::default(),
                    filesystem_activity: FilesystemActivity::default(),
                    registry_activity: RegistryActivity::default(),
                    api_calls: vec![],
                    dropped_files: vec![],
                    screenshots: vec![],
                    behavior_signatures: vec![],
                    iocs: vec![],
                    verdict: SandboxVerdict::Unknown,
                    confidence: 0.0,
                    error_message: Some(e.to_string()),
                });
            }
        };

        // Analyze behavior
        let behavior_signatures = self.analyze_behavior(
            &process_tree,
            &network_activity,
            &filesystem_activity,
            &registry_activity,
            &api_calls,
        );

        // Extract IOCs
        let iocs = self.extract_iocs(&network_activity, &filesystem_activity, &dropped_files);

        // Calculate verdict
        let (verdict, confidence) = self.calculate_verdict(&behavior_signatures, &iocs);

        let completed_at = Utc::now();
        let duration_secs = (completed_at - start_time).num_seconds() as u64;

        Ok(SandboxExecutionResult {
            id: result_id,
            sample_id: sample_id.to_string(),
            status,
            started_at: start_time,
            completed_at: Some(completed_at),
            duration_secs,
            exit_code,
            process_tree,
            network_activity,
            filesystem_activity,
            registry_activity,
            api_calls,
            dropped_files,
            screenshots: vec![],
            behavior_signatures,
            iocs,
            verdict,
            confidence,
            error_message: None,
        })
    }

    /// Create sandbox container
    async fn create_sandbox_container(&self, sample: &MalwareSample) -> Result<String> {
        let image = self.config.docker_image.as_ref()
            .ok_or_else(|| anyhow!("Docker image not configured"))?;

        let network_mode = match &self.config.network_mode {
            SandboxNetworkMode::Isolated => "none",
            SandboxNetworkMode::NAT => "bridge",
            SandboxNetworkMode::INetSim => "inetsim-network",
            SandboxNetworkMode::Custom(n) => n.as_str(),
        };

        let output = Command::new("docker")
            .args([
                "create",
                "--network", network_mode,
                "--memory", &format!("{}m", self.config.memory_limit_mb),
                "--cpus", &format!("{}", self.config.cpu_limit),
                "--rm",
                "-v", &format!("{}:/sample:ro", sample.file_path.display()),
                image,
            ])
            .output()?;

        if !output.status.success() {
            return Err(anyhow!("Failed to create container: {}",
                String::from_utf8_lossy(&output.stderr)));
        }

        Ok(String::from_utf8_lossy(&output.stdout).trim().to_string())
    }

    /// Execute sample in Docker container
    async fn execute_in_docker(&self, container_id: &str, _sample: &MalwareSample) -> Result<(
        Option<i32>,
        Vec<ProcessInfo>,
        NetworkActivity,
        FilesystemActivity,
        RegistryActivity,
        Vec<ApiCall>,
        Vec<DroppedFile>,
        ExecutionStatus,
    )> {
        // Start container
        let output = Command::new("docker")
            .args(["start", container_id])
            .output()?;

        if !output.status.success() {
            return Err(anyhow!("Failed to start container"));
        }

        // Wait for execution with timeout
        let wait_output = Command::new("docker")
            .args(["wait", container_id])
            .output()?;

        let exit_code = String::from_utf8_lossy(&wait_output.stdout)
            .trim()
            .parse::<i32>()
            .ok();

        // Collect results (simplified - would parse actual monitoring output)
        let process_tree = vec![
            ProcessInfo {
                pid: 1,
                ppid: 0,
                name: "sample.exe".to_string(),
                command_line: "/sample/sample.exe".to_string(),
                image_path: "/sample/sample.exe".to_string(),
                started_at: Utc::now(),
                exited_at: Some(Utc::now()),
                exit_code,
                username: Some("sandbox".to_string()),
                integrity_level: Some("Medium".to_string()),
                is_injected: false,
            },
        ];

        Ok((
            exit_code,
            process_tree,
            NetworkActivity::default(),
            FilesystemActivity::default(),
            RegistryActivity::default(),
            vec![],
            vec![],
            ExecutionStatus::Completed,
        ))
    }

    /// Cleanup container
    async fn cleanup_container(&self, container_id: &str) -> Result<()> {
        let _ = Command::new("docker")
            .args(["rm", "-f", container_id])
            .output();
        Ok(())
    }

    /// Calculate file hashes
    fn calculate_hashes(&self, data: &[u8]) -> SampleHashes {
        use md5::{Md5, Digest as Md5Digest};
        use sha1::Digest as Sha1Digest;
        use sha2::Digest as Sha2Digest;

        let mut md5_hasher = Md5::new();
        md5_hasher.update(data);

        SampleHashes {
            md5: hex::encode(md5_hasher.finalize()),
            sha1: hex::encode(sha1::Sha1::digest(data)),
            sha256: hex::encode(sha2::Sha256::digest(data)),
            ssdeep: None,
            imphash: None,
        }
    }

    /// Detect file type
    fn detect_file_type(&self, data: &[u8]) -> String {
        if data.len() >= 2 && data[0] == 0x4D && data[1] == 0x5A {
            return "PE Executable".to_string();
        }
        if data.len() >= 4 && data[0] == 0x7F && &data[1..4] == b"ELF" {
            return "ELF Executable".to_string();
        }
        if data.len() >= 4 && &data[0..4] == b"PK\x03\x04" {
            return "ZIP Archive".to_string();
        }
        if data.len() >= 5 && &data[0..5] == b"%PDF-" {
            return "PDF Document".to_string();
        }
        "Unknown".to_string()
    }

    /// Detect MIME type
    fn detect_mime_type(&self, data: &[u8]) -> String {
        let file_type = self.detect_file_type(data);
        match file_type.as_str() {
            "PE Executable" => "application/x-msdownload".to_string(),
            "ELF Executable" => "application/x-executable".to_string(),
            "ZIP Archive" => "application/zip".to_string(),
            "PDF Document" => "application/pdf".to_string(),
            _ => "application/octet-stream".to_string(),
        }
    }

    /// Analyze behavior for signatures
    fn analyze_behavior(
        &self,
        process_tree: &[ProcessInfo],
        network_activity: &NetworkActivity,
        filesystem_activity: &FilesystemActivity,
        registry_activity: &RegistryActivity,
        api_calls: &[ApiCall],
    ) -> Vec<BehaviorSignature> {
        let mut matched_signatures = Vec::new();

        for rule in &self.behavior_signatures {
            let mut all_conditions_met = true;

            for condition in &rule.conditions {
                let condition_met = match condition.condition_type {
                    ConditionType::ProcessName => {
                        process_tree.iter().any(|p|
                            p.name.to_lowercase().contains(&condition.pattern.to_lowercase())
                        )
                    }
                    ConditionType::ProcessCmdLine => {
                        process_tree.iter().any(|p|
                            p.command_line.to_lowercase().contains(&condition.pattern.to_lowercase())
                        )
                    }
                    ConditionType::FileCreated => {
                        filesystem_activity.files_created.iter().any(|f|
                            f.path.to_lowercase().contains(&condition.pattern.to_lowercase())
                        )
                    }
                    ConditionType::RegistryKey => {
                        registry_activity.keys_created.iter().any(|r|
                            r.key.to_lowercase().contains(&condition.pattern.to_lowercase())
                        ) || registry_activity.values_set.iter().any(|r|
                            r.key.to_lowercase().contains(&condition.pattern.to_lowercase())
                        )
                    }
                    ConditionType::HttpHost => {
                        let count = network_activity.http_requests.len() as u32;
                        condition.count.map(|c| count >= c).unwrap_or(true)
                    }
                    ConditionType::ApiCall => {
                        api_calls.iter().any(|a|
                            a.api_name.to_lowercase().contains(&condition.pattern.to_lowercase())
                        )
                    }
                    _ => false,
                };

                if !condition_met {
                    all_conditions_met = false;
                    break;
                }
            }

            if all_conditions_met {
                matched_signatures.push(BehaviorSignature {
                    name: rule.name.clone(),
                    description: rule.description.clone(),
                    severity: rule.severity.clone(),
                    category: rule.category.clone(),
                    ttps: rule.ttps.clone(),
                    evidence: vec![], // Would include actual evidence
                });
            }
        }

        matched_signatures
    }

    /// Extract IOCs from analysis
    fn extract_iocs(
        &self,
        network_activity: &NetworkActivity,
        _filesystem_activity: &FilesystemActivity,
        dropped_files: &[DroppedFile],
    ) -> Vec<ExtractedIoc> {
        let mut iocs = Vec::new();

        // Extract unique IPs
        for ip in &network_activity.unique_ips {
            if !ip.starts_with("10.") && !ip.starts_with("192.168.") && !ip.starts_with("127.") {
                iocs.push(ExtractedIoc {
                    ioc_type: "ip".to_string(),
                    value: ip.clone(),
                    context: "Network connection".to_string(),
                    confidence: 0.7,
                });
            }
        }

        // Extract domains
        for domain in &network_activity.unique_domains {
            iocs.push(ExtractedIoc {
                ioc_type: "domain".to_string(),
                value: domain.clone(),
                context: "DNS query".to_string(),
                confidence: 0.8,
            });
        }

        // Extract dropped file hashes
        for file in dropped_files {
            iocs.push(ExtractedIoc {
                ioc_type: "sha256".to_string(),
                value: file.hashes.sha256.clone(),
                context: format!("Dropped file: {}", file.filename),
                confidence: 0.9,
            });
        }

        iocs
    }

    /// Calculate verdict based on analysis
    fn calculate_verdict(&self, signatures: &[BehaviorSignature], iocs: &[ExtractedIoc]) -> (SandboxVerdict, f64) {
        let mut score = 0.0;

        // Score based on signature severity
        for sig in signatures {
            score += match sig.severity {
                SignatureSeverity::Critical => 30.0,
                SignatureSeverity::High => 20.0,
                SignatureSeverity::Medium => 10.0,
                SignatureSeverity::Low => 5.0,
                SignatureSeverity::Info => 1.0,
            };
        }

        // Score based on IOCs
        score += iocs.len() as f64 * 2.0;

        let verdict = if score >= 50.0 {
            SandboxVerdict::Malicious
        } else if score >= 20.0 {
            SandboxVerdict::Suspicious
        } else if score > 0.0 {
            SandboxVerdict::Suspicious
        } else {
            SandboxVerdict::Clean
        };

        let confidence = (score / 100.0).min(1.0);

        (verdict, confidence)
    }

    /// Get sample by ID
    pub fn get_sample(&self, id: &str) -> Option<&MalwareSample> {
        self.samples.get(id)
    }

    /// Get result by ID
    pub fn get_result(&self, id: &str) -> Option<&SandboxExecutionResult> {
        self.results.get(id)
    }

    /// List all samples
    pub fn list_samples(&self) -> Vec<&MalwareSample> {
        self.samples.values().collect()
    }

    /// Search samples by hash
    pub fn search_by_hash(&self, hash: &str) -> Vec<&MalwareSample> {
        let hash_lower = hash.to_lowercase();
        self.samples.values()
            .filter(|s| {
                s.hashes.md5.to_lowercase() == hash_lower
                    || s.hashes.sha1.to_lowercase() == hash_lower
                    || s.hashes.sha256.to_lowercase() == hash_lower
            })
            .collect()
    }
}

impl Default for LocalSandboxManager {
    fn default() -> Self {
        Self::new(LocalSandboxConfig::default())
    }
}

// Need sha1 for hash calculation
use sha1::Digest as Sha1Digest;

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_sandbox_config_default() {
        let config = LocalSandboxConfig::default();
        assert_eq!(config.sandbox_type, LocalSandboxType::Docker);
        assert_eq!(config.execution_timeout_secs, 120);
    }

    #[test]
    fn test_sandbox_manager_creation() {
        let manager = LocalSandboxManager::default();
        assert!(!manager.behavior_signatures.is_empty());
    }

    #[test]
    fn test_file_type_detection() {
        let manager = LocalSandboxManager::default();

        // PE file
        let pe_data = vec![0x4D, 0x5A, 0x90, 0x00];
        assert_eq!(manager.detect_file_type(&pe_data), "PE Executable");

        // ELF file
        let elf_data = vec![0x7F, 0x45, 0x4C, 0x46];
        assert_eq!(manager.detect_file_type(&elf_data), "ELF Executable");
    }

    #[test]
    fn test_verdict_calculation() {
        let manager = LocalSandboxManager::default();

        // No signatures = clean
        let (verdict, _) = manager.calculate_verdict(&[], &[]);
        assert_eq!(verdict, SandboxVerdict::Clean);

        // Critical signature = malicious
        let sigs = vec![BehaviorSignature {
            name: "Test".to_string(),
            description: "Test".to_string(),
            severity: SignatureSeverity::Critical,
            category: "test".to_string(),
            ttps: vec![],
            evidence: vec![],
        }];
        let (verdict, _) = manager.calculate_verdict(&sigs, &[]);
        assert_eq!(verdict, SandboxVerdict::Suspicious);
    }
}
