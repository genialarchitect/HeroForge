//! Resource Extraction
//!
//! Extracts embedded resources from PE files.

use anyhow::Result;
use sha2::{Sha256, Digest};

use crate::malware_analysis::types::*;
use crate::malware_analysis::sample_store::SampleStore;
use crate::binary_analysis::hashing::compute_md5;

/// Resource extractor for PE files
pub struct ResourceExtractor;

impl ResourceExtractor {
    /// Create a new resource extractor
    pub fn new() -> Self {
        Self
    }

    /// Extract resources from PE file
    pub fn extract_pe_resources(&self, data: &[u8]) -> Result<Vec<EmbeddedResource>> {
        let mut resources = vec![];

        // Parse PE to find resource section
        if let Ok(goblin::Object::PE(pe)) = goblin::Object::parse(data) {
            // Find .rsrc section
            if let Some(rsrc_section) = pe.sections.iter().find(|s| {
                let name = String::from_utf8_lossy(&s.name);
                name.starts_with(".rsrc")
            }) {
                let rsrc_start = rsrc_section.pointer_to_raw_data as usize;
                let rsrc_size = rsrc_section.size_of_raw_data as usize;

                if rsrc_start + rsrc_size <= data.len() {
                    let rsrc_data = &data[rsrc_start..rsrc_start + rsrc_size];

                    // Parse resource directory (simplified)
                    resources.extend(self.parse_resource_directory(rsrc_data, rsrc_start));
                }
            }
        }

        Ok(resources)
    }

    /// Parse PE resource directory
    fn parse_resource_directory(&self, data: &[u8], _base_offset: usize) -> Vec<EmbeddedResource> {
        let mut resources = vec![];

        // Simplified resource parsing - look for common embedded types
        // Full implementation would parse the resource directory tree

        // Look for embedded executables (MZ header)
        let mz_signature = [0x4D, 0x5A]; // "MZ"
        for (i, window) in data.windows(2).enumerate() {
            if window == mz_signature && i > 0 {
                // Found potential embedded PE
                let remaining = &data[i..];
                if remaining.len() > 64 {
                    let size = self.estimate_pe_size(remaining);
                    if size > 256 && size < remaining.len() {
                        let resource_data = &remaining[..size];
                        let entropy = SampleStore::compute_entropy(resource_data);

                        resources.push(EmbeddedResource {
                            name: format!("embedded_pe_{:08x}", i),
                            resource_type: "PE".to_string(),
                            language: "neutral".to_string(),
                            size: size as u64,
                            entropy,
                            md5: compute_md5(resource_data),
                            sha256: format!("{:x}", Sha256::digest(resource_data)),
                            file_type: Some("application/x-dosexec".to_string()),
                            is_suspicious: true,
                        });

                        if resources.len() >= 10 {
                            break;
                        }
                    }
                }
            }
        }

        // Look for embedded scripts
        let script_patterns: &[(&[u8], &str)] = &[
            (b"<?xml", "XML"),
            (b"<script", "Script"),
            (b"#!/bin/", "Shell Script"),
            (b"@echo off", "Batch"),
            (b"powershell", "PowerShell"),
        ];

        for &(pattern, script_type) in script_patterns {
            if let Some(pos) = self.find_pattern(data, pattern) {
                let size = self.find_script_end(data, pos);
                if size > 10 && size < 1_000_000 {
                    let resource_data = &data[pos..pos + size];
                    let entropy = SampleStore::compute_entropy(resource_data);

                    resources.push(EmbeddedResource {
                        name: format!("embedded_{}_{:08x}", script_type.to_lowercase(), pos),
                        resource_type: script_type.to_string(),
                        language: "neutral".to_string(),
                        size: size as u64,
                        entropy,
                        md5: compute_md5(resource_data),
                        sha256: format!("{:x}", Sha256::digest(resource_data)),
                        file_type: Some("text/plain".to_string()),
                        is_suspicious: true,
                    });
                }
            }
        }

        resources
    }

    /// Find pattern in data
    fn find_pattern(&self, data: &[u8], pattern: &[u8]) -> Option<usize> {
        data.windows(pattern.len())
            .position(|w| w.eq_ignore_ascii_case(pattern))
    }

    /// Estimate PE file size
    fn estimate_pe_size(&self, data: &[u8]) -> usize {
        if data.len() < 64 {
            return 0;
        }

        // Read PE header offset
        let pe_offset = u32::from_le_bytes([data[60], data[61], data[62], data[63]]) as usize;

        if pe_offset + 24 > data.len() {
            return 0;
        }

        // Check PE signature
        if &data[pe_offset..pe_offset + 4] != b"PE\x00\x00" {
            return 0;
        }

        // Read number of sections
        let num_sections = u16::from_le_bytes([
            data[pe_offset + 6],
            data[pe_offset + 7],
        ]) as usize;

        // Read size of optional header
        let optional_header_size = u16::from_le_bytes([
            data[pe_offset + 20],
            data[pe_offset + 21],
        ]) as usize;

        let section_table_offset = pe_offset + 24 + optional_header_size;

        // Calculate size based on sections
        let mut max_end = 0usize;
        for i in 0..num_sections.min(16) {
            let section_offset = section_table_offset + i * 40;
            if section_offset + 40 > data.len() {
                break;
            }

            let raw_offset = u32::from_le_bytes([
                data[section_offset + 20],
                data[section_offset + 21],
                data[section_offset + 22],
                data[section_offset + 23],
            ]) as usize;

            let raw_size = u32::from_le_bytes([
                data[section_offset + 16],
                data[section_offset + 17],
                data[section_offset + 18],
                data[section_offset + 19],
            ]) as usize;

            let section_end = raw_offset + raw_size;
            if section_end > max_end {
                max_end = section_end;
            }
        }

        max_end
    }

    /// Find end of script content
    fn find_script_end(&self, data: &[u8], start: usize) -> usize {
        let remaining = &data[start..];

        // Look for null terminator or end of printable characters
        for (i, &byte) in remaining.iter().enumerate() {
            if byte == 0 || (byte < 0x20 && byte != 0x09 && byte != 0x0A && byte != 0x0D) {
                return i.max(1);
            }
            if i > 100000 {
                return i;
            }
        }

        remaining.len().min(100000)
    }

    /// Extract overlay data (data after PE structure)
    pub fn extract_overlay(&self, data: &[u8]) -> Option<EmbeddedResource> {
        if let Ok(goblin::Object::PE(pe)) = goblin::Object::parse(data) {
            // Calculate PE size
            let mut pe_end = 0usize;

            for section in &pe.sections {
                let section_end = section.pointer_to_raw_data as usize +
                                 section.size_of_raw_data as usize;
                if section_end > pe_end {
                    pe_end = section_end;
                }
            }

            // Check for overlay
            if pe_end < data.len() && data.len() - pe_end > 16 {
                let overlay_data = &data[pe_end..];
                let entropy = SampleStore::compute_entropy(overlay_data);

                return Some(EmbeddedResource {
                    name: "overlay".to_string(),
                    resource_type: "Overlay".to_string(),
                    language: "neutral".to_string(),
                    size: overlay_data.len() as u64,
                    entropy,
                    md5: compute_md5(overlay_data),
                    sha256: format!("{:x}", Sha256::digest(overlay_data)),
                    file_type: self.detect_overlay_type(overlay_data),
                    is_suspicious: entropy > 7.0,
                });
            }
        }

        None
    }

    /// Detect overlay content type
    fn detect_overlay_type(&self, data: &[u8]) -> Option<String> {
        if data.len() < 4 {
            return None;
        }

        // Check common signatures
        match &data[..4] {
            [0x50, 0x4B, 0x03, 0x04] => Some("application/zip".to_string()),
            [0x50, 0x4B, 0x05, 0x06] => Some("application/zip".to_string()),
            [0x52, 0x61, 0x72, 0x21] => Some("application/x-rar".to_string()),
            [0x1F, 0x8B, ..] => Some("application/gzip".to_string()),
            [0x4D, 0x5A, ..] => Some("application/x-dosexec".to_string()),
            [0x7F, 0x45, 0x4C, 0x46] => Some("application/x-elf".to_string()),
            [0x25, 0x50, 0x44, 0x46] => Some("application/pdf".to_string()),
            [0xFF, 0xD8, 0xFF, ..] => Some("image/jpeg".to_string()),
            [0x89, 0x50, 0x4E, 0x47] => Some("image/png".to_string()),
            _ => None,
        }
    }
}

impl Default for ResourceExtractor {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_detect_overlay_type() {
        let extractor = ResourceExtractor::new();

        let zip_sig = [0x50, 0x4B, 0x03, 0x04, 0x00, 0x00];
        assert_eq!(
            extractor.detect_overlay_type(&zip_sig),
            Some("application/zip".to_string())
        );

        let pe_sig = [0x4D, 0x5A, 0x90, 0x00];
        assert_eq!(
            extractor.detect_overlay_type(&pe_sig),
            Some("application/x-dosexec".to_string())
        );
    }
}
