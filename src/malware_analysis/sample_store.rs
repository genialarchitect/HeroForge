//! Sample Store
//!
//! Provides encrypted storage for malware samples.

use std::path::{Path, PathBuf};
use std::io::{Read, Write};
use aes_gcm::{
    aead::{Aead, KeyInit, OsRng},
    Aes256Gcm, Nonce,
};
use rand::RngCore;
use sha2::{Sha256, Digest};
use anyhow::{Result, anyhow};

/// Encrypted sample store
pub struct SampleStore {
    storage_path: PathBuf,
    encryption_key: [u8; 32],
}

impl SampleStore {
    /// Create a new sample store
    pub fn new(storage_path: &Path, encryption_key: &[u8; 32]) -> Self {
        Self {
            storage_path: storage_path.to_path_buf(),
            encryption_key: *encryption_key,
        }
    }

    /// Create sample store from environment
    pub fn from_env() -> Result<Self> {
        let storage_path = std::env::var("MALWARE_STORAGE_PATH")
            .unwrap_or_else(|_| "/tmp/malware_samples".to_string());

        let key_str = std::env::var("MALWARE_ENCRYPTION_KEY")
            .unwrap_or_else(|_| {
                // Generate a default key (not recommended for production)
                "default_malware_encryption_key_32b".to_string()
            });

        let mut key = [0u8; 32];
        let key_bytes = key_str.as_bytes();
        let len = key_bytes.len().min(32);
        key[..len].copy_from_slice(&key_bytes[..len]);

        // Create storage directory if it doesn't exist
        std::fs::create_dir_all(&storage_path)?;

        Ok(Self::new(Path::new(&storage_path), &key))
    }

    /// Store a sample (encrypts the data)
    pub fn store_sample(&self, sample_id: &str, data: &[u8]) -> Result<String> {
        // Generate nonce
        let mut nonce_bytes = [0u8; 12];
        OsRng.fill_bytes(&mut nonce_bytes);
        let nonce = Nonce::from_slice(&nonce_bytes);

        // Create cipher
        let cipher = Aes256Gcm::new_from_slice(&self.encryption_key)
            .map_err(|e| anyhow!("Failed to create cipher: {}", e))?;

        // Encrypt data
        let encrypted = cipher.encrypt(nonce, data)
            .map_err(|e| anyhow!("Encryption failed: {}", e))?;

        // Create file path (use sample_id hash to avoid directory traversal)
        let hash = format!("{:x}", Sha256::digest(sample_id.as_bytes()));
        let file_path = self.storage_path.join(&hash);

        // Write nonce + encrypted data
        let mut file = std::fs::File::create(&file_path)?;
        file.write_all(&nonce_bytes)?;
        file.write_all(&encrypted)?;

        Ok(file_path.to_string_lossy().to_string())
    }

    /// Retrieve a sample (decrypts the data)
    pub fn retrieve_sample(&self, encrypted_path: &str) -> Result<Vec<u8>> {
        let path = Path::new(encrypted_path);

        // Read file
        let mut file = std::fs::File::open(path)?;
        let mut data = Vec::new();
        file.read_to_end(&mut data)?;

        if data.len() < 12 {
            return Err(anyhow!("Invalid encrypted file: too short"));
        }

        // Extract nonce and encrypted data
        let nonce = Nonce::from_slice(&data[..12]);
        let encrypted = &data[12..];

        // Create cipher
        let cipher = Aes256Gcm::new_from_slice(&self.encryption_key)
            .map_err(|e| anyhow!("Failed to create cipher: {}", e))?;

        // Decrypt data
        let decrypted = cipher.decrypt(nonce, encrypted)
            .map_err(|e| anyhow!("Decryption failed: {}", e))?;

        Ok(decrypted)
    }

    /// Delete a sample
    pub fn delete_sample(&self, encrypted_path: &str) -> Result<()> {
        let path = Path::new(encrypted_path);
        if path.exists() {
            std::fs::remove_file(path)?;
        }
        Ok(())
    }

    /// Check if a sample exists
    pub fn sample_exists(&self, encrypted_path: &str) -> bool {
        Path::new(encrypted_path).exists()
    }

    /// Get storage statistics
    pub fn get_stats(&self) -> Result<StorageStats> {
        let mut total_files = 0u64;
        let mut total_size = 0u64;

        if self.storage_path.exists() {
            for entry in std::fs::read_dir(&self.storage_path)? {
                let entry = entry?;
                if entry.file_type()?.is_file() {
                    total_files += 1;
                    total_size += entry.metadata()?.len();
                }
            }
        }

        Ok(StorageStats {
            total_files,
            total_size,
            storage_path: self.storage_path.to_string_lossy().to_string(),
        })
    }

    /// Compute hashes for sample data
    pub fn compute_hashes(data: &[u8]) -> SampleHashes {
        use md5::Md5;
        use sha1::Sha1;

        let md5 = format!("{:x}", Md5::digest(data));
        let sha1 = format!("{:x}", Sha1::digest(data));
        let sha256 = format!("{:x}", Sha256::digest(data));

        SampleHashes { md5, sha1, sha256 }
    }

    /// Compute ssdeep fuzzy hash
    pub fn compute_ssdeep(data: &[u8]) -> Option<String> {
        // ssdeep implementation would go here
        // For now, return None as it requires external library
        None
    }

    /// Compute entropy of data
    pub fn compute_entropy(data: &[u8]) -> f64 {
        if data.is_empty() {
            return 0.0;
        }

        let mut frequency = [0u64; 256];
        for &byte in data {
            frequency[byte as usize] += 1;
        }

        let len = data.len() as f64;
        let mut entropy = 0.0f64;

        for &count in &frequency {
            if count > 0 {
                let p = count as f64 / len;
                entropy -= p * p.log2();
            }
        }

        entropy
    }
}

/// Storage statistics
#[derive(Debug, Clone)]
pub struct StorageStats {
    pub total_files: u64,
    pub total_size: u64,
    pub storage_path: String,
}

/// Sample hashes
#[derive(Debug, Clone)]
pub struct SampleHashes {
    pub md5: String,
    pub sha1: String,
    pub sha256: String,
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::tempdir;

    #[test]
    fn test_store_and_retrieve() {
        let dir = tempdir().unwrap();
        let key = [0u8; 32];
        let store = SampleStore::new(dir.path(), &key);

        let sample_data = b"This is test malware data";
        let path = store.store_sample("test-sample-1", sample_data).unwrap();

        let retrieved = store.retrieve_sample(&path).unwrap();
        assert_eq!(retrieved, sample_data);
    }

    #[test]
    fn test_entropy() {
        // Random-like data should have high entropy
        let random_data: Vec<u8> = (0u16..256).map(|x| x as u8).collect();
        let entropy = SampleStore::compute_entropy(&random_data);
        assert!(entropy > 7.0);

        // Repetitive data should have low entropy
        let repetitive = vec![0u8; 256];
        let entropy = SampleStore::compute_entropy(&repetitive);
        assert!(entropy < 0.1);
    }

    #[test]
    fn test_compute_hashes() {
        let data = b"test data";
        let hashes = SampleStore::compute_hashes(data);
        assert!(!hashes.md5.is_empty());
        assert!(!hashes.sha1.is_empty());
        assert!(!hashes.sha256.is_empty());
    }
}
