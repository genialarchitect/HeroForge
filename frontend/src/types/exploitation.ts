// =============================================================================
// Exploitation Types - Password Cracking, BAS, Agents, ASM
// =============================================================================

// =============================================================================
// Password Cracking Types
// =============================================================================

/** Hash type enum matching backend modes */
export type HashTypeMode =
  | 0      // MD5
  | 100    // SHA-1
  | 1000   // NTLM
  | 1400   // SHA-256
  | 1700   // SHA-512
  | 1800   // sha512crypt
  | 3000   // LM
  | 3200   // bcrypt
  | 5600   // NetNTLMv2
  | 13100  // Kerberos 5 TGS
  | 18200  // Kerberos 5 AS-REP
  | 22000; // WPA-PMKID-PBKDF2

/** Hash type information */
export interface HashTypeInfo {
  mode: number;
  name: string;
  example?: string;
}

/** Cracker type */
export type CrackerType = 'hashcat' | 'john';

/** Cracking job status */
export type CrackingJobStatus = 'pending' | 'running' | 'completed' | 'failed' | 'stopped';

/** Hash entry in a cracking job */
export interface HashEntry {
  hash: string;
  username?: string;
  source?: string;
}

/** Cracking job progress */
export interface CrackingProgress {
  total_hashes: number;
  cracked: number;
  speed: string;
  estimated_time: string;
  progress_percent: number;
}

/** Cracking job */
export interface CrackingJob {
  id: string;
  user_id: string;
  name: string;
  status: CrackingJobStatus;
  hash_type: number;
  hash_type_name: string;
  cracker_type: CrackerType;
  hashes_count: number;
  wordlist_ids: string[];
  rule_ids: string[];
  config: CrackingConfig;
  progress: CrackingProgress;
  cracked_count: number;
  source_campaign_id?: string;
  customer_id?: string;
  created_at: string;
  started_at?: string;
  completed_at?: string;
  error_message?: string;
}

/** Cracking job configuration */
export interface CrackingConfig {
  attack_mode?: number;
  workload_profile?: number;
  optimized_kernel?: boolean;
  custom_args?: string[];
}

/** Cracked credential */
export interface CrackedCredential {
  id: string;
  job_id: string;
  hash: string;
  plaintext: string;
  hash_type: number;
  username?: string;
  asset_id?: string;
  cracked_at: string;
}

/** Wordlist entry */
export interface Wordlist {
  id: string;
  user_id?: string;
  name: string;
  description?: string;
  file_path: string;
  size_bytes?: number;
  line_count?: number;
  is_builtin: boolean;
  category?: string;
  created_at: string;
}

/** Rule file entry */
export interface RuleFile {
  id: string;
  user_id?: string;
  name: string;
  description?: string;
  file_path: string;
  rule_count?: number;
  cracker_type: CrackerType;
  is_builtin: boolean;
  created_at: string;
}

/** Create cracking job request */
export interface CreateCrackingJobRequest {
  name: string;
  hash_type: number;
  cracker_type: CrackerType;
  hashes: HashEntry[];
  wordlist_ids?: string[];
  rule_ids?: string[];
  config?: CrackingConfig;
  source_campaign_id?: string;
  customer_id?: string;
  auto_start?: boolean;
}

/** Detect hash type request */
export interface DetectHashRequest {
  hashes: string[];
}

/** Detect hash type response */
export interface DetectHashResponse {
  hash_type?: number;
  hash_type_name?: string;
  confidence: 'high' | 'medium' | 'low' | 'none';
  alternatives: HashTypeInfo[];
}

/** Cracking statistics */
export interface CrackingStats {
  total_jobs: number;
  running_jobs: number;
  completed_jobs: number;
  total_hashes: number;
  total_cracked: number;
  success_rate: number;
  total_wordlists: number;
  total_rules: number;
}

/** WebSocket progress message */
export interface CrackingProgressMessage {
  message_type: 'job_started' | 'progress_update' | 'hash_cracked' | 'job_completed' | 'job_failed';
  job_id: string;
  data: {
    total_hashes?: number;
    cracked?: number;
    speed?: string;
    eta?: string;
    hash?: string;
    plaintext?: string;
    total_cracked?: number;
    error?: string;
  };
}

// ============================================================================
// Attack Surface Management (ASM) Types
// ============================================================================

export type AsmAlertSeverity = 'critical' | 'high' | 'medium' | 'low' | 'info';

export type AsmChangeType =
  | 'new_subdomain'
  | 'new_port'
  | 'port_closed'
  | 'certificate_change'
  | 'certificate_expiring'
  | 'technology_change'
  | 'ip_address_change'
  | 'asset_removed'
  | 'service_change'
  | 'shadow_it_detected';

export type AsmTimelineEventType =
  | 'monitor_run'
  | 'baseline_created'
  | 'change_detected'
  | 'change_acknowledged'
  | 'monitor_enabled'
  | 'monitor_disabled';

export type AsmRiskFactorType =
  | 'exposed_ports'
  | 'technology_stack'
  | 'ssl_tls'
  | 'internet_exposure'
  | 'visibility'
  | 'authorization'
  | 'vulnerability_presence'
  | 'service_age';

/** Asset discovery configuration for ASM */
export interface AsmDiscoveryConfig {
  enable_subdomain_enum: boolean;
  enable_port_scan: boolean;
  enable_service_detection: boolean;
  enable_ssl_analysis: boolean;
  enable_tech_detection: boolean;
  port_range?: string;
  threads?: number;
  dns_resolvers: string[];
}

/** Alert configuration for change detection */
export interface AsmAlertConfig {
  alert_on_new_subdomain: boolean;
  alert_on_new_port: boolean;
  alert_on_cert_change: boolean;
  alert_on_tech_change: boolean;
  alert_on_ip_change: boolean;
  alert_on_asset_removed: boolean;
  alert_on_shadow_it: boolean;
  min_severity: AsmAlertSeverity;
  notification_channels: string[];
}

/** ASM Monitor configuration */
export interface AsmMonitor {
  id: string;
  user_id: string;
  name: string;
  description?: string;
  domains: string[];
  discovery_config: AsmDiscoveryConfig;
  schedule: string;
  alert_config: AsmAlertConfig;
  enabled: boolean;
  last_run_at?: string;
  next_run_at?: string;
  created_at: string;
  updated_at: string;
}

/** Port information in baseline */
export interface AsmBaselinePort {
  port: number;
  protocol: string;
  service?: string;
  version?: string;
}

/** SSL information in baseline */
export interface AsmBaselineSslInfo {
  issuer: string;
  subject: string;
  valid_from: string;
  valid_until: string;
  fingerprint: string;
}

/** Individual asset in a baseline */
export interface AsmBaselineAsset {
  hostname: string;
  ip_addresses: string[];
  ports: AsmBaselinePort[];
  technologies: string[];
  ssl_info?: AsmBaselineSslInfo;
  first_seen: string;
  last_seen: string;
}

/** Summary statistics for a baseline */
export interface AsmBaselineSummary {
  total_assets: number;
  total_ports: number;
  total_services: number;
  assets_with_ssl: number;
  unique_technologies: number;
}

/** Baseline snapshot of discovered assets */
export interface AsmBaseline {
  id: string;
  monitor_id: string;
  assets: AsmBaselineAsset[];
  summary: AsmBaselineSummary;
  is_active: boolean;
  created_at: string;
}

/** Detailed information about a change */
export interface AsmChangeDetails {
  description: string;
  old_value?: string;
  new_value?: string;
  affected_ports: number[];
  metadata: Record<string, string>;
}

/** A detected change in the attack surface */
export interface AsmChange {
  id: string;
  monitor_id: string;
  baseline_id: string;
  change_type: AsmChangeType;
  severity: AsmAlertSeverity;
  hostname: string;
  details: AsmChangeDetails;
  detected_at: string;
  acknowledged: boolean;
  acknowledged_by?: string;
  acknowledged_at?: string;
}

/** Authorized asset pattern for shadow IT detection */
export interface AsmAuthorizedAsset {
  id: string;
  user_id: string;
  hostname_pattern: string;
  ip_ranges: string[];
  description?: string;
  created_at: string;
}

/** Individual risk factor contributing to overall score */
export interface AsmRiskFactor {
  factor_type: AsmRiskFactorType;
  weight: number;
  score: number;
  description: string;
  details?: string;
}

/** Risk score for an asset */
export interface AsmAssetRiskScore {
  id: string;
  asset_id?: string;
  hostname: string;
  overall_score: number;
  factors: AsmRiskFactor[];
  calculated_at: string;
}

/** ASM Dashboard statistics */
export interface AsmDashboard {
  total_monitors: number;
  active_monitors: number;
  total_assets: number;
  total_changes_24h: number;
  total_changes_7d: number;
  critical_changes: number;
  unacknowledged_changes: number;
  average_risk_score: number;
  high_risk_assets: number;
  shadow_it_count: number;
  next_scan_at?: string;
  last_scan_at?: string;
}

/** Timeline event for visualization */
export interface AsmTimelineEvent {
  timestamp: string;
  event_type: AsmTimelineEventType;
  monitor_id: string;
  monitor_name: string;
  description: string;
  severity?: AsmAlertSeverity;
  change_id?: string;
}

/** Monitor execution result */
export interface AsmMonitorRunResult {
  monitor_id: string;
  baseline_id: string;
  assets_discovered: number;
  changes_detected: number;
  duration_secs: number;
  started_at: string;
  completed_at: string;
  error?: string;
}

/** Create monitor request */
export interface CreateAsmMonitorRequest {
  name: string;
  description?: string;
  domains: string[];
  discovery_config?: Partial<AsmDiscoveryConfig>;
  schedule: string;
  alert_config?: Partial<AsmAlertConfig>;
}

/** Update monitor request */
export interface UpdateAsmMonitorRequest {
  name?: string;
  description?: string;
  domains?: string[];
  discovery_config?: Partial<AsmDiscoveryConfig>;
  schedule?: string;
  alert_config?: Partial<AsmAlertConfig>;
  enabled?: boolean;
}

/** Create authorized asset request */
export interface CreateAsmAuthorizedAssetRequest {
  hostname_pattern: string;
  ip_ranges?: string[];
  description?: string;
}

/** Acknowledge change request */
export interface AsmAcknowledgeChangeRequest {
  notes?: string;
}

/** Changes query parameters */
export interface AsmChangesQuery {
  change_type?: AsmChangeType;
  severity?: AsmAlertSeverity;
  acknowledged?: boolean;
  limit?: number;
  offset?: number;
}

// ============================================================================
// Breach & Attack Simulation (BAS) Types
// ============================================================================

/** MITRE ATT&CK Tactic */
export interface MitreTactic {
  id: string;
  name: string;
  description: string;
  techniques: string[]; // List of technique IDs belonging to this tactic
}

/** MITRE ATT&CK Technique */
export interface AttackTechnique {
  id: string;
  name: string;
  description: string;
  tactic: string;
  tactic_name: string;
  mitre_url: string;
  platforms: string[];
  permissions_required: string[];
  data_sources: string[];
  detection: string;
  payloads: string[]; // Available payload types for this technique
}

/** Execution mode for BAS simulations */
export type BasExecutionMode = 'dry_run' | 'safe' | 'full';

/** Status of a BAS scenario */
export type BasScenarioStatus = 'draft' | 'ready' | 'builtin';

/** Status of a BAS simulation */
export type BasSimulationStatus = 'pending' | 'running' | 'completed' | 'failed' | 'cancelled';

/** BAS Scenario - a configured set of techniques to run */
export interface SimulationScenario {
  id: string;
  name: string;
  description?: string;
  status: BasScenarioStatus;
  execution_mode: BasExecutionMode;
  technique_count: number;
  target_count: number;
  tags: string[];
  created_at: string;
  updated_at: string;
}

/** Summary of a BAS simulation run */
export interface SimulationSummary {
  id: string;
  scenario_id: string;
  status: BasSimulationStatus;
  execution_mode: BasExecutionMode;
  total_techniques: number;
  detection_rate: number;
  security_score: number;
  started_at: string;
  completed_at?: string;
  duration_ms?: number;
}

/** Statistics from a simulation run */
export interface SimulationStats {
  total_techniques: number;
  succeeded: number;
  blocked: number;
  detected: number;
  failed: number;
  skipped: number;
  detection_rate: number;
  block_rate: number;
  security_score: number;
}

/** Result of executing a single technique */
export interface TechniqueExecution {
  id: string;
  technique_id: string;
  target?: string;
  status: string;
  detection_observed: boolean;
  detection_details?: string;
  duration_ms?: number;
  error?: string;
}

/** A detection gap - technique that wasn't detected */
export interface DetectionGap {
  id: string;
  technique_id: string;
  technique_name: string;
  tactics: string[];
  severity: number; // 1-5, where 5 is critical
  reason?: string;
  recommendations: string[];
  acknowledged: boolean;
}

/** Full details of a simulation run */
export interface SimulationDetails {
  id: string;
  scenario_id: string;
  status: BasSimulationStatus;
  execution_mode: BasExecutionMode;
  summary: SimulationStats;
  executions: TechniqueExecution[];
  detection_gaps: DetectionGap[];
  started_at: string;
  completed_at?: string;
  duration_ms?: number;
  error?: string;
}

/** Overall BAS statistics for the user */
export interface BasStats {
  total_scenarios: number;
  total_simulations: number;
  total_techniques_tested: number;
  avg_detection_rate: number;
  avg_security_score: number;
  total_detection_gaps: number;
  unacknowledged_gaps: number;
}

/** Request to create a new BAS scenario */
export interface CreateScenarioRequest {
  name: string;
  description: string;
  execution_mode: BasExecutionMode;
  technique_ids: string[];
  targets: string[];
  timeout_secs: number;
  parallel_execution: boolean;
  continue_on_failure: boolean;
  tags: string[];
}

/** Request to start a simulation */
export interface StartSimulationRequest {
  scenario_id: string;
  execution_mode?: BasExecutionMode;
  target_override?: string;
}

/** Request to acknowledge a detection gap */
export interface AcknowledgeGapRequest {
  notes?: string;
}

// ============================================================================
// Agent-Based Scanning Types
// ============================================================================

export type AgentStatus = 'pending' | 'online' | 'busy' | 'offline' | 'disabled';

export type AgentTaskStatus = 'pending' | 'assigned' | 'running' | 'completed' | 'failed' | 'cancelled' | 'timed_out';

export interface ScanAgent {
  id: string;
  user_id: string;
  name: string;
  description: string | null;
  token_prefix: string;
  status: AgentStatus;
  version: string | null;
  hostname: string | null;
  ip_address: string | null;
  os_info: string | null;
  capabilities: string | null; // JSON array
  network_zones: string | null; // JSON array
  max_concurrent_tasks: number;
  current_tasks: number;
  last_heartbeat_at: string | null;
  last_task_at: string | null;
  created_at: string;
  updated_at: string;
}

export interface AgentGroup {
  id: string;
  user_id: string;
  name: string;
  description: string | null;
  network_ranges: string | null; // JSON array
  color: string;
  created_at: string;
  updated_at: string;
}

export interface AgentWithGroups {
  id: string;
  user_id: string;
  name: string;
  description: string | null;
  token_prefix: string;
  status: AgentStatus;
  version: string | null;
  hostname: string | null;
  ip_address: string | null;
  os_info: string | null;
  capabilities: string | null;
  network_zones: string | null;
  max_concurrent_tasks: number;
  current_tasks: number;
  last_heartbeat_at: string | null;
  last_task_at: string | null;
  created_at: string;
  updated_at: string;
  groups: AgentGroup[];
}

export interface AgentGroupWithCount extends AgentGroup {
  agent_count: number;
}

export interface AgentGroupWithAgents extends AgentGroup {
  agents: ScanAgent[];
}

export interface AgentStats {
  total_agents: number;
  online_agents: number;
  busy_agents: number;
  offline_agents: number;
  total_tasks_completed: number;
  total_tasks_failed: number;
  average_task_duration_secs: number | null;
}

export interface AgentHeartbeat {
  id: string;
  agent_id: string;
  cpu_usage: number | null;
  memory_usage: number | null;
  disk_usage: number | null;
  active_tasks: number;
  queued_tasks: number;
  latency_ms: number | null;
  created_at: string;
}

export interface AgentTask {
  id: string;
  scan_id: string;
  agent_id: string | null;
  group_id: string | null;
  user_id: string;
  status: AgentTaskStatus;
  task_type: string;
  config: string; // JSON
  targets: string;
  priority: number;
  timeout_seconds: number;
  retry_count: number;
  max_retries: number;
  error_message: string | null;
  assigned_at: string | null;
  started_at: string | null;
  completed_at: string | null;
  created_at: string;
  updated_at: string;
}

export interface RegisterAgentRequest {
  name: string;
  description?: string;
  network_zones?: string[];
  max_concurrent_tasks?: number;
}

export interface RegisterAgentResponse {
  id: string;
  name: string;
  token: string;
  token_prefix: string;
  created_at: string;
}

export interface UpdateAgentRequest {
  name?: string;
  description?: string;
  network_zones?: string[];
  max_concurrent_tasks?: number;
  status?: string;
}

export interface CreateAgentGroupRequest {
  name: string;
  description?: string;
  network_ranges?: string[];
  color?: string;
}

export interface UpdateAgentGroupRequest {
  name?: string;
  description?: string;
  network_ranges?: string[];
  color?: string;
}

export interface AssignAgentsToGroupRequest {
  agent_ids: string[];
}

// ============================================================================
// Agent Mesh Network Types
// ============================================================================

export interface AgentMeshConfig {
  agent_id: string;
  enabled: boolean;
  mesh_port: number;
  external_address: string | null;
  cluster_id: string | null;
  cluster_role: string | null;
  config_json: string | null;
  created_at: string;
  updated_at: string;
}

export interface MeshPeerConnection {
  id: string;
  from_agent_id: string;
  to_agent_id: string;
  connection_status: 'connected' | 'disconnected' | 'connecting' | 'error';
  latency_ms: number | null;
  bandwidth_mbps: number | null;
  last_seen_at: string | null;
  error_message: string | null;
  created_at: string;
  updated_at: string;
}

export interface MeshConnectionStats {
  total_connections: number;
  active_connections: number;
  failed_connections: number;
  avg_latency_ms: number | null;
  total_bandwidth_mbps: number | null;
}

export interface AgentMeshPeerData {
  agent_id: string;
  agent_name: string;
  mesh_config: AgentMeshConfig;
  peers: MeshPeerConnection[];
  stats: MeshConnectionStats | null;
}

export interface MeshCluster {
  id: string;
  user_id: string;
  name: string;
  description: string | null;
  leader_agent_id: string | null;
  config_json: string | null;
  health_json: string | null;
  created_at: string;
  updated_at: string;
}

export interface MeshClusterWithMembers extends MeshCluster {
  member_count: number;
  members: ScanAgent[];
}

export interface CreateMeshClusterRequest {
  name: string;
  description?: string;
  config_json?: string;
}

export interface UpdateMeshClusterRequest {
  name?: string;
  description?: string;
  config_json?: string;
  health_json?: string;
}

export interface UpdateMeshConfigRequest {
  enabled?: boolean;
  mesh_port?: number;
  external_address?: string;
  cluster_id?: string;
  cluster_role?: string;
  config_json?: string;
}
